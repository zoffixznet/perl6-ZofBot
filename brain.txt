TITLE
    DRAFT: Synopsis 32: Setting Library - Basics

VERSION
        Created: 19 Mar 2009 extracted from S29-functions.pod
        Last Modified: 29 June 2012
        Version: 5
    The document is a draft.
Roles
  Mu
    The following are defined in the "Mu" class:
     class Mu {
         multi method defined ($self: --> Bool:D ) is export {...}
         multi method defined ( $self: ::role --> Bool:D ) is export { ... }
         multi method new(*%opts) { ... }
         method not() {...}
         method so() {...}
     }
    defined
          multi method defined ( $self: --> Bool:D ) is export
          multi method defined ( $self: ::role --> Bool:D ) is export
        "defined" returns true if the parameter has a value and that value
        is considered defined by its type, otherwise false is returned.
        Same as Perl 5, only takes extra optional argument to ask if value
        is defined with respect to a particular role:
          defined($x, SomeRole);
        A value may be defined according to one role and undefined according
        to another. Without the extra argument, defaults to the definition
        of defined supplied by the type of the object.
    new
          multi method new(*%attrs) { }
        Creates a new object of the same type as the object is called on,
        setting attributes with public accessors to the values provided by
        the named arguments to "new".
    undefine
          multi undefine( Any $thing is rw --> Any )
        Takes any variable as a parameter and attempts to "remove" its
        definition. For simple scalar variables this means assigning the
        undefined value to the variable. For objects, this is equivalent to
        invoking their undefine method. For arrays, hashes and other complex
        data, this might require emptying the structures associated with the
        object.
        In all cases, calling "undefine" on a variable should place the
        object in the same state as if it was just declared.
    not
             method not() {...}
    so
             method so() {...}
        XXX Copied from S02 -- should it be deleted from there?
        The definition of ".Bool" for the most ancestral type (that is, the
        "Mu" type) is equivalent to ".defined". Since type objects are
        considered undefined, all type objects (including "Mu" itself) are
        false unless the type overrides the definition of ".Bool" to include
        undefined values. Instantiated objects default to true unless the
        class overrides the definition. Note that if you could instantiate a
        "Mu" it would be considered defined, and thus true. (It is not clear
        that this is allowed, however.)
  Any
    The following are defined in the "Any" class:
     class Any is Mu {
         multi method clone (::T $self:, *%attributes --> T ) {...}
         multi method can ($self:, Str $method --> Callable ) {...}
         multi method does ($self:, $type --> Bool ) {...}
         multi method isa  ($self:, $type --> Bool ) {...}
         multi method perl ( Mu $o: --> Str ) is export {...}
         multi method warn ( Mu $o: --> Any ) is export {...}
    can
         multi method can ($self:, Str $method --> Callable )
        If there is a multi method of name $method that can be called on
        $self, then a closure is return which has $self bound to the
        position of the invocant.
        Otherwise an undefined value is returned.
    clone
         multi method clone (::T $self --> T --> Any )
         multi method clone (::T $self, *%attributes --> T --> Any )
        The first variant returns an independent copy of $o that is
        equivalent to $o.
        The second variant does the same, but any named arguments override
        an attribute during the cloning process.
    does
         multi method does ($self:, $type --> Bool )
        Returns "True" if and only if $self conforms to type $type.
    isa
         multi method isa ($self:, $type --> Bool )
        Returns "True" if a the invocant an instance of class $type, or of a
        subset type or a derived class (through inheritance) of $type.
    perl
         multi method perl ( Mu $o: --> Str ) is export
        Returns a perlish representation of the object, so that calling
        "EVAL" on the returned string reproduces the object as accurately as
        possible.
    warn
         multi method warn ( Mu $o: --> Any ) is export
        Throws a resumable warning exception, which is considered a control
        exception, and hence is invisible to most normal exception handlers.
        The outermost control handler will print the warning to $*ERR (which
        usually finds $PROCESS::ERR; see "Synopsis 16: IPC / IO / Signals"
        for details). After printing the warning, the exception is resumed
        where it was thrown. To override this behavior, catch the exception
        in a CONTROL block. A quietly {...} block is the opposite of a try
        {...} block in that it will suppress any warnings but pass fatal
        exceptions through.
        To simply print to $*ERR, please use "note" instead. "warn" should
        be reserved for use in threatening situations when you don't quite
        want to throw an exception.
  Pattern
     role Pattern {
         method ACCEPTS($self:, $other) {...}
    ACCEPTS
        Used in smartmatching; see S03.
  Scalar
    "Scalar" provides the basic tools for operating on undifferentiated
    scalar variables. All of the following are exported by default.
    VAR This is not really a method, but some kind of macro. See S12 for
        details.
AUTHORS
        Rod Adams <rod@rodadams.net>
        Larry Wall <larry@wall.org>
        Aaron Sherman <ajs@ajs.com>
        Mark Stosberg <mark@summersault.com>
        Carl Mäsak <cmasak@gmail.com>
        Moritz Lenz <moritz@faui2k3.org>
        Tim Nelson <wayland@wayland.id.au>
    DRAFT: Synopsis 32: Setting Library - Callable
        Created: 26 Feb 2009
        Last Modified: 5 Nov 2013
        Version: 3
    This document documents Code, Block, Signature, Capture, Routine, Sub,
    Method, Submethod, and Macro.
Callable
        role Callable {...}
    The "Callable" role implies the ability to support "postcircumfix:<(
    )>".
Code
        class Code does Callable {...}
    Base class for all executable objects.
    signature
         method signature( --> Signature )
    assuming
         method assuming( Code $executable: *@curried_positionals, *%curried_named --> Code)
        "assuming" primes $executable, returning a "Code" object that, when
        executed, will use curried arguments as well as any additionally
        supplied arguments. See "Priming" in S06.
         method defined( --> Bool )
        For "Code", the ".defined" method returns whether a body has been
        defined. A body consisting only of "...", "!!!", or "???" (with
        optional message arguments) does not count as defined.
        To test if a name has been declared, look up the symbol in the
        appropriate symbol table.
Block
        # Executable objects that have lexical scopes
        class Block is Code does Callable {
            method next()   {...}
            method last()   {...}
            method redo()   {...}
            method leave()  {...}
            method labels() {...}
            method as()     {...} # See L<S12/Introspection> and L<S02/Value types>
        }
Signature
     class Signature {...}
    The "Signature" class is used for function parameters, as the left-hand
    side of a binding, and for the argument to declarators like "my". See
    "Signature objects" in S02, "Signatures" in S06, and "Signature
    Introspection" in S06
Capture
     class Capture does Positional does Associative {...}
    The "Capture" class is used for the arguments of function calls and the
    right-hand side of a binding. See "Lists, parameters, and Captures" in
    S02
WrapHandle
     class WrapHandle {...}
Routine
     class Routine is Block {
          method wrap(Code $code --> WrapHandle ) {...}
          method unwrap(Wraphandle $original --> Routine ) {...}
          method name( --> Str ) {...}
          method multi( --> Bool ) {...}
    unwrap
        See "Wrapping" in S06.
    wrap
         method wrap(Code $code) {...}
Sub
        class Sub is Routine {...}
Method
        class Method is Routine {...}
Submethod
        class Submethod is Routine {...}
Macro
        class Macro is Routine {...}
    DRAFT: Synopsis 32: Setting Library - Containers.pod
        Created: 19 Feb 2009 extracted from S29-functions.pod
        Last Modified: 23 Apr 2015
        Version: 51
Function Roles
  Positional
        role Positional {...}
    The "Positional" role implies the ability to support "postcircumfix:<[
    ]>".
  Iterable
        role Iterable {...}
    The "Iterable" role implies the ability to support sequential access
    through iterators. There is also limited support for en-passant use of
    "postcircumfix:<[ ]>", but since some Iterables may only be iterated
    once, not all Iterables are considered Positional.
  Associative
        role Associative {...}
    The "Associative" role implies the ability to support "postcircumfix:<{
    }>".
    cat
         multi cat( **@list --> Cat )
        "cat" reads arrays serially rather than in parallel as "zip" does.
        It returns all of the elements of the containers that were passed to
        it like so:
         cat(@a;@b;@c);
        Typically, you could just write "(@a,@b,@c)", but sometimes it's
        nice to be explicit about that:
         @foo := [[1,2,3],[4,5,6]]; say cat(||@foo); # 1,2,3,4,5,6
        In addition, a "Cat" in item context emulates the "Str" interface
        lazily.
        [Conjecture: Cats should maybe just do the lazy strings, and leave
        flattening to other operators.]
    roundrobin
         multi roundrobin( **@list --> Seq )
        "roundrobin" is very similar to "zip". The difference is that
        "roundrobin" will not stop on lists that run out of elements but
        simply skip any undefined value:
         my @a = 1;
         my @b = 1..2;
         my @c = 1..3;
         for roundrobin( @a; @b; @c ) -> $x { ... }
        will get the following values for $x: "1, 1, 1, 2, 2, 3"
    zip
         multi zip ( **@list --> Seq )
         multi infix:<Z> ( **@list --> Seq )
        zip takes any number of arrays and returns one tuple for every
        index. This is easier to read in an example:
         for zip(@a;@b;@c) -> $nth_a, $nth_b, $nth_c {
           ...
         }
        Mnemonic: the input arrays are "zipped" up like a zipper.
        The "zip" function defaults to stopping as soon as any of its lists
        is exhausted. This behavior may be modified by conceptually
        extending any short list using "*", which replicates the final
        element.
        If all lists are potentially infinite, an evaluation in "eager"
        context will automatically fail as soon as it can be known that all
        sublists in the control of iterators of infinite extent, such as
        indefinite ranges or arbitrary replication. If it can be known at
        compile time, a compile-time error results.
        "Z" is an infix equivalent for zip:
         for @a Z @b Z @c -> $a, $b, $c {...}
        In lol context a list of "List" is returned instead of a flat list.
  List
    The following are defined in the "List" class:
        class List does Positional {...}
         multi method new(*@args --> List )
        Constructs an "List" that can visit all iterable elements of all the
        arguments.
    list
         sub list(*@args --> List )
        Constructs a "List" that can visit all iterable elements of all the
         multi cat ( @values --> Cat )
        Returns a "Cat" object, a concatenated version of the list that does
        the "Str" interface, but generates the string lazily to the extent
        permitted by the pattern of access to the string. Its two primary
        uses are matching against an array of strings and doing the
        equivalent of a "join('')", except that "join" is always eager.
        However, a "Cat" in an interpolative context is also effectively
        eager, since the interpolator needs to know the string length. List
        context is lazy, though, so a "cat" of a "cat" is also lazy, and in
        fact, you just get a flat cat because "cat" in a list context is a
        no-op. The "Cat" interface also lets you interrogate the object at a
        particular string position without actually stringifying the
        element; the regex engine can make use of this to match a tree node,
        for instance, without serializing the entire subtree.
        Accessing a filehandle as both a filehandle and as a "Cat" is
        undefined, because lazy objects are not required to be as lazy as
        possible, but may instead choose to precalculate values in
        semi-eager batches to maximize cache hits.
    classify
         multi method classify ( @values: &mapper --> Hash )
         multi method classify ( @values: %mapper --> Hash )
         multi method classify ( @values: @mapper --> Hash )
         multi classify ( &mapper, *@values --> Hash )
         multi classify ( %mapper, *@values --> Hash )
         multi classify ( @mapper, *@values --> Hash )
        "classify" transforms a finite list or array of values into a hash
        representing the classification of those values according to a
        mapper; each hash key represents the classification for one or more
        of the incoming list values, and the corresponding hash value
        contains an array of those list values classified by the mapper into
        the category of the associated key. For example:
          @list = (1, 2, 3, 4);
          (:@even, :@odd) := @list.classify: { $_ % 2 ?? 'odd' !! 'even' };
          (:@even, :@odd) := classify { $_ % 2 ?? 'odd' !! 'even' }, @list; # same
        In this example, @even will contain all even numbers from @list and
        @odd will contain all odd numbers from @list. Please note that for
        performance reasons, an implementation is free to "bind" values to
        the resulting arrays. So you should consider these arrays to be
        immutable.
        To simply transform a list into a hash of arrays:
          %cars_by_color := @cars.classify: { .color };
          %cars_by_color := classify { .color }, @cars; # same
          red_car_owners(%cars_by_color<red>.map:{.owner});
        A mapper may be any unary function, hash, or array. Values that have
        no mapping will be classified under an undefined failure key
        (whatever is returned by the mapper in use). [Conjecture: if a hash
        comes with a default value, it can map anything.]
        "classify" always assumes that the mapper returns a single value.
        However, this may also be a List to indicate a multi-level
        classification. In such a case, only the classification of the
        lowest level, will actually yield a Hash of Lists. All higher up
        classifications, will necessarily always be a Hash of Hashes. Please
        note that all Lists must have the same number of elements.
        To categorize values into multiple categories, see "categorize".
    categorize
         multi method categorize ( @values: &mapper --> Hash )
         multi method categorize ( @values: %mapper --> Hash )
         multi method categorize ( @values: @mapper --> Hash )
         multi categorize ( &mapper, *@values --> Hash )
         multi categorize ( %mapper, *@values --> Hash )
         multi categorize ( @mapper, *@values --> Hash )
        Like "classify", "categorize" transforms a finite list or array of
        values into a hash representing the categorizations of those values
        according to a mapper; each hash key represents one possible
        categorization for one or more of the incoming list values, and the
        corresponding hash value contains an array of those list values
        categorized by the mapper into the category of the associated key.
        Please note that for performance reasons, an implementation is free
        to "bind" values to the resulting arrays. So you should consider
        these arrays to be immutable.
        Unlike "classify", "categorize" always assumes that the return value
        of the mapper is a list of categories that are appropriate to the
        current value. Hence, if the mapper returns "()", the value is
        discarded rather than being stored under any key. On the other hand,
        if the mapper returns a list of categories, the value in question
        will be pushed into multiple hash locations (while "classify" would
        merely make a key out of the list returned from the mapper).
        However, a category may also be a List to indicate a multi-level
        categorization. In such a case, only the categorization of the
        categorizations, will necessarily always be a Hash of Hashes. Please
    grep
         multi method grep ( @values: Matcher $test --> Iterable )
         multi grep ( Matcher $test, *@values --> Iterable )
        "grep" takes a list, array, or sequence of values and returns a
        lazily evaluated sequence comprised of all of the values from the
        original list for which the $test smart-matches as true, maintaining
        their relative order.
        Here is an example of its use:
         @friends = @coworkers.grep: { .is_friend };
         @friends = grep { .is_friend }, @coworkers; # same
        This takes the array @coworkers, checks every element to see which
        ones return true for the ".is_friend" method, and stores the
        resulting sequence's values into @friends.
        Note that, unlike in Perl 5, a comma is required after the "Matcher"
        in the multi form.
        Note that "grep" is an implicit loop, so "next" and "last" without
        an argument will iterate or terminate the "grep" itself, not some
        loop surrounding the statement containing the "grep". Use a label if
        you mean the other thing.
    first
         multi method first ( @values: Matcher $test )
         multi first ( Matcher $test, *@values )
        "first" searches exactly like "grep" but stops testing at the first
        match and returns just that value. Returns "Nil" if no match is
        found.
    pick
         multi method pick ( -> Mu )
         multi method pick ( @values: Int $num --> Iterable )
         multi method pick ( @values: Whatever --> Iterable )
         multi pick ( Int $num, *@values --> Iterable )
         multi pick ( Whatever, *@values --> Iterable )
        "pick" takes a list, array, or sequence of values and returns a
        sequence of random elements from the list (selected without
        replacement; see "roll" for dice roll aka replacement semantics). If
        "*" is specified as the number (or if the number of elements in the
        list is less than the specified number), all the available elements
        are returned in random order:
            @team = @volunteers.pick(5);
            @shuffled = @deck.pick(*);
        A ".pick" call without arguments returns a single element instead of
        an iterable container of one element.
    roll
         multi method roll ( --> Mu )
         multi method roll ( @values: Int $num --> Iterable )
         multi method roll ( @values: Whatever --> Iterable )
         multi roll ( Int $num, *@values --> Iterable )
         multi roll ( Whatever, *@values --> Iterable )
        "roll" takes a list, array, or sequence of values and returns a
        random sequence of elements from the list, like rolling N
        independent dice, where each list element corresponds to one side of
        your dice. This is also known as "pick with replacement", that is,
        like pulling one marble out of a bag and putting it back, and doing
        this N times; see "pick" for the non-replacement semantics. If "*"
        is specified as the number, "*" provides an infinite list of random
        choices from @values:
            @byte = (0,1).roll(8);                   # 8d2
            for (1..20).roll(*) -> $die_roll { ... } # 1d20 xx *
        A ".roll" call without arguments returns an element of the invocant
        list instead of a one-element sequence.
        Note that "roll 1, 6" is not the same as a 1d6, but always returns 6
        as a degenerate one-sided die. Use "roll 1, 1..6" to simulate a
        six-sided die.
    join
         multi method join ( @values: Str $separator = '' --> Str )
         multi join ( Str $separator = '', *@values --> Str )
        "join" returns a single string comprised of all of the elements of
        @values, separated by $separator.
        Given an empty list, "join" returns the empty string.
        The separator defaults to the null string. To join with space, just
        coerce to "Str".
    map
         multi method map ( @values: Code *&expression --> Iterable )
         multi map ( Code $expression, *@values --> Iterable )
        "map" returns a lazily evaluated sequence of values which is
        comprised of the return value of the expression, evaluated once for
        every one of the @values that are passed in.
        The actual return value is a multislice containing one slice per map
        iteration, unless the expression returns a "Slip", in which case the
        resulting sequence may not be the same length as the number of
        values that were passed.
        Note that "map" is an implicit loop, so "next" and "last" without an
        argument will iterate or terminate the "map" itself, not some loop
        surrounding the statement containing the "map". Use a label if you
        mean the other thing.
    duckmap
         multi method duckmap ( @values: Code *&expression --> Iterable )
         multi duckmap ( Code $expression, *@values --> Iterable )
        Like "map", "duckmap" evaluates the expression for each of the
        values that is passed in. Unlike "map", if the evaluation produces
        an undefined value, a failover looks to see if this element actually
        contains subelements, and if so, reapplies the duckmap recursively,
        returning the structured result for that element, so that the
        structure of the original is (largely) retained in the result.
        Unlike "deepmap", it does not guarantee the same structure, since
        the mapping expression takes precedence over structure in cases
        where either would succeed.
        Because "duckmap" is defined as a recursive implicit loop, loop
        controls apply only to the current level of the tree.
    deepmap
         multi method deepmap ( @values: Code *&expression --> Any )
         multi deepmap ( Code $expression, *@values --> Any )
        Like "map" and "duckmap", "deepmap" evaluates the expression for
        each of the values you give it. Unlike "map" and "duckmap", an
        element is considered a value only if it does not do the "Iterable"
        role. If the element is iterable, the algorithm recurses to produce
        an identical structure to its input. Elements that are not iterable
        are considered leaf values and mapped through the supplied
        expression.
        Because "deepmap" is defined as a recursive implicit loop, loop
    reduce
         multi method reduce ( @values: Code *&expression )
         multi reduce ( Code $expression ;; *@values )
        "reduce" takes a sequence of values, accumulates enough values from
        that sequences to apply &expression to, then feeds that result back
        into &expression followed by enough additional values taken from
        subsequent values in the sequence. It repeats this process until no
        more values are available. The result from the last evaluation of
        &expression is then returned.
        If &expression is an operator known to have right associativity,
        values are pulled in reverse order from the sequence.
        If an empty sequence is provided and &expression has a known
        identity value, it is returned. If the identity value is known and
        the sequence is not empty, but contains one less than enough values,
        those values are returned (as if &expression had been called with
        the identity value and those values, but usually without actually
        evaluating &expression.)
        If an identity value is not known, and there are not enough values
        to evaluate &expression once, an empty sequence is usually returned.
        If a sequence does not produce enough values to perform the last
        evaluation of &expression the stray values are usually ignored.
        Note that "reduce" is an implicit loop, so "next" and "last" without
        an argument will iterate or terminate the "reduce" itself, not some
        loop surrounding the statement containing the "reduce". Use a label
        if you mean the other thing.
    reverse
         multi method reverse ( @values: --> Iterable ) is export
         multi reverse ( *@values --> Iterable )
        Given a sequence of values, "reverse" presents a sequence with the
        same values in the opposite order. If the sequence is not already
        reified, this usually involves reifying and retaining the values.
        Note that "reversing" strings is done with "flip".
    rotate
         multi method rotate ( @values is copy: Int $n = 1 --> Iterable ) is export
        Produces a new sequence with the same elements as the input
        sequence, rotated by the specified amount. See Array::rotate for
        more info.
    sort
         multi method sort( @values: *&by --> Iterable )
         multi method sort( @values: Ordering @by --> Iterable )
         multi method sort( @values: Ordering $by = &infix:<cmp> --> Iterable )
         multi sort( Ordering @by,  *@values --> Iterable )
         multi sort( Ordering $by, *@values --> Iterable )
        Returns @values sorted, using criteria $by or @by for comparisons.
        @by differs from $by in that each criterion is applied, in order,
        until a non-zero (tie) result is achieved.
        If $by is a code object of arity zero or one, it is applied on each
        item of @values, and @values is sorted by comparing the result
        values with "&infix:<cmp>" (Schwartzian Transform).
        "Ordering" is as described in "Type Declarations" in S29. Any
        "Ordering" may receive either or both of the mixins "descending" and
        "canon(Code $how)" to reverse the order of sort, or to adjust the
        case, sign, or other order sensitivity of "cmp". (Mixins are applied
        to values using "but".) If a "Signature" is used as an "Ordering"
        then sort-specific traits such as "is canon($how)" are allowed on
        the positional elements.
        If all criteria are exhausted when comparing two elements, sort
        should return them in the same relative order they had in @values
        (it is an "order preserving" sort.)
        To sort an array in place use the ".=sort" mutator form.
        See <http://www.nntp.perl.org/group/perl.perl6.language/16578> for
        more details and examples (with "is insensitive" meaning "is
        canonicalized(&lc)".)
    unique
         multi method unique(:@as --> Iterable)
         multi sub unique(*@values, :&as --> Iterable)
        Returns a list of unique values from the invocant/argument list,
        such that only the first occurrence of each duplicated value remains
        in the result list. "unique" uses "&infix:<===>" semantics to
        compare whether two objects are the same. The order of the original
        list is preserved even as duplicates are removed.
            say <a a b b b c c>.unique    # a b c
            say <a b b c c b a>.unique    # a b c
        (Use "squish" instead if you know the input is sorted such that
        identical objects are adjacent.)
        The optional ":as" parameter allows you to normalize/canonicalize
        the elements before unique-ing. The values are transformed for the
        purposes of comparison, but the original values are still emitted in
        the resulting sequence:
            say <a A B b c b C>.unique(:as(&lc))          # a B c
        This makes it possible to effectively compare with other comparison
        operators, too. For example, if you want to compare with "
        infix:<==" > semantics, this might work for you:
            say +unique 100, 100e0, 200/2, :as(*.Num)   # 1
    squish
         multi method squish(:&as --> Iterable)
         multi sub squish(*@values, :@as --> Iterable)
        Returns a list of values from the invocant/argument list where runs
        of more than one value are replaced with only the first instance.
        Like "unique", "squish" uses "&infix:<===>" semantics to compare
        whether two objects are the same. Unlike "unique", this function
        only removes adjacent duplicates; identical values further apart are
        still kept. The order of the original list is preserved even as
        duplicates are removed.
            say <a a b b b c c>.squish  # a b c
            say <a b b c c b a>.squish  # a b c b a
        The optional " :as " parameter, just like with " unique ", allows
        values to be temporarily transformed before comparison.
    min
         multi method min( @values: *&by --> Any )
         multi method min( @values: Ordering @by --> Any )
         multi method min( @values: Ordering $by = &infix:<cmp> --> Any )
         multi min( *@values, Ordering :@by --> Any )
         multi min( *@values, Ordering :$by --> Any )
        Returns the earliest (i.e., lowest index) minimum element of @values
        , using criteria $by or @by for comparisons. @by differs from $by in
        that each criterion is applied, in order, until a non-zero (tie)
        result is achieved.
        "Ordering" may receive the mixin "canonicalized(Code $how)" to
        adjust the case, sign, or other order sensitivity of "cmp". (Mixins
        are applied to values using "but".) If a "Signature" is used as an
        "Ordering" then sort-specific traits such as "is
        canonicalized($how)" are allowed on the positional elements.
        For a "min" function that does not require an ordering, see the
        "[min]" reduction operator.
    max
         multi method max( @values: *&by --> Any )
         multi method max( @values: Ordering @by --> Any )
         multi method max( @values: Ordering $by = &infix:<cmp> --> Any )
         multi max(*@values, Ordering :@by, --> Any )
         multi max(*@values, Ordering :$by, --> Any )
        Returns the earliest (i.e., lowest index) maximum element of @values
        For a "max" function that does not require an ordering, see the
        "[max]" reduction operator.
    minmax
         multi method minmax( @values: *&by --> Any )
         multi method minmax( @values: Ordering @by --> Any )
         multi method minmax( @values: Ordering $by = &infix:<cmp> --> Any )
         multi minmax( *@values, Ordering :@by --> Any )
         multi minmax( *@values, Ordering :$by --> Any )
        Returns a "Range" from the minimum element of @values to the maximum
        element, using criteria $by or @by for comparisons. @by differs from
        $by in that each criterion is applied, in order, until a non-zero
        (tie) result is achieved. "Range" elements in @values are treated as
        if their minimum and maximum values were passed individually, except
        that if the corresponding "excludes" flag is set in Range, the
        excludes flag is also set in the returned "Range".
        For a "minmax" function that does not require an ordering, see the
        "[minmax]" reduction operator.
    any
         multi method any( @values: --> Junction )
         multi any( *@values --> Junction ) is export
        Returns a junction with all the values of the list "|"-ed together.
        The junction will only match against another value if at least one
        of the values in the list matches.
    all
         multi method all( @values: --> Junction )
         multi all( *@values --> Junction ) is export
        Returns a junction with all the values of the list "&"-ed together.
        The junction will only match against another value if all of the
        values in the list match.
    one
         multi method one( @values: --> Junction )
         multi one( *@values --> Junction ) is export
        Returns a junction with all the values of the list "^"-ed together.
        The junction will only match against another value if exactly one of
        the values in the list matches.
    none
         multi method none( @values: --> Junction )
         multi none( *@values --> Junction ) is export
        Returns a junction which will only match against another value if
        none of the values in the list matches.
    comb
         multi method comb ( Regex $matcher, Int $limit = * )
         multi method comb ( Str $matcher, Int $limit = * )
        Treats a sequence values as a string (by simply "join"ing them
        together), and calls ".comb" on that string with the same
        parameters. See "Str::comb".
    combinations
         multi method combinations ( Int $of )
         multi method combinations ( Range $of = 0 .. * )
         multi combinations ( $n, $k )
        Returns all combinations of the list taken N at a time (specified by
        the $of parameter). If the range option is taken, then the range is
        iterated, and for each integer N in the range, appends all
        combinations taken N at a time to the resulting list. If the max of
        the range is greater than the size of the list, iteration stops at
        the size of the list. Hence, if the default of "0..*" is taken, the
        first return value will be an empty array, and the final return
        value will be an array containing every value in the list.
        The return value is a sequence or container of (presumably
        immutable) values. (Note: When used on actual sets and other
        iterable structures, specialized versions of this method are allowed
        to bypass turning it into a list first. Also, the return values are
        allowed to be specialized to any non-flattening container, so that
        subsets of sets can actually be a set of sets. If the ordering of
        the input doesn't matter, neither does the ordering of the subsets.)
        Note that, without an argument, the first returned combination will
        always be the empty list, and the last combination will always be
        the entire list.
        It is erroneous to ask for the combinations of any infinite list.
        The compiler is allowed to complain if it notices, however.
        The functional form assumes it is working on a list of integers
        "^$n" taken $k at a time.
    permutations
         multi method permutations ( )
         multi permutations ( $n )
        Similar to "combinations", but returns permutations instead. (Types
        such as "Range" are converted to a list of individual values before
        permuting them.)
        "^$n".
    rotor
            multi method rotor ( *@cycle, :$partial )
        Takes multiple cyclical slices of a sequence as specified by @cycle,
        which you can think of as a rotory cutter that punches out multiple
        slices depending on the arrangement of the blades (or teeth, if you
        prefer a gear analogy). Since it's cyclical, you may apply a rotor
        to an infinite list lazily. Each specifier in the cycle specifies
        how many elements to take (the "slice") and, optionally, how many to
        omit (the "gap"). The cycle repeats if @cycle runs out before the
        sequence does. The rotor stops if the sequence runs out first, that
        is, if there are insufficient values remaining to create the entire
        next slice (ignoring any associated gap). If :partial is specified,
        the final partial slice is returned at the end, if it is not empty.
        Here we slice the alphabet into alternating slices of size 2 and 3:
            my @list = 'a'...'z';
            @list.rotor(2,3)             # ab, cde, fg, hij...uv, wxy
            @list.rotor(2,3, :partial)   # ab, cde, fg, hij...uv, wxy, z
        It is allowed to specify an infinite cycle, in which case it will
        never repeat, at least not internally. The supplied list may of
        course repeat itself instead. Hence these two calls produce the same
        result:
            @list.rotor(2,3)
            @list.rotor((2,3) xx *)
        Each slice specifier may be either an integer or a pair. If it is a
        pair, the key is taken as the number of elements to take in the
        slice, and the value is taken as the size of the gap. If the
        specifier is an integer, it is taken as the size of the slice, and
        the gap is taken as 0. In other words, these are equivalent:
            @list.rotor(3)
            @list.rotor(3 => 0)
        A non-zero gap or overlap may be specified only via the pair form:
            @list.rotor(2 => 1)  # take two, skip one
            @list.rotor(2 => -1) # take two, back up one
    pairup
         multi method pairup ( )
        Turns a sequence of mixed keys, values, and pairs into a sequence of
        pairs in the same way that a hash composer does, only without
        creating the hash. While there is more to process, the next value is
        examined. If it is a Pair, it is passed through unchanged. Otherwise
        a second value is also taken from the list and those two values
        together are turned into a pair. It is an X::Pairup::OddNumber error
        if there is no next value. (It is not an error if the second value
        happens be a pair; if so, it merely becomes the value paired with
        the key of the first value.)
        Obviously you cannot create pairs where the keys are Pairs using
        this function. Use a map or some such for that.
    invert
         multi method invert ( --> Iterable ) is export {
             self.map: -> $p { $.value »=>» $.key }
        Produces a backmapping of values to keys, expanding list values into
        multiple pairs. (The "»=>»" expands the value if it is a list.)
        The invocant must be a list containing only Pairs, and throws an
        error if anything that is not a Pair is passed. To invert key/value
        lists, use ".pairup" first:
            @kv.pairup.invert
        Likewise if you wish to invert the implicit indices of an array or
        list, you must call ".pairs" first:
            <a b c>.pairs.invert  # ('a' => 0, 'b' => 1, 'c' => 2)
        (You may call ".invert" directly on a hash, because a hash naturally
        listifies to a list of pairs.)
  Array
    All these methods are defined in the "Array" role/class.
        role Array does List {...}
         multi method new(*@args --> Array )
        Constructs a new "Array" containing the arguments passed to "new".
    shape
         method shape (@array: --> List ) is export
        Returns the declared shape of the array, as described in S09.
    end
         method end (@array: --> Any ) is export
        Returns the final subscript of the first dimension; for a
        one-dimensional array this simply the index of the final element.
        For fixed dimensions this is the declared maximum subscript. For
        non-fixed dimensions (undeclared or explicitly declared with "*"),
        the index of the actual last element is used. So that the degenerate
        case of an empty range works correctly, -1 is returned if the array
        is empty. (If you actually try to index with -1, you'll get a
        failure.)
    elems
         method elems (@array: --> Int ) is export
        Returns the length of the array counted in elements.
    delete (DEPRECATED)
        The "delete" method is considered to be a deprecated internal
        method: the normal way to mark an element as deleted, is to apply
        the ":delete" adverb to a subscripting operation.
    :delete
        This adverb may be applied to any subscripting operation. The
        operation returns the elements normally, but reads them out
        destructively.
    exists (DEPRECATED)
        The "exists" method is considered to be a deprecated internal
        method: the normal way to test for existence is to apply the
        ":exists" adverb to a subscripting operation.
    :exists
        operation returns true if specified element exists. If a slice is
        specified by the subscript, a "List" of "Bool" is returned, which
        can be processed using junctions.
    pop
         multi method pop ( @array: --> Scalar ) is export
        Remove the last element of @array and return it. If @array is empty
        returns a failure.
    push
         multi method push ( @array: *@values --> Array ) is export
        Adds all the values to the end of @array eagerly. Returns the
        modified array.
    plan
         multi method plan ( @array: *@list --> Array ) is export
        Adds the list to the end of @array lazily as a kind of "lazy push".
        (That is, the reified part of the array is not modified, but the
        list is appended to the not-yet-reified specifications for how to
        extend the array on demand, if it is subscripted or shifted beyond
        the currently reified elements.) Returns the modified array.
        Note that the semantics of these are different:
            @ro := (0,1,*+*...*);
            @rw.plan(0,1,*+*...*);
        In the first case, @ro is bound directly to the list, so its values
        are memoized but not considered mutable. In contrast, @rw allows
        modification of any reified element; new elements are merely
        initialized to the fibonacci sequence. If you try to modify a
        non-reified element, the array will be reified to that point before
        the modification is attempted.
        For all external purposes, the array considers that its plan is part
        of the array. If you ask for ".elems", for instance, it will try to
        reify the entire array, which might take a long time in the case of
        infinite arrays (though a list may return "Inf" if it can determine
        this). Methods such as ".splice" can refer to the rest of the list
        in the abstract, and need only reify those elements necessary to
        perform the operation in question. (Hence, there is no need for an
        ".unplan" method, since the plan of an array may be thrown away by
        using "splice" without the risk of memory exhaustion.)
         multi method rotate ( @array is copy: Int $n = 1, Int *@n --> Array ) is export
        Produces a new array with the same elements as the old array,
        rotated by the specified amount. A positive rotation of 1 is defined
        as:
            @array.push(@array.shift);
        A negative rotation of 1 is defined as:
            @array.unshift(@array.pop);
        If the magnitude of $n is larger than the number of elements, the
        rotational semantics must be equivalent to doing:
            @array.rotate(sign($n)) for ^abs($n)
        The new array to be returned contains nothing but aliases for the
        old array's elements; however, you can use this to get any of three
        different semantic behaviors:
            @a.=rotate       # @a is rotated in place
            @b = @a.rotate   # @b contains copied elements of rotated @a
            @b := @a.rotate  # @b contains aliased elements of rotated @a
        If additional rotations are specified via the slurpy, they are
        applied to subdimensions of multidimensional arrays. (To perform a
        flat rotation on a shaped array requires flattening to a list and
        rotating that instead.)
    shift
         multi method shift ( @array: --> Scalar ) is export
        Remove the first element from @array and return it. If @array is
        empty returns a failure.
    splice
         multi method splice( @array is rw: $offset = 0, $size = Inf, *@values --> Any ) is export
        "splice" fills many niches in array-management, but its fundamental
        behavior is to remove zero or more elements from an array and
        replace them with a new (and potentially empty) list. This operation
        can shorten or lengthen the target array.
        $offset is the index of the array element to start with. A
        WhateverCode whose argument is the number of elements in the @array
        may also be used.
        $size is the number of elements to remove from @array. A
        WhateverCode similar to $offset may be used instead (note that this
        specifies a position, not an actual number of elements to remove).
        The slurpy list of values (if any) is then inserted at $offset.
        Calling splice with a traditional parameter list, you must define
        $offset and $size if you wish to pass a replacement list of values.
        To avoid having to pass these otherwise optional parameters, use the
        piping operator(s):
         splice(@array,10) <== 1..*;
        which replaces @array[10] and all subsequent elements with an
        infinite sequence starting at 1.
        If @array is multidimensional, "splice" operates only on the first
        dimension, and works with Array References.
        "splice" returns a "List" of the deleted elements, which behaves as
        expected in either list or item context.
        $offset and $size will be treated as "Int". The function fails if
        either parameter is negative, or undefined.
        Either of $offset or $size may be specified relative to the length
        of the array using a WhateverCode whose argument will be the number
        of elements in the array.
        While it is illegal for the offset to be larger than the size of the
        array, it is allowed for the final position to be off the end of the
        array; in this case the entire rest of the array is spliced,
        whatever is available.
    unshift
         multi method unshift ( @array: *@values --> Array ) is export
        "unshift" adds the values onto the start of the @array and returns
        the modified array.
    keys
    kv
    pairs
    antipairs
    enums
    values
         multi method keys      ( @array: ) is export
         multi method kv        ( @array: ) is export
         multi method pairs     ( @array: ) is export
         multi method antipairs ( @array: ) is export
         multi method enums     ( @array: ) is export
         multi method values    ( @array: ) is export
        Iterates the elements of @array, in order.
        What is returned at each element of the iteration varies with
        function. "values" returns the value of the associated element; "kv"
        returns a 2 element list in (index, value) order, "pairs" a
        "Pair(index, value)". With "pairs" the values are references back to
        the original containers, while with "enums" a snapshot of those
        values is taken. That is, ".pairs" returns a "PairMap" while "enums"
        returns an "EnumMap".
        If @array is declared to be multi-dimensional, the keys returned may
        in fact be slice lists. (Arrays that are effectively
        multi-dimensional by containing other arrays or hashes are treat
        with their declared dimensionality, not their effective
        dimensionality.)
        Note that "kv @array" returns the same as "zip(^@array; @array)"
  Hash
    The following are defined in the "Hash" class.
        class Hash is EnumMap {...}
        method: the normal way to remove a key from a hash, is to apply the
        ":delete" adverb to a subscripting operation.
         multi method keys      ( %hash: ) is export
         multi method kv        ( %hash: ) is export
         multi method pairs     ( %hash: ) is export
         multi method antipairs ( %hash: ) is export
         multi method enums     ( %hash: ) is export
         multi method values    ( %hash: ) is export
        Iterates the elements of %hash. The order is implementation
        dependent and arbitrary, but will be the same between successive
        calls to these functions, as long as %hash doesn't change.
        function. "keys" only returns the key; "values" the value; "kv"
        returns both as a 2 element list in (key, value) order, "pairs" a
        "Pair(key, value)". With "pairs" the values are references back to
        Note that "kv %hash" returns the same as "zip(keys %hash; values
        %hash)"
        The lvalue form of "keys" is no longer supported. Use the ".buckets"
        property instead.
         multi method any( %hash: --> Junction ) is export
        Returns a junction with all the keys of the hash "|"-ed together.
        of the keys in the hash matches.
         multi method all( %hash: --> Junction ) is export
        Returns a junction with all the keys of the hash "&"-ed together.
        keys in the hash match.
         multi method one( %hash: --> Junction ) is export
        Returns a junction with all the keys of the hash "^"-ed together.
        the keys in the hash matches.
         multi method none( %hash: --> Junction ) is export
        none of the keys in the hash matches.
         multi method antipairs ( %hash: --> List ) is export {
             %hash.map: { .value => .key }
        Produces a simple backmapping of values to keys, like ".pairs" but
        with each returned pair returned as an antipair, that is, a pair
        with key and value exchanged. Unlike the "invert" method, there is
        no attempt to expand list values into multiple pairs.
         multi method invert ( %hash: --> List ) is export {
             %hash.map: { .value »=>» .key }
        Produces a backmapping of values to keys, but unlike ".antipairs",
        expands list values into multiple pairs. (The "»=>»" expands
        ".value" if it is a list.)
        This function is essentially a shortcut for ".pairs.invert", but
        bypasses the creation of pairs only to invert them.
         multi method push ( %hash: *@values --> Hash ) is export
        Like hash assignment insofar as it accepts either "Pair" objects or
        alternating keys and values; also like in that it returns the new
        hash. However, unlike assignment, when a duplicate key is detected,
        "push" coerces the colliding entry's value to an array and pushes
        the "Pair"'s value onto that array. Hence to invert a hash
        containing duplicate values without losing (associative)
        information, say:
            %out.push(%in.invert)
        Note that when reading the values of such a hash, you must not
        assume that all the elements are arrays, since the first instance of
        a key merely sets the value without turning it into an array.
        (Fortunately, most list operators create a list of one element when
        used on an object that is not a list.)
        The intent is that inverting a hash twice produces a hash equivalent
        to the original hash.
Classes and Roles
    This documents Buf, List, Range, Set, Bag, Junction, Array, Hash,
    MixHash, SetHash, BagHash, Pair, and PairMap.
  Range
        class Range does Positional does Iterable {
            method min() {...}
            method max() {...}
            method bounds() returns List {...}
            method excludes-min {...}
            method excludes-max {...}
            method sample {...}
   Methods
    sample
            multi method sample ( $range: Int $num = 1 --> List )
            multi method sample ( $range: Whatever --> List )
        Returns a lazy list of "Num" values, taken as linearly distributed
        samples from the real interval specified by the invocant. The
        argument, if any, indicates how many samples to return. Hence,
        "(^1).sample" is equivalent to "rand", and "(^10).sample(*)" is
        equivalent to "rand * 10 xx *". Ranges with exclusions other than
        "..^" may be less efficient by virtue of having to generate from a
        larger interval, throwing out values that are outside the specified
        interval.
  Buf
        class Buf does Positional does Stringy {...}
    A mutable container for an array of integer values in contiguous memory.
    The default constructor takes a single array parameter of integers, the
    largest of which determines the actual type. So
        Buf.new([:16<c3>, :16<B6>]) # or
        Buf.new([195, 182])         # which is exactly the same
    returns a "buf8" containing two "uint8" items, while
        Buf.new([256])
    returns a "buf16" which consists of a single "uint16".
    To explicit request a "Buf" of a specific size, you can use
        Buf.new([127], :size(16))     # returns a buf16
        Buf.new([1024], :size(8))     # dies, because 1024 >= 2**8
    Subtypes with additional constraints like "utf8" (which only allows
    valid UTF-8 byte sequences) exist and provide similar constructors. See
    "Built-In Data Types" in S02.
    The array in the constructor used to be slurpy rather than positional,
    but the former was deemed to be too inefficient (during signature
    construction) for arrays of many elements.
    decode
            method decode($encoding = $?ENC, $nf = $?NF --> Str )
        Decode the "Buf" into a "Str". For subtypes that know their encoding
        (like "utf8", "utf16") the $encoding parameter defaults to their
        intrinsic encoding instead.
    subbuf
            method subbuf($from, $elems?) returns Buf:D
        Returns a part of the original buffer, starting from index $from and
        taking $elems elements (or to the end of the buffer, if not
        provided).
        The method fails with "X::OutOfRange" if either $from or $elems are
        negative. The method also fails if $from is larger than the amount
        of elements in the buffer.
        $from may be specified relative to the end of the string using a
        WhateverCode:
         Buf.new(0x00, 0xFF).subbuf(*-1, 1)
    subbuf-rw
           method subbuf-rw( $from; $elems?) is rw
         A version of C<.subbuf> that returns a writable reference to a part of a
         buffer:
          $b.subbuf-rw($from,$to) = Buf.new(0x00, 0x77);
   "Buf" Operators
    Two "Buf" objects of the same bit size can be compared with the same
    operators as strings (in particular "eq", "lt", "le", "gt", "ge", "ne"
    and "leg"), but actually compares the stored integers, not characters.
    Concatenating two compatible "Buf"s produces an object of the most
    specific type possible, for example "buf8.new() ~ utf8.new()" results in
    a "buf8" object.
    Comparing or concatenating two "Buf" objects of different bit sizes, or
    a "Buf" that doesn't know its encoding with a "Str" throws an exception.
    Likewise, coercing an encoding-unaware "Buf" to "Str" dies.
    [Conjecture: The behaviour of encoding-aware "Buf" objects on string
    operators is intentionally not defined yet, because I have no idea what
    implications on speed and usage they might have --moritz].
  Enum and Pair
        class Enum does Associative {...}
        class Pair does Associative {...}
    A value formed by associating a single key with a single value. In an
    "Enum", both key and value are immutable. In a "Pair", the key is
    immutable but the value mutable. "Enum" works identically to "Pair"
    unless you try to modify it.)
    antipair
            multi method antipair ( $pair: --> Pair ) is export {
                $pair.value => $pair.key
            }
        Returns new pair with key and value swapped. Note singular spelling,
        since this operates only on one pair.
            multi method invert ( $pair: --> List ) is export {
                $pair.value »=>» $pair.key
        Note that this is not a simple exchange, but splits pairs with
        "Positional" values into multiple pairs in support of database
        inversion operations (when used along with "Hash.push").
        Equivalent to "antipair" if no values are "Positional".
  EnumMap
        class EnumMap does Associative does Positional {...}
    An immutable hash value, viewable either as a (constant) hash or as a
    sequence of "Enum"s. The keys may not contain duplicates, while the
    values may. The implementation of "EnumMap" associativity is not
    guaranteed to be as efficient as a "Hash" lookup. (A brute force linear
    scan for the matching key is allowed. Optimization is also allowed.)
  PairMap
        class PairMap does Associative does Positional {...}
    A hash value that is mutable only in values, differing from a normal
    hash insofar as the key set is frozen. It may be accessed either as a
    frozen hash or as a sequence of "Pair"s. The keys may not contain
    duplicates, while the values may. The implementation of "PairMap"
    associativity is not guaranteed to be as efficient as a "Hash" lookup.
    (A brute force linear scan for the matching key is allowed. Optimization
    to something like an ordered hash is also allowed.)
  Set
        class Set does Associative {...}
    A set of unique values or objects. (Sets are notionally "object hashes",
    that is, hashes that allow more than just strings as keys; as such, they
    are subject to "===" equality rather than "eqv" equality.) A "Set"
    responds to hash operators as if it were a "Hash of True". that is, when
    used as a hash, a set always treats the set's elements as the keys of
    the hash, returning "True" for existing set elements, and "False" for
    any key not found in the set.
    See "SetHash" for a container that can represent different sets as keys
    are added or deleted.
    Regardless of their behavior as hashes, set (and bag) types do not
    flatten in list context; in the absence of explicit interpolation
    instructions (such as use of the "@" sigil or ".keys" method) they are
    returned as items in list context. On the other end, the constructors
    for set and bag types do not automatically interpolate the contents of
    sets or bags (or any other other item type). They simply take the list
    of objects slurped in and turn them into a set. Together these rules
    allow us to constructs sets and bags containing sets and bags as
    elements.
    Use the "set" composer to construct a set of the elements of the list.
    The empty set may be indicated with either "set()" or "∅" (U+2205 EMPTY
    SET).
    The "set" composer will very literally make a set of whatever you pass
    it; in particular, it will make a set of Pairs if you try to pass it a
    list of Pairs (recall that a hash returns a list of Pairs in list
    context). To create a set from the keys of a list of Pairs, use a
    "Set()" coercion rather than a constructor. Or to create a set from a
    hash, use the ".keys" or ":k" to extract only the keys.
         multi method pick ( $set: Int $num = 1 --> Any )
         multi method pick ( $set: Whatever --> Any )
        Works like an ordinary list "pick".
         multi method roll ( $set: Int $num = 1 --> Any )
         multi method roll ( $set: Whatever --> Any )
        Works like an ordinary list "roll".
        Works as if the set were turned into a list of elements and then the
        combinations were turned back into a list of sets, ordered by
        increasing size. You may, of course, turn that list back into a set
        of sets.
        Note that, without an argument, this method basically calculates the
        powerset.
  SetHash
    A mutable Set container, represented as "QuantHash[Bool,False]".
  Bag
        class Bag does Associative {...}
    A collection of values or objects that work just like sets, except that
    they need not be unique. The count of each value or object is
    represented by an associative mapping from each key value/object to its
    replication number. The ".total" method returns the sum of all
    replication values. The ".minpairs" and ".maxpairs" methods return the
    pairs with the minimum and maximum replication number.
    Sets and bags do not flatten into list context, nor do the constructors
    interpolate items passed to them, even if they look like sets or bags.
    (To create a bag from a list of Pairs or a hash, use a "Bag()" coercion
    rather than a constructor.)
         multi method pick ( $bag: Int $num = 1 --> Any )
         multi method pick ( $bag: Whatever --> Any )
         multi method pickpairs ( $bag: Int $num = 1 --> Pairs )
         multi method pickpairs ( $bag: Whatever --> Pairs )
        Like an ordinary list "pick", but returns keys of the bag weighted
        by values, as if the keys were replicated the number of times
        indicated by the corresponding value and then list pick used.
        "BagHash" is the mutable form of "Bag". A "Bag" responds to hash
        operators as if it were a "Hash of UInt".
        The underlying metaphor for picking is that you're pulling colored
        marbles out a bag. (For "picking with replacement" see "roll"
        instead.) Picking require tracking the temporary state, so the
        immutable "Bag" is copied to a temporary private "BagHash", and the
        picks are made from that using the corresponding ".grab" or
        ".grabpairs" method (see below).
        Each ".pick"/".pickpairs" invocation maintains its own private state
        and has no effect on subsequent ".pick"/".pickpairs" invocations.
        The ".pickpairs" version returns the grabbed values as a list of
        "Pair" objects, whose keys are the keys and whose values are the
        replication values.
         multi method roll ( $bag: Int $num = 1 --> Any )
         multi method roll ( $bag: Whatever --> Any )
        Like an ordinary list "roll", but returns keys of the bag weighted
        indicated by the corresponding value and then list "roll" used. The
        underlying metaphor for rolling is that you're throwing $num dice
        that are independent of each other, which (in bag terms) is
        equivalent to picking a colored marble out your bag and then putting
        it back, and doing this $num times. In dice terms, the number of
        marbles corresponds to the number of sides, and the number of
        marbles of the same color corresponds to number of sides with the
        same color. (For "picking without replacement" see "pick" instead.)
        Rolling requires no temporary state.
    kxxv
         method kxxv (-->List)
        Returns a list of the keys of the bag, with each key multiplied by
        its replication factor (hence the name: .k xx .v).
  BagHash
    A mutable "Bag" container, represented as "QuantHash[UInt,0]".
  QuantHash
        role QuantHash[::T, $default = Any] does Mixy does Associative {...}
    A "QuantHash" represents a mutable set of objects, represented as the
    keys of a "Hash". When asked to behave as a list it ignores its
    ".values" and returns only ".keys" (possibly replicated by weight in the
    case of bag types). "SetHash" and "BagHash" are derived from this type,
    but constrain their hash values to be "Bool" and "UInt", respectively. A
    "QuantHash" automatically deletes any key whose corresponding value goes
    to the default value for the hash. For any "QuantHash", the ".total"
    methods returns the current sum of the values, which the "QuantHash"
    must either track or compute on demand. Tracking is preferable for
    efficient implementation of ".pick" and ".grab".
    All standard "QuantHash" containers have a default value that is false
    (such as 0 or '' or "Nil" or "Bool::False"), and keep around only those
    entries with non-default values, automatically deleting any entry if its
    value goes to that (false) default value.
    grab
         multi method grab ( $bag: Int $num = 1 --> Any )
         multi method grab ( $bag: Whatever --> Any )
         multi method grabpairs ( $bag: Int $num = 1 --> Any )
         multi method grabpairs ( $bag: Whatever --> Any )
        Like "pick", a "grab" returns a random selection of elements,
        weighted by the values corresponding to each key. Unlike "pick", it
        works only on mutable structures. Use of "grab" on an immutable
        structure results in an exception (much like "push" would). Since a
        "QuantHash", unlike a "Set" or "Bag", is mutable, ".grab" works
        directly on the "QuantHash", modifying it in place. (You may use
        ".pick" to treat the "QuantHash" as immutable; this will copy it and
        grab only from the temporary copy.)
        Grabbing decrements the grabbed key's replication value by one
        (deleting the key when it goes to 0). By definition, ".total" of the
        bag also decreases by one, so the probabilities stay consistent
        through subsequent grab operations.
        With the ".grabpairs" version, the replication value of the picked
        key is forced immediately to 0, removing all marbles of that color
        from the bag, as it were. Instead of returning keys, returns the
        grabbed values as a list of "Pair" objects, whose keys are the
        deleted keys and whose values are the deleted replication values.
  MixHash
    A "QuantHash[Real,0]"; like a "BagHash" but may have non-integral
    weights for use in weighted picking. Keys with fractional weights are
    deleted if they go to 0. Negative weights are not deleted, but the
    implementation may complain if it notices you attempting to use such a
    weight.
  Junction
    All method calls on junctions autothread because the type provides no
    public methods.
    !eigenstates
            method !eigenstates (Junction $j: --> List)
        Returns an unordered list of the values that constitute the junction
        (formerly called ".values"). It flattens nested junctions of the
        same type, so "(1|(2|3)).eigenstates" returns an arbitrary
        permutation of the list "1, 2, 3".
        Note this is a private method; you must arrange for yourself to be
        trusted by the junctions class in order to call it, which probably
        involves evil MONKEY-TYPING.
        Alternately, the values may be explicitly converted to a set value
        using ".Set" or "Set()". Note, however, that the set of eigenstates
        for a "none" junction defines the values that are *not* there, so
        the resulting "Set" will be the *complement* to the universe of
        values recognized by the junction! Also note that "any" and "all"
        junctions represent *sets* of sets of items, not sets of items.
        Since set items are by definition unique, only the "one" junction
        can be unthinkingly mapped to and from a given set. (This is why we
        discourage casual use of the eigenstates as a set.)
    DRAFT: Synopsis 32: Setting Library - Exceptions
        Last Modified: 28 Dec 2013
        Version: 27
Roles and Classes
    All built-in exceptions save for the base class "Exception" live in the
    "X::" namespace.
    Generally error classes are supposed to provide the objects involved
    with the error, and only convert them to a string form when producing
    the error message. This does not apply to compile errors that involve
    types which have not been fully composed yet; in that case just the name
    of the incomplete type is included in the exception object.
    Names of error classes should describe the problem in some way, or at
    least mention the operation that went wrong. If an error can only occur
    in relation to a certain type, the error types should be under
    "X::ThatType::".
  Exception
    All built-in exceptions inherit from "Exception", which provides some
    basic behavior: storing a backtrace and providing an interface for the
    backtrace printer.
        class Exception {
            has $.backtrace;
            method message() { ... } # an actual stub
            method gist { "$.message\n$.backtrace" }
            method throw() { }
            method fail()  { }
            method resumable() { }
            method resume() { }
    All direct subclasses are supposed to override method "message".
  X::OS
        role X::OS { has $.os-error }
    for all errors that are triggered by some error reported by the
    operating system (failed IO, system calls, fork, memory allocation).
  X::IO
        role X::IO does X::OS { }
    For IO related errors
   X::IO::Rename
    Thrown when a file rename fails. TODO: maybe unify with X::IO::Copy?
        my class X::IO::Rename does X::IO is Exception {
            has $.from;
            has $.to;
            method message() {
                "Failed to rename '$.from' to '$.to': $.os-error"
   X::IO::Copy
    Thrown when a file copy operation fails
        my class X::IO::Copy does X::IO is Exception {
                "Failed to copy '$.from' to '$.to': $.os-error"
   X::IO::Mkdir
    Thrown when an "mkdir" operation fails.
        my class X::IO::Mkdir does X::IO is Exception {
            has $.path;
            has $.mode;
                "Failed to create directory '$.path' with mode '0o{$.mode.fmt("%03o")}': $.os-error"
   X::IO::Chdir
    Thrown when a "chdir" fails
        my class X::IO::Chdir does X::IO is Exception {
                "Failed to change the working directory to '$.path': $.os-error"
   X::IO::Dir
    Thrown when a "dir()" fails
        my class X::IO::Dir does X::IO is Exception {
                "Failed to get the directory contents of '$.path': $.os-error"
   X::IO::Cwd
    Thrown when unable to determine the current directory.
        my class X::IO::Cwd does X::IO is Exception {
                "Failed to get the working directory: $.os-error"
   X::IO::Rmdir
    Thrown when "rmdir" fails.
        my class X::IO::Rmdir does X::IO is Exception {
                "Failed to remove the directory '$.path': $.os-error"
   X::IO::Unlink
    Thrown when "unlink" fails.
        my class X::IO::Unlink does X::IO is Exception {
                "Failed to remove the file '$.path': $.os-error"
   X::IO::Chmod
    Thrown when "chmod" fails.
        my class X::IO::Chmod does X::IO is Exception {
                "Failed to set the mode of '$.path' to '0o{$.mode.fmt("%03o")}': $.os-error"
  X::NYI
        class X::NYI is Exception {
            has $.feature;
            method message() { "$.feature is not yet implemented. Sorry. " }
    For errors that stem from incomplete implementations of the Perl 6
    language. A full Perl 6.0 implementation should not throw such errors.
  X::AdHoc
        class X::AdHoc is Exception {
            has $.payload handles <Str Numeric>;
            method message() { $.payload.Str }
    If you call &die with non-"Exception" arguments, what the user finds in
    his $! variables is an object of type "X::AdHoc".
    So &die could be written as
        multi sub die(Exception $e) is hidden-from-backtrace {
            $e.throw
        multi sub die($payload) is hidden-from-backtrace {
            X::AdHoc.new(:$payload).throw;
  Compile-time errors
   X::Comp
        role X::Comp {
            has $.filename;
            has $.line;
            has $.column;
    For errors that arise from compiling code. Note that in this case the
    backtrace shows how the compilation was triggered (through "use
    SomeModule;", "EVAL"s etc.). The actual location of the error does not
    appear in the backtrace, but rather in the attributes defined in this
    role.
    For exceptions that can occur both at run time and at compile time, the
    base exception type should not do "X::Comp", but it should be mixed in
    into the exception object when thrown at compile time.
   X::Placeholder::Block
    Thrown when a placeholder variable is used in a block that does not
    allow a signature (for example "class A { $^foo }".
        my class X::Placeholder::Block does X::Comp {
            has $.placeholder;
                "Placeholder variable $.placeholder may not be used here because the surrounding block takes no signature";
   X::Placeholder::Mainline
    Thrown when a placeholder variable is used in the mainline, ie outside
    of any explicit block.
        my class X::Placeholder::Mainline is X::Placeholder::Block {
                "Cannot use placeholder parameter $.placeholder in the mainline"
   X::Redeclaration
    Thrown when a symbol is redeclared
        my class X::Redeclaration does X::Comp {
            has $.symbol;
            has $.postfix = '';
            has $.what    = 'symbol';
                "Redeclaration of $.what $.symbol$.postfix";
   X::Undeclared
    Occurs when a symbol is being referenced that needs to be declared, but
    isn't.
        my class X::Undeclared does X::Comp {
            has $.what = 'Variable';
                "$.what $.symbol is not declared";
   X::Attribute::Undeclared
    Thrown when an undeclared attribute is being referenced.
        my class X::Attribute::Undeclared is X::Undeclared {
            has $.package-kind;
            has $.package-name;
                "Attribute $.name not declared in $.package-kind $.package-name";
   X::Phaser::Multiple
    Thrown when multiple phasers of the same type occur in a block, but only
    one is allowed (for example "CATCH" or "CONTROL").
        my class X::Phaser::Multiple does X::Comp {
            has $.block;
            method message() { "Only one $.block block is allowed" }
   X::Parameter::Default
    Thrown when a parameter has a default, but isn't allowed to have one,
    for example on mandatory parameters.
        my class X::Parameter::Default does X::Comp {
            has $.how;
            has $.parameter;
                $.parameter
                    ?? "Cannot put default on $.how parameter $.parameter"
                    !! "Cannot put default on anonymous $.how parameter";
   X::Parameter::Placeholder
    Thrown when the user tries to use a placeholder as a formal parameter.
    (Usually ":$foo" misspelled as $:foo).
        my class X::Parameter::Placeholder does X::Comp {
            has $.right;
                "In signature parameter, placeholder variables like $.parameter are illegal\n"
                ~ "you probably meant a named parameter: '$.right'";
   X::Parameter::Twigil
    Thrown when an illegal twigil is used in a formal parameter.
        my class X::Parameter::Twigil does X::Comp {
            has $.twigil;
                "In signature parameter $.parameter, it is illegal to use the $.twigil twigil";
   X::Parameter::MultipleTypeConstraints
    Thrown for multiple prefix type constraints like "Int Str $x".
        my class X::Parameter::MultipleTypeConstraints does X::Comp {
                qq[{"Parameter $.parameter" || 'A parameter'} may only have one prefix type constraint];
   X::Parameter::WrongOrder
    Thrown when parameters are listed in a signature in the wrong order (for
    example optional before mandatory parameters).
        my class X::Parameter::WrongOrder does X::Comp {
            has $.misplaced;
            has $.after;
                "Cannot put $.misplaced parameter $.parameter after $.after parameters";
   X::Signature::NameClash
    Thrown when multiple named parameters have the same name.
        my class X::Signature::NameClash does X::Comp {
            has $.name;
                "Name $.name used for more than one named parameter";
   X::Method::Private::Permission
    Thrown when attempting to call a private method outside the current
    class or role without a fitting trust relation.
        my class X::Method::Private::Permission does X::Comp {
            has $.method;
            has $.source-package;
            has $.calling-package;
                "Cannot call private method '$.method' on package $.source-package because it does not trust $.calling-package";
   X::Method::Private::Unqualified
    Thrown when attempting to call a method on something else than "self"
    without fully qualifying the class.
        my class X::Method::Private::Unqualified does X::Comp {
                "Private method call to $.method must be fully qualified with the package containing the method";
   X::Bind::NativeType
    Thrown when trying to bind to a natively typed variable TODO: inherit
    from X::Bind?
        my class X::Bind::NativeType does X::Comp {
                "Cannot bind to natively typed variable '$.name'; use assignment instead'
   X::Attribute::Package
    Thrown when trying to declare an attribute inside a package which
    doesn't support attributes.
        my class X::Attribute::Package does X::Comp {
            method message() { "A $.package-kind cannot have attributes" }
   X::Attribute::NoPackage
    Thrown when an attribute is declared where it does not make sense (for
    example in the mainline)
        my class X::Attribute::NoPackage does X::Comp {
            method message() { "You cannot declare an attribute here; maybe you'd like a class or a role?" }
   X::Value::Dynamic
    Thrown when a value must be known at compile time, but is not.
        my class X::Value::Dynamic does X::Comp {
            has $.what;
            method message() { "$.what value must be known at compile time" }
   X::Declaration::Scope
    Thrown when a declaration does not harmonize with the declared scope
    (for example "has sub foo() { }".
        my class X::Declaration::Scope does X::Comp {
            has $.scope;
            has $.declaration;
            method message() { "Cannot use '$.scope' with $.declaration declaration" }
   X::Declaration::Scope::Multi
    Thrown when a multi is declared with an incompatible scope, for example
    "our multi sub".
        my class X::Declaration::Scope::Multi is X::Declaration::Scope {
                "Cannot use '$.scope' with individual multi candidates. Please declare an {$.scope}-scoped proto instead";
   X::Anon::Multi
    Thrown when an anonymous multi is being declared.
        my class X::Anon::Multi does X::Comp {
            has $.multiness;
            has $.routine-type = 'routine';
            method message() { "Cannot put $.multiness on anonymous $.routine-type" }
   X::Anon::Augment
    Thrown when trying to augment an anonymous package.
        my class X::Anon::Augment does X::Comp {
            method message() { "Cannot augment anonymous $.package-kind" }
   X::Augment::NoSuchType
    Thrown when trying to augment a type which doesn't exist.
        my class X::Augment::NoSuchType does X::Comp {
            has $.package;
            method message() { "You tried to augment $.package-kind $.package, but it does not exist" }
   X::Package::Stubbed
    Thrown at "CHECK" time when there are packages stubbed but not later
    defined.
        my class X::Package::Stubbed does X::Comp {
            has @.packages;
            # TODO: suppress display of line number
                "The following packages were stubbed but not defined:\n    "
                ~ @.packages.join("\n    ");
   X::Inheritance::Unsupported
    Thrown when trying to inherit from a type that does not support
    inheritance (like a package or an enum).
        my class X::Inheritance::Unsupported does X::Comp {
            # note that this exception is thrown before the child type object
            # has been composed, so it's useless to carry it around. Use the
            # name instead.
            has $.child-typename;
            has $.parent;
            method message {
                $.child-typename ~ ' cannot inherit from ' ~
                $.parent.^name ~ ' because it is not inheritable';
  Syntax Errors
    Note that the distinction between general compile-time errors and syntax
    errors is somewhat blurry and arbitrary.
   X::Syntax
        role X::Syntax does X::Comp { }
    Common role for all syntax errors.
   X::Syntax::Obsolete
    Thrown when obsolete (mostly Perl 5) syntax is detected.
        role X::Syntax::Obsolete does X::Syntax {
            has $.old;
            has $.replacement; # cannot call it 'new',
                               # would collide with constructor
            has $.when = 'in Perl 6';
                "Unsupported use of $.old; $.when please use $.replacement";
   X::Syntax::Name::Null
    Thrown when a name component is empty, but shouldn't (for example "use
    ::;").
        my class X::Syntax::Name::Null does X::Syntax {
            method message() { 'Name component may not be null'; }
   X::Syntax::UnlessElse
    Thrown when an "unless" clause is followed by an "else" clause.
        my class X::Syntax::UnlessElse does X::Syntax {
            method message() { '"unless" does not take "else", please rewrite using "if"' }
   X::Syntax::Reserved
    Thrown when a syntax is used which is reserved for future expansion.
        my class X::Syntax::Reserved does X::Syntax {
            has $.reserved;
            has $.instead = '';
            method message() { "The $.reserved is reserved$.instead" }
   X::Syntax::P5
    Thrown when some piece of syntax is clearly Perl 5, not Perl 6.
        my class X::Syntax::P5 does X::Syntax {
            method message() { 'This appears to be Perl 5 code' }
   X::Syntax::NegatedPair
    Thrown when a negated pair has a value, for example ":!foo($val)".
        my class X::Syntax::NegatedPair does X::Syntax {
            has $.key;
            method message() { "Argument not allowed on negated pair with keys '$.key'" }
   X::Syntax::Variable::Numeric
    Thrown on "my $0" and the likes.
        my class X::Syntax::Variable::Numeric does X::Syntax {
            has $.what = 'variable';
            method message() { "Cannot declare a numeric $.what" }
   X::Syntax::Variable::Match
    Thrown on "my $<foo>" and the likes.
        my class X::Syntax::Variable::Match does X::Syntax {
            method message() { 'Cannot declare a match variable' }
   X::Syntax::Variable::Twigil
    Thrown on "my $:foo" and the likes
        my class X::Syntax::Variable::Twigil does X::Syntax {
            method message() { "Cannot use $.twigil twigil on $.scope variable" }
   X::Syntax::Variable::IndirectDeclaration
    Thrown on "my $::($name);" and similar constructs.
        my class X::Syntax::Variable::IndirectDeclaration does X::Syntax {
            method message() { 'Cannot declare a variable by indirect name (use a hash instead?)' }
   X::Syntax::Augment::WithoutMonkeyTyping
    Thrown when "augment" is used without "use MONKEY-TYPING".
        my class X::Syntax::Augment::WithoutMonkeyTyping does X::Syntax {
            method message() { "augment not allowed without 'use MONKEY-TYPING'" };
   X::Syntax::Augment::Role
    Thrown when trying to augment a role.
        my class X::Syntax::Augment::Role does X::Syntax {
            has $.role-name;
            method message() { "Cannot augment role $.role-name, since roles are immutable" };
   X::Syntax::Placeholder
    Occurs when a placeholder is used in a block that already has a
    signature attached. TODO: report the placeholder variables.
        my class X::Signature::Placeholder does X::Syntax {
                'Placeholder variable cannot override existing signature';
   X::Syntax::Comment::Embedded
    Thrown when "#`" is encountered and it is not followed by an opening
    bracket.
        my class X::Syntax::Comment::Embedded does X::Syntax {
            method message() { "Opening bracket required for #` comment" }
   X::Syntax::Pod::BeginWithoutIdentifier
    Thrown when "=begin" is encountered and no identifier comes after it.
        my class X::Syntax::Pod::BeginWithoutIdentifier does X::Syntax does X::Pod {
                '=begin must be followed by an identifier; (did you mean "=begin pod"?)'
   X::Syntax::Pod::BeginWithoutEnd
    Thrown when "=begin identifier" is parsed without the matching "=end
    identifier".
        my class X::Syntax::Pod::BeginWithoutEnd does X::Syntax does X::Pod {
            method message() { '=begin without matching =end' }
   X::Syntax::Confused
    The most general syntax error, if no more specific error message can be
    given.
        my class X::Syntax::Confused does X::Syntax {
            method message() { 'Confused' }
   X::Syntax::Malformed
    Thrown when a parsed construct is malformed.
        my class X::Syntax::Malformed does X::Syntax {
            method message() { "Malformed $.what" }
   X::Syntax::Missing
    Thrown when the previous piece of syntax requires the existence of
    another piece of syntax, and that second piece is missing.
        my class X::Syntax::Missing does X::Syntax {
            method message() { "Missing $.what" }
   X::Syntax::SigilWithoutName
    Thrown when a sigil without a following name is encountered in a place
    where this is not allowed.
        my class X::Syntax::SigilWithoutName does X::Syntax {
            method message() { 'Non-declarative sigil is missing its name' }
   X::Syntax::Self::WithoutObject
    Thrown when "self" is referenced in a place where no invocant is
    available.
        my class X::Syntax::Self::WithoutObject does X::Syntax {
            method message() { "'self' used where no object is available" }
   X::Syntax::VirtualCall
    Thrown when a "$.foo" style virtual call appears before an object is
    fully constructed, for example "has $.a = $.b;".
        my class X::Syntax::VirtualCall does X::Syntax {
            has $.call;
            method message() { "Virtual call $.call may not be used on partially constructed objects" }
   X::Syntax::NoSelf
    Thrown when "$.foo" style calls are used where no invocant is available.
        my class X::Syntax::NoSelf does X::Syntax {
            has $.variable;
            method message() { "Variable $.variable used where no 'self' is available" }
   X::Syntax::Number::RadixOutOfRange
    Thrown when the radix of a radix number is larger not allowed, like
    ":1<1>" or ":42<ouch>".
        my class X::Syntax::Number::RadixOutOfRange does X::Syntax {
            has $.radix;
            method message() { "Radix $.radix out of range (allowed: 2..36)" }
   X::Syntax::Regex::Adverb
    Thrown when an unrecognized or illegal regex adverb is encountered (for
    example "rx:g/a/").
        my class X::Syntax::Regex::Adverb does X::Syntax {
            has $.adverb;
            has $.construct;
            method message() { "Adverb $.adverb not allowed on $.construct" }
   X::Syntax::Regex::SolitaryQuantifier
    Thrown when a stand alone quantifier in a regex is encountered (for
    example "/ * /").
        my class X::Syntax::Regex::SolitaryQuantifier does X::Syntax {
            method message { 'Quantifier quantifies nothing' }
   X::Syntax::Term::MissingInitializer
    Thrown when a backslash-variable is declared without initialization
    assignment.
        my class X::Syntax::Term::MissingInitializer does X::Syntax {
            method message { "Term definition requires an initializer" }
   X::Syntax::AddCategorial::MissingSeparator
    Thrown when a circumfix operator is defined without separator between
    opening and closing terminators.
        my class X::Syntax::AddCategorial::MissingSeparator does X::Syntax {
            has $.opname;
            method message { "Unable to identify both starter and stopper from $.opname\nPerhaps you forgot to separate them with whitespace?" }
   X::Syntax::Signature::InvocantMarker
    Thrown when the invocant in a signature is anywhere else than after the
    first parameter.
        my class X::Syntax::Signature::InvocantMarker does X::Syntax {
                "Can only use : as invocant marker in a signature after the first parameter"
   X::Syntax::Extension::Category
    Thrown when a subroutine of name "category:<symbol>()" is encountered,
    and the category is not known.
        my class X::Syntax::Extension::Category does X::Syntax {
            has $.category;
                "Cannot add tokens of category '$.category'";
   X::Syntax::InfixInTermPosition
    Thrown when the parser expects a term, but finds an infix operator.
        my class X::Syntax::InfixInTermPosition does X::Syntax {
            has $.infix;
                "Preceding context expects a term, but found infix $.infix instead";
  X::Pod
        role X::Pod { }
    Common role for all Pod-related errors.
  Dispatch errors
   X::Method::NotFound
    Thrown when the user tries to call a method that isn't there, for
    example "1.foo".
    TODO: should hold the actual invocation, not the type name. Currently
    that's due to a limit in Rakudo and Parrot.
        my class X::Method::NotFound is Exception {
            has $.typename;
            has Bool $.private = False;
                $.private
                    ?? "No such private method '$.method' for invocant of type '$.typename'"
                    !! "No such method '$.method' for invocant of type '$.typename'";
   X::Method::InvalidQualifier
    Thrown when a method is call in the form "$invocant.TheClass::method" if
    <$invocant> does not conform to "TheClass"
        my class X::Method::InvalidQualifier is Exception {
            has $.invocant;
            has $.qualifier-type;
                "Cannot dispatch to method $.method on {$.qualifier-type.^name} "
                ~ "because it is not inherited or done by {$.invocant.^name}";
  X::OutOfRange
    General error when something (for example an array index) is out of an
    allowed range.
        my class X::OutOfRange is Exception {
            has $.what = 'Argument';
            has $.got = '<unknown>';
            has $.range = '<unknown>';
            has $.comment;
                $.comment.defined
                ?? "$.what out of range. Is: $.got, should be in $.range.gist(); $.comment"
                !! "$.what out of range. Is: $.got, should be in $.range.gist()"
  X::Buf::AsStr
    Thrown when a "Buf" object is used as string.
        my class X::Buf::AsStr is Exception {
                "Cannot use a Buf as a string, but you called the $.method method on it";
  X::Buf::Pack
    Thrown when an unknown template/directive is encountered by "pack" or
    "unpack".
        my class X::Buf::Pack is Exception {
            has $.directive;
                "Unrecognized directive '$.directive'";
  X::Buf::Pack::NonASCII
    Thrown when the "A" template/directive comes across a non-ASCII
    character.
        my class X::Buf::Pack::NonASCII is Exception {
            has $.char;
                "non-ASCII character '$.char' while processing an 'A' template in pack";
  X::Bind
    Thrown when trying to bind to something which isn't a valid target for
    binding (except for some more special cases listed below).
        my class X::Bind is Exception {
            has $.target;
                $.target.defined
                    ?? "Cannot bind to $.target"
                    !! 'Cannot use bind operator with this left-hand side'
  X::Bind::Slice
    Thrown when trying to bind to a slice. TODO: inherit from X::Bind?
        my class X::Bind::Slice is Exception  {
            has $.type;
                "Cannot bind to {$.type.^name} slice";
  X::Bind::ZenSlice
    Thrown when trying to bind to a Zen slice, eg "@a[] := (1, 2)".
        my class X::Bind::ZenSlice is X::Bind::Slice {
                "Cannot bind to {$.type.^name} zen slice";
  X::Does::TypeObject
    Thrown when trying to use infix "does" (not the trait) on a type object.
        my class X::Does::TypeObject is Exception {
            method message() { "Cannot use 'does' operator with a type object." }
  X::Role::Initialization
    Thrown when the "SomeRole($init)" syntax is used, but SomeRole does not
    have exactly one public attribute.
        my class X::Role::Initialization is Exception {
            method message() { 'Can only supply an initialization value for a role if it has a single public attribute' }
  X::Routine::Unwrap
    Thrown when "&routine.unwrap" is called with an argument that is not a
    wrap handle.
        my class X::Routine::Unwrap is Exception {
            method message() { "Cannot unwrap routine: invalid wrap handle" }
  X::Constructor::Positional
    Thrown from "Mu.new" when positional arguments are passed to it.
        my class X::Constructor::Positional is Exception {
            method message() { "Default constructor only takes named arguments" }
  X::Hash::Store::OddNumber
    Thrown when hash assignment finds a trailing hash key with a value.
        my class X::Hash::Store::OddNumber is Exception {
            method message() { "Odd number of elements found where hash expected" }
  X::Phaser::PrePost
    Thrown when the condition inside a "PRE" or "POST" phaser evaluate to a
    false value.
        my class X::Phaser::PrePost is Exception {
            has $.phaser = 'PRE';
            has $.condition;
                my $what = $.phaser eq 'PRE' ?? 'Precondition' !! 'Postcondition';
                $.condition.defined
                    ?? "$what '$.condition.trim()' failed"
                    !! "$what failed";
  X::Str::Numeric
    Thrown (or wrapped in a "Failure") when a conversion from string to
    number fails.
        my class X::Str::Numeric is Exception {
            has $.source;
            has $.pos;
            has $.reason;
            method source-indicator {
                constant marker = chr(0x23CF);
                join '', "in '",
                        $.source.substr(0, $.pos),
                        marker,
                        $.source.substr($.pos),
                        "' (indicated by ",
                        ")",
                        ;
                "Cannot convert string to number: $.reason $.source-indicator";
  X::Str::Match::x
    Thrown when "Str.match(:$x)" or "m:x($x)//" is called with an type of $x
    that is now allowed.
        my class X::Str::Match::x is Exception {
            has $.got;
                "in Str.match, got invalid value of type {$.got.^name} for :x, must be Int or Range"
  X::Str::Trans::IllegalKey
    Thrown when a Pair passed to "Str.trans" is of a type that the trans
    method cannot work with (regexes and types derived from "Cool" are
    fine).
        my class X::Str::Trans::IllegalKey is Exception {
                "in Str.trans, got illegal substitution key of type {$.key.^name} (should be a Regex or Str)"
  X::Str::Trans::InvalidArg
    Thrown when an argument to "Str.trans" is not a "Pair".
        my class X::Str::Trans::InvalidArg is Exception {
                "Only Pair objects are allowed as arguments to Str.trans, got {$.got.^name}";
  X::Range::InvalidArg
    Thrown when an argument to "Range.new" is a "Range".
        my class X::Range::InvalidArg is Exception {
                "{$.got.^name} objects are not valid endpoints for Ranges";
  X::Sequence::Deduction
    Exception type when the "..." sequence operator is being called without
    an explicit closure, and the sequence cannot be deduced.
        my class X::Sequence::Deduction is Exception {
            method message() { 'Unable to deduce sequence' }
  X::ControlFlow
    Thrown when a control flow construct (such as "next" or "redo") is
    called outside the dynamic scope of an enclosing construct that is
    supposed to catch them.
        my class X::ControlFlow is Exception {
            has $.illegal;   # something like 'next'
            has $.enclosing; # ....  outside a loop
            method message() { "$.illegal without $.enclosing" }
  X::ControlFlow::Return
    Thrown when a "return" is called from outside a routine.
        my class X::ControlFlow::Return is X::ControlFlow {
            method illegal()   { 'return'  }
            method enclosing() { 'Routine' }
            method message()   { 'Attempt to return outside of any Routine' }
  X::Composition::NotComposable
    Thrown when trying to compose a type into a target type, but the
    composer type cannot be used for composition (roles and enums are
    generally OK).
        my class X::Composition::NotComposable is Exception {
            has $.target-name;
            has $.composer;
                $.composer.^name ~ " is not composable, so $.target-name cannot compose it";
  X::TypeCheck
    Thrown when a type check fails.
        my class X::TypeCheck is Exception {
            has $.operation;
            has $.expected;
                "Type check failed in $.operation; expected '{$.expected.^name}' but got '{$.got.^name}'";
  X::TypeCheck::Binding
    Thrown when the type check of a binding operation fails.
    TODO: figure out if we actually need that type
        my class X::TypeCheck::Binding is X::TypeCheck {
            method operation { 'binding' }
  X::TypeCheck::Return
    Thrown when a return type check fails.
        my class X::TypeCheck::Return is X::TypeCheck {
            method operation { 'returning' }
                "Type check failed for return value; expected '{$.expected.^name}' but got '{$.got.^name}'";
  X::NoDispatcher
    Thrown when a redispatcher like "nextsame" is called without being in
    the dynamic scope of a call that could possible redispatch.
        my class X::NoDispatcher is Exception {
            has $.redispatcher;
                "$.redispatcher is not in the dynamic scope of a dispatcher";
  X::Localizer::NoContainer
    Thrown when "let" or "temp" or a similar localizer are used on a
    non-container, like "temp 1 = 2".
        my class X::Localizer::NoContainer is Exception {
            has $.localizer;
                "Can only use '$.localizer' on a container";
  X::Mixin::NotComposable
    Thrown when a mixin with infix "does" or "but" is done with a composer
    that cannot be used for mixin.
        my class X::Mixin::NotComposable is Exception {
            has $.rolish;
                "Cannot mix in non-composable type {$.rolish.^name} into object of type {$.target.^name}";
  X::Export::NameClash
    Thrown when a symbol is exported twice.
        my class X::Export::NameClash is Exception {
                "A symbol '$.symbol' has already been exported";
  X::HyperOp::NonDWIM
    Thrown when a non-DWIMy hyperop has lists of lengths that do not match.
        my class X::HyperOp::NonDWIM is Exception {
            has &.operator;
            has $.left-elems;
            has $.right-elems;
                "Lists on both side of non-dwimmy hyperop of &.operator.name() are not of the same length\n"
                ~ "left: $.left-elems elements, right: $.right-elems elements";
  X::Set::Coerce
    Thrown when "Set($obj)" is called to coerce an object to a "Set", and
    "Set" does not know how to handle an object of such type.
        my class X::Set::Coerce is Exception {
            has $.thing;
                "Cannot coerce object of type {$.thing.^name} to Set. To create a one-element set, pass it to the 'set' function";
  X::Temporal
    A common exception type for all errors related to "DateTime" or "Date".
        my role X::Temporal is Exception { }
  X::Temporal::InvalidFormat
    Thrown when the "Date" or "DateTime" constructors get a string in a
    format which is not a valid date format.
        my class X::Temporal::InvalidFormat is X::Temporal {
            has $.invalid-str;
            has $.target = 'Date';
            has $.format;
                "Invalid $.target string '$.invalid-str'; use $.format instead";
  X::Temporal::Truncation
    Thrown when "DateTime.truncated-to" or "Date.truncated-to" are called in
    a way that doesn't make sense.
        my class X::Temporal::Truncation is X::Temporal {
            has $.class = 'DateTime';
            has $.error;
                "in $.class.truncated-to: $.error";
  X::Eval::NoSuchLang
    Thrown when "EVAL($str, :$lang)" specifies a language that the compiler
    does not know how to handle.
        my class X::Eval::NoSuchLang is Exception {
            has $.lang;
                "No compiler compiler available for language '$.lang'";
  X::Numeric::Real
    Occurs when an attempt to coerce a "Numeric" to a "Real", "Num", "Int"
    or "Rat" fails (due to a number with a nonzero imaginary part, for
    instance).
        my class X::Numeric::Real is Exception {
                "Can not convert $.source to {$.target.^name}: $.reason";
  X::StubCode
    Occurs when a stub (created via "!!!", or "..." with "use fatal") is
    executed.
        my class X::StubCode is Exception {
            has $.message = 'Stub code executed';
Related types
  Failure
        class Failure is Mu {
            has Bool $.handled is rw;
            has $.X;            # the actual exception object
    An unthrown exception, usually produce by "fail()".
    (Conjecture: S04 implies that all exceptions have a "$.handled"
    attribute. Do we actually need that?)
  Backtrace
        class Backtrace does Positional[Backtrace::Frame] {
            method Stringy() { ... }
            method full() { ... }
        class Backtrace::Frame {
            has $.file;
            has $.code;
            has $.subname;
            method is-hidden () { ... }
            method is-routine() { ... }
            method is-setting() { ... }
    Backtrace information, typically used (but not limited to) in
    exceptions. Stringifies to
        in '$<routine>' at line $<line>:$<filename>
        ...
    with two leading spaces on each line.
    The default stringification includes blocks and routines from user-space
    code, but from the setting only routines are shown [conjectural].
    Routines can be hidden from the default backtrace stringification by
    apply the "hidden-from-backtrace" trait:
        sub my-die(*@msg) is hidden-from-backtrace { }
    the "is-hidden" method in "Backtrace::Frame" returns "Bool::True" for
    routines with that trait.
    The "full" method in "Backtrace" provides a string representation of the
    backtrace that includes all available code objects, including hidden
    ones.
    If a code object does not have a name, "<anon>" is used instead of the
    routine name.
The Default Exception Printer
    In case an exception does not get caught by any "CATCH" or "CONTROL"
    block, it is caught by a default handler in the setting.
    This handler calls the ".gist" method on the exception, prints the
    result, and terminates the program. The exit code is determined as
    "$exception.?exit-code // 1".
        Moritz Lenz <moritz@faui2k.org>
    Authors of previous versions of this document:
    DRAFT: Synopsis 32: Setting Library - IO
        Created: 19 Feb 2009 extracted from S29-functions.pod; added stuff from S16-IO later
        Last Modified: 05 May 2014
        Version: 23
Overview
    The most common IO operations are "print" and "say" for writing and
    "lines" and "get" for reading. All four are available as subroutines
    (defaulting to the $*OUT and $*ARGFILES file handles) and as methods on
    file handles.
    File handles are of type "IO::Handle", and can be created with &open.
    Paths are generally passed as strings or "IO::Path" objects.
    &dir returns "IO::Path" objects.
                  default handle
        routine   for sub form    purpose
        =======   ===========     =======
        print     $*OUT           string-based writing
        say       $*OUT           string-based writing
        get       $*ARGFILES      read a line (Str)
        lines     $*ARGFILES      read all lines (Str)
        read                      binary reading (Buf)
        write                     binary writing (Buf)
    File tests are performed through "IO::Path" objects.
Functions
    open
            multi open (Str $name,
              # mode
                Bool :$r  = True,
                Bool :$w  = False,
                Bool :$rw = False,
                Bool :$a  = False,
              # encoding
                Bool :$bin = False,
                Str  :$enc = "Unicode",
              # newlines
                Any  :$nl = "\n",
                Bool :$chomp = True,
                ...
                --> IO::Handle
            ) is export
        A convenience function that hides most of the OO complexity. It will
        only open normal files. Text is the default. Note that the "Unicode"
        encoding implies figuring out which actual UTF is in use, either
        from a BOM or other heuristics. If heuristics are inconclusive,
        UTF-8 will be assumed. (No 8-bit encoding will ever be picked
        implicitly.) A file opened with ":bin" may still be processed
        line-by-line, but IO will be in terms of "Buf" rather than "Str"
        types.
        For a discussion of the read/write/append modes (:r, :w, :a), see
        "IO::Handle/open" under IO::Handle.
    dir
            multi dir($directory = '.', Mu :$test = none('.', '..')) { ... }
        Returns a lazy list of file names in the $directory. By default the
        current and the parent directory are excluded, which can be
        controlled with the $test named parameter. Only items that
        smart-match against this test are returned.
        The return value is a list of "IO::Path" objects. Because of this,
        you may want use the "basename" method on the results to get the
        just the file name, without its full path. If dir() fails, it
        returns an X::IO::Dir failure.
    glob
            multi glob(Str $pattern --> Array[Str])
        Accepts a pattern that will then be expanded into a array of
        filenames (the creation of "IO" objects from this list is left to
        the user).
        The default "glob" function operates on POSIX rules, which may be
        read in more detail in the glob(7) manpage, however an overview is
        presented below.
        The "glob" function understands a few metacharacters:
            \    Escape metacharacter
            ~    Home directory
            ?    Match exactly one character
            *    Match zero or more characters
            [    Start of character class (ends with ])
        Note that this is not a regex-like syntax, so the "?" and "*" are
        not quantifiers.
            glob("foo?");  # roughly equivalent to /^ foo. $/, NOT /^ foo? $/
            glob("*bar");  # valid syntax; roughly equivalent to /^ .* bar $/
        The character class construct "[...]" matches all characters
        specified. It has a few metacharacters of its own:
            glob("[]]");     # matches the ] character
            glob("[!abc]");  # matches all but 'a', 'b', or 'c' (negation)
            glob("[a-z]");   # matches all lowercase letters from a to z (range)
            glob("[a-]");    # matches 'a' and '-'
            glob("[[:xdigit:]]"); # matches hexadecimal digit (named character class)
        Ranges matches all the characters that fall between and the
        startpoint and endpoint, inclusively. Note that the "/" character
        can never be matched by a range. If contained within the a range
        (such as "[--0]"), the "/" is skipped. If explicitly specified as
        the start- or endpoint, it's considered a syntax error.
            glob("[--0]");   # matches '-', '.', or '0' (skips '/')
            glob("[a/b]");   # matches 'a', '/', or 'b'
            glob("[/-0]");   # syntax error
        There are some notable departures from POSIX in terms of what the
        Perl 6 &glob function allows with character classes. Namely, neither
        the "[[.ch.]]" nor "[[=ch=]]" forms are supported, and the "[^...]"
        form is not undefined, but rather matches the "^" character among
        other things.
        Glob metacharacters that must be escaped outside character classes
        aren't within.
            glob('\[\*\?\~');    # Matches the filename "[*?~"
            glob("[[*?~]");      # Matches the filenames "[", "*", "?", and "~"
        Unlike Perl 5, no special attention is given to the interpolation
        rules of strings, particularly braces.
    note
            multi note (*@LIST --> Bool)
        Does a "say" to $*ERR, more or less. Like "warn", it adds a newline
        only if the message does not already end in newline. Unlike "warn",
        it is not trappable as a resumable exception because it outputs
        directly to $*ERR. You can suppress notes in a lexical scope by
        declaring:
            only note(*@) {}
    slurp
            multi slurp (IO::Handle $fh = $*ARGFILES,
                --> Str|Buf
            )
            multi slurp (Str $filename,
        Slurps the entire file into a "Str" (or "Buf" if ":bin") regardless
        of context. (See also "lines".)
        The routine will "fail" if the file does not exist, or is a
        directory.
    spurt
            multi spurt (IO::Handle $fh,
                Str   $contents,
                Str  :$enc = $?ENC,
                Bool :append = False,
                Bool :$createonly = False,
                Buf   $contents,
            multi spurt (Str $filename,
        Opens the file for writing, dumps the contents, and closes the file.
        This routine will "fail" if the file exists and ":createonly" is
        set.
        If ":append" is provided, an existing file will not be clobbered,
        but the string will be appended.
        The routine will also "fail" with the corresponding exception if
        there was any other error in opening, writing, or closing.
    chdir
            multi sub chdir(Str:D)
            multi sub chdir(IO::Path:D)
        Changes the current (emulated) working directory to the new value,
        scoped to the current scope of $*CWD (usually thread-local at worst,
        or the scope of a "visitdir" inside the current thread). Fails
        (X::IO::Chdir) on error. If $*CWD is not scoped to the current
        dynamic scope, you must call "chdir" again when exiting the dynamic
        scope to get back to the original directly, just as you would with a
        real "chdir". In this case you would probably be better off using
        "visitdir" instead, which will automatically scope $*CWD to the
        current dynamic scope.
        Note that actually changing the process's working directory requires
        a call to "PROCESS::chdir" (which will inform the chdir emulation
        that the process's actual current working directory has changed).
        This function is not threadsafe, however. And if calling out to a
        foreign function, only one thread can safely use it; in general it's
        better to pass absolute paths to foreign functions that don't allow
        you to set the working directory as a parameter.
    visitdir
            multi sub visitdir(Str:D)
            multi sub visitdir(IO::Path:D)
        scoped to the current dynamic scope just as "temp $*CWD = newdir();"
        would. Fails (X::IO::Chdir) on error. Since $*CWD is dynamically
        scoped, leaving the current dynamic scope automatically restores the
        current (emulated) working directory.
    unlink
            sub unlink(Cool:D $path)
        Unlinks an ordinary file, link, or symbolic link from disk -- that
        is, it is deleted. Returns True on success; otherwise returns an
        "X::IO::Unlink" in S32::Exception failure.
    rmdir
            sub rmdir(Cool:D $directory)
        Removes the directory given from disk. Returns True on success, or
        an X::IO::Rmdir failure.
    mkdir
            sub mkdir(Cool:D $directory)
        Makes (creates) the directory represented by the IO::Path. Returns
        True on success, or an X::IO::Mkdir failure.
IO Types
  IO
        role IO { };
    The base role only tags that this is an "IO" object for more generic
    purposes. It doesn't specify any methods or attributes.
  IO::Handle
        class IO::Handle does IO { ... }
    A handle of a file, pipe or anything else that supports reading or
    writing like a file.
            multi method open (
        Open the handle for reading or writing (or both). Specifying ":r",
        the default, opens the handle as read-only, ":w" is write-only,
        ":rw" is read-write, and ":a" appends writes to the file.
        The ":enc" parameter controls which text encoding the file is
        interpreted as. Unicode is the default encoding. See "encoding" for
        encoding options.
        The ":nl" option sets "input-line-separator", and ":chomp"
        determines if the new line separator will be chopped removed by
        "get" and "lines".
        Conjectural: The <:p> parameter opens a pipe, which is readable with
        ":r" (default) and writable with ":w".
    get
            method get() returns Str:D
        Reads and returns one line from the handle. Uses
        "input-line-separator" to determine where a line ends.
    lines
            method lines($limit = Inf)
        Returns a lazy list of lines read via the "get" method, limited to
        $limit lines.
    getc
            method getc (IO::Handle:D: Int $chars = 1 --> Str)
        Reads $chars and returns them
    print
            method print (IO::Handle:D: *@LIST --> Bool)
            multi print (*@LIST --> Bool)
        Stringifies each element, concatenates those strings, and sends the
        result to the output. Returns "Bool::True" if successful, "Failure"
        otherwise.
        The compiler will warn you if use a bare sub "print" without
        arguments. (However, it's fine if you have an explicit argument list
        that evaluates to the empty list at runtime.)
            print;             # warns
            if $_ { print }    # warns
            if $_ { print() }  # ok, but does nothing
            if $_ { print () } # ok, but does nothing
    say
            method say (IO::Handle:D: *@LIST --> Bool)
            multi say (*@LIST --> Bool)
        This is identical to print() except that it stringifies its
        arguments by calling ".gist" on them and auto-appends a newline
        after the final argument.
            Was:    print "Hello, world!\n";
            Now:    say   "Hello, world!";
        As with "print", the compiler will warn you if you use a bare sub
        "say" without arguments.
    printf
            method printf (Str $fmt, *@LIST --> Bool)
            multi printf (IO::Handle:D: Str $fmt, *@LIST --> Bool)
        Output through "Str.sprintf". See S32::Str for details.
    write
            method write(IO::Handle:D: Buf $buf --> Int)
        Tries to write $buf. The actual number of bytes written is returned.
        It might return unthrown failures, to be specified by each "IO"
        implementation.
        This is "raw" write. $buf contains plain octets. If you want to
        "write" a "Str", you should ".encode" it first, or use "print" or
        other "IO::Writeable::Encoded" methods.
            method slurp(
                --> Str|Buf)
        Opens the handle if necessary, slurps the entire file into a "Str"
        (or "Buf" if ":bin" parameter is given) regardless of context.
        Closes the handle after it is done, and returns the contents of the
        file. (See also "lines".)
            multi method spurt (
                Bool :$createonly = False)
    t
            method t() returns Bool:D
        Returns "True" if the handle is opened to a tty.
    p
            method p() returns Bool:D
        Returns "True" if the handle is opened to a pipe.
    eof
            method eof() returns Bool:D
        Returns "True" if the handle is exhausted.
    seek
        method seek(Int $position, Int $whence --> Bool)
        Position this stream into $position. The meaning of this position is
        always in "octets".
        Fails if the handle is not seekable.
        TODO: make $whence an Enum
    tell
            method tell() returns Int:D:
        Returns the current raw position in the stream in number of
        "octets".
    ins
            method ins( --> Int)
        Returns the number of lines that have been read with "get".
    input-line-separator
            method input-line-separator( --> Str) is rw
        This regulates how "get" and "lines" behave.
        The input line (record) separator, newline by default. This
        influences Perl's idea of what a ``line'' is. Works like awk's RS
        variable, including treating empty lines as a terminator if set to
        the null string. (An empty line cannot contain any spaces or tabs.)
        You may set it to a multi-character string to match a
        multi-character terminator, or to Nil to read through the end of
        file. Setting it to "\n\n" means something slightly different than
        setting to "", if the file contains consecutive empty lines. Setting
        to "" will treat two or more consecutive empty lines as a single
        empty line. Setting to "\n\n" will blindly assume that the next
        input character belongs to the next paragraph, even if it's a
        newline.
        You may also set it to a regular expression. The value of $/ will be
        (temporarily) set to the matched separator upon input, if you care
        about the contents of the separator.
    encoding
            multi method encoding($enc?)
        With no arguments, simply returns the current encoding used on the
        handle. If supplied a string identifying a valid encoding, change
        the handle to read with that encoding. Options include "binary",
        "utf8", and other text encodings. An invalid encoding causes the
        method to fail.
    IO  Returns the handle itself (no-op).
    close
        Closes the handle. Fails on error.
  IO::FileTestable
        role IO::FileTestable does IO { ... }
    Provides ways to inspect a file or path without opening it.
    If you apply that role to a class, that class must provide a "Str"
    method which returns the full path. "IO::FileTestable" will call this
    method to obtain the path to test. Stringification must return "Str:D"
    here.
    The methods are typically only one letter long (for now; Perl 5
    tradition strikes) and are summarized in the following table:
        M  Test performed                              Returns
        =  ==============                              =======
        r  Path is readable by effective uid/gid.      Bool:D
        w  Path is writable by effective uid/gid.      Bool:D
        x  Path is executable by effective uid/gid.    Bool:D
        o  Path is owned by effective uid.             Bool:D
        R  Path is readable by real uid/gid.           Bool:D
        W  Path is writable by real uid/gid.           Bool:D
        X  Path is executable by real uid/gid.         Bool:D
        O  Path is owned by real uid.                  Bool:D
        e  Path exists.                                Bool:D
        s  Size of the path in bytes.                  Int:D
        z  Path has zero size (an empty file).         Bool:D
        f  Path is a plain file.                       Bool:D
        d  Path is a directory.                        Bool:D
        l  Path is a symbolic link.                    Bool:D
        p  Path is a named pipe (FIFO)                 Bool:D
        S  Path is a socket.                           Bool:D
        b  Path is a block special file.               Bool:D
        c  Path is a character special file.           Bool:D
        u  Path has setuid bit set.                    Bool:D
        g  Path has setgid bit set.                    Bool:D
        k  Path has sticky bit set.                    Bool:D
    All methods (except for "e") return the appropriate type object if a
    path has been specified that does not exist.
    accessed
        Returns the last access time ("atime") of the path, to the degree
        that it is updated on that system.
    modified
        Returns the time that the path was last modified ("mtime").
    changed
        Returns the time that the path was last changed (modified or a
        metadata change).
    stat
        Returns a stat buffer for the path.
    TODO: methods created, accessed, modified: return format, failure
  IO::Path
        class IO::Path is Cool does IO::FileTestable { }
    Holds a path of a file or directory. The path is generally divided into
    three parts, the *volume*, *directory* and *base name*.
    On Windows, the volume is a drive letter like "C:", or a UNC network
    volume like "\\share\". On UNIX-based systems, the volume part is empty.
    The base name is name of the file or directory that the IO::Path object
    represents, and the directory is the part of the path leading up to the
    base name.
        path              volume         directory  base name
        /usr/bin/gvim                    /usr/bin   gvim
        /usr/bin/                        /usr       bin
        foo/bar.txt                      foo        bar.txt
        C:\temp\f.txt     C:             \temp      f.txt
        \\server\share\a  \\server\share \          a
    IO::Path uses the syntax for the current operating system. If you want
    to work paths as if you were using another OS, use the OS-specific
    subclasses such as IO::Path::Cygwin.
    There are several ways of creating an IO::Path. Both IO::Handle and Cool
    have a .path method, or you can construct it directly:
            "my/path".path
            $filehandle.path
            IO::Path.new( $full-path );
            IO::Path.new( :$volume, :$directory, :$basename);
    Str Stringification returns the path (volume, directory and base name
        joined together) as a string.
    volume
        Returns the volume part of the path. On Unix-like OSes or systems
        without a concept of volume in the path, returns the empty string.
    directory
        Returns the directory part of the path, not including the last item.
        Functions equivalently to the "dirname" shell program on Unix-like
        systems.
    basename
        Returns the base name part of the path -- that is, the last portion.
        Functions equivalently to the "basename" shell program on Unix-like
    path
        Returns the entire IO::Path object (a no-op).
    contents
            method contents( Mu :$test = none('.', '..') )
        Returns a lazy list of file names in the path, if it is a directory.
        The current and the parent directory are excluded, which can be
        just the file name, without its full path.
    cleanup
                method cleanup( :$parent = False )
        Returns a new IO::Path object with the canonical path. This
        eliminates extra slashes and '.' directories, but leaves '..' in (or
        whatever the parent directory is called on that platform).
        With ":parent", cleanup will logically remove references to the
        parent directory without *checking the filesystem*. That is, the
        parent of a symbolic link will remove the symlink itself, not the
        parent of the symlink's destination.
    resolve
        Returns a new IO::Path object that is cleaned-up (as above), and all
        symbolic links and references to the parent directory ("..") are
        physically resolved. This means that the filesystem is examined for
        each directory in the path, and any symlinks found are followed.
        Identical to ".cleanup(:parent)" on systems where symbolic links are
        not supported.
           # bar is a symlink pointing to "/baz"
           my $path = "foo/./bar///..".path;
           $path.=cleanup;  # now "foo/bar/.."
           $path.cleanup(:parent); # yields "foo"
           $path.=resolve;  # now "/" (the parent of "/baz")
    is-relative
        Returns True if the path is a relative path (like "foo/bar"), False
    is-absolute
        Returns True if the path is an absolute path (like "/usr/bin"),
        False otherwise.
    absolute
            method absolute ( Str $base = $*CWD )
        Transforms the path into an absolute form, and returns the result as
        a new IO::Path. If $base is supplied, transforms it relative to that
        base directory; otherwise the current working directory is used.
        Paths that are already absolute are returned unchanged.
    relative
            method relative ( Str $base = $*CWD )
        Transforms the path into an relative form, and returns the result as
        Paths that are already relative are returned unchanged.
    parent
        Removes the last portion the given path, and returns a new IO::Path.
        This does not remove ".", "..", or symbolic links, so you may want
        to consider calling cleanup or resolve first.
        On a Unix/POSIX filesystem, if called recursively, it will work like
        so:
            parent level          relative       absolute
            Starting Path (0)     foo/bar        /foo/bar
            1                       foo            /foo
            2                        .              /
            3                        ..             /
            4                      ../..            /
            5                     ../../..          /
    child
            method child ( Str $childname )
        Appends $childname to the end of the path, adding path separators
        where needed and returns the result as a new IO::Path.
    succ
        Increments the basename portion of the string, as Str.succ does, and
        returns that successor as an IO::Path.
        This is useful for getting all the parts of say, a multi-part
        archive, but does not always return the next item in the folder. To
        crawl a folder, you probably want to iterate on the parent
        directory's contents.
    pred
        Decrements the basename portion of the string, as Str.pred does, and
        returns that predecessor as an IO::Path.
    copy
            method copy ($dest, :$createonly = False )
        Copies a file from the path, to the destination specified. If
        :createonly is set to True, copy fails when a file already exists in
        the destination. If the operation cannot be completed, fails as
        X::IO::Copy.
        Unlinks (deletes) the ordinary file, link, or symbolic link
        represented by the IO::Path. Returns True on success; on error,
        fails with an X::IO::Unlink.
        Removes (deletes) the directory represented by the IO::Path.
        Typically fails unless the directory is empty. Returns True on
        success; fails with an X::IO::Rmdir on error.
        True on success. The method will "fail" with X::IO::Mkdir if it can
        not create the directory, if file or directory already exists or if
        the parent directory of the path does not exist.
   OS Specific subclasses.
    IO::Path::Unix, IO::Path::Win32, and IO::Path::Cygwin subclasses are
    available for manipulating paths from different operating systems than
    the one you're currently using. Unix works with any POSIX-like operating
    system, such as Linux or Darwin. Win32 works for paths from Windows,
    DOS, OS/2, NetWare, and Symbian.
  IO::Spec
    This class is a collection of methods dealing with file specifications
    (commonly known as file names, though it can include the entire
    directory path). Most of the methods are less convenient than in
    IO::Path, but it allows access to lower-level operations on file path
    strings.
    As with IO::Path, these operations are significantly different on some
    operating systems, so we have the following subclasses: IO::Spec::Unix,
    IO::Spec::Win32, and IO::Spec::Cygwin. IO::Spec automatically loads the
    correct module for use on the current system.
    Each class can (and should) be used in its undefined form:
        my $cleanpath = IO::Spec.canonpath("a/.//b/")  # gives "a/b"
    Although we inherit a lot from Perl 5's File::Spec, some things have
    changed: "no_updirs" has been removed (but see
    "no-parent-or-current-test") and "case_tolerant" has also been removed
    (and put in a module). Method "join" is no longer an alias for catfile,
    but is now a function similar to "catpath".
    Each of the following methods are available under the subclasses, with
    the exception of "os".
    os  The os method takes a single argument, an operating system string,
        and returns an IO::Spec object for the appropriate OS.
            my $mac_os_x_spec = File::Spec.os('darwin');
            # returns a File::Spec::Unix object
            my $windows_spec = File::Spec.os('MSWin32');
            #returns File::Spec::Win32
            say File::Spec.os('Win32').canonpath('C:\\foo\\.\\bar\\');
            # prints "C:\foo\bar"
        The parameter can be either an operating system string, or the last
        part of the name of a subclass ('Win32', 'Mac'). The default is
        `$*OS`, which gives you the same subclass that IO::Spec already uses
        for your system.
        This is only implemented by the IO::Spec class, and not its
        subclasses.
    canonpath
        No physical check on the filesystem, but a logical cleanup of a
        path.
            $cpath = IO::Spec.canonpath( $path ) ;
        Note that this does *not* collapse x/../y sections into y. This is
        by design. If /foo on your system is a symlink to /bar/baz, then
        /foo/../quux is actually /bar/quux, not /quux as a naive ../-removal
        would give you. If you want to do this kind of processing, you
        probably want IO::Path's "resolve" method to actually traverse the
        filesystem cleaning up paths like this.
        Takes as its argument a path, and returns True if it is an absolute
        path, False otherwise. For File::Spec::Win32, it returns 1 if it's
        an absolute path with no volume, and 2 if it's absolute with a
        volume.
            $is_absolute = IO::Spec.is-absolute( $path );
    splitpath
            method splitpath( $path, $nofile = False )
        Splits a path in to volume, directory, and filename portions. On
        systems with no concept of volume, returns '' for volume.
            my ($volume,$directories,$file) = IO::Spec.splitpath( $path );
            my ($volume,$directories,$file) = IO::Spec.splitpath( $path, $no_file );
        For systems with no syntax differentiating filenames from
        directories, assumes that the last file is a path unless $no_file is
        true or a trailing separator or /. or /.. is present. On Unix, this
        means that $no_file true makes this return ( '', $path, '' ).
        The directory portion may or may not be returned with a trailing
        '/'.
        The results can be passed to "catpath()" to get back a path
        equivalent to (usually identical to) the original path.
    split
        A close relative of `splitdir`, this function also splits a path
        into volume, directory, and filename portions. Unlike splitdir,
        split returns paths compatible with dirname and basename *and*
        returns it arguments as a hash of "volume", "directory", and
        "basename".
        This means that trailing slashes will be eliminated from the
        directory and basename components, in Win32 and Unix-like
        environments. The basename component will always contain the last
        part of the path, even if it is a directory, '.', or '..'. If a
        relative path's directory portion would otherwise be empty, the
        directory is set to '.' (or whatever "curdir" is).
        On systems with no concept of volume, returns '' (the empty string)
        for volume.
            my %splitfile = IO::Spec.split( $path );
            say IO::Spec::Win32( "C:\\saga\\waffo\\" );
                # ("volume" => "C:", "directory" => "\\saga", "basename" => "waffo")
        The results can be passed to `.join` to get back a path equivalent
        to (but not necessarily identical to) the original path. If you want
        to keep all of the characters involved, use `.splitdir` instead.
    Comparison of splitpath and split
            OS      Path       splitpath               split (.values)
            linux   /a/b/c     ("", "/a/b/", "c")      ("", "/a/b", "c")
            linux   /a/b//c/   ("", "/a/b//c/", "")    ("", "/a/b", "c")
            linux   /a/b/.     ("", "/a/b/.", "")      ("", "/a/b", ".")
            Win32   C:\a\b\    ("C:", "\\a\\b\\", "")  ("C:", "\\a", "b")
            VMS     A:[b.c]    ("A:", "[b.c]", "")     ("A:", "[b]", "[c]")
        * The VMS section is still speculative, and not yet supported.
    catpath()
        Takes volume, directory and file portions and returns an entire path
        string. Under Unix, $volume is ignored, and directory and file are
        concatenated. On other OSes, $volume is significant. Directory
        separators like slashes are inserted if need be.
            $full_path = IO::Spec.catpath( $volume, $directory, $file );
        A close relative of `.catpath`, this function takes volume,
        directory and basename portions and returns an entire path string.
        If the dirname is `'.'`, it is removed from the (relative) path
        output, because this function inverts the functionality of dirname
        and basename.
            $full-path = IO::Spec.join(:$volume, :$directory, :$basename);
            say IO::Spec::Unix.join( directory => '/hobbit', basename => 'frodo' );
                # "/hobbit/frodo"
        Directory separators are inserted if necessary. Under Unix, $volume
        is ignored, and only directory and basename are concatenated. On
        other OSes, $volume is significant.
        This method is the inverse of `.split`; the results can be passed to
        it to get the volume, dirname, and basename portions back.
    Comparison of catpath and join
            OS     Components            catpath        join
            linux  ("", "/a/b", "c")     /a/b/c         /a/b/c
            linux  ("", ".", "foo")      ./foo          foo
            linux  ("", "/", "/")        //             /
            Win32  ("C:", "\a", "b")     C:\a\b         C:\a\b
            VMS    ("A:", "[b]", "[c]")  A:[b][c]       A:[b.c]
    splitdir
        The opposite of "catdir".
            @dirs = IO::Spec.splitdir( $directories );
        $directories must be only the directory portion of the path on
        systems that have the concept of a volume or that have path syntax
        that differentiates files from directories.
        Unlike just splitting the directories on the separator, empty
        directory names ('') can be returned, because these are significant
        on some OSes.
    catdir
        Concatenate two or more directory names to form a complete path
        ending with a directory. Removes any trailing slashes from the
        resulting string, unless it's the root directory.
            $path = IO::Spec.catdir( @directories );
    catfile
        Concatenate one or more directory names and a filename to form a
        complete path ending with a filename
            $path = IO::Spec.catfile( @directories, $filename );
    abs2rel
        Takes a destination path and an optional base path returns a
        relative path from the base path to the destination path:
            $rel_path = IO::Spec.abs2rel( $path ) ;
            $rel_path = IO::Spec.abs2rel( $path, $base ) ;
        If $base is not present or '', then $*CWD is used. If $base is
        relative, then it is converted to absolute form using
        "IO::Spec/rel2abs". This means that it is taken to be relative to
        $*CWD.
        On systems with the concept of volume, if $path and $base appear to
        be on two different volumes, we will not attempt to resolve the two
        paths, and we will instead simply return $path.
        On systems that have a grammar that indicates filenames, this
        ignores the $base filename as well. Otherwise all path components
        are assumed to be directories.
        If $path is relative, it is converted to absolute form using
        No checks against the filesystem are made.
    rel2abs
        Converts a relative path to an absolute path.
            $abs_path = IO::Spec.rel2abs( $path ) ;
            $abs_path = IO::Spec.rel2abs( $path, $base ) ;
        If $base is not present or '', then $*CWD is used. If $base is also
        relative, then it is first converted to absolute form, relative to
        be on two different volumes, IO::Spec will not attempt to resolve
        the two paths, and will instead simply return $path.
        On systems that have a grammar that indicates filenames (like VMS),
        this ignores the $base filename as well. Otherwise all path
        components are assumed to be directories.
        If $path is absolute, it is cleaned up and returned using
        "canonpath".
    curdir
        Returns a string representation of the current directory ("." on
        Linux and Windows).
            my $curdir = IO::Spec.curdir;
    updir
        Returns a string representation of the parent directory (".." on
            my $updir = IO::Spec.updir;
    rootdir
        Returns a string representation of the root directory ("/" on
        Linux).
            my $rootdir = IO::Spec.rootdir;
    devnull
        Returns a string representation of the null device ("/dev/null" on
            my $devnull = IO::Spec.devnull;
        Takes no argument. Returns the environment variable "PATH" (or the
        local platform's equivalent) as a list.
            my @PATH = IO::Spec.path;
    tmpdir
        Returns a string representation of the first writable directory from
        a list of possible temporary directories. Returns the current
        directory if no writable temporary directories are found. The list
        of directories checked depends on the platform; e.g. IO::Spec::Unix
        checks "%*ENV<TMPDIR>" and /tmp.
            $tmpdir = IO::Spec.tmpdir;
    no-parent-or-current-test
        Returns a test as to whether a given path is identical to the parent
        or the current directory. On Linux, this is simply "none('.',
        '..')". The "Functions/dir" function automatically removes these for
        you in directory listings, so under normal circumstances you
        shouldn't need to use it directly.
            'file' ~~ IO::Spec.no-parent-or-current-test    #False
            '.'    ~~ IO::Spec.no-parent-or-current-test    #True
            '..'   ~~ IO::Spec.no-parent-or-current-test    #True
        This can, however, be used to extend "dir()" through its `$test`
        parameter:
            dir( "my/directory", test=>
              all(IO::Spec.no-parent-or-current-test, /^ '.' /));
        This example would return all files beginning with a period that are
        not `.` or `..` directories. This would work similarly with
        IO::Path.contents.
        This method replaces the functionality of the Perl 5 "no_updirs"
        method.
Here Be Dragons
    Everything below this point hasn't been reviewed properly
  IO::Socket
        role IO::Socket {
            has %.options;
            has Bool $.Listener;
            ...
    Accessing the "%.options" would on Unix be done with
    *getsockopt(2)*/*setsockopt(2)*.
    The $.Listener attribute indicates whether the socket will be a
    listening socket when opened, rather than indicating whether it is
    currently listening.
            method new(
                :$Listener, # initializes $.Listener
        The initial value of the $.Listener attribute is defined according
        to the following rules:
         * If $Listener is passed to .new(), then that value is used
         * If neither a local address nor a remote address are passed in, throw an exception
         * If no remote address is passed, then $.Listener is set to SOMAXCONN
         * If no local address is used, then $Listener is set to 0
         * If both local and remote addresses are used, throw an exception that asks people to
           specify $Listener
            method open()
        If $.Listener is true, does a *bind(2)* and a *listen(2)*, otherwise
        does a *connect(2)*.
        It's end-user use case is intended for the case where NoOpen is
        passed to .new(). .new() itself will presumably also call it.
            method close()
        Implements the close() function from IO::Closeable by doing a
        shutdown on the connection (see below) with @how set to ('Readable',
        'Writeable').
    shutdown
            method shutdown(Str @how)
        Does a *shutdown(2)* on the connection. See also
        IO::Readable.isReadable and IO::Writeable.isWriteable.
        $how can contain 1 or more of the strings 'Readable' and
        'Writeable'.
    accept
            method accept( --> IO::Socket)
    method read(Int $bytes --> Buf)
        Reads and returns $bytes bytes from the handle
    method write(Buf $buf --> Int)
        Implements the IO::Writeable interface by doing a *send(2)*.
  IO::Socket::INET
        class IO::Socket::INET does IO::Socket {
            has Str $.proto = 'TCP';
            has Str $.host;
            has Int $.port;
            has Str $.localhost;
            has Int $.localport;
            multi method new(:$host!, :$port, *%attributes) { ... }
            multi method new(:$localhost!, :$localport, :$listen! *%attributes) { ... }
        Creates a new socket and opens it.
  IO::Handle (opened version)
    This role indicates that this object actually represents an open file
    descriptor in the os level.
    method int fileno()
        File descriptors are always native integers, conforming to C89.
Conjectural Stuff
    Everything below this point should be considered as mere ideas for
    future evolution, not as things that a compiler write should implement
    unquestioningly.
  IO::ACL
    This is a basic abstraction; for better control, use the
    operating-system specific interfaces, over which this is a thin veneer.
        class IO::ACL {
            has Str $.type; # "User", "Group", "Everyone", ???
            has Str $.id; # username or groupname; unused for $type eq "Everyone"
            has %.permissions;
                    # Unsupported values may (or may not) throw
                    # UnsupportedPermission when set or read
            has Path $.owningObject;
    The permissions used in %permissions are:
    Readable
        Should be supported by all filesystems as an item to read from the
        hash for the group "Everyone".
    Writeable
    Executable
        Supported on most Unix systems, anyway. Windows should be able to
        guess when this is read, and throw an exception if written to.
    Default
        An ACL of User,fred,Default sets the user "fred" to be the owner of
        the file. This can be done with groups too. Works on Unix, at least.
    The "$.owningObject" attribute of "ACL" shows what the ACL is set on. On
    a Windows system, this can be a parent directory, as permissions are
    inherited.
  IO::Pipe
        class IO::Pipe does IO::Streamable does IO::Readable does IO::Writable {
    Will need to set IO::Readable.isReadable and IO::Writable.isWriteable
    depending on opening method.
    close()
        If the file handle came from a piped open, "close" will additionally
        return "Failure" (aliased to $!) if one of the other system calls
        involved fails, or if the program exits with non-zero status. The
        exception object will contain any pertinent information. Closing a
        pipe also waits for the process executing on the pipe to complete,
        in case you want to look at the output of the pipe afterwards, and
        implicitly puts the exit status value into the "Failure" object if
        necessary.
    IO::Pipe.to
            method to(Str $command, *%opts --> Bool)
            method to(Str *@command, *%opts --> Bool)
        Opens a one-way pipe writing to $command. "IO" redirection for
        stderr is specified with ":err(IO)" or ":err<Str>". Other "IO"
        redirection is done with feed operators. XXX how to specify "2>&1"?
    IO::Pipe.from
            method from(Str $command, *%opts --> Bool)
            method from(Str *@command, *%opts --> Bool)
        Opens a one-way pipe reading from $command. "IO" redirection for
    IO::Pipe.pair
            method pair(--> List of IO::Pipe)
        A wrapper for *pipe(2)*, returns a pair of "IO" objects representing
        the reader and writer ends of the pipe.
           ($r, $w) = IO::Pipe.pair;
  OS-specific classes
   Unix
   Path::Unix
    chown
            multi chown ($uid = -1, $gid = -1, *@files --> Int)
        Changes the owner (and group) of a list of files. The first two
        elements of the list must be the numeric uid and gid, in that order.
        A value of -1 in either position is interpreted by most systems to
        leave that value unchanged. Returns the number of files successfully
        changed.
            $count = chown $uid, $gid, 'foo', 'bar';
            chown $uid, $gid, @filenames;
        On systems that support "fchown", you might pass file handles among
        the files. On systems that don't support "fchown", passing file
        handles produces a fatal error at run time.
        Here's an example that looks up nonnumeric uids in the passwd file:
           $user = prompt "User: ";
           $pattern = prompt "Files: ";
           ($login,$pass,$uid,$gid) = getpwnam($user)
               or die "$user not in passwd file";
           @ary = glob($pattern);      # expand filenames
           chown $uid, $gid, @ary;
        On most systems, you are not allowed to change the ownership of the
        file unless you're the superuser, although you should be able to
        change the group to any of your secondary groups. On insecure
        systems, these restrictions may be relaxed, but this is not a
        portable assumption. On POSIX systems, you can detect this condition
        this way:
            use POSIX qw(sysconf _PC_CHOWN_RESTRICTED);
            $can-chown-giveaway = not sysconf(_PC_CHOWN_RESTRICTED);
    chmod LIST
        Changes the permissions of a list of files. The first element of the
        list must be the numerical mode, which should probably be an octal
        number, and which definitely should *not* be a string of octal
        digits: "0o644" is okay, 0644 is not. Returns the number of files
        successfully changed.
            $count = chmod 0o755, 'foo', 'bar';
            chmod 0o755, @executables;
            $mode = '0644'; chmod $mode, 'foo';      # !!! sets mode to --w----r-T
            $mode = '0o644'; chmod $mode, 'foo';     # this is better
            $mode = 0o644;   chmod $mode, 'foo';     # this is best
    IO.stat
            $node.stat(Bool :$link); # :link does an lstat instead
        Returns a stat buffer. If the lstat succeeds, the stat buffer
        evaluates to true, and additional file tests may be performed on the
        value. If the stat fails, all subsequent tests on the stat buffer
        also evaluate to false.
   IO::Socket::Unix
        role IO::Socket::Unix does IO::Socket {
            has Str $.RemoteAddr, # Remote Address
            has Str $.LocalAddr,  # Local Address
                Str  :$RemoteAddr,
                Str  :$LocalAddr,
                Bool :$Listener,   # Passed to IO::Socket.new()
                Bool :$Blocking,   # Passed to IO::Streamable.new()
                Bool :$NoOpen,     # Passed to IO::Streamable.new()
                --> IO::Socket::Unix
            ) {...}
    pair
            method pair(Int $domain, Int $type, Int $protocol --> List of IO)
        A wrapper for *socketpair(2)*, returns a pair of "IO" objects
        representing the reader and writer ends of the socket.
           use IO::Socket;
           ($r, $w) = IO::Socket::Unix.pair(AF_UNIX, SOCK_STREAM, PF_UNSPEC);
   IO::POSIX
    Indicates that this object can perform standard posix "IO" operations.
    It implies "IO::Readable" and "IO::Writeable".
    method dup( --> IO)
    has Bool $.blocking is rw
    method flock(:$r,:$w --> Bool)
    method funlock( --> Bool)
    ...
Unfilled
    IO.ioctl
        Available only as a handle method.
    alarm
    prompt
            multi prompt (Str $prompt --> Str)
        Should there be an IO::Interactive role?
    Str.readpipe
    sysopen
    IO.sysseek
    umask
Removed functions
    IO.eof
        Gone, see eoi "IO::Seekable".
    IO.fileno
        See "IO::Handle".
    /(get|set)(host|net|proto|serv|sock).*/
        Should be implemented by an external library.
    lstat
        Use "stat" with the ":link" option.
    IO.name
        Changed to ".path", but we haven't gotten around to specifying this
        on all of them.
        The ".name" method returns the name of the file/socket/uri the
        handle was opened with, if known. Returns Nil otherwise. There is no
        corresponding "name()" function.
    pipe
        Gone, see Pipe.pair
    select(both)
        Gone. (Note: for sub-second sleep, just use sleep with a fractional
        argument.)
    IO.shutdown()
        Gone, see "IO::Socket.close()", "$IO::Readable.isReadable", and
        "$IO::Writeable.isWriteable"
    socketpair
        Gone, see Socket.pair
    IO.sysread
        Gone, see "IO::Readable.read()".
    IO.syswrite
        Gone, see "IO::Writeable.read()".
    utime
        Gone, see "Path.times".
  IO::Buffered
    Indicates that this object performs buffering. The management of the
    buffer is completely implementation specific.
    method flush( --> Bool)
        Flushes the buffers associated with this object.
    method autoflush( --> Bool) is rw
        Forces this object to keep its buffers empty
        If set to nonzero, forces a flush right away and after every write
        or print on the currently selected output channel. Default is 0
        (regardless of whether the channel is really buffered by the system
        or not; "$OUT_FH.autoflush" tells you only whether you've asked Perl
        explicitly to flush after each write). $*OUT will typically be line
        buffered if output is to the terminal and block buffered otherwise.
        Setting this variable is useful primarily when you are outputting to
        a pipe or socket, such as when you are running a Perl program under
        rsh and want to see the output as it's happening. This has no effect
        on input buffering.
  IO::Streamable
    This role represents objects that depend on some external resource,
    which means that data might not be available at request.
        role IO::Streamable does IO {...}
    new()
                Bool :$NoOpen,
                Bool :$Blocking,
                --> IO::Streamable
        Unless the NoOpen option is passed, an open will be done on the "IO"
        object when it is created.
        If blocking is passed in, .blocking() is called (see below).
    method blocking( --> Bool) is rw
        This allows the user to control whether this object should do a
        blocking wait or immediately return in the case of not having data
        available.
    uri
            method uri(Str $uri --> IO::Streamable) {...}
        This should be callable on the class, and act like a kind of "new()"
        function. When given a URI, it returns an "IO::Streamable" of the
        appropriate type, and throws an error when an inappropriate type is
        passed in. For example, calling "IO::File.uri('http://....')" will
        throw an error (but will suggest using just uri('http://...')
        instead).
  IO::Encoded
    This is a generic role for encoded data streams.
    method encoding( --> Str) is rw
    method locale( --> Str) is rw
        Encoding and locale are required for sane conversions.
  IO::Readable::Encoded
    This role provides encoded access to a readable data stream, implies
    "IO::Encoded". Might imply "IO::Buffered", but that's not a requirement.
            method uri(Str $uri --> IO::Streamable);
            sub uri(Str $uri --> IO::Streamable);
        Returns an appropriate "IO::Streamable" descendant, with the type
        depending on the uri passed in. Here are some example mappings:
            URI type IO type
            ======== =======
            file:    IO::Path
            ftp:     IO::Socket::INET (data channel)
            http:    IO::Socket::INET
        These can naturally be overridden or added to by other modules.
    %*PROTOCOLS dynamic variable
        For each protocol, stores a type name that should be instantiated by
        calling the "uri" constructor on that type, and passing in the
        appropriate uri.
        The authors of the related Perl 5 docs
        Daniel Ruoso <daniel@ruoso.com>
        Lyle Hopkins <webmaster@cosmicperl.com>
        Brent Laabs <bslaabs@gmail.com>
        Tobias Leich <email@froggs.de>
    Synopsis 32: Setting Library - IO
        Created: 19 Feb 2009
        Last Modified: 28 Oct 2014
    This synopsis describes in depth the subroutines and methods that were
    described broadly in S16. Please note that any implementation is free to
    use multi-method dispatch on both subroutines as well as methods should
    this increase the performance or maintainability.
  print()
        sub print(*@text --> Bool) is export
    Print the given text on $*OUT.
  say()
        sub say(*@text --> Bool) is export
    Print the given text, followed by a new line "\n" on $*OUT. Before
    printing, call the ".gist" method on any non-"Str" objects.
  note()
        sub note(*@text --> Bool) is export
    Print the given text, followed by a new line "\n" on $*ERR. Before
  dd()
        sub dd(@vars --> Bool) is export
    Tiny Data Dumper. Takes the "variables" specified and "note"s them (on
    $*ERR) in an easy to read format, along with the "name" of the variable.
    So:
      my $a = 42;
      dd($a);   # notes "$a = 42"
  prompt()
        sub prompt($msg --> Bool) is export
    Simple Prompter. Print message on $*OUT and obtains a single line of
    input from $*IN.
  open()
        sub open ($name as IO,
          # mode
            Bool :$r  = True,
            Bool :$w  = False,
            Bool :$rw = False,
            Bool :$a  = False,
          # encoding
            Bool :$bin = False,
            Str  :$enc = "Unicode",  # utf-8 unless otherwise
          # newlines
            Any  :$nl    = "EOL",
            Bool :$chomp = True,
            --> IO::Handle ) is export
    A convenience function for opening normal files as text (by default) as
    specified by its (first) parameter. It returns an instantiated
    "IO::Handle" object. The following named parameters may also be
    specified:
    :r  Open file for reading. Default is "True".
    :w  Open file for writing by creating an empty file with the given name.
        The original contents of an existing file with that name, will be
        lost. Default is "False".
    :rw Open file for reading and writing with the given name. The original
        contents of an existing file with that name, will be lost. Default
        is "False".
    :a  Open file for appending, create one if it didn't exist yet. This may
        or may not inhibit overwriting the original contents when moving the
        file pointer. Default is "False".
    :bin
        Open file in binary mode (byte mode). A file opened with ":bin" may
        still be processed line-by-line, but IO will be in terms of "Buf"
        rather than "Str" types. Default is "False", implying text
        semantics.
    :enc
        Encoding to use if opened in text mode. Defaults to "Unicode", which
        implies figuring out which actual UTF is in use, either from a BOM
        or other heuristics. If heuristics are inconclusive, UTF-8 will be
        assumed. (No 8-bit encoding will ever be picked implicitly.)
    :nl The marker used to indicate the end of a line of text. Only used in
        text mode. Defaults to "EOL", which implies accepting any
        combination of "\n", "\r\n" or "\r" or any other Unicode character
        that has the "Zl" (Separator, Line) property.
    :chomp
        Whether or not to remove new line characters from text obtained with
        ".lines" and ".get". Defaults to "True".
  dir()
        sub dir($directory as Str = $*CWD,
            Mu       :$test = $*SPEC.curupdir,
            Bool     :$absolute = False,
            Bool     :$Str = False,
            IO::Path :$CWD = $*CWD,
            --> List ) is export
    Returns a lazy list of (relative) paths in the $directory as "IO::Path"
    objects, by default from the directory pointed to by $*CWD. If dir()
    fails, it returns an X::IO::Dir failure. The following named parameters
    are optional:
    :test
        Expression against which to smart-match for inclusion in result
        list. By default excludes "curdir" (usually ".") and "updir"
        (usually "..") only.
    :absolute
        Boolean indicating to return absolute path names, rather than
        relative ones. False by default.
    :Str
        Boolean indicating to return "Str"ings, rather than "IO::Path"
        objects. False by default.
    :CWD
        Only important if ":absolute" is specified with a True value. The
        directory to pre-pend to the relative file paths. Defaults to $*CWD.
  slurp()
        sub slurp ($what = $*ARGFILES,
            Str  :$enc = "Unicode",
            --> Str|Buf ) is export
    Slurps the contents of the entire file into a "Str" (or "Buf" if
    ":bin"). Accepts ":bin" and ":enc" optional named parameters, with the
    same meaning as "open()". The routine will "fail" if the file does not
    exist, or is a directory.
  spurt()
        sub spurt ($where, $what,
            Str  :$enc        = $*ENC,
            Bool :append      = False,
            Bool :$createonly = False,
            --> Bool ) is export
    Writes the indicated contents (2nd positional parameter) to the location
    indicated by the first positional parameter (which can either be a
    string, an "IO::Path" object, or an already opened "IO::Handle" object).
    If a file needs to be opened for writing, it will also be "close"d.
    Returns True on success, or the appropriate "Failure" if something went
    wrong.
    These named parameters are optional and only have meaning if the first
    positional parameter was not an "IO::Handle":
        The encoding with which the contents will be written. [conjectural]
    :append
        Boolean indicating whether to append to a (potentially) existing
        file. If the file did not exist yet, it will be created. Defaults to
        "False".
    :createonly
        Boolean indicating whether to fail if the file already exists.
        Defaults to "False".
  mkdir()
        sub mkdir($dir as IO, $mode = 0o777 --> Bool) is export
    Creates the directory as indicated by the positional parameter. Returns
    "True" on success or an appropriate "Failure".
  rmdir()
        sub rmdir($dir as IO --> Bool) is export
    Removes the (empty) directory as indicated by the positional parameter.
    Returns "True" on success or an appropriate "Failure".
  chdir()
        sub chdir($dir as IO, $CWD = $*CWD,
            :$test = <d r>
            --> Bool) is export
    Changes the current working directory to the given directory, for the
    scope in which $*CWD is active (if no second positional parameter is
    given) or for the scope of the indicated localized $*CWD. A typical use
    case:
      {
          chdir("foo", my $*CWD);
          # working directory changed to "foo"
      }
      # restored to what it was
    Returns "True" if successful, or an appropriate "Failure", e.g if the
    directory does not exist, or is not a directory, or is not readable.
    Please note that this directory has no connection with whatever the
    operating system thinks is the current working directory. The value of
    $*CWD just will always be prepended to any relative paths in any file
    operation in Perl 6.
    Also note that you can use "chdir" to set similar dynamic variables,
    like $*TMPDIR and $*HOME this way:
      chdir("bar", my $*TMPDIR);   # set $*TMPDIR in this scope
      chdir("bar", my $*HOME);     # set $*HOME in this scope
  copy()
        sub copy ($source as IO, $dest as IO,
            :$createonly = False,
    Copies a file, as indicated by the first positional parameter, to the
    destination specified. If :createonly is set to True, copy fails if a
    file already exists in the destination. Returns "True" upon success, or
    an appropriate "Failure" if the operation could not be completed.
  rename()
        sub rename ($source as IO, $dest as IO,
    Moves a file, as indicated by the first positional parameter, by
    renaming it to the destination specified. If :createonly is set to True,
    the rename fails if a file already exists in the destination. Returns
    "True" upon success, or an appropriate "Failure" if the operation could
    not be completed.
    Please use "move()" if a file could not be moved by renaming (usually
    because the destination is on a different physical storage device).
  move()
        sub move ($source as IO, $dest as IO,
    Moves a file, as indicated by the first positional parameter, by copying
    its contents to the destination specified, and then removing the file at
    the original location. If :createonly is set to True, the move fails if
    a file already exists in the destination. Returns "True" upon success,
    or an appropriate "Failure" if the operation could not be completed.
    Please use "rename()" if a file can be moved by renaming (which is
    usually possible if the destination is on the same different physical
    storage device). Alternately, the "move()" function is free to try the
    "rename()" first, and if that (silently) fails, do it the hard way.
  unlink()
        sub unlink(*@files --> @removed) is export
    Delete all specified ordinary files, links, or symbolic links. Returns
    the names of the files that were successfully deleted.
   chmod()
        sub chmod($permission, *@files --> @changed) is export
    Changes the permissions of a list of files. The first element of the
    list must be the numerical mode, which should probably be an octal
    number, and which definitely should *not* be a string of octal digits:
    "0o644" is okay, 0644 is not. Returns the names of the files that were
    successfully changed.
        $count = chmod 0o755, 'foo', 'bar';
        chmod 0o755, @executables;
        $mode =  '0644'; chmod $mode, 'foo';  # BAD!!! sets mode to --w----r-T
        $mode = '0o644'; chmod $mode, 'foo';  # this is better
        $mode =  0o644 ; chmod $mode, 'foo';  # this is best
  link()
        sub link($target, $source --> Bool) is export
    Create a hard link between the target from the given source path.
    Returns "True" if successful, or an appropriate "Failure".
  symlink()
        sub symlink($target, $source --> Bool) is export
    Create a symbolic link between the target from the given source path.
    directory path). Most of the methods allow access to lower-level
    operations on file path strings.
    These operations are significantly different on some operating systems,
    so the actual work is being done by subclasses such as "IO::Spec::Unix",
    "IO::Spec::Win32" and "IO::Spec::Cygwin".
    The correct "IO::Spec" class for your system, is available in the $*SPEC
    dynamic variable. So typically, you would call methods on that:
      my $cleanpath = $*SPEC.canonpath("a/.//b/")  # gives "a/b"
    This set of modules was inspired by Perl 5's "File::Spec". An
    implementation may choose to inherit from "IO::Spec", or any of its
    subclasses, if that helps in avoiding code duplication.
    The "select" method is the only method provided by "IO::Spec" itself.
   .select
        method select(IO::Spec:U: $name = $*DISTRO.name as Str --> IO::Spec:U)
    The ".select" method takes an optional argument: a string indicating the
    type of system for which to perform file specification operations. By
    default, it takes "$*DISTRO.name".
    At startup, $*SPEC is initialized to "IO::Spec.select".
  IO::Spec subclasses
    The following methods should be provided by the "IO::Spec" subclasses,
    or may be inherited from another class. They will never check anything
    with an actual file system. In alphabetical order:
   .abs2rel
        method abs2rel($path as Str, $base = $*CWD --> Str)
    Takes a path and an optional base path (default $*CWD) and returns a
    relative path from the base path to the destination path. If the base
    path is relative, then it will first be transformed to an absolute path
    with ".rel2abs", relative to $*CWD.
    On systems with the concept of volume, if $path and $base appear to be
    on two different volumes, it will not attempt to resolve the two paths,
    and will instead simply return $path.
    On systems that have a grammar that indicates filenames, this ignores
    the $base filename as well. Otherwise all path components are assumed to
    be directories.
    If $path is relative, it is first converted to absolute form using
    ".rel2abs". This means that it is taken to be relative to $*CWD.
   .canonpath
        method canonpath($path as Str --> Str)
    Perform a logical cleanup of a path and returns that. Note that this
    does *not* collapse x/../y sections into y. This is by design. If /foo
    on your system is a symlink to /bar/baz, then /foo/../quux is actually
    /bar/quux, not /quux as a naive ../-removal would give you. If you want
    to do this kind of processing, you probably want "IO::Path"'s ".resolve"
    method to actually traverse the filesystem cleaning up paths like this.
   .catdir
        method catdir(*@dir as Array[Str] --> Str)
    Concatenate two or more directory names to form a complete path ending
    with a directory. Removes any trailing slashes from the resulting
    string, unless the result is the ".rootdir".
   .catpath
        method catpath($volume, $dir, $file --> Str)
    Takes volume, directory and file portions and returns an entire path
    string. Under Unix, $volume is ignored, and directory and file are
    concatenated. On other OSes, $volume is significant. Directory
    separators like slashes are inserted if need be.
   .contents
   .curdir
        method curdir(--> Str)
    Returns a string representation of the current directory (Usually ".").
   curupdir
    Returns a test as to whether a given path is identical to the current
    directory (as indicated by ".curdir") or the parent directory (as
    indicated by ".updir". This is usually "none(<. ..>)". It is the default
    for the ":test" parameter to "/dir()" and "IO::Path"'s ".contents"
    method. It can also be used to extend "dir()" through its ":test" named
    parameter:
      dir "my/directory", test => all($*SPEC.curupdir, /^ '.' /);
    This example would return all files beginning with a period that are not
    "." or ".." directories.
   .devnull
        method devnull(--> Str)
    Returns a string representation of the null device (e.g. "/dev/null" on
    Unix-like systems).
   .extension
        method extension($path as Str --> Str)
    Returns the extension (if any) of the given path.
   .is-absolute
        method is-absolute($path as Str --> Bool)
    Takes as its argument a path, and returns "True" if it is an absolute
    path, "False" otherwise. For "IO::Spec::Win32", it returns 1 if it's an
    absolute path without a volume, and 2 if it's absolute with a volume.
   .join
        method join(:$volume, $dir, $file --> Str)
    A close relative of ".catpath", this method takes volume, directory and
    basename portions and returns an entire path string. If a directory is
    ".", it is removed from the (relative) path output, because this
    function inverts the functionality of dirname and basename.
    Directory separators are inserted if necessary. Under Unix, $volume is
    ignored, and only directory and basename are concatenated. On other
    OSes, $volume is significant.
    This method is the inverse of ".split"; the results can be passed to it
    to get the volume, dirname, and basename portions back.
   .PATH
        method PATH($PATH = %*ENV<PATH> --> List[Str])
    Convert a string formatted like a system's "PATH" specification, and
    returns it as a list of strings. Takes "%*ENV<PATH>" by default.
   .rel2abs
        method rel2abs($path as Str, $base = $*CWD as Str --> Str)
    Converts a relative path to an absolute path, using an optional base
    directory. If the base directory is not specified, $*CWD will be
    assumed.
    If $base is relative, then it is first converted to absolute form,
    relative to $*CWD.
    on two different volumes, t will not attempt to resolve the two paths,
    On systems that have a grammar that indicates filenames (like VMS), this
    ignores the $base specification as well. Otherwise all path components
    are assumed to be directories.
    If $path is absolute, it is cleaned up and returned using ".canonpath".
   .rootdir
        method rootdir(--> Str)
    Returns a string representation of the root directory (usually "/").
   .split
        method split($path as Str --> Hash[Str])
    A close relative of ".splitdir", this function also splits a path into
    volume, directory, and basename portions. Unlike ".splitdir", split
    returns paths compatible with dirname and basename *and* returns it
    arguments as a hash of "volume", "directory", and "basename".
    This means that trailing slashes will be eliminated from the directory
    and basename components, in Win32 and Unix-like environments. The
    basename component will always contain the last part of the path, even
    if it is a directory, '.', or '..'. If a relative path's directory
    portion would otherwise be empty, the directory is set to whatever
    "curdir" is.
    On systems with no concept of volume, returns '' (the empty string) for
    volume. The results can be passed to ".join" to get back a path
    equivalent to (but not necessarily identical to) the original path. If
    you want to keep all of the characters involved, use ".splitdir"
    instead.
   .splitdir
        method splitdir($directories as Str --> List[Str])
    The opposite of ".catdir". $directories must be only the directory
    portion of the path on systems that have the concept of a volume or that
    have path syntax that differentiates files from directories.
    Unlike just splitting the directories on the separator, empty directory
    names ('') can be returned, because these are significant on some OSes.
   .splitpath
        method splitpath( $path, $nofile = False )
    Splits a path in to volume, directory, and filename portions and returns
    these as a List. On systems with no concept of volume, returns '' for
    volume.
        my ($volume,$directories,$file) = $*SPEC.splitpath( $path );
        my ($volume,$directories,$file) = $*SPEC.splitpath( $path, $no_file );
    For systems with no syntax differentiating filenames from directories,
    assumes that the last file is a path unless $no_file is "True" or a
    trailing separator or /. or /.. is present. On Unix, this means that
    $no_file true makes this return ( '', $path, '' ).
    The directory portion may or may not be returned with a trailing '/'.
    The results can be passed to ".catpath" to get back a path equivalent to
    (but not necessarily identical to) the original path.
   .tmpdir
        method tmpdir(--> IO::Path)
    Returns an "IO::Path" representation of the first writable directory
    from an implicit list of possible temporary directories. Returns the
    current directory if no writable temporary directories are found. The
    list of directories checked depends on the platform.
   .updir
        method updir(--> Str)
    Returns a string representation of the parent directory (usually "..").
   Comparison of .splitpath and .split
        OS      Path       splitpath               split
        Unix    /a/b/c     ("", "/a/b/", "c")      ("", "/a/b", "c")
        Unix    /a/b//c/   ("", "/a/b//c/", "")    ("", "/a/b", "c")
        Unix    /a/b/.     ("", "/a/b/.", "")      ("", "/a/b", ".")
        Win32   C:\a\b\    ("C:", "\\a\\b\\", "")  ("C:", "\\a", "b")
        VMS     A:[b.c]    ("A:", "[b.c]", "")     ("A:", "[b]", "[c]")
    * The VMS section is still speculative, and not yet supported.
   Comparison of .catpath and .join
        OS     Components            catpath        join
        Unix   ("", "/a/b", "c")     /a/b/c         /a/b/c
        Unix   ("", ".", "foo")      ./foo          foo
        Unix   ("", "/", "/")        //             /
        Win32  ("C:", "\a", "b")     C:\a\b         C:\a\b
        VMS    ("A:", "[b]", "[c]")  A:[b][c]       A:[b.c]
        class IO::Path is Cool { }
    three parts, the *volume*, *dirname* and *base name*.
    The basename is name of the file or directory that the "IO::Path" object
    basename.
        path              volume         dirname    basename
    By default, "IO::Path" uses the "IO::Spec" setting as found in $*SPEC
    when the object is created. If you want to work paths as if you were
    using another OS, you can specify another "IO::Spec" subclass with the
    optional ":SPEC" named parameter.
    There are several ways of creating an "IO::Path". The easiest way is to
    use ".IO" coercer:
      my $io = "foo/bar".IO;
    Of course, you can always call the ".new" method as well:
      my $io = IO::Path.new( $full-path );
      my $io = IO::Path.new( :$volume, :$dirname, :$basename);
    Whenever a new "IO::Path" is created, an internal absolute and cleaned
    version of the specified path is stored, using the implicitly or
    explicitly specified values for $*SPEC and $*CWD:
      my $io = IO::Path.new( "foo", :SPEC<win32>, :CWD</usr/local/src> );
    would create an "IO::Path" object with "IO::Spec::Win32" semantics, with
    an absolute path of "/usr/local/src/foo". Yes, that would be strange,
    but it is possible. A shorter way would be:
      my $io = "foo".IO( :SPEC<win32>, :CWD</usr/local/src> );
    The (implicit) value of ":CWD" is only used for creating the absolute
    path at instantiation time. The (implicit) value of ":SPEC" is actually
    saved in the object to be able to perform path operations with the
    correct semantics at a later time.
   File test methods
    The following (single letter) methods can be used on the "IO::Path"
    object:
        r  Path is readable by effective uid/gid.      Bool
        w  Path is writable by effective uid/gid.      Bool
        x  Path is executable by effective uid/gid.    Bool
        o  Path is owned by effective uid.             Bool
        R  Path is readable by real uid/gid.           Bool
        W  Path is writable by real uid/gid.           Bool
        X  Path is executable by real uid/gid.         Bool
        O  Path is owned by real uid.                  Bool
        e  Path exists.                                Bool
        s  Size of the path in bytes.                  Int
        z  Path has zero size (an empty file).         Bool
        f  Path is a plain file.                       Bool
        d  Path is a directory.                        Bool
        l  Path is a symbolic link.                    Bool
        L  Actual path of symbolic link (readlink)     Str
        p  Path is a named pipe (FIFO)                 Bool
        S  Path is a socket.                           Bool
        b  Path is a block special file.               Bool
        c  Path is a character special file.           Bool
        u  Path has setuid bit set.                    Bool
        g  Path has setgid bit set.                    Bool
        k  Path has sticky bit set.                    Bool
    To allow for easy chaining of file tests, there is an ".all" method that
    can be fed the tests to be tried as a "List" of strings. The value
    returned will be the first non-True value, or the final True value.
      say "rwx" if $io.all: <r w x>;
      if $io.all(<f r w x s>) -> $size {
          say "plain file with rwx of $size bytes";
    For convenience, you can also specify the negated letter for the
    opposite test:
      if $io.all(<!d r w x s>) -> $size {
          say "not a directory with rwx of $size bytes";
    Other methods are listed here in alphabetical order:
   .absolute
        method absolute($base as Str --> Str)
    The absolute path of the path, optionally from the relative base.
   .accessed
        method accessed(--> Instant)
    Returns the "Instant" when the file was last accessed, or "Failure" if
    this could not be determined.
   .basename
        method basename(--> Str)
    Returns the base name part of the path -- that is, the last portion.
    Functions equivalently to the "basename" shell program on Unix-like
    systems.
   .changed
        method changed(--> Instant)
    Returns the "Instant" when the metadata of the file was last changed, or
    "Failure" if this could not be determined.
   .chdir
        method chdir(:$CWD = $*CWD --> Bool)
    Like "chdir()", but with ".absolute" as the first parameter.
   .child
        method child($childname --> IO::Path)
    Appends $childname to the end of the path, adding path separators where
    needed and returns the result as a new "IO::Path".
   .chmod
        method chmod($permissions --> Bool)
    Like "chmod()", but with ".absolute" as the second parameter.
   .copy
        method copy($dest, :$createonly --> Bool)
    Like "copy()", but with ".absolute" as the first parameter.
   .dir
        method dir(:$test, :$absolute, :$CWD --> List[Str])
    Like "dir()", but with ".absolute" as the first parameter.
   .dirname
        method dirname(-->Str)
    Returns the directory part of the path, not including the last item.
    Functions equivalently to the "dirname" shell program on Unix-like
        method extension(--> Str)
    Returns the extension of the path, if any.
   .IO
        method IO(--> IO::Path)
    Returns itself.
        method is-absolute(--> Bool)
    Always returns "True" since internally the path is always stored as an
    absolute path.
   .is-relative
        method is-relative(--> Bool)
    Always returns "False" since internally the path is always stored as an
   .lines
        method lines( --> List[Str] )
    Returns a (lazy) list of lines of which the file consists, or a
    "Failure" if something went wrong.
   .mkdir
        method mkdir($mode = 0o777 --> Bool)
    Like "mkdir()", but with ".absolute" as the first parameter.
   .modified
        method modified(--> Instant)
    Returns the "Instant" when the contents of the file were last modified,
    or "Failure" if this could not be determined.
   .move
        method move($dest as IO, :$createonly --> Bool)
    Like "move()", but with ".absolute" as the first parameter.
   .open
        method open(... --> IO::Handle)
    Like "open()", but with ".absolute" as the first parameter.
   .parent
        method parent(--> IO::Path)
    Removes last portion of the path and returns the result as a new
    "IO::Path".
   .pred
        method pred(--> IO::Path)
    Create previous logical path and return the result as a new "IO::Path"
    or returns "Failure" if that is not possible.
   .relative
        method relative ($base as Str = $*CWD --> IO::Path)
    Transforms the path into an relative form, and returns the result as a
    new "IO::Path". If $base is supplied, transforms it relative to that
    base directory, otherwise the $*CWDis used. Paths that are already
    relative are returned unchanged.
   .rename
        method rename($dest as IO, :$createonly --> Bool)
    Like "rename()", but with ".absolute" as the first parameter.
   .resolve
        method resolve(--> IO::Path)
    Returns a new IO::Path object with all symbolic links and references to
    the parent directory ("..") are physically resolved. This means that the
    filesystem is examined for each directory in the path, and any symlinks
    found are followed.
      # bar is a symlink pointing to "/baz"
      my $io = "foo/./bar/..".IO.resolve;  # now "/" (the parent of "/baz")
   .rmdir
        method rmdir(--> Bool)
    Removes (deletes) the directory represented by the "IO::Path". Returns
    "True" if successful, or a "Failure" of some kind if not. Typically
    fails if the path is not a directory or the directory is not empty.
   .slurp
        method slurp(:$bin, :$enc  --> Str|Buf)
    Like "slurp()", but with ".absolute" as the first parameter.
   .SPEC
        method SPEC(--> IO::Spec)
    Returns the "IO::Spec" object that was (implicitely) specified at object
    creation time.
   .spurt
        method spurt(:$enc, :$append, :$createonly, :$bin  --> Str|Buf)
    Like "spurt()", but with ".absolute" as the first parameter.
   .succ
        method succ(--> IO::Path)
    Create next logical path and return the result as a new "IO::Path".
   .unlink
        method unlink(--> Bool)
    Like "unlink()", but with ".absolute" as the first parameter. Returns
   .volume
        method volume(-->Str)
    Returns the volume part of the path. On Unix-like OSes or systems
    without a concept of volume in the path, returns the empty string.
   .words
        method words( :$nw = "WS" --> List[Str] )
    Returns a (lazy) list of words of which the file consists, or a
    "Failure" if something went wrong. Also takes the following optional
    named parameters:
    :nw The delimiter between what are to be considered words. By default
        assumes "WS", which indicates any whitespace character.
   Subclasses
    The "IO::Path" class may have "IO::Spec" specific subclasses. But
    basically, these would only implicitely specify the "IO::Class" to be
    specified for the ".new" method:
      class IO::Path::Win32 {
          method new(|c) { IO::Path.new(|c, :SPEC(IO::Spec::Win32) }
    The "IO::Handle" object is usually not directly instantiated, but with
    "open()" or "IO::Path"'s".open". Nonetheless, you can create an
    "IO::Handle" object with just a path:
      my $handle = IO::Handle.new($filename as Str);
      my $handle = IO::Handle.new($filename as Str, :SPEC(*$SPEC));
      my $handle = IO::Handle.new($filename as Str, :SPEC(*$SPEC), :CWD($*CWD));
    This does not interact with anything at all and will appear as if the
    file has been ".close"d. From then on, the ".path" method will return
    the "IO::Path" object that was created
    The ".open" method does interact with the file system:
      $handle.open;  # same as $handle = $filename.IO.open
    It has the same optional named parameters as "open()" and either returns
    itself (for historical reasons), or a "Failure" with additional
    information.
   Methods handled by .path
    The filename specified with ".new" is internally stored as an "IO::Path"
    object, obtainable with the ".path" method. The following methods are
    handled by ".path" and work exactly the same:
      absolute       the absolute, canonical path
      accessed       last access time (if available)
      basename       the basename of the path
      changed        last (metadata) changed time
      chmod          change attributes of path
      dirname        the directory part of the absolute path
      extension      the extension of the file
      is-absolute    is the (original) path absolute
      is-relative    is the (original) path relative
      modified       last modified time
      relative       the relative path against CWD
      SPEC           the :SPEC at instantiation time
      volume         the volume of the path (if any)
    The following methods also work the same as with "IO::Path", but it may
    be less logical to use these on an "IO::Handle" object as these return
    new "IO::Path" objects.
      child          append basename to path
      IO             same as .path
      parent         remove last portion of path
      pred           previous logical path
      resolve        follow symlinks to the real path
      succ           next logical path
    These "IO::Path" methods seem to only make sense if the "IO::Handle"
    object is closed. But there may be some uses for this, but it seems more
    like extra rope for shooting yourself in the foot.
      copy           create a copy of file
      mkdir          create directory
      move           move (rename) to other storage
      rename         rename (move) to other name
      rmdir          remove directory if empty directory
      unlink         remove file
    [Conjecture: perhaps the above methods should fail on IO::Handle]
    Contrary to the "IO::Path" methods with the same name, these methods
    operate only from the current file position. If the file was just
    opened, it's identical as with the "IO::Path" version. But if you have
    done anything to the handle that moved the file pointer, you will get a
    different result.
      lines          contents of file as lines
      slurp          obtain the contents of the file
      spurt          write / append contents to file
      words          contents of file as words
    The other methods of "IO::Handle" are:
   .close
        method close(--> Bool)
    Closes the handle and returns "True", or a "Failure" if something went
   .encoding
        method encoding(--> Str)
        method encoding($encoding --> Str)
    Without arguments, simply returns the current encoding used on the
    handle. If supplied with a string identifying a valid encoding, change
    the handle to read with that encoding from then on. Options include
    "binary", "utf8", and other text encodings. An invalid encoding causes
    the method to return a "Failure".
   .eof
        method eof(--> Bool)
    Returns "True" if the handle is exhausted, "False" otherwise.
   .fileno
        method fileno(--> int)
    Returns the file descriptor, which is always a native integer,
    conforming to C89.
   .flush
        method flush(--> Bool)
    Attempts to flush any buffered data, returns "True" if successful, an
    appropriate "Failure" otherwise.
   .get
        method get(--> Str)
    Reads the next line and returns it. Uses the (implicit) specification of
    ":nl" with "open" to determine where a line ends. Returns a "Str" type
    object if no more lines to be read.
   .getc
        method getc(Int $chars = 1 --> Str)
    Tries to read $chars characters and return them concatenated as a
    string. Returns a "Str" type object if no more lines to be read.
   .ins
        method ins(--> Int)
    Returns the number of lines that have been read with ".get" or ".lines".
   .opened
        method opened(--> Bool)
    Return whether the file is opened.
   .p
        method p(--> Bool)
    Returns whether the handle is opened to a pipe.
   .print
        method print (*@text --> Bool)
    Stringifies each element, concatenates those strings, and writes the
    result to the file. Returns "True" if successful, a "Failure" otherwise.
   .read
        method read(Int $bytes --> Buf)
    Reads and returns $bytes bytes from the handle, or as many as are
    possible.
   .say
        method say (*@text --> Bool)
    This is identical to ".print" except that it stringifies its arguments
    by calling ".gist" on them and auto-appends a newline after the final
    argument.
   .seek
        method seek(Int $position, MoveMethod $whence --> Bool)
    Move the file pointer to $position. The meaning of this position is
    always in "bytes", so you better know what you're doing in a text-file.
    The $whence value should be a "MoveMethod" value, which is one of:
        name        value
        =========== =====
        FromStart     0
        FromCurrent   1
        FromEnd       2
    These numerical values will also be accepted. Returns "True" on success,
    or a "Failure" if something went wrong (e.g. when using $*IN on a
    terminal input).
   .t
        method t(--> Bool)
    Returns "True" if the handle is opened to a tty, aka there might
    actually be a person watching.
   .tell
        method tell(--> Int)
    Returns the position of the file pointer in number of "octets".
   .write
        method write(Buf $buf --> Int)
    Tries to write $buf to the file. The actual number of bytes written is
    returned, or a "Failure" if something went wrong.
        This is "raw" write. $buf contains plain bytes. If you want to
        "write" a "Str", you should ".encode" it first, or use ".print".
        Elizabeth Mattijsen <liz@dijkmat.nl>
    DRAFT: Synopsis 32: Setting Library - Numeric
        Last Modified: 14 Feb 2015
        Version: 20
    This documents Int, Numeric, Rat, Complex, and Bool.
Function Packages
  Bool
         multi method succ ( Bool $b: --> Bool ) is export
        Returns "Bool::True".
         multi method pred ( Bool $b: --> Bool ) is export
        Returns "Bool::False".
  Numeric
    "Numeric" is a role for everything that's a scalar number. So "Num",
    "Int", "Rat", "Complex" and other numeric types do that role. However it
    is an abstract interface, so "$number.WHAT" will never return "Numeric".
    Users who provide their own scalar numeric types are encouraged to
    implement the "Numeric" role. It is intended that such types support the
    basic arithmetic operators to the extent possible, as well as "==". In
    addition, it is hoped that comparison operators will at least return
    consistent results, even if there is no sensible mathematical ordering
    of your type. That allows functions like sort to not choke and die if
    they are handed a value of your type. (See also the "Real" role for
    scalar numeric types that represent real numbers.)
    The following are all defined in the "Numeric" role:
    "Numeric" provides some constants in addition to the basic mathematical
    functions.
        constant tau is export = 6.28318_53071_79586_47692_52867_66559_00576;
        constant pi  is export = 3.14159_26535_89793_23846_26433_83279_50288;
        constant e   is export = 2.71828_18284_59045_23536_02874_71352_66249;
        constant i   is export = 1i;
    "τ" and "π" are provided as aliases for "tau" and "pi", respectively.
    Real
         multi method Real ( --> Real )
        If this "Numeric" is equivalent to a "Real", return that "Real".
        (For instance, if this number is a "Complex" with a zero imaginary
        part.) Fail with "X::Numeric::Real" otherwise.
    Int
         multi method Int ( --> Int )
        If this "Numeric" is equivalent to a "Real", return the equivalent
        of calling "truncate" on that "Real" to get an "Int". Fail with
        "X::Numeric::Real" otherwise.
    Rat
         multi method Rat ( Real $epsilon = 1.0e-6 --> Rat )
        If this "Numeric" is equivalent to a "Real", return a "Rat" which is
        within $epsilon of that "Real"'s value. Fail with "X::Numeric::Real"
    Num
         multi method Num ( --> Num )
        If this "Numeric" is equivalent to a "Real", return that "Real" as a
        "Num" as accurately as is possible. Fail with "X::Numeric::Real"
         multi method succ ( Numeric $x: --> Numeric ) is export
         multi method succ ( Int $x: --> Int     )     is export
        Returns the successor of $x. This method is used by "prefix:<++>"
        and "postfix:<++>" to increment the value in a container.
         multi method pred ( Numeric $x: --> Numeric ) is export
         multi method pred ( Int $x: --> Int     ) is export
        Returns the predecessor of $x. This method is used by "prefix:<-->"
        and "postfix:<-->" to decrement the value in a container.
    abs
         multi method abs ( Numeric $x: --> Numeric ) is export
        Absolute Value.
    conj
         multi method conj ( Numeric $x: --> Numeric ) is export
        The complex conjugate of the value. For non-complex types, returns
        self.
    exp
         multi method exp ( Numeric $exponent: Numeric :$base = Num::e --> Numeric ) is export
        Performs similar to "$base ** $exponent". $base defaults to the
        constant *e*.
    log
         multi method log ( Numeric $x: Numeric $base = Num::e --> Numeric ) is export
        Logarithm of base $base, default Natural. Calling with "$x == 0" is
        an error.
    log10
         multi method log10 (Numeric $x: --> Numeric ) is export
        A base 10 logarithm, otherwise identical to "log".
    rand
         sub term:<rand> ( --> Num )
        Pseudo random number in range "0 ..^ 1". That is, 0 is theoretically
        possible, while 1 is not. Note that there is no unary "rand"
        function in Perl 6, but there is a "rand" method. For picking a
        random integer you probably want to use something like "(1..6).pick"
        instead.
    sqrt
         multi method sqrt ( Numeric $x: --> Numeric ) is export
        Returns the principal square root of the parameter.
    roots
          method roots (Numeric $x: Int $n ) is export
        Returns a list of all $nth (complex) roots of $x. Returns "NaN" if
        "$n <= 0", itself if "$n == 0", and is free to return a single "NaN"
        if $x is "NaN" or "Inf", or in case of complex numbers if one of the
        components is.
    i
         multi postfix:<i> ( Numeric $x --> Complex )
        Returns a complex number representing the parameter multiplied by
        the imaginary unit "i". Note that there is no ".i" method. To follow
        a variable name with the postfix, it's necessary to use a backslash
        or parentheses:
            $land\i
            ($land)i
    to-radians
         multi method to-radians ( Numeric $x: TrigBase $base --> Numeric ) is export
        Convert from $base to radians.
    from-radians
         multi method from-radians ( Numeric $x: TrigBase $base --> Numeric ) is export
        Convert from radians to $base.
    narrow
         multi method narrow ( Numeric $x: ) is export
        Attempts to coerce the number to the narrowest type that can
        represent it accurately; for instance, a "Rat" with a denominator of
        1 maybe be coerced to an "Int" instead; an integral "Num" may
        likewise turn into an "Int". (Neither "Num" nor "Rat" convert to
        each other, however.) "Complex" with a 0 imaginary part may narrow
        to a "Real" type. Conjecturally, wide native types could narrow to
        narrower native types.
  Real
        role Real does Numeric;
    "Real", like "Numeric", is an abstract role that represents the
    interface of a real scalar number (i.e. neither "Complex" nor
    vector-like). For example "Num", "Int", "Bool" and "Rat" implement the
    "Real" role.
    Users who provide their own scalar real numeric types are encouraged to
    implement the "Real" role. Because real numbers are
    strictly-totally-ordered and "Real" types try to emulate that property,
    it is desirable that any two "Real" types be mutually compatible, even
    if they are not aware of each other. The current proposal requires you
    to define a "Bridge" method in your "Real" type, which converts your
    type into a neutral "Real" type by restating it in terms of the
    fundamental Perl 6 types and calling "Bridge" on them. This then makes
    the default "Real" methods and operators all work with your "Real" type.
    While the name of this method may changed, it is hoped that something
    like this will remain in the spec.
    Complex
         multi method Complex ( --> Complex )
        Returns a "Complex" whose real part is this "Real" and whose
        imaginary part is 0.
    Str
         multi method Str ( --> Str )
        Returns the "Real" as a "Str". All built-in "Real" types format it
        as a decimal number, so for example, the "Rat" "5/4" is returned as
        "1.2".
    base
          multi method base($base, $digits?)
        Returns a "Str" representing the invocant in base $base. Fails if
        $base is smaller than 2 or larger than 36.
        For bases above ten, the digit repertoire is enhanced with uppercase
        latin characters starting from "A".
        The optional $digits argument asks for that many digits of fraction
        (which may not be negative). If omitted, a reasonable default is
        chosen based on type. For Int this default is 0. For Num, the
        default is 8. For Rat, the number of places is scaled to the size of
        the denominator, with a minimum of 6.
        The final digit produced is always rounded.
    floor
         multi method floor ( Real $x: --> Int ) is export
        Returns the highest integer not greater than $x.
    ceiling
         multi method ceiling ( Real $x: --> Int ) is export
        Returns the lowest integer not less than $x.
    round
         multi method round ( Real $x: $scale = 1 --> Real ) is export
        With no arguments, returns the nearest integer to $x. If $scale is
        given, rounds $x to the nearest multiple of $scale. The algorithm
        is:
            floor($x / $scale + 0.5) * $scale
        (Other rounding algorithms will be given extended names beginning
        with "round".)
    truncate
         multi method truncate ( Real $x: --> Int ) is export
        Returns the closest integer to $x whose absolute value is not
        greater than the absolute value of $x. (In other words, just chuck
        any fractional part.) This is the default rounding function used by
        implicit integer conversions.
        You may also truncate using explicit integer casts, either "Int()"
        for an arbitrarily large integers, or "int()" for native integers.
    sign
         multi method sign ( Real $x: --> Int ) is export
        Returns 1 when $x is greater than 0, -1 when it is less than 0, 0
        when it is equal to 0, or undefined when the value passed is
        undefined.
    srand
         multi srand ( Real $seed = default_seed_algorithm())
        Seed the generator "rand" uses. $seed defaults to some combination
        of various platform dependent characteristics to yield a
        non-deterministic seed. Note that you get one "srand()" for free
        when you start a Perl program, so you *must* call "srand()" yourself
        if you wish to specify a deterministic seed (or if you wish to be
        differently nondeterministic).
         multi method rand (Real $x: --> Num ) is export
        Pseudo random number in range "0 ..^ $x". That is, 0 is
        theoretically possible, while $x is not. For picking a random
        integer you probably want to use something like "(1..6).pick"
    cis
            multi method cis (Real $angle: --> Complex ) is export
        Returns 1.unpolar($angle)
    unpolar
            multi method unpolar (Real $mag: Real $angle --> Complex ) is export
        Returns a complex number specified in polar coordinates. Angle is in
        radians.
    polymod
            method polymod(*@mods)
        Returns a sequence of mod results corresponding to the divisors in
        @mods. If the number of divisors is finite, returns one more result
        than the number of divisors, and the final result is the remainder
        after all the divisions. If the number of divisors is infinite, runs
        until the remainder is 0. The "Int" version of this method assumes
        all the divisors are also integers. Coerce the invocant to "Num" or
        "Rat" if you wish to use fractional operations.
  Num
        class Num does Real
    "Num" is a machine-precision numeric real value.
  Complex
    "Complex" is an immutable type. Each "Complex" object stores two
    numbers, the real and imaginary part. For all practical purposes a
    "Complex" with a "NaN" in real or imaginary part may be considered a
    "NaN" itself (and "(NaN+1i) ~~ NaN" is "True").
    Coercion of a "Complex" to any "Real" returns the real part (coerced, if
    necessary) if the imaginary part is 0, and fails otherwise. Comparison
    between a "Real" number and a "Complex" must be smart enough not to
    coerce the "Complex" to a real number blindly.
            multi method new(Real $re, Real $im --> Complex )
        Constructs a "Complex" number from real and imaginary part. This is
        the method form of "$re+$im\i". (But use the "<1+2i>" form for
        literals, so that you don't have to worry about precedence or rely
        on constant folding.)
    polar
            multi method polar (Complex $nim: --> List ) is export
        Returns (magnitude, angle) corresponding to the complex number. The
        magnitude is non-negative, and the angle in the range "-π ..^ π".
    re
            multi method re( --> Real )
        Returns the real part of the complex number.
    im
            multi method im( --> Real )
        Returns the imaginary part of a complex number.
            multi method conj(Complex $c --> Complex )
        Returns "($c.re - $c.im\i)", the complex conjugate.
    gist
            multi method gist( --> Str )
        Returns a string representation of the form ""1+2i"", without
        internal spaces. ("Str" coercion also returns this.)
            multi method perl( --> Str )
        Returns a string representation corresponding to the unambiguous
        "val()"-based representation of complex literals, of the form
        ""<1+2i>"", without internal spaces, and including the angles that
        keep the "+" from being treated as a normal addition operator.
         multi method floor ( Complex $c: --> Complex ) is export
        Returns "$c.re.floor + $c.im.floor". That is, each of the real and
        imaginary parts is rounded to the highest integer not greater that
        the value of that part.
         multi method ceiling ( Complex $c: --> Complex ) is export
        Returns "$c.re.ceiling + $c.im.ceiling". That is, each of the real
        and imaginary parts is rounded to the lowest integer not less that
         multi method round ( Complex $c: $scale = 1 --> Complex ) is export
        With no arguments, rounds both the real and imaginary parts to the
        nearest integer and returns a new Complex number. If $scale is
        given, rounds both parts of $c to the nearest multiple of $scale.
        Uses the same algorithm as Real.round on each part of the number.
         multi method truncate ( Complex $c: --> Complex ) is export
        Removes the fractional part of both the real and imaginary parts of
        the number, using Real.truncate, and returns the result as a new
        Complex.
  Trigonometric functions
    The following are also defined in "Numeric". Most trig functions are
    specified to operate in terms of radians, as the mathematical and
    programming standard. Functions are provided to convert other angle
    specifications to and from radians. Angle specifications are given in
    terms of enum TrigBase:
     enum TrigBase is export (
        Radians  => 1,
        Degrees  => (pi / 180),
        Gradians => (pi / 200),
        Circles  => 2*pi
     );
    *Standard Trig Functions*
         Numeric multi method func ( Numeric  $x ) is export
        where *func* is one of: sin, cos, tan, asin, acos, atan, sec, cosec,
        cotan, asec, acosec, acotan, sinh, cosh, tanh, asinh, acosh, atanh,
        sech, cosech, cotanh, asech, acosech, acotanh.
        Performs the various trigonometric functions. The argument is always
        expressed in radians. The return value from "CORE::" versions of
        these functions is always "Num", unless domain limits force it to be
        "Complex" instead.
    *Converting Angles*
        If you prefer to express angles in units other than radians, you
        have two choices. First, you can convert the angles into radians, by
        multiplication:
         sin(90 * Degrees)
        or by using the "to-radians" method:
         sin(90.to-radians(Degrees));
        Alternatively, you can use the "trigbase" pragma to install a new
        set of trigonometric functions into the current lexical scope, which
        will handle a different unit:
         use trigbase Degrees;
         sin(90)
        The parameter to the trigbase pragma must be something that is
        usable as a number. The above code fragment is more or less
        equivalent to:
         constant $?TRIGBASE = Degrees;
         sub sin($x) { CORE::sin($x * Degrees) }
         # repeat for all the other trig operators
        Two points must be emphasized. First, "trigbase" has no effect on
        the method forms of trig operators; ".sin" always expects radians.
        Second, because it defines dozens of subs, it's probably a good idea
        to use "trigbase" in the highest scope where it makes sense.
        The "$?TRIGBASE" constant is not used by the trig operators
        themselves. It exists only to allow modules to be "trigbase" aware.
    atan2
         multi method atan2 ( Real $y: Real $x = 1, TrigBase $base = CALLER::<$?TRIGBASE> --> Real )
         multi atan2 ( Real $y, Real $x = 1, TrigBase $base = CALLER::<$?TRIGBASE> --> Real )
        This second form of "atan" computes the arctangent of "$y/$x", and
        takes the quadrant into account. Otherwise behaves as other
        trigonometric functions.
  Int
    An "Int" is an immutable, integral number of arbitrary size.
    expmod
         multi method expmod ( Int $x: Int $y, Int $mod --> Int ) is export
        Returns $x raised to the $y power within modulus $mod.
    is-prime
         multi method is-prime ( Int $x: Int $tries = 100) is export
        Returns True if $x is known to be a prime, or is likely to be a
        prime based on a probabalistic Miller-Rabin test. (The optional
        argument tells how many times to iterate the probabalistic test, if
        such is necessary.)
        Returns False if $x is known not to be a prime.
    lsb
         multi method lsb ( Int $x: ) is export
        Returns the least significant bit position containing a 1 bit,
        counting bit positions from least significant to most significant.
        (In other words, it's the base 2 logarithm of number represented by
        that 1 bit.)
        This function returns "Nil" on a 0 value, since there are no bits
        set. Negative integers are treated as 2's complement, so always have
        a lowest bit set somewhere, if only the sign bit. Hence, a -32768
        returns an lsb of 15 regardless of whether it's stored in an "int16"
        or an "Int".
    msb
         multi method msb ( Int $x: ) is export
        Returns the most significant bit position containing a 1 bit, that
        is, the base 2 logarithm of the top 1 bit.
        This function returns "Nil" on a 0 value. For negative values, the
        function is dependent on the type. For native types, signed integers
        are treated as unsigned, so a negative number stored in "int64" will
        always return 63. Negative integers stored in an "Int" notionally
        have an infinite number of 1 bits on top, which is a problem.
        Instead of returning "+Inf", which is relatively useless, we return
        the position of the first of that infinite supply of sign bits. So
        "msb(-1)" returns 0, "msb(-2)" returns 1, and "msb(-32768)" returns
        15, just as if we'd converted it from "int16" to "uint16" and
        examined that for its top bit.
  Rat
        class Rat does Real
    An immutable rational number, represented by two "Int"s, a numerator and
    a denominator. All interface methods return values as if the numerator
    and denominator were stored in a normal form: both numerator and
    denominator are minimal in their magnitude, and the denominator is
    positive. So "Rat.new(2, -4).denominator" return 2, because the normal
    form is "-1/2".
    (An implementation is allowed to be lazy about this internally when it
    determines that normalizing repeatedly is detrimental to performance,
    such as when adding a column of numbers that all have an internal
    denominator of 100.)
            multi method new(Int $num, Int $denom)
        Constructs a "Rat" object from the numerator and denominator. Fails
        if "$denom == 0". You can use division to produce a "Rat" through
        constant folding, but generally if you know the values in advance,
        you should use one of literal forms so that you don't have to rely
        on precedence. You may use the "val()"-based "<3/5>" form, or you
        can simply write decimal numbers with a decimal point, since 12.34
        is essentially identical to "<1234/100>" as a literal.
    nude
            multi method nude( --> List )
        Returns a "List" of numerator and denominator.
    denominator
            multi method denominator( --> Int )
        Returns the denominator.
    numerator
            multi method numerator( --> Int )
        Returns the numerator.
        Returns a string representation of the number in decimal. If the
        number can be represented exactly in decimal, it will be. In any
        case, the portion before the decimal point (the "integer" part) is
        guaranteed to be exact. The precision of the fractional part is
        defined to be one more digit than the size of the denominator after
        the integer part has been removed, but at least 6 digits for
        repeating fractions. The final digit of the fractional part is
        rounded.
        "Str" coercion is identical to "gist".
        "val()"-based representation of rational literals. If the number can
        be represented exactly in decimal, it will be. Otherwise uses the
        form ""<3/5>"", without internal spaces, and including the angles
        that keep the "/" from being treated as a normal division operator.
    base-repeating
          multi method base-repeating($base)
        Returns two strings representing the invocant in base $base. Fails
        if $base is smaller than 2 or larger than 36.
        The first returned string is the non-repeating part of the
        representation. The second is the repeating part. The precision is
        arbitrarily limited to 100000. Above that, the repeating group will
        return '???'. If there is no repeating group, the second returned
        string is ''.
        Stefan O'Rear <stefanor@cox.net>
    DRAFT: Synopsis 32: Setting Library - Rules
        Created: 27 Feb 2009
        Last Modified: 5 Jul 2013
        Version: 2
    This synopsis deals with objects produced by the regexes and grammars
    described in much greater detail in S05.
Classes
  Regex
        class Regex is Method {...}
    Regex objects are created through the syntax described in S05:
        / ... /
        rx/ ... /
        regex { ... }
    They can be stored in variables for later use, as with the "qr//" syntax
    in Perl 5.
    method Bool(Regex:D: )
        In boolean context, a regex object will match against $_, and return
        the result as a Bool.
  Match
        class Match is Cool does Positional does Associative {
            method from( --> Int )  {...}
            method to( --> Int )    {...}
            method chars( --> Int ) {...}
            method orig()           {...}
            method ast()            {...}
            method caps()           {...}
            method chunks()         {...}
            method pos()            {...}
            method bool()           {...}
            method Str()            {...}
            method Num()            {...}
  Cursor
        class Cursor {
            method pos( --> Int ) {...}
            method orig() {...}
  Grammar
        class Grammar is Cursor
    Much as a class is a collection of named attributes and methods, a
    grammar is a collection of named regexes and rules. For more on creating
    and using grammars, see "Grammars" in S05.
    parse / subparse
            method parse ($target, :$rule = 'TOP', Mu :$actions = Mu, *%opts)
            method subparse ($target, :$rule = 'TOP', Mu :$actions = Mu, *%opts)
        Parses the $target string with given <:rule>, and returns the result
        as a Match object. Defaults to the "TOP" rule. A class containing
        actions may be attached using the "actions" named argument.
        The "parse" method automatically anchors the rule to the beginning
        and end of the target string (adding "^" and "$" around the rule).
        The "subparse" method does not add anchors, and will match
        substrings against the rule.
    parsefile
            method parsefile (Cool $filename, :$rule = 'TOP', Mu :$actions = Mu, *%opts)
        Parse the file as with ".parse", but matches the grammar against the
        contents of $filename instead.
    See Abstractions.pod
    Synopsis 1: Overview
        Created: 10 Aug 2004
        Last Modified: 11 Feb 2015
        Version: 10
    This document originally summarized Apocalypse 1, which covers the
    initial design concept. That original summary may be found below under
    "Random Thoughts". However, these Synopses also contain updates to
    reflect the evolving design of Perl 6 over time, unlike the Apocalypses,
    which are frozen in time as "historical documents". These updates are
    not marked--if a Synopsis disagrees with its Apocalypse, assume the
    Synopsis is correct.
    Another assumption has been that if we don't talk about something in
    these Synopses, it's the same as it is in Perl 5. Soon we plan to fill
    in the gaps with the Perl 5 details though.
Project Plan
    Mostly, we're just a bunch of ants all cooperating (sort of) to haul
    food toward the nest (on average). There are many groups of people
    working on various bits and pieces as they see fit, since this is
    primarily a volunteer effort.
    This document does not attempt to summarize all these subprojects--see
    <http://perl6.org> for such information. What we can say here is that,
    unlike how it was with Perl 5, none of these projects is designed to be
    the Official Perl. Perl 6 is anything that passes the official test
    suite. This test suite was initially developed under the Pugs project
    because that project was at one point the furthest along in exploring
    the high-level semantics of Perl 6. (Other projects may be better at
    other things, such as speed or interoperability. This is fine; it is not
    necessary that all implementations be equally good at everything.) The
    official test suite is community property, and is intended to be
    platform neutral, so that Perl 6 is defined primarily by its desired
    semantics, not by accidents of history.
    Another aspect of this is the Perl 6 compiler will be self-hosting. That
    is, the compiler will eventually compile itself, at least down to the
    point where various code-generating backends can take over. This largely
    removes platform dependencies from the frontend, so that only the
    backends need to worry about platform-specific issues.
    But above all, our project plan is simply to help people find a spot
    where they can feel like they're creating the future, both for
    themselves and for others. Around here, that's what we call fun.
Random Thoughts
    *   The word "apocalypse" historically meant merely "a revealing", and
        we're using it in that unexciting sense.
    *   If you ask for RFCs from the general public, you get a lot of
        interesting but contradictory ideas, because people tend to stake
        out polar positions, and none of the ideas can build on each other.
    *   Larry's First Law of Language Redesign: Everyone wants the colon.
    *   RFCs are rated on "PSA": whether they point out a real Problem,
        whether they present a viable Solution, and whether that solution is
        likely to be Accepted as part of Perl 6.
    *   Languages should be redesigned in roughly the same order as you
        would present the language to a new user.
    *   Perl 6 should be malleable enough that it can evolve into the
        imaginary perfect language, Perl 7. This darwinian imperative
        implies support for multiple syntaxes above and multiple platforms
        below.
    *   Many details may change, but the essence of Perl will remain
        unchanged. Perl will continue to be a multiparadigmatic,
        context-sensitive language. We are not turning Perl into any other
        existing language.
    *   Migration is important. A Perl 6 interpreter, if invoked as
        ""perl"", will assume that it is being fed Perl 5 code unless the
        code starts with a "class" or "module" keyword, or you specifically
        tell it you're running Perl 6 code in some other way, such as by:
            #!/usr/bin/perl6
            use v6.0;
        Also, a file with a ".p6" extension may be taken as indicative, as
        may any other extension containing the digit 6, such as "p6l" or
        "p6m" or "pl6" or "pm6". (Though ".pl" and ".pm" are still perfectly
        acceptable extensions as long as the Perl-6-ness is indicated by one
        of the other indicators.)
    *   Migration in the other direction is also important. In Perl 6 mode,
        one can drop back to Perl 5 mode with "use v5" at the beginning of a
        lexical block. Such blocks may be nested:
            use v6;
            # ...some Perl 6 code...
            {
                use v5;
                # ...some Perl 5 code...
                {
                    use v6;
                    # ...more Perl 6 code...
                }
        Some platforms may restrict this to a subset of Perl 5 when it is
        not expedient to include a full Perl 5 interpreter. The standard
        Perl 6 grammar will include the ability to parse a well-behaved
        subset of Perl 5 on its own (much like PPI does); implementations
        are required only to support this subset, though of course they may
        also choose to implement bug-for-bug compatibility.
    *   Scaling is one of those areas where Perl needs to be
        multiparadigmatic and context sensitive. Perl 5 code is not strict
        by default, while Perl 6 code is. But it should be easy to relax
        with "-e" or the 'no strict' pragma:
            perl -e '$x = 1'
            #!/usr/bin/perl
            no strict;
            $x = 1;
    *   It must be possible to write policy metamodules that invoke other
        modules on the user's behalf.
    *   If you want to treat everything as objects in Perl 6, Perl will help
        you do that. If you don't want to treat everything as objects, Perl
        will help you with that viewpoint as well.
    *   Operators are just functions with funny names and syntax.
    *   Language designers are still necessary to synthesize unrelated ideas
        into a coherent whole.
    *   The language designer is neither omniscient nor omnipotent, and
        never will be, despite requests for those particular features.
        Therefore the design process will be spiral, cooperative, and
        convergent. The rate of convergence is an emergent property, and
        cannot be forced, only encouraged. As long as anyone is hacking on
        any implementation of Perl 6 to make it conform to the test suite,
        or hacking on the test suite to make it reflect consensus of
        specification, the rate of convergence will be deemed to be
        positive. If you are unhappy with the current rate of convergence,
        please cooperate more with someone else you think is interested in
        convergence.
    *   The spec will not be frozen prematurely, but will continue to
        solidify as various aspects of it are proven (or disproven) in
        various implementations. Many parts of the spec are already
        effectively frozen, or are in a slushy state. "The future is already
        here, it's just unevenly distributed."
    *   All specced features that have not been proven in an implementation
        should be considered somewhat conjectural, even if not so marked. As
        implementations start to agree on what is practical and what is not,
        do not be surprised if some features that are currently specced may
        be deferred to future versions; these should still be considered
        long-term direction in the evolution of Perl 6 over time, and the
        short-term design should be conservative in preserving that
        long-term evolution. Note that we are not in a hurry to defer any
        sections of the spec, even if that would give the illusion of
        progress. Convergence of specs and implementations will happen
        naturally as we get implementations that are closer to the spec. It
        is quite likely that the first practical implementation will largely
        determine which features are considered to be required in 6.0.0.
    *   Everyone is allowed to panic *once*. However, continual panic will
        be deemed poisonous. Nobody gets special treatment, even if they
        think special treatment is necessary for success. This means you.
About These Documents
    If you are reading the HTML version, it is generated from the POD
    sources in the specs repository under <https://github.com/perl6/specs>,
    so edit it there in the git repository if you would like to make
    changes.
  Additions
    Please post errors and feedback to perl6-language. If you are making a
    general laundry list, please separate messages by topic.
    Synopsis 2: Bits and Pieces
        Last Modified: 16 Oct 2015
        Version: 296
    This document summarizes Apocalypse 2, which covers small-scale lexical
    items and typological issues. (These Synopses also contain updates to
    Synopsis is correct.)
One-pass parsing
    To the extent allowed by sublanguages' parsers, Perl is parsed using a
    one-pass, predictive parser. That is, lookahead of more than one
    "longest token" is discouraged. The currently known exceptions to this
    are where the parser must:
    *   Locate the end of interpolated expressions that begin with a sigil
        and might or might not end with brackets.
    *   Recognize that a reduce operator is not really beginning a "[...]"
        composer.
    One-pass parsing is fundamental to knowing exactly which language you
    are dealing with at any moment, which in turn is fundamental to allowing
    unambiguous language mutation in any desired direction. (Generic
    languages are allowed, but only if intended; accidentally generic
    languages lead to loss of linguistic identity and integrity. This is the
    hard lesson of Perl 5's source filters and other multi-pass parsing
    mistakes.)
Lexical Conventions
  Unicode Semantics
    In the abstract, Perl is written in Unicode, and has consistent Unicode
    semantics regardless of the underlying text representations. By default
    Perl presents Unicode in "NFG" formation, where each grapheme counts as
    one character. A grapheme is what the novice user would think of as a
    character in their normal everyday life, including any diacritics.
    Perl can count Unicode line and paragraph separators as line markers,
    but that behavior had better be configurable so that Perl's idea of line
    numbers matches what your editor thinks about Unicode lines.
    Unicode horizontal whitespace is counted as whitespace, but it's better
    not to use thin spaces where they will make adjoining tokens look like a
    single token. On the other hand, Perl doesn't use indentation as syntax,
    so you are free to use any amount of whitespace anywhere that whitespace
    makes sense. Comments always count as whitespace.
  Bracketing Characters
    For some syntactic purposes, Perl distinguishes bracketing characters
    from non-bracketing. Bracketing characters are defined as any Unicode
    characters with either bidirectional mirrorings or Ps/Pe/Pi/Pf
    properties.
    In practice, though, you're safest using matching characters with
    Ps/Pe/Pi/Pf properties, though ASCII angle brackets are a notable
    exception, since they're bidirectional but not in the Ps/Pe/Pi/Pf sets.
    Characters with no corresponding closing character do not qualify as
    opening brackets. This includes the second section of the Unicode
    BidiMirroring data table.
    If a character is already used in Ps/Pe/Pi/Pf mappings, then any entry
    in BidiMirroring is ignored (both forward and backward mappings). For
    any given Ps character, the next Pe codepoint (in numerical order) is
    assumed to be its matching character even if that is not what you might
    guess using left-right symmetry. Therefore "U+298D" ("⦍") maps to
    "U+298E" ("⦎"), not "U+2990" ("⦐"), and "U+298F" ("⦏") maps to "U+2990"
    ("⦐"), not "U+298E" ("⦎"). Neither "U+298E" ("⦎") nor "U+2990" ("⦐") are
    valid bracket openers, despite having reverse mappings in the
    BidiMirroring table.
    The "U+301D" ("〝") codepoint has two closing alternatives, "U+301E"
    ("〞") and "U+301F" ("〟"); Perl 6 only recognizes the one with lower code
    point number, "U+301E" ("〞"), as the closing brace. This policy also
    applies to new one-to-many mappings introduced in the future.
    However, many-to-one mappings are fine; multiple opening characters may
    map to the same closing character. For instance, "U+2018" ("‘"),
    "U+201A" ("‚"), and "U+201B" ("‛") may all be used as the opener for the
    "U+2019" ("’") closer. Constructs that count openers and closers assume
    that only the given opener is special. That is, if you open with one of
    the alternatives, all other alternatives are treated as non-bracketing
    characters within that construct.
  Multiline Comments
    Pod sections may be used reliably as multiline comments in Perl 6.
    Unlike in Perl 5, Pod syntax now lets you use "=begin comment" and "=end
    comment" to delimit a Pod block correctly without the need for "=cut".
    (In fact, "=cut" is now gone.) The format name does not have to be
    "comment" -- any unrecognized format name will do to make it a comment.
    (However, bare "=begin" and "=end" probably aren't good enough, because
    all comments in them will show up in the formatted output.)
    We have single paragraph comments with "=for comment" as well. That lets
    "=for" keep its meaning as the equivalent of a "=begin" and "=end"
    combined. As with "=begin" and "=end", a comment started in code reverts
    to code afterwards.
    Since there is a newline before the first "=", the Pod form of comment
    counts as whitespace equivalent to a newline. See S26 for more on
    embedded documentation.
  Single-line Comments
    Except within a quote literal, a "#" character always introduces a
    comment in Perl 6. There are two forms of comment based on "#". Embedded
    comments require the "#" to be followed by a backtick ("`") plus one or
    more opening bracketing characters.
    All other uses of "#" are interpreted as single-line comments that work
    just as in Perl 5, starting with a "#" character and ending at the
    subsequent newline. They count as whitespace equivalent to newline for
    purposes of separation. Unlike in Perl 5, "#" may *not* be used as the
    delimiter in quoting constructs.
  Embedded Comments
    Embedded comments are supported as a variant on quoting syntax,
    introduced by "#`" plus any user-selected bracket characters (as defined
    in "Bracketing Characters" above):
        say #`( embedded comment ) "hello, world!";
        $object\#`{ embedded comments }.say;
        $object\ #`「
            embedded comments
        」.say;
    Brackets may be nested, following the same policy as ordinary quote
    brackets.
    There must be no space between the "#`" and the opening bracket
    character. (There may be the *visual appearance* of space for some
    double-wide characters, however, such as the corner quotes above.)
    For multiline comments it is recommended (but not required) to use two
    or more brackets both for visual clarity and to avoid relying too much
    on internal bracket counting heuristics when commenting code that may
    accidentally miscount single brackets:
        #`{{
            say "here is an unmatched } character";
        }}
    However, it's sometimes better to use Pod comments because they are
    implicitly line-oriented.
  User-selected Brackets
    For all quoting constructs that use user-selected brackets, you can open
    with multiple identical bracket characters, which must be closed by the
    same number of closing brackets. Counting of nested brackets applies
    only to pairs of brackets of the same length as the opening brackets:
        say #`{{
            This comment contains unmatched } and { { { {   (ignored)
            Plus a nested {{ ... }} pair                    (counted)
        }} q<< <<woot>> >>   # says " <<woot>> "
    Note however that bare circumfix or postcircumfix "<<...>>" is not a
    user-selected bracket, but the ASCII variant of the "«...»"
    interpolating word list. Only "#`" and the "q"-style quoters (including
    "m", "s", "tr", and "rx") enable subsequent user-selected brackets.
  Unspaces
    Some languages such as C allow you to escape newline characters to
    combine lines. Other languages (such as regexes) allow you to backslash
    a space character for various reasons. Perl 6 generalizes this notion to
    any kind of whitespace. Any contiguous whitespace (including comments)
    may be hidden from the parser by prefixing it with "\". This is known as
    the "unspace". An unspace can suppress any of several whitespace
    dependencies in Perl. For example, since Perl requires an absence of
    whitespace between a noun and a postfix operator, using unspace lets you
    line up postfix operators:
        %hash\  {$key}
        @array\ [$ix]
        $subref\($arg)
    As a special case to support the use above, a backslash where a postfix
    is expected is considered a degenerate form of unspace. Note that
    whitespace is not allowed before that, hence
        $subref \($arg)
    is a syntax error (two terms in a row). And
        foo \($arg)
    will be parsed as a list operator with a "Capture" argument:
        foo(\($arg))
    However, other forms of unspace may usefully be preceded by whitespace.
    (Unary uses of backslash may therefore never be followed by whitespace
    or they would be taken as an unspace.)
    Other postfix operators may also make use of unspace:
        $number\  ++;
        $number\  --;
        1+3\      i;
        $object\  .say();
        $object\#`{ your ad here }.say
    Another normal use of a you-don't-see-this-space is typically to put a
    dotted postfix on the next line:
        $object\ # comment
        .say
        $object\#`[ comment
        ].say
        $object\
    But unspace is mainly about language extensibility: it lets you continue
    the line in any situation where a newline might confuse the parser,
    regardless of your currently installed parser. (Unless, of course, you
    override the unspace rule itself...)
    Although we say that the unspace hides the whitespace from the parser,
    it does not hide whitespace from the lexer. As a result, unspace is not
    allowed within a token. Additionally, line numbers are still counted if
    the unspace contains one or more newlines. Since Pod chunks count as
    whitespace to the language, they are also swallowed up by unspace.
    Heredoc boundaries are suppressed, however, so you can split excessively
    long lines introducing heredocs like this:
        ok(q:to'CODE', q:to'OUTPUT', \
        "Here is a long description", \ # --more--
        todo(:parrøt<0.42>, :dötnet<1.2>));
            CODE
            OUTPUT
    To the heredoc parser that just looks like:
        ok(q:to'CODE', q:to'OUTPUT', "Here is a long description", todo(:parrøt<0.42>, :dötnet<1.2>));
    Note that this is one of those cases in which it is fine to have
    whitespace before the unspace, since we're only trying to suppress the
    newline transition, not all whitespace as in the case of postfix
    parsing. (Note also that the example above is not meant to spec how the
    test suite works. )
  Comments in Unspaces and vice versa
    An unspace may contain a comment, but a comment may not contain an
    unspace. In particular, end-of-line comments do not treat backslash as
    significant. If you say:
        #`\ (...
    or
        #\ `(...
    it is an end-of-line comment, not an embedded comment. Write:
        \ #`(
             ...
    to mean the other thing.
  Unspace disallowed within regexes
    Within a regex, unspace is disallowed as too ambiguous with customary
    backslashing conventions in surrounding cultures. Hence you must write
    an explicit whitespace match some other way, such as with quotes or with
    a "\x20" or "\c32" escape. On the other hand, while an unspace can start
    with "\#" in normal code, "\#" within a regex is specifically allowed,
    and is not taken as unspace, but matches a literal "U+0023" (NUMBER
    SIGN). (Within a character class, you may also escape whitespace with a
    backslash; the restriction on unspace applies only at the normal
    pattern-matching level.)
  Optional Whitespace and Exclusions
    In general, whitespace is optional in Perl 6 except where it is needed
    to separate constructs that would be misconstrued as a single token or
    other syntactic unit. (In other words, Perl 6 follows the standard
    *longest-token* principle, or in the cases of large constructs, a
    *prefer shifting to reducing* principle. See "Grammatical Categories"
    below for more on how a Perl program is analyzed into tokens.)
    This is an unchanging deep rule, but the surface ramifications of it
    change as various operators and macros are added to or removed from the
    language, which we expect to happen because Perl 6 is designed to be a
    mutable language. In particular, there is a natural conflict between
    postfix operators and infix operators, either of which may occur after a
    term. If a given token may be interpreted as either a postfix operator
    or an infix operator, the infix operator requires space before it.
    Postfix operators may never have intervening space, though they may have
    an intervening dot. If further separation is desired, an unspace or
    embedded comment may be used as described above, as long as no
    whitespace occurs outside the unspace or embedded comment.
    For instance, if you were to add your own "infix:<++>" operator, then it
    must have space before it. The normal autoincrementing "postfix:<++>"
    operator may never have space before it, but may be written in any of
    these forms:
        $x++
        $x\++
        $x.++
        $x\ ++
        $x\ .++
        $x\#`( comment ).++
        $x\#`((( comment ))).++
        $x\
        .++
        $x\         # comment
                    # inside unspace
        ++          # (but without the optional postfix dot)
        $x\#`『      comment
                    more comment
        』.++
        $x\#`[   comment 1
        comment 2
        =begin Podstuff
        whatever (Pod comments ignore current parser state)
        =end Podstuff
        comment 3
        ].++
   Implicit Topical Method Calls
    A consequence of the postfix rule is that (except when delimiting a
    quote or terminating an unspace) a dot with whitespace in front of it is
    always considered a method call on $_ where a term is expected. If a
    term is not expected at this point, it is a syntax error. (Unless, of
    course, there is an infix operator of that name beginning with dot. You
    could, for instance, define a Fortranly "infix:<.EQ.>" if the fit took
    you. But you'll have to be sure to always put whitespace in front of it,
    or it would be interpreted as a postfix method call instead.)
    For example,
        foo .method
    and
        foo
        .method
    will always be interpreted as
        foo $_.method
    but never as
        foo.method
    Use some variant of
        foo\
    if you mean the postfix method call.
    One consequence of all this is that you may no longer write a Num as 42.
    with just a trailing dot. You must instead say either 42 or 42.0. In
    other words, a dot following a number can only be a decimal point if the
    following character is a digit. Otherwise the postfix dot will be taken
    to be the start of some kind of method call syntax. (The .123 form with
    a leading dot is still allowed however when a term is expected, and is
    equivalent to 0.123 rather than "$_.123".)
  Keywords and whitespace
    One other spot where whitespace makes a difference is after various
    keywords, such as control flow or other statement-oriented keywords.
    Such keywords require whitespace after them. (Again, this is in the
    interests of extensibility). So for instance, if you define a symbol
    that happens to be the same as the keyword "if", you can still use it as
    a non-keyword, as long as you don't put whitespace after it:
        my \if = 42; say (if) if if;   # prints 42
    Here only the middle if of the second statement is taken as a keyword
    because it has whitespace after it. The other mentions of "if" do not,
    and would be illegal were it not that the symbol is defined in this
    scope. If you omit the definition, you'd get a message like this:
        Whitespace required after keyword 'if'
        at myfile:1
        ------> say (if⏏) if if;
        Undeclared routine:
            if used at line 1
Built-In Data Types
    Perl 6 has an optional type system that helps you write safer code that
    performs better. The compiler is free to infer what type information it
    can from the types you supply, but it will not complain about missing
    type information unless you ask it to.
    Perl 6 is an OO engine, but you're not generally required to think in OO
    when that's inconvenient. However, some built-in concepts such as
    filehandles are more object-oriented in a user-visible way than in Perl
    5.
  The P6opaque Datatype
    In support of OO encapsulation, there is a new fundamental data
    representation: P6opaque. External access to opaque objects is always
    through method calls, even for attributes.
  Name Equivalence of Types
    Types are officially compared using name equivalence rather than
    structural equivalence. However, we're rather liberal in what we
    consider a name. For example, the name includes the version and
    authority associated with the module defining the type (even if the type
    itself is "anonymous"). Beyond that, when you instantiate a parametric
    type, the arguments are considered part of the "long name" of the
    resulting type, so one "Array of Int" is equivalent to another "Array of
    Int". (Another way to look at it is that the type instantiation
    "factory" is memoized.) Typename aliases are considered equivalent to
    the original type. In particular, the "Array of Int" syntax is just
    sugar for "Array:of(Int)", which is the canonical form of an
    instantiated generic type.
    This name equivalence of parametric types extends only to parameters
    that can be considered immutable (or that at least can have an immutable
    snapshot taken of them). Two distinct classes are never considered
    equivalent even if they have the same attributes because classes are not
    considered immutable.
  Properties on Objects
    Perl 6 supports the notion of properties on various kinds of objects.
    Properties are like object attributes, except that they're managed by
    the individual object rather than by the object's class.
    According to S12, properties are actually implemented by a kind of mixin
    mechanism, and such mixins are accomplished by the generation of an
    individual anonymous class for the object (unless an identical anonymous
    class already exists and can safely be shared).
   Traits
    Properties applied to objects constructed at compile-time, such as
    variables and classes, are also called traits. Traits cannot be changed
    at run-time. Changes to run-time properties are done via mixin instead,
    so that the compiler can optimize based on declared traits.
  Types as Constraints
    A variable's type is a constraint indicating what sorts of values the
    variable may contain. More precisely, it's a promise that the object or
    objects contained in the variable are capable of responding to the
    methods of the indicated "role". See S12 for more about roles.
        # $x can contain only Int objects
        my Int $x;
  Container Types
    A variable may itself be bound to a container type that specifies how
    the container works, without specifying what kinds of things it
    contains.
        # $x is implemented by the MyScalar class
        my $x is MyScalar;
    Constraints and container types can be used together:
        # $x can contain only Int objects,
        # and is implemented by the MyScalar class
        my Int $x is MyScalar;
    Note that $x is also initialized to the "Int" type object. See below for
    more on this.
  Nil
    There is a special value named "Nil". It means "there is no value here".
    It is a little bit like the empty "()" list, insofar as both represent
    an absence of values, except that "()" is defined and means "there are 0
    arguments here if you're counting that low". The "Nil" value represents
    the absence of a value where there *should* be one, so it does not
    disappear in list context, but relies on something downstream to catch
    it or blow up. "Nil" also indicates a failed match.
    Since method calls are performed directly on any object, "Nil" can
    respond to certain method calls. "Nil.defined" returns "False" (whereas
    "().defined" returns "True"). "Nil.so" also returns "False".
    "Nil.ACCEPTS" always returns "Nil". "Nil.perl" and "Nil.gist" return
    'Nil'. "Nil.Stringy" and "Nil.Str" throw a resumable warning that
    returns a value of '' on resumption. "Nil.Numeric" likewise throws a
    resumable warning that returns 0 on resumption. Any undefined method
    call on "Nil" returns "Nil", so that "Nil" propagates down method call
    chains. Likewise any subscripting operation on "Nil" returns "Nil".
    Any attempt to change the "Nil" value should cause an exception to be
    thrown.
    Assigning "Nil" to any scalar container causes the container to throw
    out any contents and restore itself to an uninitialized state (after
    which it will appear to contain an object appropriate to the declared
    default of the container, where "Any" is the default default; the
    element may be simply deleted if that's how the default can be
    represented in the structure). Binding of "Nil" with ":=" simply puts
    Nil in the container. However, binding "Nil" to a parameter ("::="
    semantics) works more like assignment; passing "Nil" to a parameter with
    a default causes that parameter to be set to its default value rather
    than an undefined value, as if the argument had not been supplied.
    Assigning "Nil" to any entire composite container (such as an "Array" or
    "Hash") empties the container, resetting it back to an uninitialized
    state. The container object itself then becomes undefined. (Assignment
    of "()" leaves it defined.)
  Type Objects
    "my Dog $spot" by itself does not automatically call a "Dog"
    constructor. It merely assigns an undefined "Dog" prototype object to
    $spot:
        my Dog $spot;           # $spot is initialized with ::Dog
        my Dog $spot = Dog;     # same thing
        $spot.defined;          # False
        say $spot;              # "Dog()"
    Any type name used as a value is the undefined prototype object of that
    type, or *type object* for short. See S12 for more on that.
    Any type name in rvalue context is parsed as a single type value and
    expects no arguments following it. However, a type object responds to
    the function call interface, so you may use the name of a type with
    parentheses as if it were a function, and any argument supplied to the
    call is coerced to the type indicated by the type object. If there is no
    argument in the parentheses, the type object returns itself:
        my $type = Num;             # type object as a value
        $num = $type($string)       # coerce to Num
    To get a real "Dog" object, call a constructor method such as "new":
        my Dog $spot .= new;
        my Dog $spot = $spot.new;   # .= is rewritten into this
    You can pass in arguments to the constructor as well:
        my Dog $cerberus .= new(heads => 3);
        my Dog $cerberus = $cerberus.new(heads => 3);   # same thing
    Just like "Nil", type objects do not disappear in list context, but rely
    on something downstream to catch it or blow up. This allows type objects
    to be assigned to scalars, but to disappear in non-scalar contexts.
  Coercive type declarations
    The parenthesized form of type coercion may be used in declarations
    where it makes sense to accept a wider set of types but coerce them to a
    narrow type. (This only works for one-way coercion, so you may not
    declare any "rw" parameter with a coercive type.) The type outside the
    parens indicates the desired end result, and subsequent code may depend
    on it being that type. The type inside the parens indicates the
    acceptable set of types that are allowed to be bound or assigned to this
    location via coercion. If the wide type is omitted, "Any" is assumed. In
    any case, the wide type is only indicative of permission to coerce;
    there must still be an available coercion routine from the wide type to
    the narrow type to actually perform the coercion.
        sub foo (Str(Any) $y) {...}
        sub foo (Str()    $y) {...}    # same thing
        my Num(Cool) $x = prompt "Gimme a number";
    Coercions may also be specified on the return type:
        sub bar ($x, $y --> Int()) { return 3.5 }  # returns 3
  Containers of Native Types
    If you say
        my int @array is MyArray;
    you are declaring that the elements of @array are native integers, but
    that the array itself is implemented by the "MyArray" class. Untyped
    arrays and hashes are still perfectly acceptable, but have the same
    performance issues they have in Perl 5.
  Methods on Arrays
    To get the number of elements in an array, use the ".elems" method. You
    can also ask for the total string length of an array's elements, in
    codepoints or graphemes, using these methods, ".codes" or ".chars"
    respectively on the array. The same methods apply to strings as well.
    (Note that ".codes" is not well-defined unless you know which
    canonicalization is in effect. Hence, it allows an optional argument to
    specify the meaning exactly if it cannot be known from context.)
    There is no ".length" method for either arrays or strings, because
    "length" does not specify a unit.
  Built-in Type Conventions
    Built-in object types start with an uppercase letter. This includes
    immutable types (e.g. "Int", "Num", "Complex", "Rat", "Str", "Bit",
    "Regex", "Set", "Block", "Iterator"), as well as mutable (container)
    types, such as "Scalar", "Array", "Hash", "Buf", "Routine", "Module",
    and non-instantiable Roles such as "Callable" and "Integral".
    Non-object (native) types are lowercase: "int", "num", "complex", "rat",
    "buf", "bit". Native types are primarily intended for declaring compact
    array storage, that is, a sequence of storage locations of the specified
    type laid out in memory contiguously without pointer indirection.
    However, Perl will try to make those look like their corresponding
    uppercase types if you treat them that way. (In other words, it does
    autoboxing and autounboxing as necessary. Note, however, that repeated
    autoboxing and unboxing can make your program much slower, compared to a
    program that makes consistent use of either native types or object
    types.)
   The ".WHICH" Method for Value Types
    Some object types can behave as value types. Every object can produce a
    "WHICH" value that uniquely identifies the object for hashing and other
    value-based comparisons. Normal objects use some kind of unique ID as
    their identity, but if a class wishes to behave as a value type, it can
    define a ".WHICH" method that makes different objects look like the same
    object if they happen to have the same contents.
   The "ObjAt" Type
    When we say that a normal object uses its location as its identity, we
    do *not* mean that it returns its address as a number. In the first
    place, not all objects are in the same memory space (see the literature
    on NUMA, for instance), and two objects should not accidentally have the
    same identity merely because they were stored at the same offset in two
    different memory spaces. We also do not want to allow accidental
    identity collisions with values that really are numbers (or strings, or
    any other mundane value type). Nor should we be encouraging people to
    think of object locations that way in any case. So "WHICH" still returns
    a value rather than another object, but that value must be of a special
    "ObjAt" type that prevents accidental confusion with normal value types,
    and at least discourages trivial pointer arithmetic.
    Certainly, it is difficult to give a unique name to every possible
    address space, let alone every possible address within every such a
    space. In the absence of a universal naming scheme, it can only be made
    improbable that two addresses from two different spaces will collide. A
    sufficiently large random number may represent the current address space
    on output of an "ObjAt" to a different address space, or if serialized
    to YAML or XML. (This extra identity component need not be output for
    debugging messages that assume the current address space, since it will
    be the same big number consistently, unless your process really is
    running under a NUMA.)
    Alternately, if an object is being serialized to a form that does not
    preserve object identity, there is no requirement to preserve
    uniqueness, since in this case the object is really being translated to
    a value type representation, and reconstituted on the other end as a
    different unique object.
  Variables Containing Undefined Values
    A variable with a non-native type constraint may contain an *undefined*
    value such as a type object, provided the undefined value meets the type
    constraint.
        my Int $x = Int;  # works
        my Buf $x = Buf8; # works
    Variables with native types do not support undefinedness: it is an error
    to assign an undefined value to them:
        my int $y = Int;    # dies
    Since "num" can support the value "NaN" but not the general concept of
    undefinedness, you can coerce an undefined value like this:
        my num $n = computation() // NaN;
    Variables of non-native types start out containing a type object of the
    appropriate type unless explicitly initialized to a defined value.
    Any container's default may be overridden by the "is default(VALUE)"
    trait. If the container's contents are deleted, the value is notionally
    set to the provided default value; this value may or may not be
    physically represented in memory, depending on the implementation of the
    container. You should officially not care about that (much).
  The "HOW" Method
    Every object supports a "HOW" function/method that returns the metaclass
    instance managing it, regardless of whether the object is defined:
        'x'.HOW.methods('x');   # get available methods for strings
        Str.HOW.methods(Str);   # same thing with the prototype object Str
        HOW(Str).methods(Str);  # same thing as function call
        'x'.methods;        # this is likely an error - not a meta object
        Str.methods;        # same thing
    (For a prototype system (a non-class-based object system), all objects
    are merely managed by the same meta object.)
  Roles
    Perl supports generic types through what are called "roles" which
    represent capabilities or interfaces. These roles are generally not used
    directly as object types. For instance all the numeric types perform the
    "Numeric" role, and all string types perform the "Stringy" role, but
    there's no such thing as a "Numeric" object, since these are generic
    types that must be instantiated with extra arguments to produce normal
    object types. Common roles include:
        Stringy
        Numeric
        Real
        Integral
        Rational
        Callable
        Positional
        Associative
        Buf
        Blob
  "Numeric" Types
    Perl 6 intrinsically supports big integers and rationals through its
    system of type declarations. "Int" automatically supports promotion to
    arbitrary precision, as well as holding "Inf" and "NaN" values. Note
    that "Int" assumes 2's complement arithmetic, so "+^1 == -2" is
    guaranteed. (Native "int" operations need not support this on machines
    that are not natively 2's complement. You must convert to and from "Int"
    to do portable bitops on such ancient hardware.)
    "Num" must support the largest native floating point format that runs at
    full speed. It may be bound to an arbitrary precision type, but by
    default it is the same type as a native "num". See below.
    "Rat" supports extended precision rational arithmetic. Dividing two
    "Integral" objects using "infix:</>" produces a "Rat", which is
    generally usable anywhere a "Num" is usable, but may also be explicitly
    cast to "Num". (Also, if either side is "Num" already, "infix:</>" gives
    you a "Num" instead of a "Rat".)
    "Rat" and "Num" both do the "Real" role.
    Lowercase types like "int" and "num" imply the native machine
    representation for integers and floating-point numbers, respectively,
    and do not promote to arbitrary precision, though larger representations
    are always allowed for temporary values. Unless qualified with a number
    of bits, "int" and "num" types represent the largest native integer and
    floating-point types that run at full speed.
    Because temporary values are biased in favor of correct semantics over
    compact storage, native numeric operators that might overflow must come
    in two variants, one which returns a guaranteed correct boxed value, and
    one of which returns a guaranteed fast native value. By default the
    boxing variant is selected (probably by virtue of hiding the native
    variants), but within a given lexical scope, the "use native" pragma
    will allow use of the dangerous but fast variants instead. Arguments to
    the pragma can be more specific about what types of return values are
    allowed, e.g. "use native 'int';" and such. (The optimizer is also
    allowed to substitute such variants when it can determine that the final
    destination would store natively in any case, or that the variant could
    not possibly malfunction given the arguments.) [Conjecture: we could
    allow an 'N' metaoperator to select the native variant on a case by case
    basis.]
    Numeric values in untyped variables use "Int" and "Num" semantics rather
    than "int" and "num". Literals, on the other hand, may default to native
    storage formats if they reasonably can. We rely on the semantics of
    boxing temporary values by default (see above) to maintain correct
    semantics; the optimizer is of course allowed to box or unbox a literal
    at compile time (or cache a boxed/unboxed version of the value) whenever
    it seems appropriate. In any case, native literals should be preferred
    under "use native" semantics.
    For pragmatic reasons, "Rat" values are guaranteed to be exact only up
    to a certain point. By default, this is the precision that would be
    represented by the "Rat64" type, which is an alias for
    "Rational[Int,Uint64]", which has a numerator of "Int" but is limited to
    a denominator of "Uint64" (which may or may not be implemented as a
    native "uint64", since small representations may be desirable for small
    denominators). A "Rat64" that would require more than 64 bits of storage
    in the denominator is automatically converted either to a "Num" or to a
    lesser-precision "Rat", at the discretion of the implementation. (Native
    types such as "rat64" limit the size of both numerator and denominator,
    though not to the same size. The numerator should in general be twice
    the size of the denominator to support user expectations. For instance,
    a "rat8" actually supports "Rational[int16,uint8]", allowing numbers
    like 100.01 to be represented, and a "rat64", defined as
    "Rational[int128,uint64]", can hold the number of seconds since the Big
    Bang with attosecond precision. Though perhaps not with attosecond
    accuracy...)
    The limitation on "Rat" values is intended to be enforced only on
    user-visible types. Intermediate values used in the internal
    calculations of "Rat" operators may exceed this precision, or represent
    negative denominators. That is, the temporaries used in calculating the
    new numerator and denominator are (at least in the abstract) of "Int"
    type. After a new numerator and denominator are determined, any sign is
    forced to be represented only by the numerator. Then if the denominator
    exceeds the storage size of the unsigned integer used, the fraction is
    reduced via GCD. If the resulting denominator is still larger than the
    storage size, then and *only* then may the precision be reduced to fit
    into a "Rat" or "Num".
    "Rat" addition and subtraction should attempt to preserve the
    denominator of the more precise argument if that denominator is an
    integral multiple of the less precise denominator. That is, in practical
    terms, adding a column of dollars and cents should generally end up with
    a result that has a denominator of 100, even if values like 42 and 3.5
    were added in. With other operators, this guarantee cannot be made; in
    such cases, the user should probably be explicitly rounding to a
    particular denominator anyway.
    For applications that really need arbitrary precision denominators as
    well as numerators at the cost of performance, "FatRat" may be used,
    which is defined as "Rational[Int,Int]", that is, as arbitrary precision
    in both parts. There is no literal form for a "FatRat", so it must be
    constructed using "FatRat.new($nu,$de)". In general, only math operators
    with at least one "FatRat" argument will return another "FatRat", to
    prevent accidental promotion of reasonably fast "Rat" values into
    arbitrarily slow "FatRat" values.
    Although most rational implementations normalize or "reduce" fractions
    to their smallest representation immediately through a GCD algorithm,
    Perl allows a rational datatype to do so lazily at need, such as
    whenever the denominator would run out of precision, but avoid the
    overhead otherwise. Hence, if you are adding a bunch of "Rat"s that
    represent, say, dollars and cents, the denominator may stay 100 the
    entire way through. The ".nu" and ".de" methods will return these
    unreduced values. You can use "$rat.=norm" to normalize the fraction.
    (This also forces the sign on the denominator to be positive.) The
    ".perl" method will produce a decimal number if the denominator is a
    power of 10, or normalizable to a power of 10 (that is, having factors
    of only 2 and 5 (and -1)). Otherwise it will normalize and return a
    rational literal of the form "<-47/3>". Stringifying a rational via
    ".gist" or ".Str" returns an exact decimal number if possible, and
    otherwise rounds off the repeated decimal based on the size of the
    denominator. For full details see the documentation of "Rat.gist" in
    S32.
    "Num.Str" and "Num.gist" both produce valid "Num" literals, so they must
    include the "e" for the exponential.
        say 1/5;    # 0.2 exactly
        say 1/3;    # 0.333333
        say <2/6>.perl
                    # <1/3>
        say 3.14159_26535_89793
                    # 3.141592653589793 including last digit
        say 111111111111111111111111111111111111111111111.123
                    # 111111111111111111111111111111111111111111111.123
        say 555555555555555555555555555555555555555555555/5
                    # 111111111111111111111111111111111111111111111
        say <555555555555555555555555555555555555555555555/5>.perl
                    # 111111111111111111111111111111111111111111111.0
        say 2e2;    # 200e0 or 2e2 or 200.0e0 or 2.0e2
  Infinity and "NaN"
    Perl 6 by default makes standard IEEE floating point concepts visible,
    such as "Inf" (infinity) and "NaN" (not a number). Within a lexical
    scope, pragmas may specify the nature of temporary values, and how
    floating point is to behave under various circumstances. All IEEE modes
    must be lexically available via pragma except in cases where that would
    entail heroic efforts to bypass a braindead platform.
    The default floating-point modes do not throw exceptions but rather
    propagate "Inf" and "NaN". The boxed object types may carry more
    detailed information on where overflow or underflow occurred. Numerics
    in Perl are not designed to give the identical answer everywhere. They
    are designed to give the typical programmer the tools to achieve a good
    enough answer most of the time. (Really good programmers may
    occasionally do even better.) Mostly this just involves using enough
    bits that the stupidities of the algorithm don't matter much.
  Strings, the "Str" Type
    A "Str" type is a Unicode string object. It boxes a native "str" (the
    difference being in representation; a "Str" is a P6opaque and as such
    you may mix in to it, but this is not possible with a "str"). A "Str"
    functions at grapheme level. This means that `.chars` should give the
    number of graphemes, `.substr` should never cut a combining character in
    two, and so forth. Both "str" and "Str" are immutable. Their exact
    representation in memory is implementation defined, so implementations
    are free to use ropes or other data structures internally in order to
    make concatenation, substring, and so forth cheaper.
    Implementation note: since Perl 6 mandates that "Str" must view
    graphemes as the fundamental unit rather than codepoints, this has some
    implications regarding efficient implementation. It is suggested that
    all graphemes be translated on input to unique grapheme numbers and
    represented as integers within some kind of uniform array for fast
    substr access. For those graphemes that have a precomposed form, use of
    that codepoint is suggested. (Note that this means Latin-1 can still be
    represented internally with 8-bit integers.)
    For graphemes that have no precomposed form, a temporary private id
    should be assigned that uniquely identifies the grapheme. If such ids
    are assigned consistently throughout the process, comparison of two
    graphemes is no more difficult than the comparison of two integers, and
    comparison of base characters no more difficult than a direct lookup
    into the id-to-NFD table.
    Obviously, any temporary grapheme ids must be translated back to some
    universal form (such as NFD) on output, and normal precomposed graphemes
    may turn into either NFC or NFD forms depending on the desired output.
    Maintaining a particular grapheme/id mapping over the life of the
    process may have some GC implications for long-running processes, but
    most processes will likely see a limited number of non-precomposed
    graphemes.
    Code wishing to work at a codepoint level instead of a grapheme level
    should use the "Uni" type, which has subclasses representing the various
    Unicode normalization forms (namely, "NFC", "NFD", "NFIC", and "NFKD").
    Note that "ord" is defined as a codepoint level operation. Even though
    the "Str" may contain synthetics internally, these should never be
    exposed by "ord"; instead, the behaviour should be as if the "Str" had
    been converted to an "NFC" and then the first element accessed
    (obviously, implementations are free to do something far more
    efficient).
  The "Buf" Type
    A "Buf" is a stringish view of an array of integers, and has no Unicode
    or character properties without explicit conversion to some kind of
    "Str". (The "buf8", "buf16", "buf32", and "buf64" types are the native
    counterparts; native buf types are required to occupy contiguous memory
    for the entire buffer.) Typically a "Buf" is an array of bytes serving
    as a buffer. Bitwise operations on a "Buf" treat the entire buffer as a
    single large integer. Bitwise operations on a "Str" generally fail
    unless the "Str" in question can provide an abstract "Buf" interface
    somehow. Coercion to "Buf" should generally invalidate the "Str"
    interface. As a generic role "Buf" may be instantiated as any of "buf8",
    "buf16", or "buf32" (or as any type that provides the appropriate "Buf"
    interface), but when used to create a buffer "Buf" is punned to a class
    implementing "buf8" (actually "Buf[uint8]").
    Unlike "Str" types, "Buf" types prefer to deal with integer string
    positions, and map these directly to the underlying compact array as
    indices. That is, these are not necessarily byte positions--an integer
    position just counts over the number of underlying positions, where one
    position means one cell of the underlying integer type. Builtin string
    operations on "Buf" types return integers and expect integers when
    dealing with positions. As a limiting case, "buf8" is just an old-school
    byte string, and the positions are byte positions. Note, though, that if
    you remap a section of "buf32" memory to be "buf8", you'll have to
    multiply all your positions by 4.
   Native "buf" Types
    These native types are defined based on the "Buf" role, parameterized by
    the native integer type it is composed of:
        Name        Is really
        ====        =========
        buf1        Buf[bit]
        buf8        Buf[uint8]
        buf16       Buf[uint16]
        buf32       Buf[uint32]
        buf64       Buf[uint64]
    There are no signed buf types provided as built-ins, but you may say
        Buf[int8]
        Buf[int16]
        Buf[int32]
        Buf[int64]
    to get buffers of signed integers. It is also possible to define a "Buf"
    based on non-integers or on non-native types:
        Buf[complex64]
        Buf[FatRat]
        Buf[Int]
    However, no guarantee of memory contiguity can be made for non-native
    types.
  The "Whatever" Object
    The "*" character as a standalone term captures the notion of
    "Whatever", the meaning of which can be decided lazily by whatever it is
    an argument to. Alternately, for those unary and binary operators that
    don't care to handle "*" themselves, it is automatically primed at
    compile time into a closure that takes one or two arguments. (See
    below.)
    Generally, when an operator handles "*" itself, it can often be thought
    of as a "glob" that gives you everything it can in that argument
    position. For instance, here are some operators that choose to handle
    "*" and give it special meaning:
        if $x ~~ 1..* {...}                 # if 1 <= $x <= +Inf
        my ($a,$b,$c) = "foo" xx *;         # an arbitrary long list of "foo"
        if /foo/ ff * {...}                 # a latching flipflop
        @slice = @x[*;0;*];                 # all indexes for 1st and 3rd dimensions
        @slice = %x{*;'foo'};               # all keys in domain of 1st dimension
        @array[*]                           # list of all values, unlike @array[]
        (*, *, $x) = (1, 2, 3);             # skip first two elements
                                            # (same as lvalue "undef" in Perl 5)
    "Whatever" is an undefined prototype object derived from "Any". As a
    type it is abstract, and may not be instantiated as a defined object.
    When used for a particular MMD dispatch, and nothing in the MMD system
    claims it, it dispatches to as an "Any" with an undefined value, and (we
    hope) blows up constructively.
    Since the "Whatever" object is effectively immutable, the optimizer is
    free to recognize "*" and optimize in the context of what operator it is
    being passed to. An operator can declare that it wants to handle "*"
    either by declaring one or more of its arguments for at least one of its
    candidates with an argument of type "Whatever", or by marking the proto
    sub with the trait, "is like-Whatever-and-stuff". [Conjecture: actually,
    this is negotiable--we might shorten it to "is like(Whatever)" or some
    such. ":-)"]
   Autopriming of Unary and Binary Operators with Whatever
    Perl 6 has several ways of performing partial function application.
    Since this is an unwieldy term, we've settled on calling it *priming*.
    (Many folks call this "currying", but that's not really a correct
    technical usage of the term.) Most generally, priming is performed on a
    "Callable" object by calling its ".assuming" method, described
    elsewhere. This section is about a convenient syntactic sugar for that.
    For any unary or binary operator (specifically, any prefix, postfix, and
    infix operator), if the operator has not specifically requested (via
    signature matching) to handle "*" itself, the compiler is required to
    translate directly to an appropriately primed closure at compile time.
    We call this *autopriming*. Most of the built-in numeric operators fall
    into this category. So:
        * - 1
        '.' x *
        * + *
    are autoprimed into closures of one or two arguments:
        { $^x - 1 }
        { '.' x $^y }
        { $^x + $^y }
    This rewrite happens after variables are looked up in their lexical
    scope, and after declarator install any variables into the lexical
    scope, with the result that
        * + (state $s = 0)
    is effectively primed into:
        -> $x { $x + (state $OUTER::s = 0) }
    rather than:
        -> $x { $x + (state $s = 0) }
    In other words, "*" priming does not create a useful lexical scope.
    (Though it does have a dynamic scope when it runs.) This prevents the
    semantics from changing drastically if the operator in question suddenly
    decides to handle "Whatever" itself.
    As a postfix operator, a method call is one of those operators that is
    automatically primed. Something like:
        *.meth(1,2,3)
    is rewritten as:
        { $^x.meth(1,2,3) }
    In addition to priming a method call without an invocant, such primed
    methods are handy anywhere a smartmatcher is expected:
        @primes = grep *.is-prime, 2..*;
        subset Duck where *.^can('quack');
        when !*.defined {...}
    Metaoperators are treated as normal operators; the autopriming does not
    automatically distribute to the inner operator. For example,
        @array X* *
    does not make a list of closures, but is equivalent to
        -> $arg { @array X* $arg }
    Postcircumfixes (with or without the dot) are also autoprimed, so we
    have
        *[$x]       -> @a { @a[$x] }
        *{$x}       -> %h { %h{$x} }
        *<foo>      -> %h { %h<foo> }
        *($x)       -> &c { &c($x) }
   The "WhateverCode" Types
    These returned closures are of type WhateverCode:($) or
    "WhateverCode:($,$)" rather than type "Whatever", so constructs that do
    want to handle "*" or its derivative closures can distinguish them by
    type:
        @array[*]    # subscript is type Whatever, returns all elements
        @array[*-1]  # subscript is type WhateverCode:($), returns last element
        0, 1, *+1 ... *  # counting
        0, 1, *+* ... *  # fibonacci
    For any prefix, infix, postfix, or postcircumfix operator that would be
    primed by a "Whatever", a "WhateverCode" also autoprimes it, such that
    any noun phrase based on "*" as a head noun autoprimes transitively
    outward as far as it makes sense, including outward through
    metaoperators. Hence:
        * + 2 + 3   # { $^x + 2 + 3 }
        * + 2 + *   # { $^x + 2 + $^y }
        * + * + *   # { $^x + $^y + $^z }
        (-*.abs)i   # { (-$^x.abs)i }
        @a «+» *    # { @a «+» $^x }
    Note in particular that parentheses will autoprime on a "WhateverCode",
        *[0](1,2,3,4,5)
    means
        -> @a { @a[0](1,2,3,4,5) }
    rather than
        (-> @a { @a.[0] })(1,2,3,4,5)
    If you want the latter semantics for some reason, use a temporary:
        my $c = *[0]; $c(1,2,3,4,5);
    or just put the autoprime in parens:
        (*[0])(1,2,3,4,5)
    Note that only "*" autoprimes, because it's an instantiated object. A
    "Whatever" type object never autoprimes.
   Operators with idiosyncratic Whatever
    The above is only for operators that are not "Whatever"-aware. There is
    no requirement that a "Whatever"-aware operator return a "WhateverCode"
    when "Whatever" is used as an argument; that's just the *typical*
    behavior for functions that have no intrinsic "globbish" meaning for
    "*". If you want to prime one of these globbish operators, you'll need
    to write an explicit closure or do an explicit priming on the operator
    with ".assuming()". Operators in this class, such as "infix:<..>" and
    "infix:<xx>", typically *do* autoprime arguments of type "WhateverCode"
    even though they do not autoprime "Whatever", so we have:
        "foo" xx *          # infinite supply of "foo"
        "foo" xx *-1        # { "foo" xx $^a - 1 }
        0 .. *              # half the real number line
        0 .. * - 1          # { 0 .. $^a - 1 }
        * - 3 .. * - 1      # { $^a - 3 .. $^b - 1 }
    (If the last is used as a subscript, the subscripter notices there are
    two arguments and passes that dimension's size twice.)
    The smartmatch operator will autoprime "*" but not a "WhateverCode".
        * ~~ Int            # same as { $_ ~~ Int }
        $x ~~ *             # same as { $x ~~ $_ }
        $x ~~ * == 42       # same as $x ~~ { $_ == 42 }
        * == 42 ~~ Any      # same as { $_ == 42 } ~~ Any
   Non-closure-returning Operators with "*"
    Operators that are known to return non-closure values with "*" include:
        0 .. *      # means 0 .. Inf
        0 ... *     # means 0 ... Inf
        'a' xx *    # means 'a' xx Inf
        1,*         # means 1,*  :)
        $a = *      # just assigns Whatever
        $a = * + 1  # just assigns WhateverCode
    The sequence operators "&infix:<...>" and "&infix:<...^>" do not
    autoprime "WhateverCode", because we want to allow "WhateverCode"
    closures as the stopper:
        0 ...^ *>5  # means 0, 1, 2, 3, 4, 5
    [Conjecture: it is possible that, for most of the above operators that
    take "*" to mean "Inf", we could still actually return a closure that
    defaults that particular argument to "Inf". However, this would work
    only if we provide a "value list context" that forbids closures, in the
    sense that it always calls any closure it finds in its list and replaces
    the closure in the list with its return value or values, and then
    rescans from that point (kinda like a text macro does), in case the
    closure returned a list containing a closure. So for example, the
    closure returned by "0..*" would interpolate a "Range" object into the
    list when called. Alternately, it could return the 0, followed by
    another closure that does "1..*". Even the "..." operator could likely
    be redefined in terms of a closure that regenerates itself, as long as
    we figure out some way of remembering the last N values each time.]
    In any case, array indexes must behave as such a 'value list context',
    since you can't directly index an array with anything other than a
    number. The final element of an array is subscripted as @a[*-1], which
    means that when the subscripting operation discovers a Code:($) object
    for a subscript, it calls it and supplies an argument indicating the
    number of elements in (that dimension of) the array. See S09.
   The "HyperWhatever" Type
    A variant of "*" is the "**" term, which is of type "HyperWhatever". It
    is generally understood to be a multidimension form of "*" when that
    makes sense. When modified by an operator that would turn "*" into a
    function of one argument, WhateverCode:($), "**" instead turns into a
    function with one slurpy argument, "Code(*@)", such that multiple
    arguments are distributed to some number of internal whatevers. That is:
        * - 1    means                -> $x { $x - 1 }
        ** - 1   means   -> *@x { map -> $x { $x - 1 }, @x }
    Therefore @array[^**] represents @array[{ map { ^* }, @_ }], that is to
    say, every element of the array, no matter how many dimensions.
    (However, @array[**] means the same thing because (as with "..." above),
    the subscript operator will interpret bare "**" as meaning all the
    subscripts, not the list of dimension sizes. The meaning of "Whatever"
    is always controlled by the first context it is bound into.)
    Other uses for "*" and "**" will doubtless suggest themselves over time.
    These can be given meaning via the MMD system, if not the compiler. In
    general a "Whatever" should be interpreted as maximizing the degrees of
    freedom in a dwimmy way, not as a nihilistic "don't care anymore--just
    shoot me".
  Native types
    Values with these types autobox to their uppercase counterparts when you
    treat them as objects:
        bit         single native bit
        int         native signed integer
        uint        native unsigned integer (autoboxes to Int)
        buf         native buffer (finite seq of native ints or uints, no Unicode)
        rat         native rational
        num         native floating point
        complex     native complex number
        bool        native boolean
    Since native types cannot represent Perl's concept of undefined values,
    in the absence of explicit initialization, native floating-point types
    default to "NaN", while integer types (including "bit") default to 0.
    The complex type defaults to "NaN + NaN\i". A buf type of known size
    defaults to a sequence of 0 values.
    You can set a different default on any container type by use of a trait
    such as "is default(42)". Deleting or undefining such a container sets
    the contents back to the default value (or optionally removes it in
    cases where the default value can be autovivified on demand).
    If you wish for a native declaration to attempt no initialization, but
    leave whatever garbage was in memory, you may use the "is default(*)"
    trait. There are several use cases for this, if you know you're going to
    initialize the memory otherwise, or you're doing some form of memory
    mapping.
    If a buf type is initialized with a Unicode string value, the string is
    decomposed into Unicode codepoints, and each codepoint shoved into an
    integer element. If the size of the buf type is not specified, it takes
    its length from the initializing string. If the size is specified, the
    initializing string is truncated or 0-padded as necessary. If a
    codepoint doesn't fit into a buf's integer type, a parse error is issued
    if this can be detected at compile time; otherwise a warning is issued
    at run time and the overflowed buffer element is filled with an
    appropriate replacement character, either "U+FFFD" (REPLACEMENT
    CHARACTER) if the element's integer type is at least 16 bits, or
    "U+007f" (DELETE) if the larger value would not fit. If any other
    conversion is desired, it must be specified explicitly. In particular,
    no conversion to UTF-8 or UTF-16 is attempted; that must be specified
    explicitly. (As it happens, conversion to a buf type based on 32-bit
    integers produces valid UTF-32 in the native endianness.)
  The "Mu" type
    Among other things, "Mu" is named after the eastern concept of "Mu" or 無
    (see <http://en.wikipedia.org/wiki/MU>, especially the "Mu (negative)"
    entry), so in Perl 6 it stands in for Perl 5's concept of "undef" when
    that is used as a noun. However, "Mu" is also the "nothing" from which
    everything else is derived via the undefined type objects, so it stands
    in for the concept of "Object" as used in languages like Java. Or think
    of it as a "micro" or µ-object that is the basis for all other objects,
    something atomic like a Muon. Or if acronyms make you happy, there are a
    variety to pick from:
        Most Universal
        More Undefined
        Modern Undef
        Master Union
        Meta Ur
        Mega Up
    Or just think of it as a sound a cow makes, which simultaneously means
    everything and nothing.
  Undefined types
    Perl 6 does not have a single value representing undefinedness. Instead,
    objects of various types can carry type information while nevertheless
    remaining undefined themselves. Whether an object is defined is
    determined by whether ".defined" returns true or not. These typed
    objects typically represent uninitialized values. Failure objects are
    also officially undefined despite carrying exception information; these
    may be created using the "fail" function, or by direct construction of a
    "Failure" object of some sort. (See S04 for how failures are handled.)
        Mu          Most Undefined
        Failure     Failure (lazy exceptions, thrown if not handled properly)
    Whenever you declare any kind of type, class, module, or package, you're
    automatically declaring an undefined prototype value with the same name,
    known as the *type object*. The name itself returns that type object:
        Mu          Perl 6 object (default block parameter type, Any, Junction, or Each)
        Any         Perl 6 object (default routine parameter type, excludes Junction, Nil, Failure)
        Cool        Perl 6 Convenient OO Loopbacks
        Whatever    Wildcard (like Any, but subject to do-what-I-mean via MMD)
        Int         Any Int object
        Widget      Any Widget object
    All user-defined classes derive from the "Any" class by default.
    Type objects sometimes stringify to their name in parens, to indicate
    undefinedness. Note that type objects are not classes, but may be used
    to name classes when the type's associated meta-object allows it:
        Widget.new()        # create a new Widget
    The "Any" type encompasses all normal value and object types. It is the
    unit type, but includes units that are containers of multiple values. It
    is not the most general type, however. "Any" derives from "Mu", which is
    the top type in Perl 6, and encompasses certain conceptual types that
    fall outside the realm of ordinary "Any" values. These conceptual types
    include:
        Junction    unordered superposition of data with and/or/one/none
        Each        ordered superposition (conjectural)
        Failure     a lazy exception
    Conceptual types rely on the failure to match an "Any" type in order to
    trigger various extraordinary behaviors. The "Junction" and "Each" types
    trigger an inside-out linguistic distribution of various list behaviors
    from inside a scalar expression that pretends a bunch of values are
    really a single value. (These are modeled on similar linguistic
    behaviors in English.) The distributional behavior triggered for these
    types is known as *autothreading*.
    The "Failure" type is considered conceptual so that dynamic context can
    determine the treatment of failures that in other languages would always
    throw exceptions. This gives Perl 6 programs the flexibility to handle
    exceptions either in-band or out-of-band. It is particularly important
    to be able to handle exceptions in-band when you are trying to perform
    parallel operations, so that the failure of one computation does not
    result in fratricide of all its fellow computations. (You can think of
    this as analogous to the way "NaN" propagates through floating-point
    calculations.)
    Single dispatch of a "Failure" invocant to any method not in "Failure"
    returns the same "Failure", so that cascaded method calls can be checked
    with a single check:
        $object.fee.fie.[$foe].{$foo}.sic // die "Oops: $!";
    Failures may only be passed into functions via parameters that allow
    "Mu" or "Failure", and a failure may only be returned from a function
    whose return type permits it.
    After the failure is returned, any subsequent attempt to use the failure
    in an "Any" context will be subject to further failure analysis, and
    will likely throw an exception immediately. Likewise, discarding the
    failure in sink context produces an immediate exception.
    Note that a "Failure" object is undefined, but may contain one or more
    defined "Exception" objects, which are considered normal objects that
    just happen to be used in exception throwing and handling.
  Immutable types
    Objects with these types behave like values, i.e. "$x === $y" is true if
    and only if their types and contents are identical (that is, if
    "$x.WHICH" eqv "$y.WHICH").
        Str         Perl string (finite sequence of Unicode characters)
        Bit         Perl single bit (allows traits, aliasing, undefinedness, etc.)
        Int         Perl integer (allows Inf/NaN, arbitrary precision, etc.)
        Num         Perl number (approximate Real, generally via floating point)
        Rat         Perl rational (exact Real, limited denominator)
        FatRat      Perl rational (unlimited precision in both parts)
        Complex     Perl complex number
        Bool        Perl boolean
        Exception   Perl exception
        Block       Executable objects that have lexical scopes
        Range       A pair of Ordered endpoints
        Set         Unordered collection of values that allows no duplicates
        Bag         Unordered collection of values that allows duplicates
        Mix         Unordered collection of values with weights
        Enum        An immutable Pair
        EnumMap     A mapping of Enums with no duplicate keys
        Signature   Function parameters (left-hand side of a binding)
        LoL         Arguments in a semicolon list
        Capture     Function call arguments (right-hand side of a binding)
        Blob        An undifferentiated mass of ints, an immutable Buf
        Instant     A point on the continuous atomic timeline
        Duration    The difference between two Instants
        HardRoutine A routine that is committed to not changing
    "Set" values may be composed with the "set" listop or method. "Bag"
    values may be composed with the "bag" listop or method. "Mix" values may
    be composed with the "mix" listop or method.
    "Instant"s and "Duration"s are measured in atomic seconds with
    fractions. Notionally they are real numbers which may be implemented in
    any "Real" type of sufficient precision, preferably a "Rat" or "FatRat".
    (Implementations that make fixed-point assumptions about the available
    subsecond precision are discouraged; the user interface must act like
    real numbers in any case.) Interfaces that take "Duration" arguments,
    such as sleep(), may also take "Real" arguments, but "Instant" arguments
    must be explicitly created via any of various culturally aware time
    specification APIs. A small number of "Instant" values that represent
    common epoch instant values are also available.
    In numeric context a "Duration" happily returns a "Rat" or "FatRat"
    representing the number of seconds. "Instant" values, on the other hand,
    are largely opaque, numerically speaking, and in particular are epoch
    agnostic. (Any epoch is just a particular "Instant", and all times
    related to that epoch are really "Instant" ± "Duration", which returns a
    new "Instant".) In order to facilitate the writing of culturally aware
    time modules, the "Instant" type provides "Instant" values corresponding
    to various commonly used epochs, such as the 1958 TAI epoch, the POSIX
    epoch, the Mac epoch, and perhaps the year 2000 epoch as UTC thinks of
    it. There's no reason to exclude any useful epoch that is well
    characterized in atomic seconds. All normal times can be calculated from
    those epoch instants using addition and subtraction of "Duration"
    values. Note that the "Duration" values are still just atomic time
    without any cultural deformations; in particular, the "Duration" formed
    of by subtracting "Instant::Epoch::POSIX" from the current instant will
    contain more seconds than the current POSIX "time()" due to POSIX's
    abysmal ignorance of leap seconds. This is not the fault of the
    universe, which is not fooled (neglecting relativistic considerations).
    "Instant"s and "Duration"s are always linear atomic seconds. Systems
    which cannot officially provide a steady time base, such as POSIX
    systems, will simply have to make their best guess as to the correct
    atomic time when asked to interconvert between cultural time and atomic
    time. Alternately, they may use some other less-official time mechanism
    to achieve steady clock behavior. Most Unix systems can count clock
    ticks, even if POSIX time types get confused.
    Although the conceptual type of an "Instant" resembles "FatRat", with
    arbitrarily large size in either numerator or denominator, the internal
    form may of course be optimized internally for "nearby" times, so that,
    if we know the year as an integer, the instant within the year can just
    be a "Rat" representing the offset from the beginning of the year.
    Calculations that fall within the same year can then be done in "Rat"
    rather than "FatRat", or a table of yearly offsets can find the
    difference in integer seconds between two years, since (so far) nobody
    has had the nerve to propose fractional leap seconds. Or whatever.
    "Instant" is opaque, so we can swap implementations in and out without
    user-visible consequences.
    The term "now" returns the current time as an "Instant". As with the
    "rand" and "self" terms, it is not a function, so don't put parens after
    it. It also never looks for arguments, so the next token should be an
    operator or terminator.
        now + 300   # the instant five minutes from now
    Basic math operations are defined for instants and durations such that
    the sum of an instant and a duration is always an instant, while the
    difference of two instants is always a duration. Math on instants may
    only be done with durations (or numbers that will be taken as durations,
    as above); you may not add two instants.
        $instant + $instant      # WRONG
        $instant - $instant      # ok, returns a duration
        $instant + $duration     # ok, returns an instant
    Numeric operations on durations return "Duration" where that makes sense
    (addition, subtraction, modulus). The type returned for other numeric
    operations is unspecified; they may return normal numeric types or they
    may return other dimensional types that attempt to assist in dimensional
    analysis. (The latter approach should likely require explicit
    declaration for now, until we can demonstrate that it does not adversely
    impact the average programmer, and that it plays well with the concept
    of gradual typing.)
    The "Blob" type is like an immutable buffer, and therefore responds both
    to array and (some) stringy operations. Note that, like a "Buf", its
    size is measured in whatever the base unit is, which is not always
    bytes. If you have a "my Blob[bit] $blob", then "$blob.elems" returns
    the number of bits in it. As with buffers, various native types are
    automatically derived from native unsigned int types:
        blob1       Blob[bit], a bit string
        blob2       Blob[uint2], a DNA sequence?
        blob3       Blob[uint[3]], an octal string
        blob4       Blob[uint4], a hex string
        blob8       Blob[uint8], a byte string
        blob16      Blob[uint16]
        blob32      Blob[uint32]
        blob64      Blob[uint64]
    The "utf8" type is derived from "blob8", with the additional constraint
    that it may only contain validly encoded UTF-8. Likewise, "utf16" is
    derived from "blob16", and "utf32" from "blob32".
    Note that since these are type names, parentheses must always be used to
    call them as coercers, since the listop form is not allowed for
    coercions. That is:
        utf8 op $x
    is always parsed as
        (utf8) op $x
    and never as
        utf8(op $x)
    These types do (at least) the following roles:
        Class       Roles
        =====       =====
        Str         Stringy
        Bit         Numeric Boolean Integral
        Int         Numeric Real Integral
        Num         Numeric Real
        Rat         Numeric Real Rational
        FatRat      Numeric Real Rational
        Complex     Numeric
        Bool        Boolean
        Block       Callable
        Range       Iterable
        Set         Setty Iterable
        Bag         Baggy Iterable
        Mix         Mixy Iterable
        Enum        Associative
        EnumMap     Associative Positional Iterable
        Signature
        List        Positional Iterable
        Capture     Positional Associative
        Blob        Stringy Positional
        Instant     Numeric Real
        Duration    Numeric Real
        HardRoutine Routine
    [Conjecture: "Stringy" may best be split into 2 roles where both "Str"
    and "Blob" compose the more general one and just "Str" composes a less
    general one. The more general of those would apply to what is common to
    any dense sequence ("string") that "Str" and "Blob" both are (either of
    characters or bits or integers etc), and the string operators like
    concatenation ("~") and replication ("x", "xx") would be part of the
    more general role. The more specific role would apply to "Str" but not
    "Blob" and includes any specific operators that are specific to
    *characters* and don't apply to bits or integers etc. The other
    alternative is to more clearly distance character strings from bit
    strings, keeping "~"/etc for character strings only and adding an
    analogy for bit strings.]
    The "Iterable" role indicates not that you can iterate the type
    directly, but that you can request the type to return an iterator.
    Iterable types may have multiple iterators (lists) running across them
    simultaneously, but an iterator/list itself has only one thread of
    consumption. Every time you do "get" on an iterator, a value disappears
    from its list.
    Note that "Set" iterators return only the keys, not the boolean values.
    You must explicitly use ".pairs" to get key/value pairs. The "Bag" and
    "Mix" types, on the other hand, default to returning pairs, as a "Hash"
    does.
  Mutable types
    Objects with these types have distinct ".WHICH" values that do not
    change even if the object's contents change. (Routines are considered
    mutable because they can be wrapped in place.)
        Iterator    Perl list
        RangeIter   Iterator over a Range
        Scalar      Perl scalar
        Array       Perl array
        Hash        Perl hash
        SetHash     Setty QuantHash[Bool,False]
        BagHash     Baggy QuantHash[UInt,0]
        MixHash     Mixy  QuantHash[Real,0.0]
        Pair        A single key-to-value association
        Buf         Perl buffer (array of integers with some stringy features)
        IO          Perl filehandle
        Routine     Base class for all wrappable executable objects
        Sub         Perl subroutine
        Method      Perl method
        Submethod   Perl subroutine acting like a method
        Macro       Perl compile-time subroutine
        Regex       Perl pattern
        Match       Perl match, usually produced by applying a pattern
        Stash       A symbol table hash (package, module, class, lexpad, etc)
        SoftRoutine A routine that is committed to staying mutable
    The "QuantHash" role differs from a normal "Associative" hash in how it
    handles default values. If the value of a "QuantHash" element is set to
    the default value for the "QuantHash", the element is deleted. If
    undeclared, the default default for a "QuantHash" is 0 for numeric
    types, "False" for boolean types, and the null string for string and
    buffer types. A "QuantHash" of an object type defaults to the undefined
    prototype for that type. More generally, the default default is whatever
    defined value a "Nil" would convert to for that value type. A
    "QuantHash" of "Scalar" deletes elements that go to either 0 or the null
    string. A "QuantHash" also autodeletes keys for normal undefined values
    (that is, those undefined values that do not contain an unthrown
    exception).
    A "SetHash" is a "QuantHash" of booleans with a default of "False". If
    you use the "Hash" interface and increment an element of a "SetHash" its
    value becomes true (creating the element if it doesn't exist already).
    If you decrement the element it becomes false and is automatically
    deleted. Decrementing a non-existing value results in a "False" value.
    Incrementing an existing value results in "True". When not used as a
    "Hash" (that is, when used as an "Array" or list or "Set" object) a
    "SetHash" behaves as a "Set" of its keys. (Since the only possible value
    of a "SetHash" is the "True" value, it need not be represented in the
    actual implementation with any bits at all.)
    A "BagHash" is a "QuantHash" of "UInt" with a default of 0. If you use
    the "Hash" interface and increment an element of a "BagHash" its value
    is increased by one (creating the element if it doesn't exist already).
    If you decrement the element the value is decreased by one; if the value
    goes to 0 the element is automatically deleted. An attempt to decrement
    a non-existing value returns an undefined value. When not used as a
    "Hash" (that is, when used as an "Array" or list or "Bag" object) a
    "BagHash" behaves as a "Bag" of its pairs.
    A "MixHash" is a "QuantHash" of "Real" with a default of 0.0. If the
    value goes to 0 the element is automatically deleted. When not used as a
    "Hash" (that is, when used as an "Array" or list or "Mix" object) a
    "MixHash" behaves as a "Mix" of its pairs.
    As with "Hash" types, "Pair" and "PairSeq" are mutable in their values
    but not in their keys. (A key can be a reference to a mutable object,
    but cannot change its ".WHICH" identity. In contrast, the value may be
    rebound to a different object, just as a hash element may.)
    The following roles are supported:
        Iterator    List
        Scalar
        Array       Positional Iterable
        Hash        Associative
        SetHash     Setty QuantHash[Bool]
        BagHash     Baggy QuantHash[UInt]
        MixHash     Mixy  QuantHash[Real]
        Pair        Associative
        PairSeq     Associative Positional Iterable
        Buf         Stringy
        IO
        Routine     Callable
        Sub         Callable
        Method      Callable
        Submethod   Callable
        Macro       Callable
        Regex       Callable
        Match       Positional Associative
        Stash       Associative
        SoftRoutine Routine
    Types that do the "List" role are generally hidden from casual view,
    since iteration is typically triggered by context rather than by
    explicit call to the iterator's ".get" method. Filehandles are a notable
    exception.
    See "Wrapping" in S06 for a discussion of soft vs. hard routines.
  Of types
    Explicit types are optional. Perl variables have two associated types:
    their "of type" and their "container type". (More generally, any
    container has a container type, including subroutines and modules.) The
    "of" type is stored as its "of" property, while the container type of
    the container is just the object type of the container itself. The word
    "returns" is allowed as an alias for "of".
    The "of" type specifies what kinds of values may be stored in the
    variable. An "of" type is given as a prefix or with the "of" keyword:
        my Dog $spot;
        my $spot of Dog;
    In either case this sets the "of" property of the container to "Dog".
    You may not mix these notations; if you do, a compiler error will
    result.
    An "of" type on an array or hash specifies the type stored by each
    element:
        my Dog @pound;  # each element of the array stores a Dog
        my Rat %ship;   # the value of each entry stores a Rat
    The key type of a hash may be specified as a shape trait--see S09.
    Containers enforce type safety on setting, whereas subroutines enforce
    type safety on return. The "returns" declarations is an alias for the
    "of" type of a subroutine.
        sub get_pet() of Animal {...}       # of type, obviously
        sub get_pet() returns Animal {...}  # of type
        our Animal sub get_pet() {...}      # of type
    To coerce your return value, use a coercion type:
        sub get_pet() returns Pet(Animal) {...}  # coerce any Animal to Pet
    For a container, however, use of a coercion type as the "of" coerces
    upon setting rather than returning the value.
  Container types
    The container type specifies how the variable itself is implemented. It
    is given as a trait of the variable:
        my $spot is Scalar;             # this is the default
        my $spot is PersistentScalar;
        my $spot is DataBase;
    Defining a container type is the Perl 6 equivalent to tying a variable
    in Perl 5. But Perl 6 variables are tied directly at declaration time,
    and for performance reasons may not be tied with a run-time "tie"
    statement unless the variable is explicitly declared with a container
    type that does the "Tieable" role.
    However, package variables are always considered "Tieable" by default.
    As a consequence, all named packages are also "Tieable" by default.
    Classes and modules may be viewed as differently tied packages. Looking
    at it from the other direction, classes and modules that wish to be
    bound to a global package name must be able to do the "Package" role.
  Hierarchical types
    A non-scalar type may be qualified, in order to specify what type of
    value each of its elements stores:
        my Egg $cup;                       # the value is an Egg
        my Egg @carton;                    # each elem is an Egg
        my Array of Egg @box;              # each elem is an array of Eggs
        my Array of Array of Egg @crate;   # each elem is an array of arrays of Eggs
        my Hash of Array of Recipe %book;  # each value is a hash of arrays of Recipes
    Each successive "of" makes the type on its right a parameter of the type
    on its left. Parametric types are named using square brackets, so:
        my Hash[Array[Recipe]] %book;
    actually means:
        my Hash of Array of Recipe %book;
    which is:
        my Hash:of(Array:of(Recipe)) %book;
    Because the actual variable can be hard to find when complex types are
    specified, there is a postfix form as well:
        my Hash of Array of Recipe %book;           # HoHoAoRecipe
        my %book of Hash of Array of Recipe;        # same thing
    Alternately, the return type may be specified within the signature:
        my sub get_book ($key --> Hash of Array of Recipe) {...}
    You may also specify the type as the "of" trait (with "returns" allowed
    as a synonym):
        my Hash of Array of Recipe sub get_book ($key) {...}
        my sub get_book ($key) of Hash of Array of Recipe {...}
        my sub get_book ($key) returns Hash of Array of Recipe {...}
  Parameter types
    Parameters may be given types, just like any other variable:
        sub max (int @array is rw) {...}
        sub max (@array of int is rw) {...}
  Generic types
    Within a declaration, a class variable (either by itself or following an
    existing type name) declares a new type name and takes its parametric
    value from the actual type of the parameter it is associated with. It
    declares the new type name in the same scope as that of the associated
    declaration.
        sub max (Num ::X @array) {
            push @array, X.new();
    The new type name is introduced immediately, so two such types in the
    same signature must unify compatibly if they have the same name:
        sub compare (Any ::T $x, T $y) {
            return $x eqv $y;
  The Cool class (and package)
    The "Cool" type is derived from "Any", and contains all the methods that
    are "cool" (as in, "I'm cool with an argument of that type.").
    More specifically, these are the methods that are culturally universal,
    insofar as the typical user will expect the name of the method to imply
    conversion to a particular built-in type that understands the method in
    question. For instance, "$x.abs" implies conversion to an appropriate
    numeric type if $x is "cool" but doesn't already support a method of
    that name. Conversely, "$x.substr" implies conversion to a string or
    buffer type.
    The "Cool" module also contains all multisubs of last resort; these are
    automatically searched if normal multiple dispatch does not find a
    viable candidate. Note that the "Cool" package is mutable, and both
    single and multiple dispatch must take into account changes there for
    the purposes of run-time monkey patching. However, since the multiple
    dispatcher uses the "Cool" package only as a failover, compile-time
    analysis of such dispatches is largely unaffected for any arguments with
    an exact or close match. Likewise any single dispatch a method that is
    more specific than the "Cool" class is not affected by the mutability of
    "Cool". User-defined classes don't derive from "Cool" by default, so
    such classes are also unaffected by changes to "Cool".
Names and Variables
  Apostrophe separator
    The $Package'var syntax is gone. Use $Package::var instead. (Note,
    however, that identifiers may now contain an apostrophe or hyphen if
    followed by a character matching "<.alpha>")
  Sigils
    Perl 6 includes a system of sigils to mark the fundamental structural
    type of a variable:
        $   scalar (object)
        @   ordered array
        %   unordered hash (associative array)
        &   code/rule/token/regex
        ::  package/module/class/role/subset/enum/type/grammar
    Within a declaration, the "&" sigil also declares the visibility of the
    subroutine name without the sigil within the scope of the declaration:
        my &func := sub { say "Hi" };
        func;   # calls &func
    Within a signature or other declaration, the "::" pseudo-sigil followed
    by an identifier marks a type variable that also declares the visibility
    of a package/type name without the sigil within the scope of the
    declaration. The first such declaration within a scope is assumed to be
    an unbound type, and takes the actual type of its associated argument.
    With subsequent declarations in the same scope the use of the
    pseudo-sigil is optional, since the bare type name is also declared.
    A declaration nested within must not use the sigil if it wishes to refer
    to the same type, since the inner declaration would rebind the type.
    (Note that the signature of a pointy block counts as part of the inner
    block, not the outer block.)
   Sigils indicate interface
    Sigils indicate overall interface, not the exact type of the bound
    object. Different sigils imply different minimal abilities.
    $x may be bound to any object, including any object that can be bound to
    any other sigil. Such a scalar variable is always treated as a singular
    item in any kind of list context, regardless of whether the object is
    essentially composite or unitary. It will not automatically dereference
    to its contents unless placed explicitly in some kind of dereferencing
    context. In particular, when interpolating into list context, $x never
    expands its object to anything other than the object itself as a single
    item, even if the object is a container object containing multiple
    items.
    @x may be bound to an object of the "Array" class, but it may also be
    bound to any object that does the "Positional" role, such as a "Range",
    "Buf", "List", or "Capture". The "Positional" role implies the ability
    to support "postcircumfix:<[ ]>".
    Likewise, %x may be bound to any object that does the "Associative"
    role, such as "Pair", "Set", "Bag", "Mix", or "Capture". The
    "Associative" role implies the ability to support "postcircumfix:<{ }>".
    &x may be bound to any object that does the "Callable" role, such as any
    "Block" or "Routine". The "Callable" role implies the ability to support
    "postcircumfix:<( )>".
    In any case, the minimal container role implied by the sigil is checked
    at binding time at the latest, and may fail earlier (such as at compile
    time) if a semantic error can be detected sooner. If you wish to bind an
    object that doesn't yet do the appropriate role, you must either stick
    with the generic "$" sigil, or mix in the appropriate role before
    binding to a more specific sigil.
    An object is allowed to support both "Positional" and "Associative". An
    object that does not support "Positional" may not be bound directly to
    @x. However, any construct such as %x that can interpolate the contents
    of such an object into list context can automatically construct a list
    value that may then be bound to an array variable. Subscripting such a
    list does not imply subscripting back into the original object.
   No intervening whitespace
    Unlike in Perl 5, you may no longer put whitespace between a sigil and
    its following name or construct.
  Twigils
    Ordinary sigils indicate normally scoped variables, either lexical or
    package scoped. Oddly scoped variables include a secondary sigil (a
    twigil) that indicates what kind of strange scoping the variable is
    subject to:
        $foo        ordinary scoping
        $.foo       object attribute public accessor
        $^foo       self-declared formal positional parameter
        $:foo       self-declared formal named parameter
        $*foo       dynamically overridable global variable
        $?foo       compiler hint variable
        $=foo       Pod variable
        $<foo>      match variable, short for $/{'foo'}
        $!foo       object attribute private storage
        $~foo       the foo sublanguage seen by the parser at this lexical spot
    Most variables with twigils are implicitly declared or assumed to be
    declared in some other scope, and don't need a "my" or "our". Attribute
    variables are declared with "has", though.
  Scope declarators
    Normal names and variables are declared using a *scope declarator*:
        my          # introduces lexically scoped names
        our         # introduces package-scoped names
        has         # introduces attribute names
        anon        # introduces names that are private to the construct
        state       # introduces lexically scoped but persistent names
        augment     # adds definitions to an existing name
        supersede   # replaces definitions of an existing name
        unit        # like our, but introduces a compilation-unit scoped name
    Names may also be declared in the signature of a function. These are
    equivalent to a "my" declaration inside the block of the function,
    except that such parameters default to readonly.
    The "anon" declarator allows a declaration to provide a name that can be
    used in error messages, but that isn't put into any external symbol
    table:
        my $secret = anon sub marine () {...}
        $secret(42);  # too many arguments to sub marine
    However, the name is introduced into the scope of the declaration
    itself, so it may be used to call itself recursively:
        my $secret = anon sub tract($n) { say $n; tract($n-1) if $n };
        $secret(5); # 5 4 3 2 1 0
  Invariant sigils
    Sigils are now invariant. "$" always means a scalar variable, "@" an
    array variable, and "%" a hash variable, even when subscripting. In item
    context, variables such as @array and %hash simply return themselves as
    "Array" and "Hash" objects. (Item context was formerly known as scalar
    context, but we now reserve the "scalar" notion for talking about
    variables rather than contexts, much as arrays are disassociated from
    list context.)
  List stringification
    In string contexts, lists and list-like objects automatically stringify
    to appropriate (white-space separated) string values. In numeric
    contexts, the number of elements in the container is returned. In
    boolean contexts, a true value is returned if and only if there are any
    elements in the container.
  The ".perl" method
    To get a Perlish representation of any object, use the ".perl" method.
    Like the "Data::Dumper" module in Perl 5, the ".perl" method will put
    quotes around strings, square brackets around list values, curlies
    around hash values, constructors around objects, properly handle
    circular references etc., so that Perl can evaluate the result back to
    the same object. The ".perl" method will return a representation of the
    object on the assumption that, if the code is reparsed at some point, it
    will be used to regenerate the object as a scalar in item context. If
    you wish to interpolate the regenerated object in a list context, it may
    be necessary to use "prefix:<|>" to force interpolation.
    Note that ".perl" has a very specific definition, and it is expected
    that some modules will rely on the ability to roundtrip values with
    "EVAL". As such, overriding ".perl" with a different format (globally
    using "MONKEY-TYPING", or for specific classes unless special care is
    taken to maintain parsability) is unwise. Code which does not depend on
    ".perl"'s definition should use ".gist" instead to allow more control.
  The ".gist" method
    ".gist", by contrast with ".perl", returns a flexible form of an object
    intended for human interpretation. For example, when presented with a
    very long list or array, only the first 100 entries will be printed,
    followed by "..." to indicate there are more entries. If that's not what
    you want, stringify the list instead. This method is only supposed to
    give you the gist of the value, not the whole value.
    Specific user classes are encouraged to override ".gist" to do something
    appropriate, and it is completely acceptable to monkey patch ".gist"
    methods while doing debugging, without risk of breaking any used module.
    ".gist", like any method, will accept and ignore unrecognized named
    arguments; implementations of ".gist" are encouraged to standardize on a
    set of flags.
    [Some conjectural suggestions:
        :oneline        Do not indent or linebreak output
        :width($d)      Wrap output at $d chars
        :charset($obj)  Represent unrecognized characters as escapes
        :ascii          Short for some instantiation of :charset
    Conjecturally, ".gist" on system-defined classes could redispatch to
    &*PRETTYPRINTER or some similar system, allowing for a more disciplined
    way to change pretty formats.
    It may also be desirable to use a richer format for intermediate strings
    than simple "Str", for instance using an object format that can handle
    intelligent line breaking. However, that's probably overkill.]
  The ".fmt" method
    To get a formatted representation of any scalar value, use the
    ".fmt('%03d')" method to do an implicit "sprintf" on the value.
    To format an array value separated by commas, supply a second argument:
    ".fmt('%03d', ', ')". To format a hash value or list of pairs, include
    formats for both key and value in the first string: ".fmt('%s: %s',
    "\n")".
  Subscripts
    Subscripts now consistently dereference the container produced by
    whatever was to their left. Whitespace is not allowed between a variable
    name and its subscript. However, there are two ways to stretch the
    construct out visually. Since a subscript is a kind of postfix operator,
    there is a corresponding dot form of each subscript ("@foo.[1]" and
    "%bar.{'a'}") that makes the dereference a little more explicit.
    Constant string subscripts may be placed in angles, so "%bar.{'a'}" may
    also be written as "%bar<a>" or "%bar.<a>". Additionally, you may insert
    extra whitespace using the unspace.
    Slicing is specified by the nature of the subscript, not by the sigil.
   Subscripts have list context
    The context in which a subscript is evaluated is no longer controlled by
    the sigil either. Subscripts are always evaluated in list context. (More
    specifically, they are evaluated in a variant of list context known as
    *lol* context (List of List), which preserves dimensional information so
    that you can do multi-dimensional slices using semicolons. However, each
    slice dimension evaluates its sublist in normal list context, so
    functions called as part of a subscript don't see a lol context. See S09
    for more on slicing.)
    If you need to force inner context to item (scalar), we now have
    convenient single-character context specifiers such as + for numbers and
    ~ for strings:
        $x        =  g();       # item context for g()
        @x[f()]   =  g();       # list context for f() and g()
        @x[f()]   = +g();       # list context for f(), numeric item context for g()
        @x[+f()]  =  g();       # numeric item context for f(), list context for g()
        @x[f()]   =  @y[g()];   # list context for f() and g()
        @x[f()]   = +@y[g()];   # list context for f() and g()
        @x[+f()]  =  @y[g()];   # numeric item context for f(), list context for g()
        @x[f()]   =  @y[+g()];  # list context for f(), numeric item context for g()
        %x{~f()}  =  %y{g()};   # string item context for f(), list context for g()
        %x{f()}   =  %y{~g()};  # list context for f(), string item context for g()
    Sigils used as functions with parenthesis also force context, so these
    also work:
        @x[$(g())]         # item context for g()
        %x{$(g())}         # item context for g()
    But note that these don't do the same thing:
        @x[$g()]           # call function in $g
        %x{$g()}           # call function in $g
    Array and Hash variables can be evaluated in item context by prefixing
    them with a single dollar sign:
        $@a               # same as  item @a
        $%h               # same as  item %h
  List assignment and binding
    There is a need to distinguish list assignment from list binding. List
    assignment works much like it does in Perl 5, copying the values.
    There's a new ":=" binding operator that lets you bind names to "Array"
    and "Hash" objects without copying, in the same way as subroutine
    arguments are bound to formal parameters. See S06 for more about
    binding.
    Comma-separated values (as well as word-quoting constructs such as "<a b
    c>") form a "List":
        (1,2,3,:mice<blind>)
    The result is a "List" object containing three "Int" objects and a
    "Pair" object, that is, four positional objects. When, however, you say
    something like:
        rhyme(1,2,3,:mice<blind>)
    the syntactic list is translated (at compile time, in this case) into a
    "Capture" object with three positionals and one named argument in
    preparation for binding. More generally, a list is transmuted to a
    capture any time it is bound to a complete signature.
    You may force immediate conversion to a "Capture" object by prefixing
    the list with a backslash:
        $args = \(1,2,3,:mice<blind>)
    Individual arguments in an argument list (or capture composer) are
    parsed as ordinary expressions, and any functions mentioned are called
    immediately, with each function's results placed as an argument within
    the outer argument list. Whether any given argument is flattened will
    depend on its eventual binding, and in general cannot be known at
    composition time.
    We use "argument" here to mean anything that would be taken as a single
    argument if bound to a positional or named parameter:
        rhyme(1,2,3,:mice<blind>)     # rhyme has 4 arguments
        rhyme((1,2),3,:mice<blind>)   # rhyme has 3 arguments
        rhyme((1,2,3),:mice<blind>)   # rhyme has 2 arguments
        rhyme((1,2),(3,:mice<blind>)) # rhyme has 2 arguments
        rhyme((1,2,3,:mice<blind>))   # rhyme has 1 argument
    In these examples, the first argument to the function is a list in all
    but the first case, where it is simply the literal integer 1. An
    argument is either of:
    *   A parenthesized list that groups together a sublist, or
    *   Any other object that can function as a single argument.
    Looking at it the other way, all arguments that don't actually need to
    be wrapped up in a list are considered degenerate lists in their own
    right when it comes to binding. Note that a capture is not considered a
    kind of list, so does not flatten in flat context.
  Lists, parameters, and Captures
    When an argument is bound to a parameter, the behavior depends on
    whether the parameter is "flattening" or "argumentative". Positional
    parameters and slice parameters are argumentative and just return the
    next syntactic argument without flattening. (A slice differs from an
    ordinary positional parameter in being "slurpy", that is, it is intended
    to fetch multiple values from the variadic region of the surrounding
    capture. Slurpy contexts come in flattening ("*" parameters), slicing
    ("**" parameters), and one-arg ("+" parameters) forms.)
    The fact that a parameter is being bound implies that there is an outer
    capture being bound to a signature. The capture's iterator provides a
    ".get" and a ".getarg" method to tell the iterator what context to bind
    in. For positional/slice parameters, the ".getarg" method returns the
    entire next argument from the iterator. It returns other objects
    unchanged. In contrast, flat parameters call ".get" on the capture's
    iterator, which flattens any sublists before pulling out the next item.
    In either case, no bare list object is seen as a normal bound argument.
    (There is a way to bind the underlying list using backslash, however.
    This is how internal routines can deal with lists as real objects.)
    In contrast to parameter binding, if a "List" is bound to an entire
    signature (typically as part of a function or method call), it will be
    transformed first into a capture object, which is much like a list but
    has its arguments divvied up into positional and named subsets for
    faster binding. (Usually this transformation happens at compile time.)
    If the first positional is followed by a colon instead of a comma, it is
    marked as the invocant in case it finds itself in a context that cares.
    It's illegal to use the colon in place of the comma anywhere except
    after the first argument.
    Explicit binding to an individual variable is considered a form of
    signature binding, which is to say a declarator puts implicit signature
    parens around the unparenthesized form:
        my (*@x) := foo(); # signature binding
        my *@x := foo();   # same thing
    The parens are, of course, required if there is more than one parameter.
    "Capture" objects are immutable in the abstract, but evaluate their
    arguments lazily. Before everything inside a "Capture" is fully
    evaluated (which happens at compile time when all the arguments are
    constants), the eventual value may well be unknown. All we know is that
    we have the promise to make the bits of it immutable as they become
    known.
    "Capture" objects may contain multiple unresolved iterators such as
    feeds or lazy lists. How these are resolved depends on what they are
    eventually bound to. Some bindings are sensitive to multiple dimensions
    while others are not. Binding to a list of lists is often known as
    "slicing", because it's commonly used to index "slices" of a potentially
    multi-dimensional array.
    You may retrieve parts from a "Capture" object with a prefix sigil
    operator:
        $args = \3;     # same as "$args = \(3)"
        @$args;         # same as "Array($args)"
        %$args;         # same as "Hash($args)"
    When cast into an array, you can access all the positional arguments;
    into a hash, all named arguments.
    All prefix sigil operators accept one positional argument, evaluated in
    item context as a rvalue. They can interpolate in strings if called with
    parentheses. The special syntax form "$()" translates into "$( $/.made
    // Str($/) )" to operate on the current match object; similarly "@()"
    and "%()" can extract positional and named submatches.
    "Capture" objects fill the ecological niche of references in Perl 6. You
    can think of them as "fat" references, that is, references that can
    capture not only the current identity of a single object, but also the
    relative identities of several related objects. Conversely, you can
    think of Perl 5 references as a degenerate form of "Capture" when you
    want to refer only to a single item.
    The "sink" statement prefix will eagerly evaluate any block or
    statement, throw away the results, and instead return the empty "List"
    value, "()". This can be useful to peg some behavior to an empty list
    while still returning an empty list:
        # Check that incoming argument list isn't null
        @inclist = map { $_ + 1 }, @list || sink warn 'Nil input!';
        @inclist = do for @list || sink { warn 'Nil input!'; $warnings++; } {
            $_ + 1;
        # Check that outgoing result list isn't null
        @inclist = do map { $_ + 1 }, @list or sink warn 'Nil result!';
        @inclist = do for @list {
        } or sink { warn 'Nil result'; $warnings++; }
    Given "sink", there's no need for an "else" clause on Perl 6's loops,
    and the "sink" construct works in any list, not just "for" loops.
  CaptureCursors
    A "CaptureCursor" object is a view into another capture with an
    associated start position. Such a cursor is essentially a
    pattern-matching state. Capture cursors are used for operations like
    "grep" and "map" and "for" loops that need to apply a short signature
    multiple times to a longer list of values supplied by the base capture.
    When we say "capture" we sometimes mean either "Capture" or
    "CaptureCursor". "CaptureCursors" are also immutable. When pattern
    matching a signature against a cursor, you get a new cursor back which
    tells you the new position in the base capture.
  Signature objects
    A signature object ("Signature") may be created with colon-prefixed
    parens:
        my ::MySig ::= :(Int, Num, Complex, Status)
    Expressions inside the signature are parsed as parameter declarations
    rather than ordinary expressions. See S06 for more details on the syntax
    for parameters.
    Declarators generally make the colon optional:
        my ($a,$b,$c);      # parsed as signature
    Signature objects bound to type variables (as in the example above) may
    be used within other signatures to apply additional type constraints.
    When applied to a capture argument, the signature allows you to take the
    types of the capture's arguments from "MySig", but declare the (untyped)
    variable names yourself via an additional signature in parentheses:
        sub foo (Num  $num, MySig $a ($i,$j,$k,$mousestatus)) {...}
        foo($mynum, \(1, 2.7182818, 1.0i, statmouse());
  Ampersand and invocation
    Unlike in Perl 5, the notation &foo merely stands for the "foo" function
    as a "Routine" object without calling it. You may call any Code object
    by dereferencing it with parens (which may, of course, contain
    arguments):
        &foo($arg1, $arg2);
    Whitespace is not allowed before the parens because it is parsed as a
    postfix. As with any postfix, there is also a corresponding ".()"
    operator, and you may use the "unspace" form to insert optional
    whitespace and comments between the backslash and either of the postfix
    forms:
        &foo\   ($arg1, $arg2);
        &foo\   .($arg1, $arg2);
        &foo\#`[
            embedded comment
        ].($arg1, $arg2);
    Note however that the parentheses around arguments in the "normal" named
    forms of function and method calls are not postfix operators, so do not
    allow the ".()" form, because the dot is indicative of an actual
    dereferencing operation, which the named forms aren't doing. You may,
    however, use "unspace" to install extra space before the parens in the
        foo()       # okay
        foo\ ()     # okay
        foo.()      # means foo().()
        .foo()      # okay
        .foo\ ()    # okay
        .foo.()     # means .foo().()
        $.foo()     # okay
        $.foo\ ()   # okay
        $.foo.()    # means $.foo().()
    If you *do* use the dotty form on these special forms, it will assume
    you wanted to call the named form without arguments, and then
    dereference the result of that.
  Specifying a dispatch candidate
    With multiple dispatch, &foo is actually the name of a "dispatch"
    routine (instantiated from a "proto") controlling a set of candidate
    functions (which you can use as if it were an ordinary function, because
    a "dispatch" is really an "only" function with pretensions to management
    of a dispatcher). However, in that case &foo by itself is not sufficient
    to uniquely name a specific function. To do that, the type may be
    refined by using a signature literal as a postfix operator:
        &foo:(Int,Num)
    Use of a signature that does not unambiguously select a single multi
    results in failure.
    It still just returns a "Routine" object. A call may also be partially
    applied (primed) by using the ".assuming" method:
        &foo.assuming(1,2,3,:mice<blind>)
  Multidimensional slices and lists
    Slicing syntax is covered in S09. A multidimensional slice will be done
    with semicolons between individual slice sublists. The semicolons imply
    one extra level of tree-ness. So when you say
        @matrix[1..*; 0]
    really means
        @matrix[List.new( (1..*), 0 )]
    Each such slice sub-list is evaluated lazily.
    Just as parens and brackets can be used to compose lists and arrays, if
    you put any semicolons into either form, it becomes a multi-dimensional
    composer:
        (1..*; 0)   # same as (lol (1..*), 0), that is LoL.new($(1..*), 0)
        [1..*; 0]   # same as [lol (1..*), 0], that is Array.new($(1..*), 0)
    A consequence of this is that you may not put more than one statement
    inside parens or brackets expecting sequence semantics, that is, the way
    a normal block evaluates all but the final statement for declarations or
    side effects, then returns the value of the final statement. In order to
    do that in Perl 6, you need to use one of these constructs:
        do { my $x = 42; $x }
        $( my $x = 42; $x )
        @( my @x = 42,43; @x )
        %( my %x = a => 42; %x )
    Note that the first one limits the scope of the declaration to the
    block, while the parenthesized forms are parasitic on the outer lexical
    scope.
  Subscript adverbs
    To make a slice subscript return something other than values, append an
    appropriate adverb to the subscript.
        @array = <A B>;
        @array[0,1,2];      # returns 'A', 'B', (Any)
        @array[0,1,2] :p;   # returns 0 => 'A', 1 => 'B'
        @array[0,1,2] :kv;  # returns 0, 'A', 1, 'B'
        @array[0,1,2] :k;   # returns 0, 1
        @array[0,1,2] :v;   # returns 'A', 'B'
        %hash = (:a<A>, :b<B>);
        %hash<a b c>;       # returns 'A', 'B', (Any)
        %hash<a b c> :p;    # returns a => 'A', b => 'B'
        %hash<a b c> :kv;   # returns 'a', 'A', 'b', 'B'
        %hash<a b c> :k;    # returns 'a', 'b'
        %hash<a b c> :v;    # returns 'A', 'B'
    These adverbial forms all weed out non-existing entries if the adverb is
    true; if not, they leave them in, just as an ordinary slice would. So:
        @array[0,1,2] :!p;  # returns 0 => 'A', 1 => 'B', 2 => (Any)
        %hash<a b c>  :!kv; # returns 'a', 'A', 'b', 'B', 'c', (Any)
    Likewise,
        my ($a,$b,$c) = %hash<a b c> :delete;
    deletes the entries *en passant* while returning them. (Of course, any
    of these forms also work in the degenerate case of a slice containing a
    single index.) Note that these forms work by virtue of the fact that the
    subscript is the topmost previous operator. You may have to parenthesize
    or force list context if some other operator that is tighter than comma
    would appear to be topmost:
        1 + (%hash{$x} :delete);
        $x = (%hash{$x} :delete);
        ($x) = %hash{$x} :delete;
    (The situation does not often arise for the slice modifiers above
    because they are usually used in list context, which operates at comma
    precedence.)
    The element is deleted only if the adverb is true. While ":!delete" is
    essentially a no-op; you could conditionally delete entries *en passant*
    based on passing a flag such as in ":delete($kill'em)". In either case,
    the values are returned.
    You may also perform an existence test, either on a single item or a
    junction of items:
        if %hash<foo> :exists {...}
        if %hash{any <a b c>} :exists {...}
        if %hash{all <a b c>} :exists {...}
        if %hash{one <a b c>} :exists {...}
        if %hash{none <a b c>} :exists {...}
    Using the ":exists" adverb together with a list slice results in in a
    "List" of "Bool", which you could also put in a junction with similar
    semantics:
        if any %hash<a b c> :exists {...}
        if all %hash<a b c> :exists {...}
        if one %hash<a b c> :exists {...}
        if none %hash<a b c> :exists {...}
    although with different optimization options for the compiler.
    You may use ":!exists" to test for non-existence. This is specifically
    handy because of precedence rules making "!%hash<a> :exists" apply the
    ":exists" to the prefix "!". "%hash<a> :!exists" does not have that
    problem.
  Combining subscript adverbs
    Like named parameters in a call, there is no order in handling multiple
    adverbs with subscripts. Some combinations make sense, such as:
      %a = %b{@keys-to-extract} :delete :p; # same as :p :delete
    would slice out pairs for the given keys out of one hash into another.
    Whereas
      @actually-deleted = %h{@keys-to-extract} :delete :k; # same as :k :delete
    would return the *keys* that were actually deleted from the hash.
    The adverbs that specify a return type only, can not be combined,
    because combinations such as ":kv :p" or ":v :k" simply do not make
    sense.
    These combinations are considered legal and mean the following:
      :delete :kv            delete, return key/values of actually deleted keys
      :delete :!kv           delete, return key/values of all keys attempted
      :delete :p             delete, return pairs of actually deleted keys
      :delete :!p            delete, return pairs of all keys attempted
      :delete :k             delete, return actually deleted keys
      :delete :!k            delete, return all keys attempted to delete
      :delete :v             delete, return values of actually deleted keys
      :delete :!v            delete, return values of all keys attempted
      :delete :exists        delete, return Bools indicating keys existed
      :delete :!exists       delete, return Bools indicating keys did not exist
      :delete :exists :kv    delete, return list with key,True for key existed
      :delete :!exists :kv   delete, return list with key,False for key existed
      :delete :exists :!kv   delete, return list with key,Bool whether key existed
      :delete :!exists :!kv  delete, return list with key,!Bool whether key existed
      :delete :exists :p     delete, return pairs with key/True for key existed
      :delete :!exists :p    delete, return pairs with key/False for key existed
      :delete :exists :!p    delete, return pairs with key/Bool whether key existed
      :delete :!exists :!p   delete, return pairs with key/!Bool whether key existed
      :exists :kv            return pairs with key,True for key exists
      :!exists :kv           return pairs with key,False for key exists
      :exists :!kv           return pairs with key,Bool for key exists
      :!exists :!kv          return pairs with key,!Bool for key exists
      :exists :p             return pairs with key/True for key exists
      :!exists :p            return pairs with key/False for key exists
      :exists :!p            return pairs with key/Bool for key exists
      :!exists :!p           return pairs with key/!Bool for key exists
    An implementation is free to silently ignore any other combinations or
    silently prefer one of the adverbs given above any other.
  Numeric and boolean context of hashes
    In numeric context (i.e. when cast into "Int" or "Num"), a "Hash" object
    becomes the number of pairs contained in the hash. In a boolean context,
    a Hash object is true if there are any pairs in the hash.
  List sorting
    Sorting a list of pairs should sort on their keys by default, then on
    their values. Sorting a list of lists should sort on the first elements,
    then the second elements, etc. For more on "sort" see S29.
  Special variables
    Many of the special variables of Perl 5 are going away. Those that apply
    to some object such as a filehandle will instead be attributes of the
    appropriate object. Those that are truly global will have global
    alphabetic names, such as $*PID or @*ARGS.
    Any remaining special variables will be lexically scoped. This includes
    $_ and @_, as well as the new $/, which is the return value of the last
    regex match. $0, $1, $2, etc., are aliases into the $/ object.
  Array end index
    The $#foo notation is dead. Use "@foo.end" or @foo[*-1] instead. (Or
    "@foo.shape[$dimension]" for multidimensional arrays.)
Names
    An *identifier* is composed of an alphabetic character followed by any
    sequence of alphanumeric characters. The definitions of alphabetic and
    numeric include appropriate Unicode characters. Underscore is always
    considered alphabetic. An identifier may also contain isolated
    apostrophes or hyphens provided the next character is alphabetic.
    A *name* is anything that is a legal part of a variable name (not
    counting the sigil). This includes
        $foo                # simple identifiers
        $Foo::Bar::baz      # compound identifiers separated by ::
        $Foo::($bar)::baz   # compound identifiers that perform interpolations
        $42                 # numeric names
        $!                  # certain punctuational variables
    When not used as a sigil, the semantic function of "::" within a name is
    to force the preceding portion of the name to be considered a package
    through which the subsequent portion of the name is to be located. If
    the preceding portion is null, it means the package is unspecified and
    must be searched for according to the nature of what follows. Generally
    this means that an initial "::" following the main sigil is a no-op on
    names that are known at compile time, though "::()" can also be used to
    introduce an interpolation (see below). Also, in the absence of another
    sigil, "::" can serve as its own sigil indicating intentional use of a
    not-yet-declared package name.
    Unlike in Perl 5, if a sigil is followed by comma, semicolon, a colon
    not followed by an identifier, or any kind of bracket or whitespace
    (including Unicode brackets and whitespace), it will be taken to be a
    sigil without a name rather than a punctuational variable. This allows
    you to use sigils as coercion operators:
        print $( foo() )    # foo called in item context
        print %( foo() )   # foo called in hash context
    Bare sigils may be used as placeholders for anonymous variables:
        my ($a, $, $c) = 1..3;
        print unless (state $)++;
    Outside of declarative constructs you may also use "*" for a
    placeholder:
        ($a, *, $c) = 1..3;
    Which would be the same as:
        ($a, $, $c) = 1..3;
  Package-qualified names
    Ordinary package-qualified names look like they do in Perl 5:
        $Foo::Bar::baz      # the $baz variable in package Foo::Bar
    Sometimes it's clearer to keep the sigil with the variable name, so an
    alternate way to write this is:
        Foo::Bar::<$baz>
    This is resolved at compile time because the variable name is a
    constant.
  Pseudo-packages
    The following pseudo-package names are reserved at the front of a name:
        MY          # Symbols in the current lexical scope (aka $?SCOPE)
        OUR         # Symbols in the current package (aka $?PACKAGE)
        CORE        # Outermost lexical scope, definition of standard Perl
        GLOBAL      # Interpreter-wide package symbols, really UNIT::GLOBAL
        PROCESS     # Process-related globals (superglobals)
        COMPILING   # Lexical symbols in the scope being compiled
    The following relative names are also reserved but may be used anywhere
    in a name:
        CALLER      # Contextual symbols in the immediate caller's lexical scope
        CALLERS     # Contextual symbols in any caller's lexical scope
        DYNAMIC     # Contextual symbols in my or any caller's lexical scope
        OUTER       # Symbols in the next outer lexical scope
        OUTERS      # Symbols in any outer lexical scope
        LEXICAL     # Contextual symbols in my or any outer's lexical scope
        UNIT        # Symbols in the outermost lexical scope of compilation unit
        SETTING     # Lexical symbols in the unit's DSL (usually CORE)
        PARENT      # Symbols in this package's parent package (or lexical scope)
        CLIENT      # The nearest CALLER that comes from a different package
    Other all-caps names are semi-reserved. We may add more of them in the
    future, so you can protect yourself from future collisions by using
    mixed case on your top-level packages. (We promise not to break any
    existing top-level CPAN package, of course. Except maybe "ACME", and
    then only for coyotes.)
    The file's scope is known as "UNIT", but there are one or more lexical
    scopes outside of that corresponding to the linguistic setting (often
    known as the prelude in other cultures). Hence, the "SETTING" scope is
    equivalent to "UNIT::OUTERS". For a standard Perl program "SETTING" is
    the same as "CORE", but various startup options (such as "-n" or "-p")
    can put you into a domain specific language, in which case "CORE"
    remains the scope of the standard language, while "SETTING" represents
    the scope defining the DSL that functions as the setting of the current
    file. When used as a search term in the middle of a name, "SETTING"
    includes all its outer scopes up to "CORE". To get *only* the setting's
    outermost scope, use "UNIT::OUTER" instead. See also the
    "-L"/"--language" switch described in S19. If a setting wishes to gain
    control of the main execution, it merely needs to declare a "MAIN"
    routine as documented in S06. In this case the ordinary execution of the
    user's code is suppressed; instead, execution of the user's code is
    entirely delegated to the setting's "MAIN" routine, which calls back to
    the user's lexically embedded code with "{YOU_ARE_HERE}".
    The "{YOU_ARE_HERE}" functions within the setting as a proxy for the
    user's "UNIT" block, so "-n" and "-p" may be implemented in a setting
    with:
        for $*ARGFILES.lines {YOU_ARE_HERE}                 # -n
        map *.say, do for $*ARGFILES.lines {YOU_ARE_HERE}   # -p
        map {YOU_ARE_HERE}, $*ARGFILES.lines;               # -n
        map *.say, map {YOU_ARE_HERE}, $*ARGFILES.lines;    # -p
    and the user may use loop control phasers as if they were directly in
    the loop block. Any "OUTER" in the user's code refers to the block
    outside of "{YOU_ARE_HERE}". If used as a standalone statement,
    "{YOU_ARE_HERE}" runs as if it were a bare block.
    Note that, since the "UNIT" of an "EVAL" is the evaluated string itself,
    the "SETTING" of an "EVAL" is the language in effect at the point of the
    "EVAL", not the language in effect at the top of the file. (You may,
    however, use "OUTER::SETTING" to get the setting of the code that is
    executing the "EVAL".) In more traditional terms, the normal program is
    functioning as the "prelude" of the "EVAL".
    So the outermost lexical scopes nest like this, traversed via "OUTER":
        CORE <= SETTING < UNIT < (your_block_here)
    The outermost package scopes nest like this, traversed via "PARENT":
        GLOBAL <  (your_package_here)
    Your main program starts up in the "GLOBAL" package and the "UNIT"
    lexical scope. Whenever anything is declared with "our" semantics, it
    inserts a name into both the current package and the current lexical
    scope. (And "my" semantics only insert into the current lexical scope.)
    Note that the standard setting, "CORE", is a lexical scope, not a
    package; the various items that are defined within (or imported into)
    "CORE" are *not* in "GLOBAL", which is pretty much empty when your
    program starts compiling, and mostly only contains things you either put
    there yourself, or some other module put there because you used that
    module. In general things defined within (or imported into) "CORE"
    should only be declared or imported with "my" semantics. All Perl code
    can see "CORE" anyway as the outermost lexical scope, so there's no need
    to also put such things into "GLOBAL".
    The "GLOBAL" package itself is accessible via "UNIT::GLOBAL". The
    "PROCESS" package is accessible via "UNIT::PROCESS". The "PROCESS"
    package is not the parent of "GLOBAL". However, searching up the dynamic
    stack for dynamic variables will look in all nested dynamic scopes
    (mapped automatically to each call's lexical scope, not package scope)
    out to the main dynamic scope; once all the dynamic scopes are
    exhausted, it also looks in the "GLOBAL" package and then in the
    "PROCESS" package, so $*OUT typically finds the process's standard
    output handle. Hence, "PROCESS" and "GLOBAL" serve as extra outer
    dynamic scopes, much like "CORE" and "SETTING" function as extra outer
    lexical scopes.
    Extra "SETTING" scopes keep their identity and their nesting within
    "CORE", so you may have to go to "OUTER" several times from "UNIT"
    before you get to "CORE". Normally, however, there is only the core
    setting, in which case "UNIT::OUTER" ends up meaning the same as
    "SETTING" which is the same as "CORE".
    Extra "GLOBAL" scopes are treated differently. Every compilation unit
    has its own associated "UNIT::GLOBAL" package. As the currently
    compiling compilation unit expresses the need for various other
    compilation units, the global names known to those other units must be
    merged into the new unit's "UNIT::GLOBAL". (This includes the names in
    all the packages within the global package.) If two different units use
    the same global name, they must generally be taken to refer to the same
    item, but only if the type signatures can be meshed (and augmentation
    rules followed, in the case of package names). If two units provide
    package names with incompatible type signatures, the compilation of the
    unit fails. In other words, you may not use incompatible global types to
    provide a union type. However, if one or the other unit underspecifies
    the type in a compatible way, the underspecified type just takes on the
    extra type information as it learns it. (Presumably some combination of
    Liskov substitution, duck-typing, and run-time checking will prevent
    tragedy in the unit that was compiled with the underspecified type.
    Alternately, the compiler is allowed to recompile or re-examine the unit
    with the new type constraints to see if any issues are certain to arise
    at run time, in which case the compiler is free to complain.)
    Any dynamic variable declared with "our" in the user's main program
    (specifically, the part compiled with "GLOBAL" as the current package)
    is accessible (by virtue of being in "GLOBAL") as a dynamic variable
    even if not directly in the dynamic call chain. Note that dynamic vars
    do *not* look in "CORE" for anything. (They *might* look in "SETTING" if
    you're running under a setting distinct from "CORE", if that setting
    defines a dynamic scope outside your main program, such as for the "-n"
    or "-p" switch.) Context variables declared with "our" in the "GLOBAL"
    or "PROCESS" packages do not need to use the "*" twigil, since the
    twigil is stripped before searching those packages. Hence, your
    environment variables are effectively declared without the sigil:
        augment package GLOBAL { our %ENV; }
  Interpolating into names
    You may interpolate a string into a package or variable name using
    "::($expr)" where you'd ordinarily put a package or variable name. The
    string is allowed to contain additional instances of "::", which will be
    interpreted as package nesting. You may only interpolate entire names,
    since the construct starts with "::", and either ends immediately or is
    continued with another "::" outside the parens. Most symbolic references
    are done with this notation:
        $foo = "Bar";
        $foobar = "Foo::Bar";
        $::($foo)           # lexically-scoped $Bar
        $::("MY::$foo")     # lexically-scoped $Bar
        $::("OUR::$foo")    # package-scoped $Bar
        $::("GLOBAL::$foo") # global $Bar
        $::("PROCESS::$foo")# process $Bar
        $::("PARENT::$foo") # current package's parent's $Bar
        $::($foobar)        # $Foo::Bar
        $::($foobar)::baz   # $Foo::Bar::baz
        $::($foo)::Bar::baz # $Bar::Bar::baz
        $::($foobar)baz     # ILLEGAL at compile time (no operator baz)
    Note that unlike in Perl 5, initial "::" doesn't imply global. Here as
    part of the interpolation syntax it doesn't even imply package. After
    the interpolation of the "::()" component, the indirect name is looked
    up exactly as if it had been there in the original source code, with
    priority given first to leading pseudo-package names, then to names in
    the lexical scope (searching scopes outwards, ending at "CORE"). The
    current package is searched last.
    Use the "MY" pseudopackage to limit the lookup to the current lexical
    scope, and "OUR" to limit the scopes to the current package scope.
  Strict lookup
    When "strict" is in effect (which is the default except for one-liners),
    non-qualified variables (such as $x and @y) are only looked up from
    lexical scopes, but never from package scopes.
    To bind package variables into a lexical scope, simply say "our ($x,
    @y)". To bind global variables into a lexical scope, predeclare them
    with "use":
        use PROCESS <$IN $OUT>;
    Or just refer to them as $*IN and $*OUT.
  Direct lookup
    To do direct lookup in a package's symbol table without scanning, treat
    the package name as a hash:
        Foo::Bar::{'&baz'}  # same as &Foo::Bar::baz
        PROCESS::<$IN>      # Same as $*IN
        Foo::<::Bar><::Baz> # same as Foo::Bar::Baz
    The "::" before the subscript is required here, because the
    "Foo::Bar{...}" syntax is reserved for attaching a "WHENCE"
    initialization closure to an autovivifiable type object. (see S12).
    Unlike "::()" symbolic references, this does not parse the argument for
    "::", nor does it initiate a namespace scan from that initial point. In
    addition, for constant subscripts, it is guaranteed to resolve the
    symbol at compile time.
    The null pseudo-package is reserved to mean the same search list as an
    ordinary name search. That is, the following are all identical in
    meaning:
        $foo
        $::{'foo'}
        ::{'$foo'}
        $::<foo>
        ::<$foo>
    That is, each of them scans lexical scopes outward, and then the current
    package scope (though the package scope is then disallowed when "strict"
    is in effect).
    As a result of these rules, you can write any arbitrary variable name as
    either of:
        $::{'!@#$#@'}
        ::{'$!@#$#@'}
    You can also use the "::<>" form as long as there are no spaces in the
    name.
  Symbol tables
    The current lexical symbol table is now accessible through the
    pseudo-package "MY". The current package symbol table is visible as
    pseudo-package "OUR". The "OUTER" name refers to the "MY" symbol table
    immediately surrounding the current "MY", and "OUTER::OUTER" is the one
    surrounding that one.
        our $foo = 41;
        say $::foo;         # prints 41, :: is no-op
        {
            my $foo = 42;
            say MY::<$foo>;         # prints "42"
            say $MY::foo;           # same thing
            say $::foo;             # same thing, :: is no-op here
            say OUR::<$foo>;        # prints "41"
            say $OUR::foo;          # same thing
            say OUTER::<$foo>;      # prints "41" (our $foo is also lexical)
            say $OUTER::foo;        # same thing
    You may not use any lexically scoped symbol table, either by name or by
    reference, to add symbols to a lexical scope that is done compiling. (We
    reserve the right to relax this if it turns out to be useful though.)
  Dynamic lookup
    The "CALLER" package refers to the lexical scope of the (dynamically
    scoped) caller. The caller's lexical scope is allowed to hide any
    user-defined variable from you. In fact, that's the default, and a
    lexical variable must have the trait ""is dynamic"" to be visible via
    "CALLER". ($_, $! and $/ are always dynamic, as are any variables whose
    declared names contain a "*" twigil.) If the variable is not visible in
    the caller, it returns "Failure". Variables whose names are visible at
    the point of the call but that come from outside that lexical scope are
    controlled by the scope in which they were originally declared as
    dynamic. Hence the visibility of "CALLER::<$*foo>" is determined where
    $*foo is actually declared, not by the caller's scope (unless that's
    where it happens to be declared). Likewise "CALLER::CALLER::<$x>"
    depends only on the declaration of $x visible in your caller's caller.
    User-defined dynamic variables should generally be initialized with
    "::=" unless it is necessary for variable to be modified. (Marking
    dynamic variables as readonly is very helpful in terms of sharing the
    same value among competing threads, since a readonly variable need not
    be locked.)
    Empty "proto" definitions defined with "{*}" are considered invisible to
    "CALLER", so a "multi" may refer directly to the caller of the "proto"
    using a single "CALLER" lookup. Autogenerated "proto" entries follow the
    same rule.
  "DYNAMIC"
    The "DYNAMIC" pseudo-package is just like "CALLER" except that it starts
    in the current dynamic scope and from there scans outward through all
    dynamic scopes (frames) until it finds a dynamic variable of that name
    in that dynamic frame's associated lexical pad. (This search is implied
    for variables with the "*" twigil; hence $*FOO is equivalent to
    "DYNAMIC::<$*FOO>".) If, after scanning outward through all those
    dynamic scopes, there is no variable of that name in any immediately
    associated lexical pad, it strips the "*" twigil out of the name and
    looks in the "GLOBAL" package followed by the "PROCESS" package. If the
    value is not found, it returns "Failure".
    Unlike "CALLER", "DYNAMIC" will see a dynamic variable that is declared
    in the current scope, since it starts searching 0 scopes up the stack
    rather than 1. You may, however, use "CALLER::<$*foo>" to bypass a
    dynamic definition of $*foo in your current scope, such as to initialize
    it with the outer dynamic value:
        my $*foo ::= CALLER::<$*foo>;
    The "temp" declarator may be used (without an initializer) on a dynamic
    variable to perform a similar operation:
        temp $*foo;
    The main difference is that by default it initializes the new $*foo with
    its current value, rather than the caller's value. Also, it is allowed
    only on read/write dynamic variables, since the only reason to make a
    copy of the outer value would be because you'd want to override it later
    and then forget the changes at the end of the current dynamic scope.
    You may also use "OUTER::<$*foo>" to mean you want to start the search
    in your outer lexical scope, but this will succeed only if that outer
    lexical scope also happens to be one of your current *dynamic* scopes.
    That is, the same search is done as with the bare $*foo, but any "hits"
    are ignored until we've got to the "OUTER" scope in our traversal.
  Package lookup
    There is no longer any special package hash such as %Foo::. Just
    subscript the package object itself as a hash object, the key of which
    is the variable name, including any sigil. The package object can be
    derived from a type name by use of the "::" postfix:
        MyType::<$foo>
    (Directly subscripting the type with either square brackets or curlies
    is reserved for various generic type-theoretic operations. In most other
    matters type names and package names are interchangeable.)
    Typeglobs are gone. Use binding (":=" or "::=") to do aliasing.
    Individual variable objects are still accessible through the hash
    representing each symbol table, but you have to include the sigil in the
    variable name now: "MyPackage::{'$foo'}" or the equivalent
    "MyPackage::<$foo>".
  Globals
    Interpreter globals live in the "GLOBAL" package. The user's program
    starts in the "GLOBAL" package, so "our" declarations in the mainline
    code go into that package by default. Process-wide variables live in the
    "PROCESS" package. Most predefined globals such as $*UID and $*PID are
    actually process globals.
  The "PROCESS" package
    There is only ever a single "PROCESS" package. For an ordinary Perl
    program running by itself, there is only one "GLOBAL" package as well.
    However, in certain situations (such as shared hosting under a
    webserver), the actual process may contain multiple virtual processes or
    interpreters, each running its own "main" code. In this case, the
    "GLOBAL" namespace holds variables that properly belong to the
    individual virtual process, while the "PROCESS" namespace holds
    variables that properly belong to the actual process as a whole. From
    the viewpoint of the program there is little difference as long as all
    global variables are accessed as if they were dynamic variables (by
    using the "*" twigil). The process as a whole may place restrictions on
    the mutability of process variables as seen by the individual
    subprocesses. Also, individual subprocesses may not create new process
    variables. If the process wishes to grant subprocesses the ability to
    communicate via the "PROCESS" namespace, it must supply a writeable
    dynamic variable to all the subprocesses granted that privilege.
  Dynamic variable creation
    It is illegal to assign or bind a dynamic variable that does not already
    exist. It will not be created in "GLOBAL" (or "PROCESS") automatically,
    nor is it created in any lexical scope. Instead, you must assign
    directly using the package name to get that to work:
        GLOBAL::<$mynewvar> = $val;
  The magic input handle
    The magic command-line input handle is $*ARGFILES. The arguments
    themselves come in @*ARGS. See also "Declaring a MAIN subroutine" in
    S06.
  Magical access to documentation
    The Pod documentation in a file is accessible from code in the same file
    via variables with a "=" secondary sigil. "$=data" is the accessor for
    your "=data" section(s), for instance. All Pod structures are available
    as a hierarchical data structure, through "$=pod". As with "*", the "="
    may also be used as a package name: "$=::data".
  Magical lexically scoped values
    Magical lexically scoped values live in variables with a "?" secondary
    sigil. These are all values that are known to the compiler, and may in
    fact be dynamically scoped within the compiler itself, and only appear
    to be lexically scoped because dynamic scopes of the compiler resolve to
    lexical scopes of the program. All $? variables are considered
    constants, and may not be modified after being compiled in. The user is
    also allowed to define or (redefine) such constants:
        constant $?TABSTOP = 4;     # assume heredoc tabs mean 4 spaces
    (Note that the constant declarator always evaluates its initialization
    expression at compile time.)
    "$?FILE" and "$?LINE" are your current file and line number, for
    instance. Instead of "$?OUTER::FOO" you probably want to write
    "OUTER::<$?FOO>". Within code that is being run during the compile, such
    as "BEGIN" blocks, or macro bodies, or constant initializers, the
    compiler variables must be referred to as (for instance)
    "COMPILING::<$?LINE>" if the bare "$?LINE" would be taken to be the
    value during the compilation of the currently running code rather than
    the eventual code of the user's compilation unit. For instance, within a
    macro body "$?LINE" is the line within the macro body, but
    "COMPILING::<$?LINE>" is the line where the macro was invoked. See below
    for more about the "COMPILING" pseudo package.
    Here are some possibilities:
        $?FILE      Which file am I in?
        $?LINE      Which line am I at?
        &?ROUTINE   Which routine am I in?
        &?BLOCK     Which block am I in?
        %?LANG      What is the current set of interwoven languages?
    The following return objects that contain all pertinent info:
        $?KERNEL    Which kernel am I compiled for?
        $?DISTRO    Which OS distribution am I compiling under
        $?VM        Which virtual machine am I compiling under
        $?XVM       Which virtual machine am I cross-compiling for
        $?PERL      Which Perl am I compiled for?
        $?SCOPE     Which lexical scope am I in?
        $?PACKAGE   Which package am I in?
        $?MODULE    Which module am I in?
        $?CLASS     Which class am I in? (as variable)
        $?ROLE      Which role am I in? (as variable)
        $?GRAMMAR   Which grammar am I in?
        %?META      The META6.json data associated with the module
        %?RESOURCE  Associated resource files, shortcut for %?META<resource>
    It is relatively easy to smartmatch these constant objects against pairs
    to check various attributes such as name, version, or authority:
        given $?VM {
            when :name<Parrot> :ver(v2) { ... }
            when :name<CLOS>            { ... }
            when :name<SpiderMonkey>    { ... }
            when :name<JVM> :ver(v6.*)  { ... }
    Matches of constant pairs on constant objects may all be resolved at
    compile time, so dead code can be eliminated by the optimizer.
    Note that some of these things have parallels in the "*" space at run
    time:
        $*KERNEL    Which kernel I'm running under
        $*DISTRO    Which OS distribution I'm running under
        $*VM        Which VM I'm running under
        $*PERL      Which Perl I'm running under
    You should not assume that these will have the same value as their
    compile-time cousins.
  The "COMPILING" pseudopackage
    While $? variables are constant to the run time, the compiler has to
    have a way of changing these values at compile time without getting
    confused about its own $? variables (which were frozen in when the
    compile-time code was itself compiled). The compiler can talk about
    these compiler-dynamic values using the "COMPILING" pseudopackage.
    References to "COMPILING" variables are automatically hoisted into the
    lexical scope currently being compiled. Setting or temporizing a
    "COMPILING" variable sets or temporizes the incipient $? variable in the
    surrounding lexical scope that is being compiled. If nothing in the
    context is being compiled, an exception is thrown.
        BEGIN { COMPILING::<$?FOO> = 42 }
        say $?FOO;                  # prints 42
            say $?FOO;              # prints 42
            BEGIN { temp COMPILING::<$?FOO> = 43 } # temporizes to *compiling* block
            say $?FOO;              # prints 43
            BEGIN {
                COMPILING::<$?FOO> = 44;
                say COMPILING::<$?FOO>; # prints 44, but $?FOO probably undefined
            say $?FOO;              # prints 44
        say $?FOO;                  # prints 42 (left scope of temp above)
        $?FOO = 45;                 # always an error
        COMPILING::<$?FOO> = 45;    # an error unless we are compiling something
    Note that "CALLER::<$?FOO>" might discover the same variable as
    "COMPILING::<$?FOO">, but only if the compiling scope is the immediate
    caller. Likewise "OUTER::<$?FOO>" might or might not get you to the
    right place. In the abstract, "COMPILING::<$?FOO"> goes outwards
    dynamically until it finds a compiling scope, and so is guaranteed to
    find the "right" "$?FOO". (In practice, the compiler hopefully keeps
    track of its current compiling scope anyway, so no scan is needed.)
    Perceptive readers will note that this subsumes various "compiler hints"
    proposals. Crazy readers will wonder whether this means you could set an
    initial value for other lexicals in the compiling scope. The answer is
    yes. In fact, this mechanism is probably used by the exporter to bind
    names into the importer's namespace.
  Switching parsers
    The currently compiling Perl parser is switched by modifying one of the
    braided languages in "COMPILING::<%?LANG>". Lexically scoped parser
    changes should temporize the modification. Changes from here to
    end-of-compilation unit can just assign or bind it. In general, most
    parser changes involve deriving a new grammar and then pointing one of
    the "COMPILING::<%?LANG>" entries at that new grammar. Alternately, the
    tables driving the current parser can be modified without derivation,
    but at least one level of anonymous derivation must intervene from the
    preceding Perl grammar, or you might be messing up someone else's
    grammar. Basically, the current set of grammars in "%?LANG" has to
    belong only to the current compiling scope. It may not be shared, at
    least not without explicit consent of all parties. No magical syntax at
    a distance. Consent of the governed, and all that.
  Slangs
    Individual sublanguages ("slangs") may be referred to using the "~"
    twigil. The following are useful:
        $~MAIN       the current main language (e.g. Perl statements)
        $~Quote      the current root of quoting language
        $~Quasi      the current root of quasiquoting language
        $~Regex      the current root of regex language
        $~Trans      the current root of transliteration language
        $~P5Regex    the current root of the Perl 5 regex language
    Hence, when you are defining a normal Perl macro, you're replacing
    "$~MAIN" with a derived language, but when you define a new regex
    backslash sequence, you're replacing "$~Regex" with a derived language.
    (There may or may not be a syntax in the main language to do this.) Note
    that such changes are automatically scoped to the lexical scope; as with
    real slang, the definitions are temporary and embedded in a larger
    language inherited from the surrounding culture.
    Instead of defining macros directly you may also mix in one or more
    grammar rules by lexically scoped declaration of a new sublanguage:
        augment slang Regex {  # derive from $~Regex and then modify $~Regex
            token backslash:std<\Y> { YY };
    This tends to be more efficient since it only has to do one mixin at the
    end of the block. Note that the slang declaration has nothing to do with
    package "Regex", but only with "$~Regex". Sublanguages are in their own
    namespace (inside the current value of "%?LANG", in fact). Hence
    "augment" is modifying one of the local strands of a braided language,
    not a package somewhere else.
    You may also supersede a sublang entirely if, for example, you just want
    to disable that sublanguage in the current lexical scope:
        supersede slang P5Regex {}
        m:P5/./;             # kaboom
    If you supersede "MAIN" then you're replacing the Perl parser entirely.
    This might be done by, say, the "use COBOL" declaration. ":-)"
  Extended identifiers
    It is often convenient to have names that contain arbitrary characters
    or other data structures. Typically these uses involve situations where
    a set of entities shares a common "short" name, but still needs for each
    of its elements to be identifiable individually. For example, you might
    use a module whose short name is "ThatModule", but the complete long
    name of a module includes its version, naming authority, and perhaps
    even its source language. Similarly, sets of operators work together in
    various syntactic categories with names like "prefix", "infix",
    "postfix", etc. The long names of these operators, however, often
    contain characters that are excluded from ordinary identifiers.
    For all such uses, an identifier followed by a subscript-like adverbial
    form (see below) is considered an *extended identifier*:
        infix:<+>    # the official name of the operator in $a + $b
        infix:<*>    # the official name of the operator in $a * $b
        infix:«<=»   # the official name of the operator in $a <= $b
        prefix:<+>   # the official name of the operator in +$a
        postfix:<--> # the official name of the operator in $a--
    This name is to be thought of semantically, not syntactically. That is,
    the bracketing characters used do not count as part of the name; only
    the quoted data matters. These are all the same name:
        infix:<+>
        infix:<<+>>
        infix:«+»
        infix:['+']
    Despite the appearance as a subscripting form, these names are resolved
    not at run time but at compile time. The pseudo-subscripts need not be
    simple scalars. These are extended with the same two-element list:
        circumfix:«<< >>»
        circumfix:['<<','>>']
    An identifier may be extended with multiple named identifier extensions,
    in which case the names matter but their order does not. These name the
    same module:
        use ThatModule:auth<Somebody>:ver<2.7.18.28.18>
        use ThatModule:ver<2.7.18.28.18>:auth<Somebody>
    Adverbial syntax is described in "Adverbial Pair forms".
Literals
    Perl 6 has a rich set of literal forms, many of which can be used for
    textual input as well. For those forms simple enough to be allowed, the
    "val()" function treats such a string value as if it were a literal in
    the program. In some cases the "val()" function will be applied on your
    behalf, and in other cases you must do so explicitly. The rationale for
    this function is that there are many cases where the programmer or user
    is forced to use a string type to represent a value that is intended to
    become a numeric type internally. Committing pre-emptively to either a
    string type or a numeric type is likely to be wrongish, so Perl 6
    instead provides the concept of *allomorphic* literals. How these work
    is described below in "Allomorphic value semantics".
    When used as literals in a program, most of these forms produce an exact
    type, and are not subject to "val()" processing. The exceptions will be
    noted as we go.
  Underscores
    A single underscore is allowed only between any two digits in a literal
    number, where the definition of digit depends on the radix. (A single
    underscore is also allowed between a radix prefix and a following digit,
    as explained in the next section.) Underscores are not allowed anywhere
    else in any numeric literal, including next to the radix point or
    exponentiator, or at the beginning or end.
  Radix markers
    Initial 0 no longer indicates octal numbers by itself. You must use an
    explicit radix marker for that. Pre-defined radix prefixes include:
        0b          base 2, digits 0..1
        0o          base 8, digits 0..7
        0d          base 10, digits 0..9
        0x          base 16, digits 0..9,a..f (case insensitive)
    Each of these allows an optional underscore after the radix prefix but
    before the first digit. These all mean the same thing:
        0xbadcafe
        0xbad_cafe
        0x_bad_cafe
  General radices
    The general radix form of a number involves prefixing with the radix in
    adverbial form:
        :10<42>             same as 0d42 or 42
        :16<DEAD_BEEF>      same as 0xDEADBEEF
        :8<177777>          same as 0o177777 (65535)
        :2<1.1>             same as 0b1.1 (0d1.5)
    Extra digits are assumed to be represented by "a".."z" and "A".."Z", so
    you can go up to base 36. (Use "A" and "B" for base twelve, not "T" and
    "E".) Alternatively you can use a list of values, which is convenient
    for decimals:
        :60[12,34,56]       # 12 * 3600 + 34 * 60 + 56
        :100[3,'.',14,16]   # pi
    All numbers representing digits must be less than the radix, or an error
    will result (at compile time if constant-folding can catch it, or at run
    time otherwise).
    Any radix may include a fractional part. A dot is never ambiguous
    because you have to tell it where the number ends:
        :16<dead_beef.face> # fraction
        :16<dead_beef>.face # method call
  Exponentials
    Only base 10 (in any form) allows an additional exponentiator starting
    with 'e' or 'E'. All other radixes must either rely on the constant
    folding properties of ordinary multiplication and exponentiation, or
    supply the equivalent two numbers as part of the string, which will be
    interpreted as they would outside the string, that is, as decimal
    numbers by default:
        :16<dead_beef> * 16**8
        :16<dead_beef*16**8>
    It's true that only radixes that define "e" as a digit are ambiguous
    that way, but with any radix it's not clear whether the exponentiator
    should be 10 or the radix, and this makes it explicit:
        0b1.1e10                    ILLEGAL, could be read as any of:
        :2<1.1> * 2 ** 10           1536
        :2<1.1> * 10 ** 10          15,000,000,000
        :2<1.1> * :2<10> ** :2<10>  6
    So we write those as
        :2<1.1*2**10>               1536
        :2<1.1*10**10>              15,000,000,000
        :2«1.1*:2<10>**:2<10>»      6
    The generic string-to-number converter will recognize all of these forms
    (including the * form, since constant folding is not available to the
    run time). Also allowed in strings are leading plus or minus, and maybe
    a trailing Units type for an implied scaling. Leading and trailing
    whitespace is ignored. Note also that leading 0 by itself *never*
    implies octal in Perl 6.
    In all these cases, the type produced will be the narrowest of "Int",
    "Rat", or "Num" that can accurately represent the number. If no type can
    represent it exactly, it should be returned as either a "Rat" or a
    "Num", whichever is more accurate. ("Rat64" will tend to be more
    accurate for numbers of normal or large magnitude, while "Num64" may be
    more accurate for numbers of very small magnitude, since the "Rat"'s
    size mismatch of numerator and denominator will eventually cost more
    accuracy than the Num's exponent overhead. As a limiting case, a "Rat64"
    cannot represent any number smaller than ":10<1*2**-64>".)
    A consequence of the preceding is that you cannot make a "FatRat" using
    colon notation. You must rely on constructors and constant folding:
        FatRat.new(1,2) ** 128
        FatRat.new(1, 2 ** 128)     # same thing
  Conversion functions
    Any of the adverbial forms may be used as a function:
        :2($x)      # "bin2num"
        :8($x)      # "oct2num"
        :10($x)     # "dec2num"
        :16($x)     # "hex2num"
    Think of these as setting the default radix, not forcing it. Like Perl
    5's old "oct()" function, any of these will recognize a number starting
    with a different radix marker and switch to the other radix. However,
    note that the ":16()" converter function will interpret leading "0b" or
    "0d" as hex digits, not radix switchers.
    Use of the functional form on anything that is not a string will throw
    an exception explaining that the user has confused a number with the
    textual representation of a number. This is to catch errors such as a
    ":8(777)" that should have been ":8<777>", or the attempt to use the
    function in reverse to produce a textual representation from a number.
  Rational literals
    Rational literals are indicated by separating two integer literals (in
    any radix) with a slash, and enclosing the whole in angles:
        <1/2>       # one half literal Rat
    Whitespace is not allowed on either side of the slash or it will be
    split under normal quote-words semantics:
        < 1 / 2 >   # (IntStr('1'), '/', IntStr('2'))
        < 1/2 >     # okay, returns RatStr('1/2') rather than Rat
    Because of constant folding, you may often get away with leaving out the
    angles:
        1/2         # 1 divided by 2
    However, in that case you have to pay attention to precedence and
    associativity. The following does *not* cube "2/3":
        2/3**3      # 2/(3**3), not (2/3)**3
    Decimal fractions not using "e" notation are also treated as literal
    "Rat" values:
        6.02e23.WHAT     # Num
        1.23456.WHAT     # Rat
        0.11 == 11/100   # True
    Literals specified without spaces in angle brackets are exempt from
    "val()" processing, so "<1/2>" produces a value that is "Rat", while "<
    1/2 >" produces a value that is both a "Rat" and a "Str". See
    "Allomorphic value semantics" below.
  Complex literals
    Complex literals are similarly indicated by writing an addition or
    subtraction of two real numbers (again, without spaces around the
    operators) inside angles:
        <5.2+1e42i>
        <-3-1i>
    As with rational literals, constant folding would produce the same
    complex number, but this form parses as a single term, ignoring
    surrounding precedence.
    (Note that these are not actually special syntactic forms: both rational
    and complex literal forms fall out naturally from the semantic rules of
    qw quotes described below.)
    "val()" processing, so "<1+2i>" produces a value that is a "Complex"
    while "< 1+2i >" produces a value that is both a "Complex" and a "Str".
    See "Allomorphic value semantics" below.
  "Blob" literals
    "Blob" literals look similar to integer literals with radix markers, but
    use curlies instead of angles:
        :2{0010_1110_1000_10}   a blob1, base 2, 1 bit per column
        :4{}                    a blob2, 2 bits per column
        :8{5235 0437 6}         a blob3, 3 bits per column
        :16{A705E}              a blob4, 4 bits per column
    Whitespace and underscores are allowed but ignored.
  Radix interpolation
    Characters indexed by hex numbers can be interpolated into strings by
    introducing with "\x", followed by either a bare hex number ("\x263a")
    or a hex number in square brackets ("\x[263a]"). Similarly, "\o12" and
    "\o[12]" interpolate octals--but generally you should be using hex in
    the world of Unicode. Multiple characters may be specified within any of
    the bracketed forms by separating the numbers with comma:
    "\x[41,42,43]". You must use the bracketed form to disambiguate if the
    unbracketed form would "eat" too many characters, because all of the
    unbracketed forms eat as many characters as they think look like digits
    in the radix specified. None of these notations work in normal Perl
    code. They work only in interpolations and regexes and the like.
    Note that the inside of the brackets is not an expression, and you may
    not interpolate there, since that would be a double interpolation. Use
    curlies to interpolate the values of expressions.
    The old "\123" form is now illegal, as is the "\0123" form. Only "\0"
    remains, and then only if the next character is not in the range
    '0'..'7'. Octal characters must use "\o" notation. Note also that
    backreferences are no longer represented by "\1" and the like--see S05.
  Angle quotes (quote words)
    The "qw/foo bar/" quote operator now has a bracketed form: "<foo bar>".
    When used as a subscript it performs a slice equivalent to
    "{'foo','bar'}". Elsewhere it is equivalent to a parenthesized list of
    strings: "('foo','bar')". Since parentheses are generally reserved just
    for precedence grouping, they merely autointerpolate in flat list
    context. Therefore
        @a = 1, < x y >, 2;
    is equivalent to:
        @a = 1, ('x', 'y'), 2;
    which is the same as:
        @a = 1, 'x', 'y', 2;
    In item context, the implied grouping parentheses are still there, so
        $a = < a b >;
        $a = ('a', 'b');
    which assigns a "List" to the variable. On the other hand, if you
    backslash the list:
        $a = \<a b>;
    it is like:
        $a = \('a', 'b');
    and ends up storing a "Capture" object (which weeds out any named
    arguments into a separate structure, in contrast to a "List", which
    keeps everything in its original list).
    Binding is different from assignment. If bound to a signature, the "<a
    b>" list will be promoted to a "Capture" object, but if bound to a
    parameter, it will make the flattening/slicing decision based on the
    nature of the individual parameter. That is, if you pass "<a b>" as an
    argument, it will bind as a single item to a positional or slice
    parameter, and as two items to a slurpy parameter.
    But note that under the parenthesis-rewrite rule, a single value will
    still act like a single value. These are all the same:
        $a = < a >;
        $a = ('a');
        $a = 'a';
    Strings within angle brackets are subject to "val()" processing, and any
    component that parses successfully as a numeric literal will become both
    a string and a number. See "Allomorphic value semantics" below.
   Explicit List construction
    As the previous section shows, a list is not automatically constructed
    by parens; the list is actually constructed by the comma, not by the
    parens. To force a single value to become a composite object in item
    context, either add a comma inside parens, or use an appropriate
    constructor or composer for clarity as well as correctness:
        $a = (< a >,);
        $a = ('a',);
        $a = List.new('a');
        $a = ['a'];
   Empty List
    Even though there is no comma in it, the empty list is represented by
    "()". Normally, one could itemize this by prefixing a "$" (as in "$()"),
    but that translates to the special syntax form "$( $/.made // Str($/)
    )". Instead, one can "().item", or less legibly, introduce a space as in
    "$( )".
   Disallowed forms
    The degenerate case "<>" is disallowed as a probable attempt to do IO in
    the style of Perl 5; that is now written "lines()". ("<STDIN>" is also
    disallowed.) Empty lists are better written with "()" in any case
    because "<>" will often be misread as meaning "('')". (Likewise the
    subscript form "%foo<>" should be written %foo{} to avoid misreading as
    @foo{''}.) If you really want the angle form for stylistic reasons, you
    can suppress the error by putting a space inside: "< >".
   Relationship between <> and «»
    Much like the relationship between single quotes and double quotes,
    single angles do not interpolate while double angles do. The double
    angles may be written either with French quotes, "«$foo @bar[]»", or
    with "Texas" quotes, "<<$foo @bar[]>>", as the ASCII workaround. The
    implicit split is done after interpolation, but respects quotes in a
    shell-like fashion, so that "«'$foo' "@bar[]"»" is guaranteed to produce
    a list of two "words" equivalent to "('$foo', "@bar[]")". "Pair"
    notation is also recognized inside "«...»" and such "words" are returned
    as "Pair" objects.
    Colon pairs (but not arrow pairs) are recognized within double angles.
    In addition, the double angles allow for comments beginning with "#".
    These comments work exactly like ordinary comments in Perl code. Unlike
    in the shells, any literal "#" must be quoted, even ones without
    whitespace in front of them, but note that this comes more or less for
    free with a colon pair like ":char<#x263a>", since comments only work in
    double angles, not single.
  Adverbial Pair forms
    There is now a generalized adverbial form of Pair notation, also known
    as a "colon pair" form. The following table shows the correspondence to
    the "fatarrow" notation:
        Fat arrow           Adverbial pair  Paren form
        =========           ==============  ==========
        a => True           :a
        a => False          :!a
        a => 0              :a(0)
        a => $x             :a($x)
        a => 'foo'          :a<foo>         :a(<foo>)
        a => <foo bar>      :a<foo bar>     :a(<foo bar>)
        a => «$foo @bar»    :a«$foo @bar»   :a(«$foo @bar»)
        a => {...}          :a{...}         :a({...})
        a => [...]          :a[...]         :a([...])
        a => $a             :$a
        a => @a             :@a
        a => %a             :%a
        a => &a             :&a
        a => %foo<a>        %foo<a>:p
    The fatarrow construct may be used only where a term is expected because
    it's considered an expression in its own right, since the fatarrow
    itself is parsed as a normal infix operator (even when autoquoting an
    identifier on its left). Because the left side is a general expression,
    the fatarrow form may be used to create a Pair with *any* value as the
    key. On the other hand, when used as above to generate "Pair" objects,
    the adverbial forms are restricted to the use of identifiers as keys.
    You must use the fatarrow form to generate a "Pair" where the key is not
    an identifier.
    Despite that restriction, it's possible for other things to come between
    a colon and its brackets; however, all of the possible non-identifier
    adverbial keys are reserved for special syntactical forms. Perl 6
    currently recognizes decimal numbers and the null key. In the following
    table the first and second columns do *not* mean the same thing:
        Simple pair         DIFFERS from    which means
        ===========         ============    ===========
        2 => <101010>       :2<101010>      radix literal 0b101010
        8 => <123>          :8<123>         radix literal 0o123
        16 => <deadbeef>    :16<deadbeef>   radix literal 0xdeadbeef
        16 => $somevalue    :16($somevalue) radix conversion function
        '' => $x            :($x)           signature literal
        '' => ($x,$y)       :($x,$y)        signature literal
        '' => <x>           :<x>            name extension
        '' => «x»           :«x»            name extension
        '' => [$x,$y]       :[$x,$y]        name extension
        '' => { .say }      :{ .say }       adverbial block (not allowed on names)
    All of the adverbial forms (including the normal ones with identifier
    keys) are considered special tokens and are recognized in various
    positions in addition to term position. In particular, when used where
    an infix would be expected they modify the previous topmost operator
    that is tighter in precedence than "loose unary" (see S03):
        1 == 100 :fuzz(3)     # calls: infix:<==>(1, 100, fuzz => 3)
    Within declarations the adverbial form is used to rename parameter
    declarations:
        sub foo ( :externalname($myname) ) {...}
    Adverbs modify the meaning of various quoting forms:
        q:x 'cat /etc/passwd'
    When appended to an identifier (that is, in postfix position), the
    adverbial syntax is used to generate unique variants of that identifier;
    this syntax is used for naming operators such as "infix:<+>" and
    multiply-dispatched grammatical rules such as "statement_control:if".
    When so used, the adverb is considered an integral part of the name, so
    "infix:<+>" and "infix:<->" are two different operators. Likewise
    "prefix:<+>" is different from "infix:<+>". (The notation also has the
    benefit of grouping distinct identifiers into easily accessible sets;
    this is how the standard Perl 6 grammar knows the current set of infix
    operators, for instance.)
    Only identifiers that produce a list of one or more values (preferably
    strings) are allowed as name extensions; in particular, closures do not
    qualify as values, so the ":{...}" form is not allowed as a name
    extender. In particular, this frees up the block form after a method
    name, so it allows us to parse a block as a method argument:
        @stuff.sort:{ +$_ }
    These might look like it is using pairs, but it is really equivalent to
        @stuff.sort: { +$_ }
    So the colons here are not really introducing pairs, but rather
    introducing the argument list of the method. In any other location,
    ":{...}" would be taken in one of two ways, depending on whether the
    brackets define a closure or a hash. If taken as a closure, ":{...}"
    creates a pair mapping the null key to the closure. If taken as a hash
    composer, the null key is ignored, and ":{...}" creates an object-keyed
    hash rather than the string-keyed hash that "{...}" would without the
    colon.)
    Either fatarrow or adverbial pair notation may be used to pass named
    arguments as terms to a function or method. After a call with
    parenthesized arguments, only the adverbial syntax may be used to pass
    additional arguments. This is typically used to pass an extra block:
        find($directory) :{ when not /^\./ }
    This just naturally falls out from the preceding rules because the
    adverbial block is in operator position, so it modifies the "find
    operator". (Parens aren't considered an operator.)
    Note that (as usual) the "{...}" form (either identifier-based or
    special) can indicate either a closure or a hash depending on the
    contents. It does *not* indicate a subscript, since ":key{}" is really
    equivalent to "key => {}", and the braces are not behaving as a postfix
    at all. (The function to which it is passed can *use* the value as a
    subscript if it chooses, however.)
    Note also that the "<a b>" form is not a subscript and is therefore
    equivalent not to ".{'a','b'}" but rather to "('a','b')". Bare "<a>"
    turns into "('a')" rather than "('a',)". (However, as with the other
    bracketed forms, the value may end up being used as a subscript
    depending on context.)
    Two or more adverbs can always be strung together without intervening
    punctuation anywhere a single adverb is acceptable. When used as named
    arguments in an argument list, you *may* put comma between, because
    they're just ordinary named arguments to the function, and a fatarrow
    pair would work the same. However, this comma is allowed only when the
    first pair occurs where a term is expected. Where an infix operator is
    expected, the adverb is always taken as modifying the nearest preceding
    operator that is not hidden within parentheses, and if you string
    together multiple such pairs, you may not put commas between, since that
    would cause subsequent pairs to look like terms. (The fatarrow form is
    not allowed at all in operator position.) See S06 for the use of adverbs
    as named arguments.
    The negated form (":!a") and the sigiled forms (":$a", ":@a", ":%a")
    never take an argument and don't care what the next character is. They
    are considered complete. These forms require an identifier to serve as
    the key. A sigiled form that includes a twigil will not include the
    twigil in the key.
    For identifiers that take a non-negative integer argument, it is allowed
    to abbreviate, for example, ":sweet(16)" to ":16sweet". (This is
    distinguishable from the ":16<deadbeef>" form, which never has an
    alphabetic character following the number.) Only literal non-negative
    integers numbers may be swapped this way. Please note that this
    abbreviation allows:
      s:2nd/foo/bar/  # or 3rd, 4th, 5th etc.
    The other forms of adverb (including the bare ":a" form) *always* look
    for an immediate bracketed argument, and will slurp it up. If that's not
    intended, you must use whitespace between the adverb and the opening
    bracket. The syntax of individual adverbs is the same everywhere in Perl
    6. There are no exceptions based on whether an argument is wanted or
    not. (There is a minor exception for quote and regex adverbs, which
    accept *only* parentheses as their bracketing operator, and ignore other
    brackets, which must be placed in parens if desired. See "Paren form" in
    the table above.)
    Except as noted above, the parser always looks for the brackets. Despite
    not indicating a true subscript, the brackets are similarly parsed as
    postfix operators. As postfixes the brackets may be separated from their
    initial ":foo" with either unspace or dot (or both), but nothing else.
    Regardless of syntax, adverbs used as named arguments (in either term or
    infix position) generally show up as optional named parameters to the
    function in question--even if the function is an operator or macro. The
    function in question neither knows nor cares how weird the original
    syntax was.
  "Q" forms
    In addition to "q" and "qq", there is now the base form "Q" which does
    *no* interpolation unless explicitly modified to do so. So "q" is really
    short for "Q:q" and "qq" is short for "Q:qq". In fact, all quote-like
    forms derive from "Q" with adverbs:
        q//         Q :q //
        qq//        Q :qq //
        rx//        Q :regex //
        s///        Q :subst ///
        tr///       Q :trans ///
    Adverbs such as ":regex" change the language to be parsed by switching
    to a different parser. This can completely change the interpretation of
    any subsequent adverbs as well as the quoted material itself.
        q:s//       Q :q :scalar //
        rx:s//      Q :regex :scalar //
    Just as "q[...]" has the short form '...', and "qq[...]" has the short
    form "...", the completely quoted "Q[...]" has a short form that uses
    halfwidth corner brackets: "｢...｣".
  Adverbs on quotes
    Generalized quotes may now take adverbs:
        Short       Long            Meaning
        =====       ====            =======
        :x          :exec           Execute as command and return results
        :w          :words          Split result on words (no quote protection)
        :ww         :quotewords     Split result on words (with quote protection)
        :v          :val            Evaluate word or words for value literals
        :q          :single         Interpolate \\, \q and \' (or whatever)
        :qq         :double         Interpolate with :s, :a, :h, :f, :c, :b
        :s          :scalar         Interpolate $ vars
        :a          :array          Interpolate @ vars
        :h          :hash           Interpolate % vars
        :f          :function       Interpolate & calls
        :c          :closure        Interpolate {...} expressions
        :b          :backslash      Interpolate \n, \t, etc. (implies :q at least)
        :to         :heredoc        Parse result as heredoc terminator
                    :regex          Parse as regex
                    :subst          Parse as substitution
                    :trans          Parse as transliteration
                    :code           Quasiquoting
        :p          :path           Return a Path object (see S16 for more options)
    You may omit the first colon by joining an initial "Q", "q", or "qq"
    with a single short form adverb, which produces forms like:
        qw /a b c/;                         # P5-esque qw// meaning q:w
        Qc '...{$x}...';                    # Q:c//, interpolate only closures
        qqx/$cmd @args[]/                   # equivalent to P5's qx//
    (Note that "qx//" doesn't interpolate.)
    If you want to abbreviate further, just define a macro:
        macro qx { 'qq:x ' }          # equivalent to P5's qx//
        macro qTO { 'qq:x:w:to ' }    # qq:x:w:to//
        macro quote:<❰ ❱> ($text) { quasi { {{{$text}}}.quoteharder } }
    All the uppercase adverbs are reserved for user-defined quotes. All
    Unicode delimiters above Latin-1 are reserved for user-defined quotes.
    A consequence of the above is that we can now say:
        %hash = qw:c/a b c d {@array} {%hash}/;
        %hash = qq:w/a b c d {@array} {%hash}/;
    to interpolate items into a "qw". Conveniently, arrays and hashes
    interpolate with only whitespace separators by default, so the
    subsequent split on whitespace still works out. (But the built-in
    "«...»" quoter automatically does interpolation equivalent to
    "qq:ww:v/.../". The built-in "<...>" is equivalent to "q:w:v/.../".)
  The ":val" modifier
    The ":v"/":val" modifier runs each word through the "val()" function,
    which will attempt to recognize literals as defined by the current
    slang. (See "Allomorphic value semantics" below.) Only pure literals
    such as numbers, versions, and enums are so recognized; all other words
    are left as strings. In any case, use of such an intuited value as a
    string will reproduce the original string including any leading or
    trailing whitespace:
        say +val(' +2/4 ')   # '0.5'
        say ~val(' +2/4 ')   # ' +2/4 '
    Of course, words derived from ":w" and ":ww" will not have any
    whitespace, since that is what the words are split apart on.
  Whitespace before adverbs
    Whitespace is allowed between the "q" and its adverb: "q :w /.../".
  Overriding the definitions of quoting keywords
    If you define an identifier (either as a term or a subroutine) that
    happens to shadow one of the quoting or matching keywords, that keyword
    is no longer available for quoting purposes:
        my \q = 42;    say q / 2;  # prints 21
        sub m { 42 };  say m / 2;  # prints 21
    Unlike with keyword overrides, it doesn't matter whether there's
    whitespace after it; the name will always just be parsed as a term or
    function call, unless followed explicitly by a colon. Generally you can
    work around such a definition by using a related form of the same quote,
    or by adding a useless modifier (either with or without the colon):
        my \q = 42;   say Q:q /2/;    # prints 2
        my \q = 42;   say qs  /2/;    # prints 2
        my \q = 42;   say q:s /2/;    # prints 2
        sub m { 42 }; say / 2 /;      # matches 2
        sub m { 42 }; say m:1st/ 2 /; # matches 2
  Delimiters of quoting forms
    For these "q" forms the choice of delimiters has no influence on the
    semantics. That is, '', "", "<>", "«»", ``, "()", "[]", and "{}" have no
    special significance when used in place of "//" as delimiters. There may
    be whitespace before the opening delimiter. (Which is mandatory for
    parens because "q()" is a subroutine call and q:w(0) is an adverb with
    arguments). A colon may never be used as the delimiter since it will
    always be taken to mean another adverb regardless of what's in front of
    it. Nor may a "#" character be used as the delimiter since it is always
    taken as whitespace (specifically, as a comment). You may not use
    whitespace or alphanumerics for delimiters.
  Quotes from Macros
    New quoting constructs may be declared as macros:
        macro quote:<qX> (*%adverbs) {...}
    Note: macro adverbs are automatically evaluated at macro call time if
    the adverbs are included in the parse. If an adverb needs to affect the
    parsing of the quoted text of the macro, then an explicit named
    parameter may be passed on as a parameter to the "is parsed" subrule, or
    used to select which subrule to invoke.
  Interpolating into a single-quoted string
    You may interpolate double-quotish text into a single-quoted string
    using the "\qq[...]" construct. Other "q" forms also work, including
    user-defined ones, as long as they start with "q". Otherwise you'll just
    have to embed your construct inside a "\qq[...]".
  Interpolation rules
    Bare scalar variables always interpolate in double-quotish strings. Bare
    array, hash, and subroutine variables may *never* be interpolated.
    However, any scalar, array, hash or subroutine variable may start an
    interpolation if it is followed by a sequence of one or more bracketed
    dereferencers: that is, any of:
    1. An array subscript
    2. A hash subscript
    3. A set of parentheses indicating a function call
    4. Any of 1 through 3 in their dot form
    5. A method call that includes argument parentheses
    6. A sequence of one or more unparenthesized method call, followed by
    any of 1 through 5
    In other words, this is legal:
        "Val = $a.ord.fmt('%x')\n"
    and is equivalent to
        "Val = { $a.ord.fmt('%x') }\n"
    However, no interpolated postfix may start with a backslash, so any
    backslash or unspace is not recognized, but instead will be assumed to
    be part of the string outside of the interpolation, and subject to the
    normal backslashing rules of that quote context:
        my $a = 42;
        "Val = $a\[junk\]";  # Val = 42[junk]
        "Val = $a\[junk]";   # Val = 42[junk]
        "Val = $a\ [junk]";  # Val = 42 [junk]
        "Val = $a\.[junk]";  # Val = 42.[junk]
   Arrays
    In order to interpolate an entire array, it's necessary now to subscript
    with empty brackets:
        print "The answers are @foo[]\n"
    Note that this fixes the spurious ""@"" problem in double-quoted email
    addresses.
    As with Perl 5 array interpolation, the elements are separated by a
    space. (Except that a space is not added if the element already ends in
    some kind of whitespace. In particular, a list of pairs will interpolate
    with a tab between the key and value, and a newline after the pair.)
   Hashes
    In order to interpolate an entire hash, it's necessary to subscript with
    empty braces or angles:
        print "The associations are:\n%bar{}"
        print "The associations are:\n%bar<>"
    Note that this avoids the spurious ""%"" problem in double-quoted printf
    formats.
    By default, keys and values are separated by tab characters, and pairs
    are separated by newlines. (This is almost never what you want, but if
    you want something polished, you can be more specific.)
   Sub calls
    In order to interpolate the result of a sub call, it's necessary to
    include both the sigil and parentheses:
        print "The results are &baz().\n"
   Method calls
    In order to interpolate the result of a method call without arguments,
    it's necessary to include parentheses or extend the call with something
    ending in brackets:
        print "The attribute is $obj.attr().\n"
        print "The attribute is $obj.attr<Jan>.\n"
    The method is called in item context. (If it returns a list, that list
    is interpolated as if it were an array.)
    It is allowed to have a cascade of argumentless methods as long as the
    last one ends with parens:
        print "The attribute is %obj.keys.sort.reverse().\n"
    (The cascade is basically counted as a single method call for the
    end-bracket rule.)
   Multiple dereferencers
    Multiple dereferencers may be stacked as long as each one ends in some
    kind of bracket or is a bare method:
        print "The attribute is @baz[3](1, 2, 3).gethash.{$xyz}<blurfl>.attr().\n"
    Note that the final period above is not taken as part of the expression
    since it doesn't introduce a bracketed dereferencer. The parens are not
    required on the ".gethash", but they are required on the ".attr()",
    since that terminates the entire interpolation.
    In no case may any of the top-level components be separated by
    whitespace or unspace. (These are allowed, though, inside any bracketing
    constructs, such as in the "(1, 2, 3)" above.)
   Closures
    A bare closure also interpolates in double-quotish context. It may not
    be followed by any dereferencers, since you can always put them inside
    the closure. The expression inside is evaluated in string item context.
    You can force list context on the expression using the "list" operator
    if necessary. A closure in a string establishes its own lexical scope.
    (Expressions that sneak in without curlies, such as "$(...)", do not
    establish their own lexical scope, but use the outer scope, and may even
    declare variables in the outer scope, since all the code inside (that
    isn't in an "EVAL") is seen at compile time.)
    The following means the same as the previous example.
        print "The attribute is { @baz[3](1,2,3).gethash.{$xyz}<blurfl>.attr }.\n"
    The final parens are unnecessary since we're providing "real" code in
    the curlies. If you need to have double quotes that don't interpolate
    curlies, you can explicitly remove the capability:
        qq:c(0) "Here are { $two uninterpolated } curlies";
    or equivalently:
        qq:!c "Here are { $two uninterpolated } curlies";
    Alternately, you can build up capabilities from single quote to tell it
    exactly what you *do* want to interpolate:
        q:s 'Here are { $two uninterpolated } curlies';
   Twigils
    Secondary sigils (twigils) have no influence over whether the primary
    sigil interpolates. That is, if $a interpolates, so do $^a, $*a, "$=a",
    "$?a", "$.a", etc. It only depends on the "$".
   Other expressions
    No other expressions interpolate. Use curlies.
   Class methods
    A class method may not be directly interpolated. Use curlies:
        print "The dog bark is {Dog.bark}.\n"
   Old disambiguation
    The old disambiguation syntax:
        ${foo[$bar]}
        ${foo}[$bar]
    is dead. Use closure curlies instead:
        {$foo[$bar]}
        {$foo}[$bar]
    (You may be detecting a trend here...)
   Topical methods
    To interpolate a topical method, use curlies: "{.bark}".
   Function calls
    To interpolate a function call without a sigil, use curlies: "{abs
    $var}".
   Backslash sequences
    Backslash sequences still interpolate, but there's no longer any "\v" to
    mean *vertical tab*, whatever that is... ("\v" now matches vertical
    whitespace in a regex.) Literal character representations are:
        \a          BELL
        \b          BACKSPACE
        \t          TAB
        \n          LINE FEED
        \f          FORM FEED
        \r          CARRIAGE RETURN
        \e          ESCAPE
   Other functions
    There's also no longer any "\L", "\U", "\l", "\u", or "\Q". Use curlies
    with the appropriate function instead: "{tclc $word}".
   Unicode codepoints
    You may interpolate any Unicode codepoint by name using "\c" and square
    brackets:
        "\c[NEGATED DOUBLE VERTICAL BAR DOUBLE RIGHT TURNSTILE]"
    Multiple codepoints constituting a single character may be interpolated
    with a single "\c" by separating the names with comma:
        "\c[LATIN CAPITAL LETTER A, COMBINING RING ABOVE]"
    Whether that is regarded as one character or two depends on the Unicode
    support level of the current lexical scope. It is also possible to
    interpolate multiple codepoints that do not resolve to a single
    character:
        "\c[LATIN CAPITAL LETTER A, LATIN CAPITAL LETTER B]"
    [Note: none of the official Unicode character names contains comma.]
    You may also put one or more decimal numbers inside the square brackets:
        "\c[13,10]" # CRLF
    Any single decimal number may omit the brackets:
        "\c8" # backspace
    (Within a regex you may also use "\C" to match a character that is not
    the specified character.)
    If the character following "\c" or "\C" is neither a left square bracket
    nor a decimal digit, the single following character is turned into a
    control character by the usual trick of XORing the 64 bit. This allows
    "\c@" for NULL and "\c?" for DELETE, but note that the ESCAPE character
    may not be represented that way; it must be represented something like:
        \e
        \c[ESCAPE]
        \c27
        \x1B
        \o33
    Obviously "\e" is preferred when brevity is needed.
   Backslashing
    Any character that *would* start an interpolation in the current quote
    context may be protected from such interpolation by prefixing with
    backslash. The backslash is always removed in this case.
    The treatment of backslashed characters that would *not* have introduced
    an interpolation varies depending on the type of quote:
    1.  Any quoting form that includes "qq" or ":qq" in its semantic
        derivation (including the normal double quote form) assumes that all
        backslashes are to be considered meaningful. The meaning depends on
        whether the following character is alphanumeric; if it is, the
        non-interpolating sequence produces a compile-time error. If the
        character is non-alphanumeric, the backslash is silently removed, on
        the assumption that the string was erroneously backslashed by an
        overenthusiastic algorithm or programmer.
    2.  All other quoting forms (including standard single quotes) assume
        that non-interpolating sequences are to be left unaltered because
        they are probably intended to pass through to the result.
        Backslashes are removed *only* for the terminating quote or for
        characters that would interpolate if unbackslashed. (In either case,
        a special exception is made for brackets; if the left bracket would
        interpolate, the right bracket may optionally also be backslashed,
        and if so, the backslash will be removed. If brackets are used as
        the delimiters, both left and right *must* be backslashed the same,
        since they would otherwise be counted wrong in the bracket count.)
    As a consequence, these all produce the same literal string:
        " \{ this is not a closure } "
        " \{ this is not a closure \} "
        q:c / \{ this is not a closure } /
        q:c / \{ this is not a closure \} /
        q:c { \{ this is not a closure \} }
        q { { this is not a closure } }
        q { \{ this is not a closure \} }
    (Of course, matching backslashes is likely to make your syntax
    highlighter a bit happier, along with any other naïve bracket counting
    algorithms...)
  Bare identifiers
    There are no barewords in Perl 6. An undeclared bare identifier will
    always be taken to mean a subroutine name, and be parsed as a list
    operator. (Class names (and other type names) are predeclared, or
    prefixed with the "::" type sigil when you're declaring a new one.) A
    consequence of this is that there's no longer any ""use strict 'subs'"".
    Since the syntax for method calls is distinguished from sub calls, it is
    only unrecognized sub calls that must be treated specially.
    You still must declare your subroutines, but a bareword with an
    unrecognized name is provisionally compiled as a subroutine call, on the
    assumption that such a declaration will occur by the end of the current
    compilation unit:
        foo;         # provisional call if neither &foo nor ::foo is defined so far
        foo();       # provisional call if &foo is not defined so far
        foo($x);     # provisional call if &foo is not defined so far
        foo($x, $y); # provisional call if &foo is not defined so far
        $x.foo;      # not a provisional call; it's a method call on $x
        foo $x:;     # not a provisional call; it's a method call on $x
        foo $x: $y;  # not a provisional call; it's a method call on $x
    If a postdeclaration is not seen, the compile fails at "CHECK" time,
    that is, at the end of compilation for this compilation unit. (You are
    still free to predeclare subroutines explicitly, of course.) The
    postdeclaration may be in any lexical or package scope that could have
    made the declaration visible to the provisional call had the declaration
    occurred before rather than after the provisional call.
    This fixup is done only for provisional calls. If there is *any* real
    predeclaration visible, it always takes precedence.
    If the unrecognized subroutine name is followed by "postcircumfix:<(
    )>", it is compiled as a provisional function call of the parenthesized
    form. If it is not, it is compiled as a provisional function call of the
    list operator form, which may or may not have an argument list. When in
    doubt, the attempt is made to parse an argument list. As with any list
    operator, an immediate postfix operator is illegal unless it is a form
    of parentheses, whereas anything following whitespace will be
    interpreted as an argument list if possible.
    Some examples of how listops, methods and labels interact syntactically:
        foo.bar             # foo().bar
        foo .bar            # foo($_.bar)   -- no postfix starts with whitespace
        foo\ .bar           # foo().bar
        foo++               # foo()++
        foo 1,2,3           # foo(1,2,3)    -- args always expected after listop
        foo + 1             # foo(+1)       -- term always expected after listop
        foo;                # foo();        -- no postfix, but no args either
        foo:                #   label       -- must be label at statement boundary.
                                            -- ILLEGAL otherwise
        foo: bar:           #   two labels in a row, okay
        .foo: 1             # $_.foo: 1     -- must be "dot" method with : args
        .foo(1)             # $_.foo(1)     -- must be "dot" method with () args
        .foo                # $_.foo()      -- must be "dot" method with no args
        .$foo: 1            # $_.$foo: 1    -- indirect "dot" method with : args
        foo bar: 1          # bar.foo(1)    -- bar must be predecl as class
                                            -- sub bar allowed here only if 0-ary
                                            -- otherwise you must say (bar):
        foo bar 1           # foo(bar(1))   -- both subject to postdeclaration
                                            -- never taken as indirect object
        foo $bar: 1         # $bar.foo(1)   -- indirect object even if declared sub
                                            -- $bar considered one token
        foo (bar()): 1      # bar().foo(1)  -- even if foo declared sub
        foo bar():          # ILLEGAL       -- bar() is two tokens.
        foo .bar:           # foo(.bar:)    -- colon chooses .bar to listopify
        foo bar baz: 1      # foo(baz.bar(1)) -- colon controls "bar", not foo.
        foo (bar baz): 1    # bar(baz()).foo(1) -- colon controls "foo"
        $foo $bar           # ILLEGAL       -- two terms in a row
        $foo $bar:          # ILLEGAL       -- use $bar."$foo"() for indirection
        (foo bar) baz: 1    # ILLEGAL       -- use $baz.$(foo bar) for indirection
    The indirect object colon only ever dominates a simple term, where
    "simple" includes classes and variables and parenthesized expressions,
    but explicitly not method calls, because the colon will bind to a
    trailing method call in preference. An indirect object that parses as
    more than one token must be placed in parentheses, followed by the
    colon.
    In short, only an identifier followed by a simple term followed by a
    postfix colon is *ever* parsed as an indirect object, but that form will
    *always* be parsed as an indirect object regardless of whether the
    identifier is otherwise declared.
  Dereferences
    There's also no ""use strict 'refs'"" because symbolic dereferences are
    now syntactically distinguished from hard dereferences. "@($array)" must
    now provide an actual array object, while "@::($string)" is explicitly a
    symbolic reference. (Yes, this may give fits to the P5-to-P6 translator,
    but I think it's worth it to separate the concepts. Perhaps the symbolic
    ref form will admit real objects in a pinch.)
  Hash subscripts and bare keys
    There is no hash subscript autoquoting in Perl 6. Use "%x<foo>" for
    constant hash subscripts, or the old standby %x{'foo'}. (It also works
    to say "%x«foo»" as long as you realized it's subject to interpolation.)
    But "=>" still autoquotes any bare identifier to its immediate left
    (horizontal whitespace allowed but not comments). The identifier is not
    subject to keyword or even macro interpretation. If you say
        $x = do {
            call_something();
            if => 1;
    then $x ends up containing the pair "("if" => 1)". Always. (Unlike in
    Perl 5, where version numbers didn't autoquote.)
    You can also use the ":key($value)" form to quote the keys of option
    pairs. To align values of option pairs, you may use the "unspace"
    postfix forms:
        :longkey\  ($value)
        :shortkey\ <string>
        :fookey\   { $^a <=> $^b }
    These will be interpreted as
        :longkey($value)
        :shortkey<string>
        :fookey{ $^a <=> $^b }
  Double-underscore forms
    The double-underscore forms are going away:
        Old                 New
        ---                 ---
        __LINE__            $?LINE
        __FILE__            $?FILE
        __PACKAGE__         $?PACKAGE
        __SUB__             &?ROUTINE
        __END__             =begin finish
        __DATA__            =begin data
    The "=begin finish" Pod stream (usually written as just "=finish") is
    special in that it assumes there's no corresponding "=end finish" before
    end of file. Anything in a source file after a "=finish" is always
    treated as Pod.
    There is no longer any special "DATA" stream--any Pod block in the
    current file can be accessed via a Pod object, such as "$=data" or
    "$=SYNOPSIS" or "$=UserBlock" etc. That is: a variable with the same
    name of the desired block, and a "=" twigil.
    These Pod objects can be used as "Positional"s (indexed by their block
    sequence). They can also be treated as "Associative"s (indexed by ":key"
    options specified with the block). Either way, each "Positional" or
    "Associative" element represents the entire contents of the
    corresponding Pod block. You have to split those contents into lines
    yourself. Each chunk has a ".range" property that indicates its line
    number range within the source file.
    [Speculative] It may also be possible to treat a Pod object as an
    IO::Handle, to read the Pod information line-by-line (like the "DATA"
    filehandle in Perl 5, but for *any* Pod block).
    The lexical routine itself is "&?ROUTINE"; you can get its name with
    "&?ROUTINE.name". The current block is "&?BLOCK". If the block has any
    labels, those shows up in "&?BLOCK.labels". Within the lexical scope of
    a statement with a label, the label is a pseudo-object representing the
    *dynamically* visible instance of that statement. (If inside multiple
    dynamic instances of that statement, the label represents the innermost
    one.) This is known as *lexotic* semantics.
    When you say:
        next LINE;
    it is really a method on this pseudo-object, and
        LINE.next;
    would work just as well. You can exit any labeled block early by saying
        MyLabel.leave(@results);
  Heredocs
    Heredocs are no longer written with "<<", but with an adverb on any
    other quote construct:
        print qq:to/END/;
            Give $amount to the man behind curtain number $curtain.
            END
    Other adverbs are also allowed, as are multiple heredocs within the same
    expression:
        print q:c:to/END/, q:to/END/;
            Give $100 to the man behind curtain number {$curtain}.
            Here is a $non-interpolated string
   Optional whitespace
    Heredocs allow optional whitespace both before and after terminating
    delimiter. Leading whitespace equivalent to the indentation of the
    delimiter will be removed from all preceding lines. If a line is deemed
    to have less whitespace than the terminator, only whitespace is removed,
    and a warning may be issued. (Hard tabs will be assumed to align to the
    next multiple of "($?TABSTOP // 8)" spaces, but as long as tabs and
    spaces are used consistently that doesn't matter.) A null terminating
    delimiter terminates on the next line consisting only of whitespace, but
    such a terminator will be assumed to have no indentation. (That is, it's
    assumed to match at the beginning of any whitespace.)
   One-pass heredoc parsing
    There are two possible ways to parse heredocs. One is to look ahead for
    the newline and grab the lines corresponding to the heredoc, and then
    parse the rest of the original line. This is how Perl 5 does it.
    Unfortunately this suffers from the problem pervasive in Perl 5 of
    multi-pass parsing, which is masked somewhat because there's no way to
    hide a newline in Perl 5. In Perl 6, however, we can use "unspace" to
    hide a newline, which means that an algorithm looking ahead to find the
    newline must do a full parse (with possible untoward side effects) in
    order to locate the newline.
    Instead, Perl 6 takes the one-pass approach, and just lazily queues up
    the heredocs it finds in a line, and waits until it sees a "real"
    newline to look for the text and attach it to the appropriate heredoc.
    The downside of this approach is a slight restriction--you may not use
    the actual text of the heredoc in code that must run before the line
    finishes parsing. Mostly that just means you can't write:
        BEGIN { say q:to/END/ }; morestuff();
            Say me!
    You must instead put the entire heredoc into the "BEGIN":
        BEGIN {
            say q:to/END/;
        }; morestuff();
    The parser is, however, smart enough to recognize that it's already at
    the end of a line if you don't put "morestuff()" there. Hence this
    works:
        BEGIN { say q:to/END/ }
  Version literals
    A version literal is written with a 'v' followed by the version number
    in dotted form. This always constructs a "Version" object, not a string.
    Only integers and certain wildcards are allowed; for anything fancier
    you must coerce a string to a "Version":
        v1.2.3                      # okay
        v1.2.*                      # okay, wildcard version
        v1.2.3+                     # okay, wildcard version
        v1.2.3beta                  # illegal
        Version('1.2.3beta')        # okay
    Note though that most places that take a version number in Perl accept
    it as a named argument, in which case saying ":ver<1.2.3beta>" is fine.
    See S11 for more on using versioned modules.
    Version objects have a predefined sort order that follows most people's
    intuition about versioning: each sorting position sorts numerically
    between numbers, alphabetically between alphas, and alphabetics in a
    position before numerics. Missing final positions are assumed to be
    '.0'. Except for '0' itself, numbers ignore leading zeros. For splitting
    into sort positions, if any alphabetics (including underscore) are
    immediately adjacent to a number, a dot is assumed between them.
    Likewise any non-alphanumeric character is assumed to be equivalent to a
    dot. So these are all equivalent:
        1.2.1alpha1.0
        1.2.1alpha1
        1.2.1.alpha1
        1.2.1alpha.1
        1.2.1.alpha.1
        1.2-1+alpha/1
    And these are also equivalent:
        1.2.1_01
        1.2.1_1
        1.2.1._1
        1.2.1._.1
        001.0002.0000000001._.00000000001
        1.2.1._.1.0.0.0.0.0
    So these are in sorted version order:
        1.2.0.999
        1.2.1_2
        1.2.1_003
        1.2.1a1
        1.2.1b1
        1.2.1.beta1
        1.2.1.gamma
        1.2.1α1
        1.2.1β1
        1.2.1γ
        1.2.1
    Note how the last pair assume that an implicit .0 sorts after anything
    alphabetic, and that alphabetic is defined according to Unicode, not
    just according to ASCII. The intent of all this is to make sure that
    prereleases sort before releases. Note also that this is still a subset
    of the versioning schemes seen in the real world. Modules with such
    strange versions can still be used by Perl since by default Perl imports
    external modules by exact version number. (See S11.) Only range
    operations will be compromised by an unknown foreign collation order,
    such as a system that sorts "delta" before "gamma".
  Allomorphic value semantics
    When "val()" processing is attempted on any list of strings (typically
    on the individual words within angle brackets), the function attempts to
    determine if the intent of the programmer or user might have been to
    provide a numeric value.
    For any item in the list that appears to be numeric, the literal is
    stored as an object with both a string and a numeric nature, where the
    string nature always returns the original string. This is implemented
    via multiple inheritance, to truly represent the allomorphic nature of a
    literal value that has not committed to which type the user intends. The
    numeric type chosen depends on the appearance of the literal. Hence:
        < 1 1/2 6.02e23 1+2i >
    produces objects of classes defined as:
        class IntStr is Int is Str {...}; IntStr('1')
        class RatStr is Rat is Str {...}; RatStr('1/2')
        class NumStr is Num is Str {...}; NumStr('6.02e23')
        class ComplexStr is Complex is Str {...}; ComplexStr('1+2i')
    One purpose of this is to facilitate compile-time analysis of
    multi-method dispatch, when the user prefers angle notation as the most
    readable way to represent a list of numbers, which it often is. Due to
    the MI semantics, the new object is equally a string and a number, and
    can be bound as-is to either a string or a numeric parameter.
    In case multiple dispatch determines that it could dispatch as either
    string or number, a tie results, which may result in an ambiguous
    dispatch error. You'll need to use prefix "+" or "~" on the argument to
    resolve the ambiguity in that case.
    [Conjecture: we may someday find a way to make strings bind a little
    looser than the numeric types, but for now we conservatively outlaw the
    dispatch as ambiguous, and watch how this plays out in use.]
    The allomorphic behavior of angle brackets is not a special case; it's
    actually an example of a more general process of figuring out type
    information by parsing text that comes from any situation where the user
    is forced to enter text when they really mean other kinds of values. A
    function prompting the user for a single value might usefully pass the
    result through "val()" to intuit the proper type.
    The angle form with a single value serves as the literal form of numbers
    such as "Rat" and "Complex" that would otherwise have to be constructed
    via constant folding. It also gives us a reasonable way of visually
    isolating any known literal format as a single syntactic unit:
        <-1+2i>.polar
        (-1+2i).polar       # same, but only by constant folding
    Any such literal, when written without spaces, produces a pure numeric
    value without a stringy allomorphism. Put spaces to override that:
        <1/2>       # a Rat
        < 1/2 >     # a RatStr
    Or use the "«»" form of quotewords, which is always allomorphic:
        «1/2»       # a RatStr
        « 1/2 »     # a RatStr
   Allomorphic Rats
    Any rational literal that would overflow a "Rat64" in the denominator is
    also stored as a string. (That is, angle brackets will be assumed in
    this case, producing a "RatStr".) If a coercion to a wider type, such as
    "FatRat", is requested, the literal reconverts from the entire original
    string, rather than just the value that would fit into a "Rat64". (It
    may then cache that converted value for next time, of course.) So if you
    declare a constant with excess precision, it does not automatically
    become a "FatRat", which would force all calculations into the pessimal
    "FatRat" type.
        constant pi is export = 3.14159_26535_89793_23846_26433_83279_50288;
        say pi.norm.nude # 1570796326794896619 500000000000000000 (as Rat, reduced)
        say pi.perl;     # 3.14159_26535_89793_23846_26433_83279_50288
        say pi.Num       # 3.14159265358979 (approximately)
        say pi.Str;      # 3.14159_26535_89793_23846_26433_83279_50288
        say pi.FatRat;   # 3.14159265358979323846264338327950288
Context
    *   Perl still has the three main contexts: sink (aka void), item (aka
        scalar), and list.
    *   In addition to undifferentiated items, we also have these item
        contexts:
            Context     Type    OOtype   Operator
            -------     ----    ------   --------
            boolean     bit     Bit      ?
            integer     int     Integral int
            numeric     num     Num      +
            string      buf     Str      ~
        There are also various container contexts that require particular
        kinds of containers (such as slice and hash context; see S03 for
        details).
    *   Unlike in Perl 5, objects are no longer always considered true. It
        depends on the state of their ".Bool" method, which may either be a
        synthetic attribute or an explicitly represented bit in the object.
        Classes get to decide which of their values are true and which are
        false. In general, most classes choose a single distinguished value
        to be false but defined, such as 0 for the various numeric types, or
        the empty string for string types. Individual objects can override
        the class definition:
            return 0 but True;
        This overrides the ".Bool" method of the 0 without changing its
        official type (by mixing the method into an anonymous derived type).
    *   The definition of ".Bool" for the most ancestral type (that is, the
    *   In general any container types should return false if they are
        empty, and true otherwise. This is true of all the standard
        container types except Scalar, which always defers the definition of
        truth to its contents. Non-container types define truthiness much as
        Perl 5 does, except that the string "0" is now considered true.
        Coerce to numeric with "<prefix:<+" >> if you want the other
        Just as with the standard types, user-defined types should feel free
        to partition their defined values into true and false values if such
        a partition makes sense in control flow using boolean contexts.
Lists
  Lazy flattening
    List context in Perl 6 is by default lazy. This means a list can contain
    infinite generators without blowing up. No flattening happens to a lazy
    list until it is bound to the signature of a function or method at call
    time (and maybe not even then). We say that such an argument list is
    "lazily flattened", meaning that we promise to flatten the list on
    demand, but not before.
  "list", "flat", "item", and ".tree"
    There is a ""list"" operator which imposes a list context on its
    arguments even if "list" itself occurs in item context.
    To force explicit flattening, use the "flat" contextualizer. This
    recursively flattens all lists into a 1-dimensional list. When bound to
    a slurpy parameter, a capture flattens the rest of its positional
    arguments.
    To reform a list so that sub-lists turn into tree nodes, use the ".tree"
    method, which is essentially a level-sensitive "map", with one closure
    provided for remapping the lists at each level:
        $p.tree                # recursively set all levels to item
        $p.tree(*)             # same thing
        $p.tree(*.item)        # force level 1 lists to item
        $p.tree(1)             # same thing
        $p.tree(*.item,*.list) # force level 1 lists to item, level 2 to list
        $p.tree(*.Array,*)     # Turn all sublists into item recursively
    When bound to a slice parameter (indicated with "**"), a capture reforms
    the rest of its positional arguments with one level of "treeness",
    equivalent to "@args.tree(1)", that is, a list of lists, or "LoL". The
    sublists are not automatically flattened; that is, if a sublist is a
    "List", it remains a list until subsequent processing decides how flat
    or treelike the sublist should be.
    To force a non-flattening item context, use the ""item"" operator.
  Forcing capture context
    The "|" prefix operator may be used to force "capture" context on its
    argument and *also* defeat any scalar argument checking imposed by
    subroutine signature declarations. Any resulting list arguments are then
    evaluated lazily.
  The "eager" operator
    To force non-lazy list processing, use the "eager" list operator. List
    assignment is also implicitly eager. (Actually, when we say "eager" we
    usually mean "mostly eager" as defined in S07).
        eager $filehandle.lines;    # read all remaining lines
    By contrast,
        $filehandle.lines;
    makes no guarantee about how many lines ahead the iterator has read.
    Iterators feeding a list are allowed to process in batches, even when
    stored within an array. The array knows that it is extensible, and calls
    the iterator as it needs more elements. (Counting the elements in the
    array will also force eager completion.)
    This operator is agnostic towards flattening or slicing. It merely
    changes the work-ahead policy for the value generator.
  The "hyper" operator
    A variant of "eager" is the "hyper" list operator, which declares not
    only that you want all the values generated now, but that you want them
    badly enough that you don't care what order they're generated in, as
    long as the results come back in the right order. That is, "eager"
    requires sequential evaluation of the list, while "hyper" requests (but
    does not require) parallel evaluation. In any case, it declares that you
    don't care about the evaluation order, only the result order.
  The "race" operator
    A further variant of "hyper" is the "race" list operator, which declares
    that you want the results so badly that you don't even care what order
    they come back in. Within its arguments, the "race" operator forces
    parallel evaluation of any iterator, hyper, or junction, such that if
    any single thread dies or hangs its computation, it does not block any
    other thread from returning its results to the race list. When the
    demand for the race list drops, hung threads may be killed. You can
    think of it as a "gather" with a '"try take start {...}"' on parallel
    computation. Note that exceptions are trapped by default; if your car
    crashes, you simply do not finish the race. If you want notifications of
    some sort back to the pit crew, you'll have to arrange them yourself.
    changes the work-ahead policy for the value generator. It is a
    transitive contextualizer insofar as iterators will have to pass on the
    policy to subiterators.
  The "=>" operator
    The "=>" operator now constructs "Pair" objects rather than merely
    functioning as a comma. Both sides are in item context.
  The ".." operator
    The ".." operator now constructs a "Range" object rather than merely
    functioning as an operator. Both sides are in item context.
    Semantically, the "Range" acts like a list of its values to the extent
    possible, but does so lazily, unlike Perl 5's eager range operator.
  Hash assignment
    There is no such thing as a hash list context. Assignment to a hash
    produces an ordinary list context. You may assign alternating keys and
    values just as in Perl 5. You may also assign lists of "Pair" objects,
    in which case each pair provides a key and a value. You may, in fact,
    mix the two forms, as long as the pairs come when a key is expected. If
    you wish to supply a "Pair" as a key, you must compose an outer "Pair"
    in which the key is the inner "Pair":
        %hash = (($keykey => $keyval) => $value);
  The anonymous "enum" function
    The anonymous "enum" function takes a list of keys or pairs, and adds
    values to any keys that are not already part of a pair. The value added
    is one more than the previous key or pair's value. This works nicely
    with the new "qq:ww" form:
        %hash = enum <<:Mon(1) Tue Wed Thu Fri Sat Sun>>;
        %hash = enum « :Mon(1) Tue Wed Thu Fri Sat Sun »;
    are the same as:
        %hash = ();
        %hash<Mon Tue Wed Thu Fri Sat Sun> = 1..7;
  Hash binding
    In contrast to assignment, binding to a hash requires a "Hash" (or
    "Pair") object, or anything that does the "Associative" role.
Files
    *   Filename globs are no longer done with angle brackets. Use the
        "glob" function.
    *   Input from a filehandle is no longer done with angle brackets.
        Instead of
            while (<HANDLE>) {...}
        you now write
            for $handle.lines {...}
Grammatical Categories
    Lexing in Perl 6 is controlled by a system of grammatical categories. At
    each point in the parse, the lexer knows which subset of the grammatical
    categories are possible at that point, and follows the longest-token
    rule across all the active alternatives, including those representing
    any grammatical categories that are ready to match. See S05 for a
    detailed description of this process.
    To get a list of the current categories, grep 'token category:' from
    STD.pm6.
    Category names are used as the short name of both various operators and
    the rules that parse them, though the latter include an extra "sym":
        infix:<cmp>           # the infix cmp operator
        infix:sym<cmp>        # the rule that parses cmp
    As you can see, the extension of the name uses colon pair notation. The
    ":sym" typically takes an argument giving the string name of the
    operator; some of the "circumfix" categories require two arguments for
    the opening and closing strings. Since there are so many match rules
    whose symbol is an identifier, we allow a shorthand:
        infix:cmp             # same as infix:sym<cmp> (not infix:<cmp>)
    Conjecturally, we might also have other kinds of rules, such as tree
    rewrite rules:
        infix:match<cmp>      # rewrite a match node after reducing its arguments
        infix:ast<cmp>        # rewrite an ast node after reducing its arguments
    Within a grammar, matching the proto subrule "<infix>" will match all
    visible rules in the infix category as parallel alternatives, as if they
    were separated by '"|"'.
    Here are some of the names of parse rules in STD:
        category:sym<prefix>                           prefix:<+>
        circumfix:sym<[ ]>                             [ @x ]
        dotty:sym<.=>                                  $obj.=method
        infix_circumfix_meta_operator:sym['»','«']     @a »+« @b
        infix_postfix_meta_operator:sym<=>             $x += 2;
        infix_prefix_meta_operator:sym<!>              $x !~~ 2;
        infix:sym<+>                                   $x + $y
        package_declarator:sym<role>                   role Foo;
        postcircumfix:sym<[ ]>                         $x[$y] or $x.[$y]
        postfix_prefix_meta_operator:sym('»')          @array »++
        postfix:sym<++>                                $x++
        prefix_circumfix_meta_operator:sym<[ ]>       [*]
        prefix_postfix_meta_operator:sym('«')          -« @magnitudes
        prefix:sym<!>                                  !$x (and $x.'!')
        quote:sym<qq>                                  qq/foo/
        routine_declarator:sym<sub>                    sub foo {...}
        scope_declarator:sym<has>                      has $.x;
        sigil:sym<%>                                   %hash
        special_variable:sym<$!>                       $!
        statement_control:sym<if>                      if $condition { 1 } else { 2 }
        statement_mod_cond:sym<if>                     .say if $condition
        statement_mod_loop:sym<for>                    .say for 1..10
        statement_prefix:sym<gather>                   gather for @foo { .take }
        term:sym<!!!>                                  $x = { !!! }
        trait_mod:sym<does>                            my $x does Freezable
        twigil:sym<?>                                  $?LINE
        type_declarator:sym<subset>                    subset Nybble of Int where ^16
    Note that some of these produce correspondingly named operators, but not
    all of them. When they do correspond (such as in the "cmp" example
    above), this is by convention, not by enforcement. (However, matching
    "<sym>" within one of these rules instead of the literal operator makes
    it easier to set up this correspondence in subsequent processing.)
    The STD::Regex grammar also adds these:
        assertion:sym<!>                         /<!before \h>/
        backslash:sym<w>                         /\w/ and /\W/
        metachar:sym<.>                          /.*/
        mod_internal:sym<P5>                     m:/ ... :P5 ... /
        quantifier:sym<*>                        /.*/
Deprecations
    A language that doesn't evolve, is a dead language. Constructs that seem
    like a good idea now, may turn out not to be such a good idea in the
    future. Such constructs will thus need to be deprecated. To mark a
    construct as being deprecated, one can add the "is
    DEPRECATED($alternative)" trait to a class, an attribute, or a sub /
    method. During execution, this will cause the caller sites to be
    recorded without any warnings. When execution finishes, a report should
    be printed to STDERR stating which deprecated features where called
    where.
    Synopsis 3: Operators
        Created: 8 Mar 2004
        Version: 288
    For a summary of the changes from Perl 5, see "Changes to Perl 5
    operators".
Operator precedence
    Perl 6 has about the same number of precedence levels as Perl 5, but
    they're differently arranged in spots. Here we list the levels from
    "tightest" to "loosest", along with a few examples of each level.
    (Column 'A' is for "associativity", see following table.)
        A  Level             Examples
        =  =====             ========
        O  Terms             42 3.14 "eek" qq["foo"] $x :!verbose @$array
        L  Method postfix    .meth .+ .? .* .() .[] .{} .<> .«» .:: .= .^ .: i
        N  Autoincrement     ++ --
        R  Exponentiation    **
        L  Symbolic unary    ! + - ~ ? | || +^ ~^ ?^ ^
        L  Multiplicative    * / % %% +& +< +> ~& ~< ~> ?& div mod gcd lcm
        L  Additive          + - +| +^ ~| ~^ ?| ?^
        L  Replication       x xx
        X  Concatenation     ~
        X  Junctive and      & (&) ∩
        X  Junctive or       | ^ (|) (^) ∪ (-)
        L  Named unary       temp let
        N  Structural infix  but does <=> leg cmp .. ..^ ^.. ^..^
        C  Chaining infix    != == < <= > >= eq ne lt le gt ge ~~ === eqv !eqv (<) (elem)
        X  Tight and         &&
        X  Tight or          || ^^ // min max
        R  Conditional       ?? !! ff fff
        R  Item assignment   = => += -= **= xx= .=
        L  Loose unary       so not
        X  Comma operator    , :
        X  List infix        Z minmax X X~ X* Xeqv ...
        R  List prefix       print push say die map substr ... [+] [*] any Z=
        X  Loose and         and andthen notandthen
        X  Loose or          or xor orelse
        X  Sequencer         <== ==> <<== ==>>
        O  Terminator        ; {...} unless extra ) ] }
    Using two "!" symbols below generically to represent any pair of
    operators that have the same precedence, the associativities specified
    above for binary operators are interpreted as follows:
            Assoc     Meaning of $a ! $b ! $c
            =====     =========================
        L   left      ($a ! $b) ! $c
        R   right     $a ! ($b ! $c)
        N   non       ILLEGAL
        C   chain     ($a ! $b) and ($b ! $c)
        X   list      infix:<!>($a; $b; $c)
        O   N/A       (not really an operator)
    For unaries this is interpreted as:
            Assoc     Meaning of !$a!
        L   left      (!$a)!
        R   right     !($a!)
    (In standard Perl there are no unaries that can take advantage of
    associativity, since at each precedence level the standard operators are
    either consistently prefix or postfix.)
    Note that list associativity (X) only works between identical operators.
    If two different list-associative operators have the same precedence,
    they are assumed to be non-associative with respect to each other, and
    parentheses must be used to disambiguate.
    For example, the "X" cross operator and the "Z" zip operator both have a
    precedence of "list infix", but:
        @a X @b Z @c
    is illegal and must be written as either of:
        (@a X @b) Z @c
        @a X (@b Z @c)
    If the only implementation of a list-associative operator is binary, it
    will be treated as right associative.
    The standard precedence levels attempt to be consistent in their
    associativity, but user-defined operators and precedence levels may mix
    right and left associative operators at the same precedence level. If
    two conflicting operators are used ambiguously in the same expression,
    the operators will be considered non-associative with respect to each
    other, and parentheses must be used to disambiguate.
    If you don't see your favorite operator above, the following sections
    cover all the operators in precedence order. Basic operator descriptions
    are here; special topics are covered afterwards.
  Term precedence
    This isn't really a precedence level, but it's in here because no
    operator can have tighter precedence than a term. See S02 for longer
    descriptions of various terms. Here are some examples.
    *   "Int" literal
            42
    *   "Num" literal
            3.14
    *   Non-interpolating "Str" literal
            '$100'
    *   Interpolating "Str" literal
            "Answer = $answer\n"
    *   Generalized "Str" literal
            q["$100"]
            qq["$answer"]
    *   Heredoc
            qq:to/END/
                Dear $recipient:
                Thanks!
                Sincerely,
                $me
                END
    *   Array composer
            [1,2,3]
        Provides list context inside. (Technically, it really provides a
        "semilist" context, which is a semicolon-separated list of
        statements, each of which is interpreted in list context; if there
        is only one statement, it makes a 1-dimensional array, but if there
        are more, it makes a 2-dimensional array instead.)
    *   Hash composer
            { }
            { a => 42 }
        Inside must be either empty, or a single list starting with a pair
        or a hash, otherwise you must use "hash()" or "%()" instead.
        By default a hash forces all its keys to be strings. To compose a
        hash that allows arbitrary objects (such as numbers) as keys, add a
        colon on front:
            :{ }
            :{ -1 => 41, 0 => 42, 1 => 43 }
        Note that with objects as keys, you cannot access non-string keys as
        strings:
            :{ -1 => 41, 0 => 42, 1 => 43 }<0>  # Any
            :{ -1 => 41, 0 => 42, 1 => 43 }{0}  # 42
    *   Closure
            { ... }
        When found where a statement is expected, executes immediately.
        Otherwise always defers evaluation of the inside scope.
    *   Capture composer
            \(@a,$b,%c)
        An abstraction representing an argument list that doesn't yet know
        its context.
    *   Sigiled variables
            $x
            @y
            %z
            $^a
            $?FILE
            &func
            &div:(Int, Int --> Int)
    *   Sigils as contextualizer functions
            $()
            @()
            %()
            &()
    *   Regexes in quote-like notation
            /abc/
            rx:i[abc]
            s/foo/bar/
    *   Transliterations
            tr/a..z/A..Z/
        Note ranges use ".." rather than "-".
    *   Type names
            Num
            ::Some::Package
    *   Subexpressions circumfixed by parentheses
            (1+2)
        Parentheses are parsed on the inside as a semicolon-separated list
        of statements, which (unlike the statements in a block) returns the
        results of all the statements concatenated together as a "List" of
        "List". How that is subsequently treated depends on its eventual
        binding.
    *   Function call with parens:
            a(1)
        In term position, any identifier followed immediately by a
        parenthesized expression is always parsed as a term representing a
        function call even if that identifier also has a prefix meaning, so
        you never have to worry about precedence in that case. Hence:
            not($x) + 1         # means (not $x) + 1
    *   Pair composers
            :limit(5)
            :!verbose
    *   Signature literal
            :(Dog $self:)
    *   Method call with implicit invocant
            .meth       # call on $_
            .=meth      # modify $_
        Note that this may occur only where a term is expected. Where a
        postfix is expected, it is a postfix. If only an infix is expected
        (that is, after a term with intervening whitespace), ".meth" is a
        syntax error. (The ".=meth" form is allowed there only because there
        is a special ".=" infix assignment operator that is equivalent in
        semantics to the method call form but that allows whitespace between
        the "=" and the method name.)
    *   Listop (leftward)
            4,3, sort 2,1       # 4,3,1,2
        As in Perl 5, a list operator looks like a term to the expression on
        its left, so it binds tighter than comma on the left but looser than
        comma on the right--see List prefix precedence below.
  Method postfix precedence
    All method postfixes (except for "i") start with a dot, though the dot
    is optional for subscripts. Since these are the tightest standard
    operator, you can often think of a series of method calls as a single
    term that merely expresses a complicated name.
    See S12 for more discussion of single dispatch method calls.
    *   Standard single-dispatch method calls
            $obj.meth
    *   Variants of standard single-dispatch method call
            $obj.+meth
            $obj.?meth
            $obj.*meth
        In addition to the ordinary "." method invocation, there are
        variants ".*", ".?", and ".+" to control how multiple related
        methods of the same name are handled.
    *   Class-qualified method call
            $obj.::Class::meth
            $obj.Class::meth    # same thing, assuming Class is predeclared
        As in Perl 5, tells the dispatcher which class to start searching
        from, not the exact method to call.
    *   Mutating method call
            $obj.=meth
        The ".=" operator does inplace modification of the object on the
        left.
    *   Meta-method call
            $obj.^meth
        The ".^" operator calls a class metamethod; "foo.^bar" is short for
        "foo.HOW.bar(foo)".
    *   Method-like postcircumfixes
            $routine.()
            $array.[]
            $hash.{}
            $hash.<>
            $hash.«»
        The dotless forms of these have exactly the same precedences.
    *   Dotted form of any other postfix operator
            $x.++         # postfix:<++>($x)
    *   Dotted postfix form of any other prefix operator
            $x.:<++>       # prefix:<++>($x)
    *   Imaginary number postfix
            42i
            $foo\i
        The only operator on this level that does not start with a dot.
        Turns a number into a purely-imaginary number (a "Complex" with a
        zero real part). Must be backslashed if after a name, including
        "Inf" and "NaN".
    *   There is specifically no "infix:<.>" operator, so
            $foo . $bar
        will always result in a compile-time error indicating the user
        should use "infix:<~>" instead. This is to catch an error likely to
        be made by Perl 5 programmers learning Perl 6.
  Autoincrement precedence
    As in C, these operators increment or decrement the object in question
    either before or after the value is taken from the object, depending on
    whether it is put before or after. Also as in C, multiple references to
    a single mutating object in the same expression may result in undefined
    behavior unless some explicit sequencing operator is interposed. See
    "Sequence points".
    As with all postfix operators in Perl 6, no space is allowed between a
    term and its postfix. See S02 for why, and for how to work around the
    restriction with an "unspace".
    As mutating methods, all these operators dispatch to the type of the
    operand and return a result of the same type, but they are legal on
    value types only if the (immutable) value is stored in a mutable
    container. However, a bare undefined value (in a suitable "Scalar"
    container) is allowed to mutate itself into an "Int" in order to support
    the common idiom:
        say $x unless %seen{$x}++;
    Increment of a "Str" (in a suitable container) works similarly to Perl
    5, but is generalized slightly. A scan is made for the final
    alphanumeric sequence in the string that is not preceded by a '.'
    character. Unlike in Perl 5, this alphanumeric sequence need not be
    anchored to the beginning of the string, nor does it need to begin with
    an alphabetic character; the final sequence in the string matching
    "<!after '.'> <rangechar>+" is incremented regardless of what comes
    before it.
    The "<rangechar>" character class is defined as that subset of
    characters that Perl knows how to increment within a range, as defined
    below.
    The additional matching behaviors provide two useful benefits: for its
    typical use of incrementing a filename, you don't have to worry about
    the path name or the extension:
        $file = "/tmp/pix000.jpg";
        $file++;            # /tmp/pix001.jpg, not /tmp/pix000.jph
    Perhaps more to the point, if you happen to increment a string that ends
    with a decimal number, it's likely to do the right thing:
        $num = "123.456";
        $num++;             # 124.456, not 123.457
    Character positions are incremented within their natural range for any
    Unicode range that is deemed to represent the digits 0..9 or that is
    deemed to be a complete cyclical alphabet for (one case of) a (Unicode)
    script. Only scripts that represent their alphabet in codepoints that
    form a cycle independent of other alphabets may be so used. (This
    specification defers to the users of such a script for determining the
    proper cycle of letters.) We arbitrarily define the ASCII alphabet not
    to intersect with other scripts that make use of characters in that
    range, but alphabets that intersperse ASCII letters are not allowed.
    If the current character in a string position is the final character in
    such a range, it wraps to the first character of the range and sends a
    "carry" to the position left of it, and that position is then
    incremented in its own range. If and only if the leftmost position is
    exhausted in its range, an additional character of the same range is
    inserted to hold the carry in the same fashion as Perl 5, so
    incrementing '(zz99)' turns into '(aaa00)' and incrementing '(99zz)'
    turns into '(100aa)'.
    The following Unicode ranges are some of the possible rangechar ranges.
    For alphabets we might have ranges like:
        A..Z        # ASCII uc
        a..z        # ASCII lc
        Α..Ω        # Greek uc
        α..ω        # Greek lc (presumably skipping C<U+03C2>, final sigma)
        א..ת        # Hebrew
          etc.      # (XXX out of my depth here)
    For digits we have ranges like:
        0..9        # ASCII
        ٠..٩        # Arabic-Indic
        ०..९        # Devangari
        ০..৯        # Bengali
        ੦..੯        # Gurmukhi
        ૦..૯        # Gujarati
        ୦..୯        # Oriya
          etc.
    Certain other non-script 0..9 ranges may also be incremented, such as
        ⁰..⁹        # superscripts (note, cycle includes latin-1 chars)
        ₀..₉        # subscripts
        ０..９      # fullwidth digits
    Ranges that are open-ended simply because Unicode has not defined
    codepoints for them (yet?) are counted as rangechars, but are
    specifically excluded from "carry" semantics, because Unicode may add
    those codepoints in the future. (This has already happened with the
    circled numbers, for instance!) For such ranges, Perl will pretend that
    the characters are contiguous for calculating successors and
    predecessors, and will fail if you run off of either end.
        Ⅰ..Ⅻ        # clock roman numerals uc
        ⅰ..ⅻ        # clock roman numerals lc
        ⓪..㊿       # circled digits/numbers 0..50
        ⒜..⒵        # parenthesized lc
        ⚀..⚅        # die faces 1..6
        ❶..❿        # dingbat negative circled 1..10
    Note: for actual ranges in Perl you'll need to quote the characters
    above:
        '⓪'..'㊿'   # circled digits/numbers 0..50
    If you want to future-proof the top end of your range against further
    Unicode additions, you may specify it as "whatever":
        '⓪'..*      # circled digits/numbers up to current known Unicode max
    Since these non-carrying ranges fail when they run out, it is
    recommended that you avoid non-carrying rangechars where, for instance,
    you need to keep generating unique filenames. It's much better to
    generate longer strings via carrying rangechars in such cases.
    Note that all character increments can be handled by lookup in a single
    table of successors since we've defined our ranges not to overlap.
    Anyway, back to string increment. Only rangechars may be incremented; we
    can't just increment unrecognized characters, because we have to locate
    the string's final sequence of rangechars before knowing which portion
    of the string to increment.
    Perl 6 also supports "Str" decrement with similar semantics, simply by
    running the cycles the other direction. However, leftmost characters are
    never removed, and the decrement fails when you reach a string like
    "aaa" or "000".
    Increment and decrement on non-"Str" types are defined in terms of the
    ".succ" and ".pred" methods on the type of object in the "Scalar"
    container. More specifically,
        ++$var
        --$var
    are equivalent to
        $var.=succ
        $var.=pred
    If the type does not support these methods, the corresponding increment
    or decrement operation will fail. (The optimizer is allowed to assume
    that the ordinary increment and decrement operations on integers will
    not be overridden.)
    Increment of a "Bool" (in a suitable container) turns it true. Decrement
    turns it false regardless of how many times it was previously
    incremented. This is useful if your %seen hash is actually a "SetHash",
    in which case decrement actually deletes the key from the "SetHash".
    Increment/decrement of an undefined "Numeric", "Cool", or "Any" variable
    sets the variable to 0 and then performs the increment/decrement. Hence
    a postincrement returns 0 the first time:
        my $x; say $x++;    # 0, not Any
    *   Autoincrement "prefix:<++>" or "postfix:<++>" operator
            $x++
            ++$x;
    *   Autodecrement "prefix:<-->" or "postfix:<-->" operator
            $x--
            --$x
  Exponentiation precedence
    *   "infix:<**>" exponentiation operator
            $x ** 2
        Unless the right argument is a non-negative integer the result is
        likely to be an approximation. If the right argument is of an
        integer type, exponentiation is at least as accurate as repeated
        multiplication on the left side's type. (From which it can be
        deduced that "Int**UInt" is always exact, since "Int" supports
        arbitrary precision. "Rat**UInt" is accurate to the precision of
        "Rat".) If the right argument is an integer represented in a
        non-integer type, the accuracy is left to implementation provided by
        that type; there is no requirement to recognize an integer to give
        it special treatment. (Coercion of an integer "Str" via "Cool" is
        likely to do the right thing, however.)
  Symbolic unary precedence
    *   "prefix:<?>", boolean context
            ?$x
        Evaluates the expression as a boolean and returns "True" if
        expression is true or "False" otherwise. See "so" below for a
        low-precedence alternative.
    *   "prefix:<!>", boolean negation
            !$x
        Returns the opposite of what "?" would. See "not" below for a
    *   "prefix:<+>", numeric context
            +$x
        Unlike in Perl 5, where "+" is a no-op, this operator coerces to
        numeric context in Perl 6. (It coerces only the value, not the
        original variable.) For values that do not already do the "Numeric"
        role, the narrowest appropriate type of "Int", "Rat", "Num", or
        "Complex" will be returned; however, string containing two integers
        separated by a "/" will be returned as a "Rat" (or a "FatRat" if the
        denominator overflows an "int64"). Exponential notation and radix
        notations are recognized.
        Only leading and trailing whitespace are allowed as extra
        characters; any other unrecognized character results in the return
        of a failure.
    *   "prefix:<->", numeric negation
            -$x
        Coerces to numeric and returns the arithmetic negation of the
        resulting number.
    *   "prefix:<~>", string context
            ~$x
        Coerces the value to a string, if it does not already do the
        "Stringy" role. (It only coerces the value, not the original
        variable.) As with numerics, it is guaranteed only to coerce to
        something "Stringy", not necessarily "Str".
    *   "prefix:<|>", flatten object into arglist
            | $capture
        Interpolates the contents of the "Capture" (or "Capture"-like) value
        into the current argument list as if they had been specified
        literally. If the first argument of the capture is marked as an
        invocant but is used in a context not expecting one, it is treated
        as an ordinary positional argument.
    *   "prefix:<||>", flatten object into semicolon list
            || $list
        Interpolates the elements of the "List" (or any other ordered or
        iterable value) into the current argument list as if they had been
        specified literally, separated by semicolons, that is, at the
        multi-dimensional level. It is an error to use this operator outside
        of a lol context; in other words it must be bound into a "**"
        (slice) parameter rather than a "*" (slurpy) parameter.
    *   "prefix:<+^>", numeric bitwise negation
            +^$x
        Coerces to "Int" and then does bitwise negation on the number,
        returning an "Int". (In order not to have to represent an infinitude
        of 1's, it represents that value as some negative in 2's complement
        form.)
    *   "prefix:<~^>", string bitwise negation
            ~^$x
        Coerces NFG strings to non-variable-encoding string buffer type
        (such as "buf8", "buf16", or "buf32") and then does negation
        (complement) on each bit of each integer element, returning a buffer
        of the same size as the input.
        The use of coercion probably indicates a design error, however. This
        operator is distinguished from numeric bitwise negation in order to
        provide bit vectors that extend on the right rather than the left
        (and always do unsigned extension).
    *   "prefix:<?^>", boolean negation
            ?^$x
        Coerces to boolean and then flips the bit. (Same as "!".)
    *   "prefix:<^>", upto operator
            ^$limit
        Constructs a range of "0 ..^ +$limit". See "Range and RangeIter
        semantics".
  Multiplicative precedence
    *   "infix:<*>"
            $x*$y
        Multiplication, resulting in the wider type of the two.
    *   "infix:</>"
            $numerator / $denominator
        Performs division of real or complex numbers, returning a real or
        complex number of appropriate type.
        If one of operands is of rational type, and the second operator is
        of integer or rational type, the operator returns the corresponding
        "Rat" value (except when the result does not fit into a "Rat", as
        detailed in S02).
        Otherwise, if either operand is of "Complex" type, converts both
        operands to "Complex" and does division returning "Complex".
        Otherwise, if either operand is of "Num" type, converts both
        operands to "Num" and does division returning "Num". If the
        denominator is zero, returns an object representing either "+Inf",
        "NaN", or "-Inf" as the numerator is positive, zero, or negative.
        (This is construed as the best default in light of the operator's
        possible use within hyperoperators and junctions. Note however that
        these are not actually the native IEEE non-numbers; they are
        undefined values of the "unthrown exception" type that happen to
        represent the corresponding IEEE concepts, and if you subsequently
        try to use one of these values in a non-parallel computation, it
        will likely throw an exception at that point.)
    *   "infix:<div>", integer division
            $numerator div $denominator
        Dispatches to the "infix:<div>" multi most appropriate to the
        operand types, returning a value of the same type. Not coercive, so
        fails on differing types.
        Policy on what to do about division by zero is up to the type, but
        for the sake of hyperoperators and junctions those types that can
        represent overflow (or that can contain an unthrown exception)
        should try to do so rather than simply throwing an exception. (And
        in general, other operators that might fail should also consider
        their use in hyperops and junctions, and whether they can profitably
        benefit from a lazy exception model.)
        On the other hand, "div" wants to be very efficient and jittable
        when used as a low-level operation, so when you use "div" on two
        native ints, it relies on hardware to detect division by 0. Hence,
        it will always throw an exception rather than return a "Failure".
        In general, "div" should give the same result as
            $x div $y == floor($x/$y)
        but the return value should be the same type as $x.
        This identity stops holding when "$x/$y" degrades to a "Num" and
        runs into precision limits. A "div" operation on two "Int" objects
        must always be done precisely.
    *   "infix:<%>", modulo
            $x % $y
        If necessary, coerces non-numeric arguments to an appropriate
        "Numeric" type, then calculates the remainder, which is defined as:
            $x % $y == $x - floor($x / $y) * $y
        If both operands are "Int"s, the operator returns an "Int".
        If both operands are of integer or rational type, the operator
        returns the corresponding "Rat" value (except when the result does
        not fit into a "Rat", as detailed in S02).
    *   "infix:<%%>", is divisible by
            $x %% $y
        Performs a "%" and then tests the result for 0, returning
        "Bool::True" if the $x is evenly divisible by $y, and "Bool::False"
        You may use "!%%" to mean "not divisible by", though "%" itself
        generally has the same effect.
    *   "infix:<mod>", integer modulo
            $x mod $y
        Dispatches to the "infix:<mod>" multi most appropriate to the
        This should preserve the identity
            $x mod $y == $x - ($x div $y) * $y
    *   "infix:<+&>", numeric bitwise and
            $x +& $y
        Converts both arguments to "Int" and does a boolean AND between
        corresponding bits of each integer, returning an "Int" result.
    *   "infix:«+<»", numeric shift left
            $integer +< $bits
        Shifts by a negative number of bits cause a corresponding right
        shift. As such the ":signed" or ":!signed" adverbs may be applied
        (see below.)
    *   "infix:«+>»", numeric shift right
            $integer +> $bits
        By default, signed types do sign extension, while unsigned types do
        not, but this may be enabled or disabled with a ":signed" or
        ":!signed" adverb.
        Shifts by a negative number of bits cause a corresponding left
        shift.
    *   "infix:<~&>", buffer bitwise and
            $x ~& $y
        (such as "buf8", "buf16", or "buf32") and then does numeric bitwise
        AND on corresponding integers of the two buffers, logically padding
        the shorter buffer with 0 values. returning a buffer sufficiently
        large to contain all non-zero integer results (which for AND is at
        most the size of the shorter of the two buffers).
        operator is distinguished from numeric bitwise AND in order to
    *   "infix:«~<»", buffer bitwise shift left
            $buf ~< $bits
    *   "infix:«~>»", buffer bitwise shift right
            $buf ~> $bits
        Sign extension is not done by default but may be enabled with a
        ":signed" adverb.
    *   "infix:<?&>", boolean and
            $x ?& $y
        Converts both arguments to type "Bool" and then ANDs those,
        returning the resulting "Bool".
    *   "infix:<gcd>", greatest common divisor
            $x gcd $y
        Converts both arguments to an integral type and then finds the
        largest integer that both arguments are evenly divisible by, and
        returns that integer.
    *   "infix:<lcm>", least common multiple
            $x lcm $y
        smallest integer that is evenly divisible by both arguments, and
    Any bit shift operator may be turned into a rotate operator with the
    ":rotate" adverb. If ":rotate" is specified, the concept of sign
    extension is meaningless, and you may not specify a ":signed" adverb.
  Additive precedence
    *   "infix:<+>", numeric addition
            $x + $y
        Microeditorial: As with most of these operators, any coercion or
        type mismatch is actually handled by multiple dispatch. The intent
        is that all such variants preserve the notion of numeric addition to
        produce a numeric result, presumably stored in a numeric type
        suitably "large" to hold the result. Do not overload the "+"
        operator for other purposes, such as concatenation. (And please do
        not overload the bitshift operators to do I/O.) In general we feel
        it is much better for you to make up a different operator than
        overload an existing operator for "off topic" uses. All of Unicode
        is available for this purpose.
    *   "infix:<->", numeric subtraction
            $x - $y
    *   "infix:<+|>", numeric bitwise inclusive or
            $x +| $y
        Converts both arguments to "Int" and does a boolean OR between
    *   "infix:<+^>" numeric bitwise exclusive or
            $x +^ $y
        Converts both arguments to "Int" and does a boolean XOR between
    *   "infix:<~|>", buffer bitwise inclusive or
            $x ~| $y
        OR on corresponding integers of the two buffers, logically padding
        the shorter buffer with 0 values, and returning a buffer
        sufficiently large to contain all non-zero integer results (which
        for OR is at most the size of the longer of the two buffers).
        operator is distinguished from numeric bitwise OR in order to
    *   "infix:<~^>" buffer bitwise exclusive or
            $x ~^ $y
        XOR on corresponding integers of the two buffers, logically padding
        large to contain all non-zero integer results (which for XOR is at
        most the size of the longer of the two buffers).
        operator is distinguished from numeric bitwise XOR in order to
    *   "infix:<?|>", boolean inclusive or
            $x ?| $y
        Converts both arguments to type "Bool" and then ORs those, returning
        the resulting "Bool".
    *   "infix:<?^>" boolean exclusive or
            $x ?^ $y
        Converts both arguments to type "Bool" and then XORs those,
  Replication
    *   "infix:<x>", string/buffer replication
            $string x $count
        Evaluates the left argument in string context, replicates the
        resulting string value the number of times specified by the right
        argument, and returns the result as a single concatenated string
        regardless of context.
        If the count is less than 1, returns the null string. The count may
        not be "*" because Perl 6 does not support infinite strings. (At
        least, not yet...) Note, however, that an infinite string may
        someday be emulated with "cat($string xx *)", in which case "$string
        x *" may be a shorthand for that.
    *   "infix:<xx>", expression repetition operator
            @list xx $count
        Evaluates the left argument the number of times specified by the
        right argument. Each evaluation is in list context, and returns a
        "Seq". The result of all these evaluations is returned as a list of
        arrays (which will behave differently depending on whether it's
        bound into a flat context or a lol context).
        If the count is less than 1, returns the empty list, "()". If the
        count is "*", returns an infinite list (lazily, since lists are lazy
        by default).
        Since the expression on the left is treated as a thunk that is
        re-evaluated each time, expressions that rely on this behavior are
        possible:
            rand xx *;                # infinite supply of random numbers
            [ 0 xx $cols ] xx $rows   # distinct arrays, not the same row replicated
        Of course, the optimizer can notice when the left side is a constant
        and avoid re-evaluation. When this is not possible, you can subvert
        the re-evaluation by use of a temporary.
  Concatenation
    *   "infix:<~>", string/buffer concatenation
            $x ~ $y
  Junctive and (all) precedence
    *   "infix:<&>", "all()" operator
            $a & $b & $c ...
        By default junctions are allowed to reorder the comparisons in any
        order that makes sense to the optimizer. To suppress this, use the
        "S" metaoperator for force sequential evaluation, which will
        construct a list of ANDed patterns with the same semantics as
        "infix:<&>", but with left-to-right evaluation guaranteed, for use
        in guarded patterns:
            $target ~~ MyType S& *.mytest1 S& *.mytest2
        This is useful when later tests might throw exceptions if earlier
        tests don't pass. This cannot be guaranteed by:
            $target ~~ MyType & *.mytest1 & *.mytest2
  Junctive or (any) precedence
    *   "infix:<|>", "any()" operator
            $a | $b | $c ...
    *   By default junctions are allowed to reorder the comparisons in any
        construct a list of ORed patterns with the same semantics as
        "infix:<|>", but with left-to-right evaluation guaranteed, for use
        in guarded patterns where the left argument is much more easily
        falsifiable than the right:
            $target ~~ *.mycheaptest S| *.myexpensivetest
        This is also useful when you want to perform tests in order of
        safety:
            $target ~~ MyType S| *.mysafetest S| *.mydangeroustest
    *   "infix:<^>", "one()" operator
            $a ^ $b ^ $c ...
        The "S^" variant guarantees left-to-right evaluation, and in boolean
        context short-circuits to false if it sees a second match.
  Named unary precedence
    Operators of one argument
        let
        temp
    Note that, unlike in Perl 5, you must use the ".meth" forms to default
    to $_ in Perl 6.
    There is no unary "rand" prefix in Perl 6, though there is a ".rand"
    method call and an argumentless "rand" term. There is no unary "int"
    prefix either; you must use a typecast to a type such as "Int" or "int".
    (Typecasts require parentheses and may not be used as prefix operators.)
    In other words:
        my $i = int $x;   # ILLEGAL
    is a syntax error (two terms in a row), because "int" is a type name
    now.
  Nonchaining binary precedence
    *   "infix:<but>"
            $value but Mixin
    *   "infix:<does>"
            $object does Mixin
    *   Sort comparisons
            $num1 <=> $num2
            $str1 leg $str2
            $obj1 cmp $obj2
        These operators compare their operands using numeric, string, or
        "eqv" semantics respectively, and if the left operand is smaller,
        the same, or larger than the right operator, return respectively
        "Order::Less", "Order::Same", or "Order::More" (which numerify to
        -1, 0, or +1, the customary values in most C-derived languages). See
        "Comparison semantics".
    *   Range object constructor
            $min  ..  $max
            $min ^..  $max
            $min  ..^ $max
            $min ^..^ $max
        Constructs "Range" objects, optionally excluding one or both
        endpoints. See "Range and RangeIter semantics".
  Chaining binary precedence
    All operators on this precedence level may be *chained*; see "Chained
    comparisons". They all return a boolean value.
    *   "infix:<==>" etc.
            == != < <= > >=
        As in Perl 5, converts to "Num" before comparison. "!=" is short for
        "!==".
    *   "infix:<eq>" etc.
            eq ne lt le gt ge
        As in Perl 5, converts to "Str" before comparison. "ne" is short for
        "!eq".
    *   Generic ordering
            $a before $b
            $a after $b
    *   Smart match
            $obj ~~ $pattern
        Perl 5's "=~" becomes the "smart match" operator "~~", with an
        extended set of semantics. See "Smart matching" for details.
        To catch "brainos", the Perl 6 parser defines an "infix:<=~>"
        operator, which always fails at compile time with a message
        directing the user to use "~~" or "~=" (string append) instead if
        they meant it as a single operator, or to put a space between if
        they really wanted to assign a stringified value as two separate
        operators.
        A negated smart match is spelled "!~~".
    *   Container identity
            VAR($a) =:= VAR($b)
        See "Comparison semantics".
    *   Value identity
            $x === $y
        For objects that are not value types, their identities are their
        values. (Identity is returned by the ".WHICH" metamethod.) The
        actual contents of the objects are ignored. These semantics are
        those used by hashes that allow objects for keys. See also
        Note that "===" is defined with an "(Any,Any)" signature, and
        therefore autothreads over junctions; hence it *cannot* be used to
        determine if two objects are the same, if either or both of them are
        junctions. However, since ".WHICH" is a macro that always returns a
        value and never autothreads, you can easily work around this
        limitation by saying:
            $junk1.WHICH eqv $junk2.WHICH
        [Conjecture: primitive identity is checked with "$junk1 \===
        $junk2".]
    *   Canonical equivalence
            $obj1 eqv $obj2
        Compares two objects for canonical equivalence. For value types
        compares the values. For object types, compares current contents
        according to some scheme of canonicalization. These semantics are
        those used by hashes that allow only values for keys (such as Perl 5
        string-key hashes). See also "Comparison semantics".
        Note that "eqv" autothreads over junctions, as do all other
        comparison operators. (Do not be confused by the fact that these
        return boolean values; in general, only boolean *context* forces
        junction collapse.)
        When comparing list-like objects, "eqv" must preserve lazy semantics
        of either or both of its arguments. (That is, it may optimize by
        calling ".elems" only when it can prove that both its arguments are
        already fully evaluated.)
        [Conjecture: primitive equivalence is checked with "$junk1 \eqv
    *   Negated relational operators
            $num !== 42
            $str !eq "abc"
            "foo" !~~ /^ <ident> $/
            VAR($a) !=:= VAR($b)
            $a !=== $b
            $a !eqv $b
        See "Negated relational operators".
  Tight and precedence
    *   "infix:<&&>", short-circuit and
            $a && $b && $c ...
        Returns the first argument that evaluates to false, otherwise
        returns the result of the last argument. In list context forces a
        false return to mean "()". See "and" below for low-precedence
        version.
  Tight or precedence
    *   "infix:<||>", short-circuit inclusive-or
            $a || $b || $c ...
        Returns the first argument that evaluates to a true value, otherwise
        returns the result of the last argument. It is specifically allowed
        to use a list or array both as a boolean and as a list value
        produced if the boolean is true:
            @a = @b || @c;              # broken in Perl 5; works in Perl 6
        In list context this operator forces a false return to mean "()".
        See "or" below for low-precedence version.
    *   "infix:<^^>", short-circuit exclusive-or
            $a ^^ $b ^^ $c ...
        Returns the true argument if there is one (and only one). Returns
        the last argument if all arguments are false. Returns "Nil"
        otherwise (when more than one argument is true). In list context
        forces a false return to mean "()". See "xor" below for
        low-precedence version.
        This operator short-circuits in the sense that it does not evaluate
        any arguments after a 2nd true result. Closely related is the reduce
        operator:
            [^^] a(), b(), c() ...
        but note that reduce operators are not macros but ordinary list
        operators, so c() is always called before the reduce is done.
    *   "infix:<//>", short-circuit default operator
            $a // $b // $c ...
        Returns the first argument that evaluates to a defined value,
        otherwise returns the result of the last argument. In list context
        forces a false return to mean "()". See "orelse" below for a similar
        but not identical low-precedence version.
    *   Minimum and maximum
            $a min $b min $c ...
            $a max $b max $c ...
        These return the minimum or maximum value. See also the "minmax"
        listop.
        Not all types can support the concept of infinity. Therefore any
        value of any type may be compared with "+Inf" or "-Inf" values, in
        which case the infinite value stands for "larger/smaller than any
        possible value of the type." That is,
            "foo" min +Inf              # "foo"
            "foo" min -Inf              # -Inf
            "foo" max +Inf              # +Inf
            "foo" max -Inf              # "foo"
        All orderable object types must support "+Inf" and "-Inf" values as
        special forms of the undefined value. It's an error, however, to
        attempt to store an infinite value into a native type that cannot
        support it:
            my int $max;
            $max max= -Inf;     # ERROR
  Conditional operator precedence
    *   Conditional operator
            say "My answer is: ", $maybe ?? "yes" !! "no";
        Also known as the "ternary" or "trinary" operator, but we prefer
        "conditional" just to stop people from fighting over the terms. The
        operator syntactically separates the expression into three
        subexpressions. It first evaluates the left part in boolean context,
        then based on that selects one of the other two parts to evaluate.
        (It never evaluates both of them.) If the conditional is true it
        evaluates and returns the middle part; if false, the right part. The
        above is therefore equivalent to:
            say "My answer is: ", do {
                if $maybe {
                    "yes";
                else {
                    "no";
            };
        It is a syntax error to use an operator in the middle part that
        binds looser in precedence, such as "=".
            my $x;
            hmm() ?? $x = 1 !! $x = 2;        # ERROR
            hmm() ?? ($x = 1) !! ($x = 2);    # works
        Note that both sides have to be parenthesized. A partial fix is even
        wronger:
            hmm() ?? ($x = 1) !! $x = 2;      # parses, but WRONG
        That actually parses as:
            (
                hmm() ?? ($x = 1) !! $x
            ) = 2;
        and always assigns 2 to $x (because "($x = 1)" is a valid lvalue).
        And in any case, repeating the $x forces you to declare it earlier.
        The best don't-repeat-yourself solution is simply:
            my $x = hmm() ?? 1 !! 2;          # much better
    *   "infix:<?>"
        To catch likely errors by people familiar with C-derived languages
        (including Perl 5), a bare question mark in infix position will
        produce an error suggesting that the user use "?? !!" instead.
    *   Flipflop ranges
            start()  ff  end()
            start() ^ff  end()
            start()  ff^ end()
            start() ^ff^ end()
    *   Flipflop ranges (sed style)
            start()  fff  end()
            start() ^fff  end()
            start()  fff^ end()
            start() ^fff^ end()
  Adverbs
    Operator adverbs are special-cased in the grammar, but give the
    appearance of being parsed as trailing unary operators at a
    pseudo-precedence level slightly tighter than item assignment. (They're
    not officially "postfix" operators because those require the absence of
    whitespace, and these allow whitespace. These adverbs insert themselves
    in the spot where the parser is expecting an infix operator, but the
    parser continues to look for an infix after parsing the adverb and
    applying it to the previous term.) Thus,
        $a < 1 and $b == 2 :carefully
    does the "==" carefully, while
        $a < 1 && $b == 2 :carefully
    does the "&&" carefully because "&&" is of tighter precedence than
    "comma". Use
        $a < 1 && ($b == 2 :carefully)
    to apply the adverb to the "==" operator instead. We say that "==" is
    the "topmost" operator in the sense that it is at the top of the parse
    tree that the adverb could possibly apply to. (It could not apply
    outside the parens.) If you are unsure what the topmost operator is,
    just ask yourself which operator would be applied last. For instance, in
        +%hash{$key} :foo
    the subscript happens first and the "+" operator happens last, so ":foo"
    would apply to that. Use
        +(%hash{$key} :foo)
    to apply ":foo" to the subscripting operator instead.
    Adverbs will generally attach the way you want when you say things like
        1 op $x+2 :mod($x)
    The proposed internal testing syntax makes use of these precedence
    rules:
        $x eqv $y+2  :ok<$x is equivalent to $y+2>;
    Here the adverb is considered to be modifying the "eqv" operator.
  Item assignment precedence
    *   "infix:<=>"
            $x = 1, $y = 2;
        With simple lvalues, "=" has this precedence, which is tighter than
        comma. (List assignments have listop precedence below.)
    *   "infix:«=>»", Pair constructor
            foo => 1, bar => "baz"
        Binary "=>" is no longer just a "fancy comma". It now constructs a
        "Pair" object that can, among other things, be used to pass named
        arguments to functions. It provides item context to both sides. It
        does not actually do an assignment except in a notional sense;
        however its precedence is now equivalent to assignment, and it is
        also right associative. Note that, unlike in Perl 5, "=>" binds more
        tightly than comma.
    *   Assignment operators
            += -= **= xx= .= etc.
        See "Assignment operators".
  Loose unary precedence
    *   "prefix:<not>"
            not any(@args) eq '-v' | '-V'
        Returns a "Bool" value representing the logical negation of an
    *   "prefix:<so>"
            so any(@args) eq '-v' | '-V'
        Returns a "Bool" value representing the logical non-negation of an
        expression. Mostly useful as documentation in parallel to a "not"
        when "else" isn't appropriate:
            if not $x { print "LOL"; }
            mumble();
            if so $x { print "SRSLY!" }
  Comma operator precedence
    *   "infix:<,>", the argument separator
            1, 2, 3, @many
        Unlike in Perl 5, comma operator never returns the last value. (In
        item context it returns a list instead.)
    *   "infix:<:>", the invocant marker
            say $*OUT: "howdy, world"
            say($*OUT: "howdy, world")
            push @array: 1,2,3
            push(@array: 1,2,3)
            \($object: 1,2,3, :foo, :!bar)
        The colon operator parses just like a comma, but marks the argument
        to its left as an invocant, which has the effect of turning what
        would otherwise be a function call into a method call. It may only
        be used on the first argument of an argument list or capture, and
        will fail to parse if used in any other position. When used within a
        capture, it is not yet known what signature the capture will be
        bound to; if bound to a non-method's signature, the invocant merely
        turns into the first positional argument, as if the colon had been a
        comma.
        To avoid confusion with other colon forms, the colon infix operator
        must be followed by whitespace or a terminator. It may optionally
        have whitespace in front of it.
        Note: distinguish this infix operator from the colon in
            @array.push: 1,2,3
            @array.push(1,2,3): 4,5,6
            push(@array, 1,2,3): 4,5,6
        which is a special form that turns an ordinary function or method
        call into a list operator. The special form is recognized only after
        a dotty method call, or after the right parenthesis of a method or
        function call. The special form does not allow intervening
        whitespace, but requires whitespace before the next argument. In all
        other cases a colon will be parsed as the start of an adverb if
        possible, or otherwise the invocant marker (the infix described
        above).
        Another way to think of it is that the special colon is allowed to
        add listop arguments to a parenthesized argument list only after the
        right parenthesis of that argument list, with the proviso that
        you're allowed to shorten ".foo(): 1,2,3" down to ".foo: 1,2,3".
        (But only for method calls, since ordinary functions don't need the
        colon in the first place to turn into a listop, just whitespace. If
        you try to extend a function name with a colon, it's likely to be
        taken as a label.)
            foo $obj.bar: 1,2,3     # special, means foo($obj.bar(1,2,3))
            foo $obj.bar(): 1,2,3   # special, means foo($obj.bar(1,2,3))
            foo $obj.bar(1): 2,3    # special, means foo($obj.bar(1,2,3))
            foo $obj.bar(1,2): 3    # special, means foo($obj.bar(1,2,3))
            foo($obj.bar): 1,2,3    # special, means foo($obj.bar, 1,2,3)
            foo($obj.bar, 1): 2,3   # special, means foo($obj.bar, 1,2,3)
            foo($obj.bar, 1,2): 3   # special, means foo($obj.bar, 1,2,3)
            foo $obj.bar : 1,2,3    # infix:<:>, means $obj.bar.foo(1,2,3)
            foo ($obj.bar): 1,2,3   # infix:<:>, means $obj.bar.foo(1,2,3)
            foo $obj.bar:1,2,3      # syntax error
            foo $obj.bar :1,2,3     # syntax error
            foo $obj.bar :baz       # adverb, means foo($obj.bar(:baz))
            foo ($obj.bar) :baz     # adverb, means foo($obj.bar, :baz)
            foo $obj.bar:baz        # extended identifier, foo( $obj.'bar:baz' )
            foo $obj.infix:<+>      # extended identifier, foo( $obj.'infix:<+>' )
            foo: 1,2,3              # label at statement start, else infix
        The moral of the story is: if you don't know how the colon is going
        to bind, use whitespace or parentheses to make it clear.
  List infix precedence
    List infixes all have list associativity, which means that identical
    infix operators work together in parallel rather than one after the
    other. Non-identical operators are considered non-associative and must
    be parenthesized for clarity.
    *   "infix:<Z>", the zip operator
            1,2 Z 3,4   # (1,3),(2,4)
        The "Z" operator is actually a degenerate case of the "Z" zipwith
        metaoperator (see "Zip operators" below).
    *   "infix:<minmax>", the minmax operator
            @a minmax @b
        Returns a "Range" from the minimum element of @a and @b to the
        maximum element. "Range" elements in the input are treated as if
        their minimum and maximum values were passed individually, except
    *   "infix:<X>", the cross operator
            1,2 X 3,4          # (1,3), (1,4), (2,3), (2,4)
        In contrast to the zip operator, the "X" operator returns all
        possible lists formed by taking one element from each of its list
        arguments. The returned lists are ordered such that the rightmost
        elements vary most rapidly. If there are just two lists, for
        instance, it forms all pairs where one element is from the first
        list and the other one from the second, with the second element
        varying most rapidly. Hence you may say:
            <a b> X <1 2>
        and you end up with
            ('a', '1'), ('a', '2'), ('b', '1'), ('b', '2')
        This becomes a flat list in flat context and a "LoL" in lol context:
            say flat(<a b> X <1 2>).perl
            'a', '1', 'a', '2', 'b', '1', 'b', '2'
            say lol(<a b> X <1 2>).perl
            LoL.new( ('a', '1'), ('a', '2'), ('b', '1'), ('b', '2') )
        The operator is list associative, so
            1,2 X 3,4 X 5,6
        produces
            (1,3,5),(1,3,6),(1,4,5),(1,4,6),(2,3,5),(2,3,6),(2,4,5),(2,4,6)
        On the other hand, if any of the lists is empty, you will end up
        with a null list.
        While either side's list may be infinite, use of an infinite list on
        the right may produce unexpected results. For instance
            <a b> X 0..*
        would produce
            ('a',0), ('a',1), ('a',2), ('a',3), ('a',4), ('a',5), ...
        and you'd never get to 'b'. If your left list consists of only a
        single element, though, this may be useful, especially if "X" is
        used as a metaoperator. See below.
    *   Cross metaoperators
            @files X~ '.' X~ @extensions
            1..10 X* 1..10
            @x Xeqv @y
            etc.
        A common idiom is to have a list with a single element on one side
        or the other:
            @vector X* 2;               # multiply each element by 2
            $prefix X~ @infinitelist;   # prefix each element of an infinite list
        In this last case it's okay to have an infinite list on the right.
        See "Cross operators".
    *   "infix:<...>", the sequence operator.
        As a list infix operator, "..." takes a list on both its left and
        right and evaluates them as lazily as possible to produce the
        desired sequence of values. The lists are evaluated as flat lists.
        As with all list infix operators, this operator is looser in
        precedence than comma, so you do not need to parenthesize comma
        lists on either side of it.
        The operator starts by getting the first value of the righthand
        list. This is the only value of the right list that the "..."
        operator is actually interested in; any additional list elements are
        treasured up lazily to be returned after the "..." is done.
        The righthand first value is considered to be the endpoint or limit
        of the sequence that is to be generated from the lefthand side by
        the "..." operator itself.
        Once we know the limit of the sequence, the left list is evaluated
        item by item, and ordinary numeric or string values are passed
        through unchanged (to the extent allowed by the limit on the right).
        If any value in the sequence smartmatches the limit value, the
        sequence terminates, including that final limit value. To omit the
        final value, use the "...^" form instead.
        Internally, these two forms are checking to see if an anonymous loop
        is going to terminate, where the loop is what is returning the
        values of the sequence. Assuming the next candidate value is in $x
        and the first element of the right side is in $limit, the two
        operators are implemented respectively as:
            ...     last($x) if $x ~~ $limit;
            ...^    last     if $x ~~ $limit;
        Since this uses smartmatching via the "~~" operator (see Smart
        matching below), the usual smartmatching rules apply. If the limit
        is "*", the sequence has no limit. If the limit is a closure, it
        will be evaluated for boolean truth on the current candidate, and
        the sequence will continue as long as the closure returns false. If
        the limit is a closure with more than 1 - or infinite - arguments
        the appropriate number of elements from the end of the sequence - or
        the whole sequence so far - are passed. It's quite possible for a
        sequence to return fewer values than are listed if the very first
        value matches the end test:
            my $lim = 0;
            1,2,3 ...^ * > $lim      # returns (), since 1 > 0
        This operator would be fairly useless if it could only return the
        literal values on the left. The power comes from generating new
        values from the old ones. You may, for instance, use an existing
        generator that happens to produce an infinite list:
            1..* ... * >= $lim
            @fib ... * >= $lim
        More typically, if the next item in the left-hand list is a closure,
        it is not returned; rather it is called on the tail of the existing
        list to produce a new value. The arity of the closure determines how
        many preceding values to use as input in generating the next value
        in the sequence. For instance, counting by twos only requires a
        single argument:
            2, { $^a + 2 } ... *      # 2,4,6,8,10,12,14,16...
        Generating the Fibonacci sequence takes two arguments at a time:
            1, 1, { $^a + $^b } ... * # 1,1,2,3,5,8,13,21...
        Any means of specifying a function will do, as long as you arrange
        it as a list value rather than calling it:
            1, 1, &infix:<+> ... *    # 1,1,2,3,5,8...
            1, 1, &[+] ... *          # same thing
            1, 1, *+* ... *           # same thing
        More typically the function is unary, in which case any extra values
        in the lefthand list may be construed as human-readable
        documentation:
            0,2,4, { $_ + 2 } ... 42   # all the evens up to 42
            0,2,4, *+2 ... 42          # same thing
            <a b c>, { .succ } ... *   # same as 'a'..*
        The function need not be monotonic:
            1, -* ... *                # 1, -1, 1, -1, 1, -1...
            False, &prefix:<!> ... *   # False, True, False...
        The function can be 0-ary as well, in which case it's okay for the
        closure to be the first thing:
            { rand } ... *             # list of random numbers
        The function may also be slurpy (n-ary), in which case "all" the
        preceding values are passed in (which means they must all be cached
        by the operator, so performance may suffer, and you may find
        yourself with a "space leak").
        The arity of the function need not match the number of return
        values, but if they do match you may interleave unrelated sequences:
            1,1,{ $^a + 1, $^b * 2 }...*   # 1,1,2,2,3,4,4,8,5,16,6,32...
        Note in this case that the any limit test is applied to the entire
        list returned from the function, which contains two values.
        A sequence generated from an explicit function places no type
        constraints on the sequence other than those constraints implied by
        the signature of the function. If the signature of the function does
        not match the existing values, however, an exception is thrown.
        If no generating closure is provided, and the sequence is numeric,
        and is obviously arithmetic or geometric (from examining its *last*
        3 values), the appropriate function is deduced:
            1, 3, 5 ... *   # odd numbers
            1, 2, 4 ... *   # powers of 2
            10,9,8 ... 0    # countdown
        That is, supposing we call the last three numbers $a, $b, and $c,
        and then define:
            $ab = $b - $a;
            $bc = $c - $b;
        If "$ab == $bc" and $ab is not zero, then we deduce an arithmetic
        progression determined by the function "*+$ab". If $ab is zero, and
        the three values look like numbers, then the function is "*+0". If
        they do not look like numbers, then the function selected is either
        "*.succ" or "*.pred" depending on whether "$b cmp $c" appears to be
        Increasing or Decreasing. If "cmp" returns Same then an identity
        function is assumed.
        If "$ab != $bc" and "none($a,$b,$c) == 0", then a similar
        calculation is done using division rather than subtraction to
        determine whether a geometric progression is warranted. Define:
            $ab = $b / $a;
            $bc = $c / $b;
        If the two quotients are equal (and finite), then a geometric
        function of "{$_ * $bc}" is deduced.
        The values on the left are considered samples of how the sequence
        will start if the end test permits it to get that far. Hence, the
        test for completion applies even to those values:
            0,2,4 ... 16    # 0,2,4,8,16
            0,2,4 ... 4     # 0,2,4
            0,2,4 ... 2     # 0,2
            0,2,4 ... 0     # 0
        If there are more than three values, only the final three are tested
        against the deduced function; the earlier ones are always produced
        regardless of their value:
            40, 2, 'Hike!', 0, 2, 4 ... 2   # 40, 2, 'Hike!', 0
        If there are only two values in the list so far, $a and $b, and the
        difference $ab is non-zero, we assume an arithmetic progression of
        "*+$ab". If $ab is zero, then again whether we use "*+0" or
        "*.succ"/"*.pred" depends on whether the two values look like
        numbers.
        If there is only one value, we always assume incrementation via
        ".succ". (This may be forced to ".pred" by examination of a limit,
        as specified below.) Hence these come out the same:
            1 .. *
            1 ... *
            1,2 ... *
            1,2,3 ... *
            <1 2 3> ... *
        Likewise, if the given value or values are not numeric, ".succ" is
        assumed, so these come out the same:
            'a' .. *
            'a' ... *
            'a','b' ... *
            'a','b','c' ... *
            <a b c> ... *
        If the list on the left is "()", we use the function "{()}" to
        generate an infinite supply of nothing.
        When there is a deduced function from the last three values, and
        when there is a limit that "misses" but is suitably literal and of a
        similar type (that is, a numeric value for a numeric sequence, or a
        string value for a string sequence), then the deduced function will
        attempt to detect when the limit would be bypassed, and stop the
        sequence right there instead of running off to infinity:
            42,1,3,5 ... 8     # 42,1,3,5,7
            42,1,3,5 ... 4     # 42,1,3
            42,1,3,5 ... 2     # 42,1
            42,1,3,5 ... 0     # 42
            1,3,5 ... 2        # 1
            1,3,5 ... 0        # ()
        If a limit is given that is not a literal, or is not of a
        sufficiently similar type, it must smartmatch exactly. If it does
        not, an infinite list results. For instance, since "asymptotically
        approaching" is not the same as "equals", both of the following are
        infinite lists, as if you'd specified "*" for the limit rather than
        0:
            1,1/2,1/4 ... 0    # like 1,1/2,1/4 ... *
            1,-1/2,1/4 ... 0   # like 1,-1/2,1/4 ... *
        Likewise, this is all of the even numbers:
            0,2,4 ... * == 7
        To catch such a situation, it is advised to write an inequality
        instead:
            0,2,4 ...^ { $_ > 7 }
        When an explicit limit function is used, it may choose to terminate
        its list by returning any true value. Since this operator is list
        associative, an inner function may be followed by a "..." and
        another function to continue the list, and so on. Hence,
            1,   *+1   ... { $_ ==   9 },
            10,  *+10  ... { $_ ==  90 },
            100, *+100 ... { $_ == 900 }
            1,2,3,4,5,6,7,8,9,
            10,20,30,40,50,60,70,80,90,
            100,200,300,400,500,600,700,800,900
        Given the normal matching rules when there's no closure, we can
        write that more simply as:
            1, 2, 3 ... 9,
            10, 20, 30 ... 90,
            100, 200, 300 ... 900
        or even just:
            1, 2, 3 ...
            10, 20, 30 ...
        since an exactly matching limit is returned as part of the sequence,
        provided it is a value of the appropriate type, and not a closure.
        For functions deduced when there is only one value on the left, the
        final value is used to determine whether "*.succ" or "*.pred" is
        more appropriate. The two values are compared with "cmp" to
        determine the direction of the progression.
        Hence the sequence operator is "auto-reversing", unlike a range
        operator.
            'z' .. 'a'   # represents a null range
            'z' ... 'a'  # z y x ... a
        For completeness, you may omit the first value using the "^..."
        form:
            'z' ^... 'a' # y x ... a
            5 ^... 1     # 4, 3, 2, 1
        But be aware that this form will almost certainly confuse your
        readers if the list on the left is complicated, especially if the
        left list is another sequence:
            1, 2, 3 ^... *;                 # 2, 3 ...  !
            1, 2, 3 ... 10, 20, 30 ^... *;  # 2, 3 ...  !?!?
        And yes, there's also a "^...^" form, for those people who have an
        undue fondness for symmetry.
        As with numeric values, a string sequence with a literal string
        endpoint will attempt to determine when it's traversing the endpoint
        without matching exactly. In addition, however, if on an increasing
        sequence the next string would be longer than the endpoint, the
        sequence stops for that as well, since string comparison does not
        always map directly to the order of successors. If this is
        insufficient, use a different endpoint smartmatch such as a regular
        expression or a closure to do fancier tests.
        Note that the sequence
            1.0, *+0.2 ... 2.0
        is calculated in "Rat" arithmetic, not "Num", so the 2.0 matches
        exactly and terminates the sequence.
        Note: the yada operator is recognized only where a term is expected.
        This operator may only be used where an infix is expected. If you
        put a comma before the "..." it will be taken as a yada list
        operator expressing the desire to fail when the list reaches that
        point:
            1..20, ... "I only know up to 20 so far mister"
        A special exception is made for any sequence whose endpoints are
        strings that happen to represent single codepoints, since the user
        will typically be thinking of such strings as characters rather than
        strings. If you say something like:
            'A' ... 'z'
            "\xff" ... "\0"
        it is assumed that you aren't interested in carrying within
        alphabetic ranges, so instead of using the ordinary ".succ"/".pred"
        for strings, it uses a monotonic function that increments or
        decrements the underlying codepoint number like
            'A', { $^prev.ord.succ.chr } ... 'z';
            "\xff", { $^prev.ord.pred.chr } ... "\0";
        You will note that this alternate definition doesn't change the
        meaning of any sequence that falls within a conventional rangechar
        range:
            'a'...'z'
            '9'...'0'
        If the start and stop strings are the same length, this is applied
        at every position, with carry.
            'aa' ... 'zz'   # same as 'a' .. 'z' X~ 'a' .. 'z'
        Hence, to produce all octal numbers that fit in 16 bits, you can
        say:
            '000000' ... '177777'
        At need, you can override these numeric codepoint semantics by using
        an explicit successor function:
            '⓪', *.succ ... '㊿'       # circled digits/numbers 0..50
        (In fact, this is precisely what the translation from ranges does,
        in order to preserve the abstract ordering of rangechars that have
        non-contiguous codepoints. But it's easier just to use the range
        operator if that's the case.)
        If the start string is shorter than the stop string, the strings are
        assumed to be right justified, and the leftmost start character is
        duplicated when there is a carry:
            '0' ... '177777'    # same octal sequence, without leading 0's
        Going the other way, digits are dropped when they go to the first
        existing digit until the current value is as short as the final
        value, then the digits are left there. Which is a fancy way of
        saying that
            '177777' ... '000000'
        and
            '177777' ... '0'
        both do exactly what the forward sequences do above, only in
        reverse.
        As an extra special rule, that works in either direction: if the
        bottom character is a '0' and the top character is alphanumeric, it
        is assumed to be representing a number in some base up to base 36,
        where digits above ten are represented by letters. Hence the same
        sequences of 16-bit numbers, only in hexadecimal, may be produced
        with:
            '0000' ... 'ffff'
            '0' ... 'ffff'
            'ffff' ... '0000'
            'ffff' ... '0'
        And as a limiting case, this applies to single characters also:
            '0' .. 'F'    # 0..9, 'A'..'F'
        Note that case is intuited from the top character of the range.
        There are many different possible semantics for string increment. If
        this isn't the semantics you want, you can always write your own
        successor function. Sometimes the stupid codepoint counting is what
        you want. For instance, you can get away with ranges of capital
        Greek letters:
            'ΑΑΑ' ... 'ΩΩΩ'
        However, if you try it with the lowercase letters, you'll get both
        forms of lowercase sigma, which you probably don't want. If there's
        only one or two letters you don't want, you can grep out those
        entries, but in the general case, you need an incrementer that knows
        what sequence you're interested in. Perhaps there can be a generic
        method,
            'ααα', *.succ-in(@greek) ... 'ωωω'
        that will take any given sequence and use it as the universe of
        incrementation for any matching characters in the string.
        To preserve Perl 5 length limiting semantics of a range like
        'A'..'zzz', you'd need something like:
            'A', *.succ ... { last if .chars > 3; $_ eq 'zzz' }
        (That's not an exact match to what Perl 5 does, since "Str.succ" is
        a bit fancier in Perl 6, but starting with 'A' it'll work the same.
        You can always supply your own increment function.)
        Note that the "last" call above returns no argument, so even though
        the internal test calls "last($x)", this call to "last" bypasses
        that as if the sequence had been specified with "...^" instead.
        Going the other way, a "...^" maybe be forced to have a final value
        by passing an argument to an explicit "last($my-last-value)". In the
        same way, that will bypass the argumentless internal "last".
        In a similar way, the sequence may be terminated by calling "last"
        from the generator function:
            10,9,8, { $_ - 1 || last } ... *   # same as 10 ... 1
        For purposes of deciding when to terminate the eager part of a
        'mostly eager' list, any sequence that terminates with an exact
        value (or that starts another sequence with exact values) is
        considered finite, as is any sequence that has an explicit ending
        closure. However, any sequence that ends "*" is considered to be of
        unknowable length. However, by the definition of "mostly eager" in
        S07, the implementation may be able to determine that such a
        sequence is finite by conjectural evaluation; such workahead cannot,
        of course, always prove that a sequence is infinite without running
        a Very Long Time. Note also that, by using the form that specifies
        both a closure and a final value, it is possible to write a sequence
        that appears to be finite but that never actually reaches its final
        value before resources are exhausted; such a sequence will be
        treated as finite, but eventually will come to grief:
            @a = 1, *+0.00000000000000000000000000000000000001 ... 2;  # heat death
        For any such sequence or list that the user knows to be infinite,
        but the computer can't easily know it, it is allowed to mark the end
        of the list with a "*", which indicates that it is to be treated as
        an infinite list in contexts that care. Similarly, any list ending
        with an operator that interprets "*" as infinity may be taken the
        same way, such as "$n xx *", or "1..*".
        On the other hand, it's possible to write a sequence that appears to
        be infinite, but is terminated by a "last" from the iterator
        closure. An implementation is required to trap such a loop
        termination and change the status of the list from 'infinite' to
        'finite, such that ".elems" reports the actual produced length, not
        "Inf".
    Many of these operators return a list of "List"s or "Seq"s, which
    depending on context may or may not flatten them all out into one flat
    list. The default is to flatten, but see the contextualizers below.
  List prefix precedence
    *   "infix:<=>", list assignment
            @array = 1,2,3;
        With compound targets, performs list assignment. The right side is
        looser than list infix. You might be wondering why we've classified
        this as a prefix operator when its token name is "infix:<=>". That's
        because you can view the left side as a special syntax for a prefix
        listop, much as if you'd said:
            @array.assign: 1,2,3
        However, the tokener classifies it as infix because it sees it when
        it's expecting an infix operator. Assignments in general are treated
        more like retroactive macros, since their meanings depend greatly on
        what is on the left, especially if what is on the left is a
        declarator of some sort. We even call some of them
        pseudo-assignments, but they're all a bit pseudo insofar as we have
        to figure out whether the left side is a list or a scalar
        destination.
        In any case, list assignment is defined to be arbitrarily lazy,
        insofar as it basically does the obvious copying as long as there
        are scalar destinations on the left or already-computed values on
        the right. However, many list lvalues end with an array destination
        (where assignment directly to an array can be considered a
        degenerate case). When copying into an array destination, the list
        assignment is "mostly eager"; it requests the list to evaluate its
        leading iterators (and values) to the extent that they are known to
        be finite, and then suspend, returning the known values. The
        assignment then copies the known values into the array. (These two
        steps might actually be interleaved depending on how the iterator
        API ends up being defined.) It then sets up the array to be
        self-extending by using the remainder of the list as the "specs" for
        the array's remaining values, to be reified on demand. Hence it is
        legal to say:
            @natural = 0..*;
        (Note that when we say that an iterator in list context suspends, it
        is not required to suspend immediately. When the scheduler is
        running an iterator, it may choose to precompute values in batches
        if it thinks that approach will increase throughput. This is likely
        to be the case on single-core architectures with heavy context
        switching, and may very well be the case even on manycore CPU
        architectures when there are more iterators than cores, such that
        cores may still have to do context switching. In any case, this is
        all more-or-less transparent to the user because in the abstract the
        list is all there, even if it hasn't been entirely computed yet.)
        Though elements may be reified into an array on demand, they act
        like ordinary array elements both before and after reification, as
        far as the user is concerned. These elements may be written to if
        the underlying container type supports it:
            @unnatural = 0..*;
            @unnatural[42] = "Life, the Universe, and Everything";
        Note that, unlike assignment, binding replaces the container, so the
        following fails because a range object cannot be subscripted:
            @natural := 0..*;     # bind a Range object
            @natural[42] = "Life, the Universe, and Everything";  # FAILS
        but this succeeds:
            @unnatural := [0..*]; # bind an Array object
            @unnatural[42] = "Life, the Universe, and Everything"; # ok
        It is erroneous to make use of any side effects of reification, such
        as movement of a file pointer, since different implementations may
        have different batch semantics, and in any case the unreified part
        of the list already "belongs" to the array.
        When a self-extending array is asked for its count of elements, it
        is allowed to return "+Inf" without blowing up if it can determine
        by inspection that its unreified parts contain any infinite lists.
        If it cannot determine this, it is allowed to use all your memory,
        and then some. ":)"
        Assignment to a hash is not lazy (probably).
    *   "infix:<:=>", run-time binding
            $signature := $capture
        A new form of assignment is present in Perl 6, called *binding*,
        used in place of typeglob assignment. It is performed with the ":="
        operator. Instead of replacing the value in a container like normal
        assignment, it replaces the container itself. For instance:
            my $x = 'Just Another';
            my $y := $x;
            $y = 'Perl Hacker';
        After this, both $x and $y contain the string "Perl Hacker", since
        they are really just two different names for the same variable.
        There is also an identity test, "=:=", which tests whether two names
        are bound to the same underlying variable. "$x =:= $y" would return
        true in the above example.
        The binding fails if the type of the variable being bound is
        sufficiently inconsistent with the type of the current declaration.
        Strictly speaking, any variation on
            my Any $x;
            $x := [1,2,3];
        should fail because the type being bound is not consistent with
        "Scalar of Any", but since the "Any" type is not a real instantiable
        type but a generic (non)constraint, and "Scalar of Any" is sort of a
        double non-constraint similar to "Any", we treat this situation
        specially as the equivalent of binding to a typeless variable.
        The binding operator parses as a list assignment, so it is
        reasonable to generate a list on the right without parens:
            @list := 1 ... *;
    *   "infix:<::=>", bind and make readonly
            $signature ::= $capture
        This does the same as ":=", then marks any destination parameters as
        readonly (unless the individual parameter overrides this with either
        the "rw" trait or the "copy" trait). It's particularly useful for
        establishing readonly dynamic variables for a dynamic scope:
                my $*OUT ::= open($file, :w) || die $!;
                doit();     # runs with redirected stdout
            doit();     # runs with original stdout
        If "doit" wants to change $*OUT, it must declare its own dynamic
        variable. It may not simply assign to $*OUT.
        Note that the semantics of "::=" are virtually identical to the
        normal binding of arguments to formal subroutine parameters (which
        also default to readonly).
        This operator parses as a list assignment.
    *   Normal listops
            print push say join split substr open etc.
    *   Listop forms of junctional operators
            any all one none
    *   Exception generators
            fail "Division by zero"
            die System::Error(ENOSPC,"Drive $d seems to be full");
            warn "Can't open file: $!"
    *   Stubby exception generators
            !!! "fill this in later, Dave"
            ??? "oops in $?CLASS"
        The "..." operator is the "yada, yada, yada" list operator, which
        among other things is used as the body in function prototypes. It
        complains bitterly (by calling "fail") if it is ever executed.
        Variant "???" calls "warn", and "!!!" calls "die". The argument is
        optional, but if provided, is passed onto the "fail", "warn", or
        "die". Otherwise the system will make up a message for you based on
        the context, indicating that you tried to execute something that is
        stubbed out. (This message differs from what "fail", "warn", and
        "die" would say by default, since the latter operators typically
        point out bad data or programming rather than just an incomplete
        design.)
    *   Reduce operators
            [+] [*] [<] [\+] [\*] etc.
        See "Reduction operators" below.
    *   Sigils as coercions to roles
            Sigil       Alpha variant
            -----       -------------
            $           Scalar
            @           Positional (or Iterable?)
            %           Associative
            &           Callable
        Note that, since these are coercions to roles, they are allowed to
        return any actual type that does the role in question.
        Unless applied directly to a scalar variable, as in @$a, these may
        only be applied with explicit parens around an argument that is
        processed as a bare "List" object, not a flattening list:
             $(1,2 Z 3,4)      # Scalar((1,3),(2,4))
             @(1,2 Z 3,4)      # ((1,3),(2,4))
             %(1,2 Z 3,4)      # (1 => 3, 2 => 4)
             $(1,2 X 3,4)      # Scalar((1,3),(1,4),(2,3),(2,4))
             @(1,2 X 3,4)      # ((1,3),(1,4),(2,3),(2,4))
        (Note, internal parens indicate nested "List" structure here, since
        there is no flattening.)
        Since a "List" with one argument is transparent, there can be no
        difference between the meaning of "@($a)" and @$a.
    *   The "item" contextualizer
            item foo()
        The new name for Perl 5's "scalar" contextualizer. Equivalent to
        "$(...)" (except that empty "$()" means "$($/.made // ~$/)", while
        empty "item()" yields "Failure"). We still call the values scalars,
        and talk about "scalar operators", but scalar operators are those
        that put their arguments into item context.
        If given a list, this function makes a "List" object from it. The
        function is agnostic about any "List" embedded in such a sequence,
        and any contextual decisions will be deferred until subsequent use
        of the contents.
        Note that this parses as a list operator, not a unary prefix
        operator, since you'd generally want it for converting a list to a
        sequence object. (Single items don't need to be converted to items.)
        Note, however, that it does no flattening of its list items:
            @x = lol(item (1,2),(3,4))  # @x eqv LoL( (1,2), (3,4) )
    *   The "list" contextualizer
            list foo()
        Forces the subsequent expression to be evaluated in list context.
        Any flattening happens lazily.
    *   The "flat" contextualizer
            flat foo()
        Forces the subsequent expression to be evaluated in a flattening
        list context. The result will be recursively flattened, i.e.,
        contain no embedded "List", "Seq" or "Range" objects.
    *   The "hash" contextualizer
            hash foo()
        Forces the subsequent expression to be evaluated in hash context.
        The expression is evaluated in list context (flattening any "List"s
        or "Seq"s), then a hash will be created from the list, taken as a
        list of "Pair"s. (Any element in the list that is not a "Pair" will
        pretend to be a key and grab the next value in the list as its
        value.) Equivalent to "%(...)" (except that empty "%()" means
        "%($/)", while empty "hash()" means an empty hash).
  Loose and precedence
    *   "infix:<and>", short-circuit and
            $a and $b and $c ...
        false return to mean "()". See "&&" above for high-precedence
    *   "infix:<andthen>", proceed on success
            test1() andthen test2() andthen test3() ...
        Returns the first argument whose evaluation indicates failure (that
        is, if the result is undefined). Otherwise it evaluates and returns
        the right argument.
        If the right side is a block or pointy block, the result of the left
        side is bound to any arguments of the block. If the right side is
        not a block, a block scope is assumed around the right side, and the
        result of the left side is implicitly bound to $_ for the scope of
        the right side. That is,
            test1() andthen test2()
        is equivalent to
            test1() andthen -> $_ { test2() }
        There is no corresponding high-precedence version.
        If you wish to have the same semantics in the opposite order, use
        the "with" statement modifier.
  Loose or precedence
    *   "infix:<or>", short-circuit inclusive or
            $a or $b or $c ...
        Returns the first argument that evaluates to true, otherwise returns
        the result of the last argument. In list context forces a false
        return to mean "()". See "||" above for high-precedence version.
    *   "infix:<xor>", exclusive or
            $a xor $b xor $c ...
        the last argument if all arguments are false. Returns "Bool::False"
        forces a false return to mean "()". See "^^" above for
        high-precedence version.
    *   "infix:<orelse>", proceed on failure
            test1() orelse test2() orelse test3() ...
        Returns the first argument that evaluates successfully (that is, if
        the result is defined). Otherwise returns the result of the right
        argument.
            test1() orelse test2()
            test1() orelse -> $_ { test2() }
        (The high-precedence "//" operator is similar, but does not set $_
        or treat blocks specially.)
        the "without" statement modifier.
  Terminator precedence
    As with terms, terminators are not really a precedence level, but looser
    than the loosest precedence level. They all have the effect of
    terminating any operator precedence parsing and returning a complete
    expression to the main parser. They don't care what state the operator
    precedence parser is in. If the parser is currently expecting a term and
    the final operator in the expression can't deal with a nullterm, then
    it's a syntax error. (Notably, the comma operator and many prefix list
    operators can handle a nullterm.)
    *   Semicolon: ";"
            $x = 1; $y = 2;
        The context determines how the expressions terminated by semicolon
        are interpreted. At statement level they are statements. Within a
        bracketing construct they are interpreted as lists of "List"s, which
        in lol context will be treated as the multiple dimensions of a
        multidimensional slice. (Other contexts may have other
        interpretations or disallow semicolons entirely.)
    *   Feed operators: "<==", "==>", "<<==", "==>>"
            source() ==> filter() ==> sink()
        The forms with the double angle append rather than clobber the
        sink's todo list. The "==>>" form always looks ahead for an
        appropriate target to append to, either the final sink in the chain,
        or the next filter stage with an explicit "@(*)" or "@(**)" target.
        This means you can stack multiple feeds onto one filter command:
            source1() ==>>
            source2() ==>>
            source3() ==>>
            filter(@(*)) ==> sink()
        Similar semantics apply to "<<==" except it looks backward for an
        appropriate target to append to.
    *   Control block: <ws>"{...}"
        When a block occurs after whitespace where an infix is expected, it
        is interpreted as a control block for a statement control construct.
        (If there is no whitespace, it is a subscript, and if it is where a
        term is expected, it's just a bare closure.) If there is no
        statement looking for such a block currently, it is a syntax error.
    *   Statement modifiers: "if", "unless", "while", "until", "for"
        Statement modifiers terminate one expression and start another.
    *   Any unexpected ")", "]", "}" at this level.
        Calls into the operator precedence parser may be parameterized to
        recognize additional terminators, but right brackets of any sort
        (except angles) are automatically included in the set of terminators
        as tokens of length one. (An infix of longer length could
        conceivably start with one of these characters, and would be
        recognized under the longest-token rule and continue the expression,
        but this practice is discouraged. It would be better to use Unicode
        for your weird operator.) Angle brackets are exempted so that they
        can form hyperoperators (see "Hyper operators").
    *   A block-final "}" at the end of the line terminates the current
        expression. A block within an argument list terminates the argument
        list unless followed by the comma operator.
Changes to Perl 5 operators
    Several operators have been given new names to increase clarity and
    better Huffman-code the language, while others have changed precedence.
    *   Perl 5's "${...}", "@{...}", "%{...}", etc. dereferencing forms are
        now "$(...)", "@(...)", "%(...)", etc. instead. (Use of the Perl 5
        curly forms will result in an error message pointing the user to the
        new forms.) As in Perl 5, the parens may be dropped when
        dereferencing a scalar variable.
    *   "->" becomes ".", like the rest of the world uses. There is a pseudo
        "postfix:«->»" operator that produces a compile-time error reminding
        Perl 5 users to use dot instead. (The "pointy block" use of "->" in
        Perl 6 requires preceding whitespace when the arrow could be
        confused with a postfix, that is, when an infix is expected.
        Preceding whitespace is not required in term position.)
    *   The string concatenation "." becomes "~". Think of it as "stitching"
        the two ends of its arguments together. String append is likewise
        "~=".
    *   The filetest operators are gone. We now use a "Pair" as a pattern
        that calls an object's method:
            if $filename.IO ~~ :e { say "exists" }
        is the same as
            if so $filename.IO.e { say "exists" }
        Likewise
            if $filename.IO ~~ :!e { say "doesn't exist" }
            if not $filename.IO.e { say "doesn't exist" }
        The 1st form actually translates to the latter form, so the object's
        class decides how to dispatch methods. It just so happens that the
        "IO" role defaults to the expected filetest semantics, but
        "$regex.i" might tell you whether the regex is case insensitive, for
        instance. Likewise, you can test anything for definedness or
        undefinedness:
            $obj ~~ :defined
            $obj ~~ :!defined
        Using the pattern form, multiple tests may be combined via
        junctions:
            given $path {
                when :r & :w & :x {...}
                when :!w | :!x    {...}
                when *            {...}
        When adverbial pairs are stacked into one term, it is assumed they
        are ANDed together, so
            when :r :w :x
        is equivalent to either of:
            when :r & :w & :x
            when all(:r,:w,:x)
        The pair forms are useful only for boolean tests because the
        method's value is evaluated as a "Bool", so the method form must be
        used for any numeric-based tests:
            if $filename.IO.s > 1024 {...}
        However, these still work:
            given $io {
                when :s  {...} # file has size > 0
                when :!s {...} # file size == 0
        One advantage of the method form is that it can be used in places
        that require tighter precedence than "~~" provides:
            sort { $^a.modified <=> $^b.modified }, @files».IO
        though that's a silly example since you could just write:
            sort { .modified }, @files».IO
        But that demonstrates the other advantage of the method form, which
        is that it allows the "unary dot" syntax to test the current topic.
        Unlike in earlier versions of Perl 6, these filetest methods do not
        return stat buffers, but simple scalars of type "Bool", "Int", or
        "Instant".
        In general, the user need not worry about caching the stat buffer
        when a filename is queried. The stat buffer will automatically be
        reused if the same object has recently been queried, where
        "recently" is defined as less than a second or so. If this is a
        concern, an explicit "stat()" or "lstat()" may be used to return an
        explicit "IO" object that will not be subject to timeout, and may be
        tested repeatedly just as a filename or handle can. An "IO" object
        has a ".path" method that can be queried for its path (if known).
        (Inadvertent use of the Perl 5 forms will normally result in
        treatment as a negated postdeclared subroutine, which is likely to
        produce an error message at the end of compilation.)
    *   All postfix operators that do not start with a dot also have an
        alternate form that does. (The converse does not hold--just because
        you can write "x().foo" doesn't mean you can write "x()foo".
        Likewise the ability to say "$x.'foo'" does not imply that $x'foo'
        will work.)
        The postfix interpretation of an operator may be overridden by use
        of a quoted method call, which calls the prefix form instead. So
        "x().!" is always the postfix operator, but "x().'!'" will always
        call "!x()". In particular, you can say things like "$array.'@'".
        This also includes any operator that would look like something with
        a special meaning if used after the method-calling dot. For example,
        if you defined a "prefix:<=>", and you wanted to write it using the
        method-call syntax instead of "=$object", the parser would take
        "$object.=" as the mutation syntax (see S12, "Mutating methods").
        Writing "$object.'='" will call your prefix operator.
    *   Unary "~" now imposes a string ("Stringy") context on its argument,
        and "+" imposes a numeric ("Numeric") context (as opposed to being a
        no-op in Perl 5). Along the same lines, "?" imposes a boolean
        ("Bool") context, and the "|" unary operator imposes a
        function-arguments ("List" or "Capture") context on its argument.
        Unary sigils are allowed when followed by a "$" sigil on a scalar
        variable; they impose the container context implied by their sigil.
        As with Perl 5, however, $$foo[bar] parses as "( $($foo) )[bar]", so
        you need "$($foo[bar])" to mean the other way. In other words,
        sigils are not really parsed as operators, and you must use the
        parenthetical form for anything complicated.
    *   Bitwise operators get a data type prefix: "+", "~", or "?". For
        example, Perl 5's "|" becomes either "+|" or "~|" or "?|", depending
        on whether the operands are to be treated as numbers, strings, or
        boolean values. Perl 5's left shift " << " becomes " +< ", and
        correspondingly with right shift. Perl 5's unary "~" (one's
        complement) becomes either "+^" or "~^" or "?^", since a bitwise NOT
        is like an exclusive-or against solid ones. Note that "?^" is
        functionally identical to "!", but conceptually coerces to boolean
        first and then flips the bit. Please use "!" instead. As explained
        in "Assignment operators", a bitwise operator can be turned into its
        corresponding assignment operator by following it with "=". For
        example Perl 5's " <<= " becomes " +<= ".
        "?|" is a logical OR but differs from "||" in that "?|" always
        evaluates both sides and returns a standard boolean value. That is,
        it's equivalent to "?$a + ?$b != 0". Another difference is that it
        has the precedence of an additive operator.
        "?&" is a logical AND but differs from "&&" in that "?&" always
        it's equivalent to "?$a * ?$b != 0". Another difference is that it
        has the precedence of a multiplicative operator.
        Bitwise string operators (those starting with "~") may only be
        applied to "buf" types or similar compact integer arrays, and treat
        the entire chunk of memory as a single huge integer. They differ
        from the "+" operators in that the "+" operators would try to
        convert the string to a number first on the assumption that the
        string was an ASCII representation of a number.
    *   "x" splits into two operators: "x" (which concatenates repetitions
        of a string to produce a single string), and "xx" (which creates a
        list of repetitions of a list or item). ""foo" xx *" represents an
        arbitrary number of copies, useful for initializing lists. The left
        side of an "xx" is re-evaluated for each copy; use a temporary to
        force a single evaluation. (But note that this is not necessary when
        the optimizer will do constant folding.)
    *   The "? :" conditional operator becomes "?? !!". A pseudo operator,
        "infix:<?>", catches migratory brainos at compile time.
    *   "qw{ ... }" gets a synonym: "< ... >", and an interpolating variant,
        "«...»". For those still living without the blessings of Unicode,
        that can also be written: "<< ... >>".
    *   Comma "," now constructs a "List" object from its operands. You have
        to use a "[*-1]" subscript to get the last one. (Note the "*".
        Negative subscripts no longer implicitly count from the end; in
        fact, the compiler may complain if you use "[-1]" on an object known
        at compile time not to have negative subscripts.)
    *   The unary backslash operator is not really an operator, but a
        special noun form. It "captures" its argument or arguments, and
        returns an object representing those arguments. You can
        *dereference* this object in several ways to retrieve different
        parts of the arguments; see the definition of "Capture" in S02 for
        details. (No whitespace is allowed after the backslash because that
        would instead start an "unspace", that is, an escaped sequence of
        whitespace or comments. See S02 for details. However, oddly enough,
        because of that unspace rule, saying "\\ $foo" turns out to be
        equivalent to "\$foo".)
    *   The old ".." flipflop operator is now done with "ff" operator. (".."
        now always produces a "Range" object even in item context.) The "ff"
        operator may take a caret on either end to exclude either the
        beginning or ending. There is also a corresponding "fff" operator
        with Perl 5's "..." semantics.
        The two sides of a flipflop are evaluated as smartmatches against
        the current value of the topic stored in $_. For instance, you may
        say
            /foo/ ff *
        to match the first line containing 'foo', along with all following
        lines: since the "*" always smartmatches, it create a flipflop that
        never flops once flipped.
        The state of a flipflop is kept in an anonymous state variable, so
        separate closure clones get their own states.
        Note that unlike Perl 5's flipflop, numeric values are not
        automatically checked against the current line number. (If you wish
        to have those semantics for your smartmatches, you could mixin a
        numeric value to $_ to create a chimeric object that is both integer
        and string. Conjecture: "lines()" should have an option that does
        this.)
    *   All comparison operators are unified at the same precedence level.
        See "Chained comparisons" below.
    *   The list assignment operator now parses on the right like any other
        list operator, so you don't need parens on the right side of:
            @foo = 1, 2, 3;
        You do still need them on the left for
            ($a, $b, $c) = 1, 2, 3;
        since assignment operators are tighter than comma to their left.
        "Don't care" positions may be indicated by assignment to the "*"
        token. A final "*" throws away the rest of the list:
            ($a, *, $c) = 1, 2, 3;      # throw away the 2
            ($a, $b, $c, *) = 1..42;    # throw away 4..42
        (Within signature syntax, a bare "$" can ignore a single argument as
        well, and a bare "*@" can ignore the remaining arguments.)
        List assignment offers the list on the right to each container on
        the left in turn, and each container may take one or more elements
        from the front of the list. If there are any elements left over, a
        warning is issued unless the list on the left ends with "*" or the
        final iterator on the right is defined in terms of "*". Hence none
        of these warn:
            ($a, $b, $c, *) = 1..9999999;
            ($a, $b, $c) = 1..*;
            ($a, $b, $c) = 1 xx *;
            ($a, $b, $c) = 1, 2, *;
        This, however, warns you of information loss:
            ($a, $b, $c) = 1, 2, 3, 4;
        As in Perl 5, assignment to an array or hash slurps up all the
        remaining values, and can never produce such a warning. (It will,
        however, leave any subsequent lvalue containers with no elements,
        just as in Perl 5.)
        The left side is evaluated completely for its sequence of containers
        before any assignment is done. Therefore this:
            my $a = 0; my @b;
            ($a, @b[$a]) = 1, 2;
        assigns 2 to @b[0], not @b[1].
    *   The item assignment operator expects a single expression with
        precedence tighter than comma, so
            loop ($a = 1, $b = 2; ; $a++, $b++) {...}
        works as a C programmer would expect. The term on the right of the
        "=" is always evaluated in item context.
        The syntactic distinction between item and list assignment is
        similar to the way Perl 5 defines it, but has to be a little
        different because we can no longer decide the nature of an inner
        subscript on the basis of the outer sigil. So instead, item
        assignment is restricted to lvalues that are simple scalar
        variables, and assignment to anything else is parsed as list
        assignment. The following forms are parsed as "simple lvalues", and
        imply item assignment to the scalar container:
            $a = 1          # scalar variable
            $foo::bar = 1   # scalar package variable
            $(ANY) = 1      # scalar dereference (including $$a)
            $::(ANY) = 1    # symbolic scalar dereference
            $foo::(ANY) = 1 # symbolic scalar dereference
        Such a scalar variable lvalue may be decorated with declarators,
        types, and traits, so these are also item assignments:
            my $fido = 1
            my Dog $fido = 1
            my Dog $fido is trained is vicious = 1
        However, anything more complicated than that (including parentheses
        and subscripted expressions) forces parsing as list assignment
        instead. Assignment to anything that is not a simple scalar
        container also forces parsing as list assignment. List assignment
        expects an expression that is looser than comma precedence. The
        right side is always evaluated in list context:
            ($x) = 1,2,3
            $x[1] = 1,2,3
            @$array = 1,2,3
            my ($x, $y) = 1,2,3
            our %hash = :a<1>, :b<2>
        The rules of list assignment apply, so all the assignments involving
        $x above produce warnings for discarded values. A warning may be
        issued at compile time if it is detected that a run-time warning is
        inevitable.
        The "=" in a default declaration within a signature is not really
        assignment, and is always parsed as item assignment. (That is, to
        assign a list as the default value you must use parentheses to hide
        any commas in the list value.)
        To assign a list to a scalar value, you cannot say:
            $a = 1, 2, 3;
        because the 2 and 3 will be seen as being in a sink (void) context,
        as if you'd said:
            ($a = 1), 2, 3;
        Instead, you must do something to explicitly disable or subvert the
        item assignment interpretation:
            $a = [1, 2, 3];             # force construction (probably best practice)
            $a = (1, 2, 3);             # force grouping as syntactic item
            $a = list 1, 2, 3;          # force grouping using listop precedence
            $a = @(1, 2, 3);            # same thing
            @$a = 1, 2, 3;              # force list assignment
            $a[] = 1, 2, 3;             # same thing
        If a function is contextually sensitive and you wish to return a
        scalar value, you must use "item" (or "$" or "+" or "~") if you wish
        to force item context for either the subscript or the right side:
            @a[foo()] = bar();           # foo() and bar() called in list context
            @a[item foo()] = item bar(); # foo() and bar() called in item context
            @a[$(foo())] = $(bar());     # same thing
            @a[+foo()] = +bar();         # foo() and bar() called in numeric context
            %a{~foo()} = ~bar();         # foo() and bar() called in string context
        But note that the first form still works fine if "foo()" and "bar()"
        are item-returning functions that are not context sensitive.
        In general, this will all just do what the user expects most of the
        time. The rest of the time item or list behavior can be forced with
        minimal syntax.
    *   List operators are all parsed consistently. As in Perl 5, to the
        left a list operator looks like a term, while to the right it looks
        like an operator that is looser than comma. Unlike in Perl 5, the
        difference between the list operator form and the function form is
        consistently indicated via whitespace between the list operator and
        the first argument. If there is whitespace, it is always a list
        operator, and the next token will be taken as the first term of the
        list (or if there are no terms, as the expression terminator). Any
        infix operator occurring where a term is expected will be
        misinterpreted as a term:
            say + 2;    # means say(+2);
        If there is no whitespace, subsequent parsing depends on the
        syntactic category of the next item. Parentheses (with or without a
        dot) turn the list operator into a function call instead, and all
        the function's arguments must be passed inside the parentheses
        (except for postfix adverbs, which may follow the parentheses
        provided they would not attach to some other operator by the rules
        of precedence).
        A postfix operator following a listop is parsed as working on the
        return value of the listop.
            foo.[]      # same as foo()[]
            foo.()      # same as foo()()
            foo++       # legal (if foo() is rw)
        If the next item after the list operator is an infix operator, a
        syntax error is reported.
        Examples:
            say foo + 1;                        say(foo(+1));
            say foo $x;                         say(foo($x));
            say foo$x;                          ILLEGAL, need space or parens
            say foo+1;                          ILLEGAL, need space or parens
            say foo($bar+1),$baz                say(foo($bar+1), $baz);
            say foo.($bar+1),$baz               say(foo().($bar+1), $baz);
            say foo ($bar+1),$baz               say(foo($bar+1, $baz));
            say foo .($bar+1),$baz              say(foo($_.($bar+1), $baz));
            say foo[$bar+1],$baz                say((foo()[$bar+1]), $baz);
            say foo.[$bar+1],$baz               say((foo()[$bar+1]), $baz);
            say foo [$bar+1],$baz               say(foo([$bar+1], $baz));
            say foo .[$bar+1],$baz              say(foo($_.[$bar+1], $baz));
            say foo{$bar+1},$baz                say((foo(){$bar+1}), $baz);
            say foo.{$bar+1},$baz               say((foo(){$bar+1}), $baz);
            say foo {$bar+1},$baz               say(foo({$bar+1}, $baz));
            say foo .{$bar+1},$baz              say(foo($_.{$bar+1}, $baz));
            say foo<$bar+1>,$baz                say(foo()<$bar+1>, $baz);
            say foo.<$bar+1>,$baz               say(foo()<$bar+1>, $baz);
            say foo <$bar+1>,$baz               say(foo(<$bar+1>, $baz));
            say foo .<$bar+1>,$baz              say(foo($_.<$bar+1>, $baz));
        Note that Perl 6 is making a consistent three-way distinction
        between term vs postfix vs infix, and will interpret an overloaded
        character like "<" accordingly:
            any <a b c>                 any('a','b','c')        # term
            any()<a b c>                (any).{'a','b','c'}     # postfix
            any() < $x                  (any) < $x              # infix
            any<a b c>                  ILLEGAL                 # stealth postfix
        This will seem unfamiliar and "undwimmy" to Perl 5 programmers, who
        are used to a grammar that sloppily hardwires a few postfix
        operators at the price of extensibility. Perl 6 chooses instead to
        mandate a whitespace dependency in order to gain a completely
        extensible class of postfix operators.
    *   A list operator's arguments are also terminated by a closure that is
        not followed by a comma or colon. (And a semicolon is implied if the
        closure is the final thing on a line. Use an "unspace" to suppress
        that.) This final closure may be followed by a postfix, in which
        case the postfix is applied to the result of the entire list
    *   A function predeclared with an empty signature is considered 0-ary
        at run time but is still parsed as a list prefix operator, and looks
        for a following argument list, which it may reject at run time.
            my sub foo () {...};
            foo;          # okay
            foo();        # okay
            foo (),(),(); # okay
            foo 1;        # fails to dispatch
        The compiler is allowed to complain about anything it knows cannot
        succeed at run time. Note that a multi may contain () as one of its
        signatures, however:
            my multi foo () {...};
            my multi foo ($x) {...};
            foo 1;        # okay
        To declare an item that is parsed as a simple term, you must use the
        form "term:<foo>", or some other form of constant declaration such
        as an enum declaration. Such a term never looks for its arguments,
        is never considered a list prefix operator, and may not work with
        subsequent parentheses because it will be parsed as a function call
        instead of the intended term. (The function in question may or may
        not exist.) For example, "rand" is a simple term in Perl 6 and does
        not allow parens, because there is no "rand()" function (though
        there's a "$n.rand" method). Most constant values such as "e" and
        "pi" are in the same category. After parsing one of these the parser
        expects to see a postfix or an infix operator, not a term. Therefore
        any attempt to use a simple value as a list operator is destined to
        fail with an error indicating the parser saw two terms in a row.
        For those values (such as types) that do respond to parentheses
        (that is, that do the "Callable" role), the parentheses (parsed as a
        postfix operator) are required in order to invoke the object:
            my $i = Int.($x);   # okay
            my $i = Int($x);    # okay
            my $i = Int $x;     # ILLEGAL, two terms in a row
    *   A non-multi sub predeclared with an arity of exactly 1 also still
        parses as a list prefix operator expecting multiple arguments. You
        must explicitly use the form "prefix:<foo>" to declare "foo" as a
        named unary in precedence; it must still take a single positional
        parameter (though any number of named parameters are allowed, which
        can be bound to adverbs). All other subs with arguments parse as
        list operators.
Junctive operators
    "|", "&", and "^" are no longer bitwise operators (see "Changes to Perl
    5 operators") but now serve a much higher cause: they are now the
    junction constructors.
    A junction is a single value that is equivalent to multiple values. They
    thread through operations, returning another junction representing the
    result:
         (1|2|3) + 4;                            # 5|6|7
         (1|2) + (3&4);                          # (4|5) & (5|6)
    As illustrated by the last example, when two junctions are applied
    through a single operator, the result is a junction representing the
    application of the operator to each possible combination of values.
    Junctions come with the functional variants "any", "all", "one", and
    "none".
    This opens doors for constructions like:
         if $roll == none(1..6) { print "Invalid roll" }
         if $roll == 1|2|3 { print "Low roll" }
    Junctions work through subscripting:
        doit() if @foo[any(1,2,3)]
    Junctions are specifically unordered. So if you say
        foo() | bar() | baz() == 42
    it indicates to the compiler that there is no coupling between the
    junctional arguments. They can be evaluated in any order or in parallel.
    They can short-circuit as soon as any of them return 42, and not run the
    others at all. Or if running in parallel, the first successful thread
    may terminate the other threads abruptly. In general you probably want
    to avoid code with side effects in junctions.
    Use of negative operators with junctions is potentially problematic if
    autothreaded naively. However, by defining "!=" and "ne" in terms of the
    negation metaoperator, we automatically get the "not raising" that is
    expected by an English speaker. That is
        if $a != 1 | 2 | 3 {...}
        if $a ![==] 1 | 2 | 3 {...}
    which the metaoperator rewrites to a higher-order function resembling
        negate((* == *), $a, (1|2|3));
    which ends up being equivalent to:
        if not $a == 1 | 2 | 3 {...}
    which is the semantics an English speaker expects. However, it may well
    be better style to write the latter form yourself.
    Junctive methods on arrays, lists, and sets work just like the
    corresponding list operators. However, junctive methods on a hash make a
    junction of only the hash's keys. Use the listop form (or an explicit
    ".pairs") to make a junction of pairs.
    The various operators for sets and bags (intersection, union, etc.) also
    have junctive precedence (except for those that return "Bool", which are
    instead classified as chaining operators).
Comparison semantics
    *   Perl 5's comparison operators are basically unchanged, except that
        they can be chained because their precedence is unified.
    *   Binary "===" tests immutable type and value correspondence: for two
        value types (that is, immutable types), tests whether they are the
        same value (eg. "1 === 1"); for two mutable types (object types),
        checks whether they have the same identity value. (For most such
        types the identity is simply the reference itself.) It is not true
        that "[1,2] === [1,2]" because those are different "Array" objects,
        but it is true that "@a === @a" because those are the same "Array"
        object).
        Any object type may pretend to be a value type by defining a
        ".WHICH" method which returns a value type that can be recursively
        compared using "===", or in cases where that is impractical, by
        overloading "===" such that the comparison treats values
        consistently with their "eternal" identity. (Strings are defined as
        values this way despite also being objects.)
        Two values are never equivalent unless they are of exactly the same
        type. By contrast, "eq" always coerces to string, while "==" always
        coerces to numeric. In fact, "$a eq $b" really means "~$a === ~$b"
        and "$a == $b" means "+$a === +$b".
        Note also that, while string-keyed hashes use "eq" semantics by
        default, object-keyed hashes use "===" semantics, and general
        value-keyed hashes use "eqv" semantics.
    *   Binary "eqv" tests equality much like "===" does, but does so with
        "snapshot" semantics rather than "eternal" semantics. For top-level
        components of your value that are of immutable types, "eqv" is
        identical in behavior to "===". For components of your value that
        are mutable, however, rather than comparing object identity using
        "===", the "eqv" operator tests whether the canonical representation
        of both subvalues would be identical if we took a snapshot of them
        right now and compared those (now-immutable) snapshots using "===".
        If that's not enough flexibility, there is also an "eqv()" function
        that can be passed additional information specifying how you want
        canonical values to be generated before comparison. This gives
        "eqv()" the same kind of expressive power as a sort signature. (And
        indeed, the "cmp" operator from Perl 5 also has a functional analog,
        "cmp()", that takes additional instructions on how to do 3-way
        comparisons of the kind that a sorting algorithm wants.) In
        particular, a signature passed to "eqv()" will be bound to the two
        operands in question, and then the comparison will proceed on the
        formal parameters according to the information contained in the
        signature, so you can force numeric, string, natural, or other
        comparisons with proper declarations of the parameter's type and
        traits. If the signature doesn't match the operands, "eqv()" reverts
        to standard "eqv" comparison. (Likewise for "cmp()".)
    *   Binary "cmp" is no longer the comparison operator that forces
        stringification. Use the "leg" operator for the old Perl 5 "cmp"
        semantics. The "cmp" is just like the "eqv" above except that
        instead of returning "Bool::False" or "Bool::True" values it always
        returns "Order::Less", "Order::Same", or "Order::More" (which
        numerify to -1, 0, or +1).
    *   The "leg" operator (less than, equal to, or greater than) is defined
        in terms of "cmp", so "$a leg $b" is now defined as "~$a cmp ~$b".
        The sort operator still defaults to "cmp" rather than "leg". The
        "<=>" operator's semantics are unchanged except that it returns an
        "Order" value as described above. In other words, "$a <=> $b" is now
        equivalent to "+$a cmp +$b".
    *   For boolean comparison operators with non-coercive "cmp" semantics,
        use the generic "before" and "after" infix operators. As ordinary
        infix operators these may be negated ("!before" and "!after") as
        well as reduced ("[before]" and "[after]").
    *   Infix "min" and "max" may be used to select one or the other of
        their arguments. Reducing listop forms "[min]" and "[max]" are also
        available, as are the "min=" and "max=" assignment operators. By
        default "min" and "max" use "cmp" semantics. As with all "cmp"-based
        operators, this may be modified by an adverb specifying different
    *   Note that, like most other operators, a comparison naturally returns
        failure if either of its arguments is undefined, and the general
        policy on unthrown exceptions is that the exception is thrown as
        soon as you try to use the exception as a real value. However,
        various parallelizable contexts such as hyper (or other "mass
        production" contexts such as sort) will pass through unthrown
        exceptions rather than throwing them.
Range and RangeIter semantics
    The ".." range operator has variants with "^" on either end to indicate
    exclusion of that endpoint from the range. It always produces a "Range"
    object. Range objects are immutable, and primarily used for matching
    intervals. 1..2 is the interval from 1 to 2 inclusive of the endpoints,
    whereas "1^..^2" excludes the endpoints but matches any real number in
    between.
    For numeric arguments of differing type, ranges coerce to the wider
    type, so:
        1 .. 1.5
    is taken to mean:
        1.0 .. 1.5
    These coercions are defined by multi signatures. (Other types may have
    different coercion policies.) It is specifically illegal to use a
    "Range" as an endpoint:
        0 ..^ 10  # 0 .. 9
        0 .. ^10  # ERROR
    For ranges with other non-numeric types on the right, the right argument
    is coerced to numeric and then used above. Hence, "Array" types in the
    second argument are assumed to be intended as numeric if the left
    argument is numeric:
        0 ..^ @x    # okay
        0 ..^ +@x   # same thing
    Likewise for strings:
        0 .. '1.5'  # okay
        0 .. +'1.5' # same thing
    "Whatever" types are also supported to represent "-Inf"/"+Inf". If
    either endpoint is a "WhateverCode", the range is primed into another
    "WhateverCode".
    For other types, ranges may be composed for any two arguments of the
    same type, if the type itself supports it. That is, in general,
    "infix:<..>:(::T Any $x, T $y)" is defined such that, if type "T"
    defines generic comparison (that is, by defining "infix:<cmp>" or
    equivalent), a range is constructed in that type. If "T" also defines
    ".succ", then the range may be iterated. (Otherwise the range may only
    be used as an interval, and will return failure if asked for a
    "RangeIter".) Note that it is not necessary to define a range
    multimethod in type "T", since the generic routine can usually
    auto-generate the range for you.
    Range objects support ".min" and ".max" methods representing their left
    and right arguments. The ".bounds" method returns both values as a
    two-element list representing the interval. Ranges are not
    autoreversing: 2..1 is always a null range. (The sequence operator "..."
    can autoreverse, however. See below.)
    Range objects support ".excludes-min" and ".excludes-max" methods
    representing the exclusion (has "^") or inclusion (no "^") of each
    endpoint in the "Range".
        Range      | .min | .max | .excludes-min | .excludes-max
        -----------+------+------+---------------+------------
        1..10      | 1    | 10   | Bool::False   | Bool::False
        2.7..^9.3  | 2.7  | 9.3  | Bool::False   | Bool::True
        'a'^..'z'  | 'a'  | 'z'  | Bool::True    | Bool::False
        1^..^10    | 1    | 10   | Bool::True    | Bool::True
    If used in a list context, a "Range" object returns an iterator that
    produces a sequence of values starting at the min and ending at the max.
    Either endpoint may be excluded using "^". Hence 1..2 produces "(1,2)"
    but "1^..^2" is equivalent to 2..1 and produces no values, like "()"
    does. To specify a sequence that counts down, use a reverse:
        reverse 1..2
        reverse 'a'..'z'
    Alternately, for numeric sequences, you can use the sequence operator
    instead of the range operator:
        100,99,98 ... 0
        100, *-1 ... 0      # same thing
    In other words, any "Range" used as a list assumes ".succ" semantics,
    never ".pred" semantics. No other increment is allowed; if you wish to
    increment a numeric sequence by some number other than 1, you must use
    the "..." sequence operator.
        0, *+0.1 ... 100    # 0, 0.1, 0.2, 0.3 ... 100
    A "Range" may be iterated only if the type in question supports the
    ".succ" method. If it does not, any attempt to iterate returns failure.
    Smart matching against a "Range" object does comparisons (by coercion,
    if necessary) in the "Real" domain if either endpoint does "Real".
    Otherwise comparison is in the "Stringy" domain if either argument does
    "Stringy". Otherwise the min's type is used if it defines ordering, or
    if not, the max's type. If neither min nor max have an ordering,
    dispatch to ".ACCEPTS" fails. It may also fail if the ordering in
    question does not have any way to coerce the object being smartmatched
    into an appropriate type implied by the chosen domain of ordering.
    In general, the domain of comparison should be a type that can represent
    all the values in question, if possible. Hence, since "Int" is not such
    a type, it is promoted to a "Real", so fractional numbers are *not*
    truncated before comparison to integer ranges. Instead the integers are
    assumed to represent points on the real number line:
        1.5 ~~ 1^..^2  # true, equivalent to 1 < 1.5 < 2
        2.1 ~~ 1..2    # false, equivalent to 1 <= 2.1 <= 2
    If a "*" (see the "Whatever" type in S02) occurs on the right side of a
    range, it is taken to mean "positive infinity" in whatever typespace the
    range is operating, as inferred from the left operand. A "*" on the left
    means "negative infinity" for types that support negative values, and
    the first value in the typespace otherwise as inferred from the right
    operand.
        0..*        # 0 .. +Inf
        'a'..*      # 'a' le $_
        *..0        # -Inf .. 0
        *..*        # -Inf .. +Inf
        v1.2.3 .. * # Any version higher than 1.2.3.
        May .. *    # May through December
    An empty range cannot be iterated; it returns "()" instead. An empty
    range still has a defined ".min" and ".max", but one of the following is
    true: 1. The ".min" is greater than the ".max". 2. The ".min" is equal
    to the ".max" *and* at least one of ".excludes-min" or ".excludes-max"
    is true. 3. Both ".excludes-min" and ".excludes-max" are true *and*
    ".min" and ".max" are consecutive values in a discrete type that cannot
    create new values between those two consecutive values. For this
    purpose, interval representations in "Real" (including integers) are
    considered infinitely divisible even though there is a practical limit
    depending on the actual representation, so #3 does not apply. (Nor does
    it apply to strings, versions, instants, or durations. #3 does apply to
    enums, however, so "Tue ^..^ Wed" is considered empty because the enum
    in question does not define "Tuesday and a half".)
    An empty range evaluates to "False" in boolean context; all other ranges
    evaluate to "True".
    Ranges that are iterated transmute into the corresponding sequence
    operator, using ".succ" semantics to find the next value, and the
    appropriate inequality semantics to determine an end to the sequence.
    For a non-discrete type with a discrete ".succ" (such as "Real"), it is
    possible to write a range that, when iterated, produces no values, but
    evaluates to true, because the ".succ" function skips over divisible
    intervals:
        say +( 0 ^..^ 1 )   # 0 elements
        say ?( 0 ^..^ 1 )   # True
        say 0.5 ~~ 0 ^..^ 1 # True; range contains non-integer values
  Unary ranges
    The unary "^" operator generates a range from 0 up to (but not
    including) its argument. So "^4" is short for "0..^4".
        for ^4 { say $_ } # 0, 1, 2, 3
  Auto-priming of ranges
    [This section is conjectural, and may be ignored for 6.0.]
    Since use of "Range" objects in item context is usually non-sensical, a
    "Range" object used as an operand for scalar operators will generally
    attempt to distribute the operator to its endpoints and return another
    suitably modified "Range" instead, much like a junction of two items,
    only with proper interval semantics. (Notable exceptions to this
    autothreading include "infix:<~~>", which does smart matching, and
    "prefix:<+>" which returns the length of the range.) Therefore if you
    wish to write a slice using a length instead of an endpoint, you can say
        @foo[ start() + ^$len ]
    which is short for:
        @foo[ start() + (0..^$len) ]
    which is equivalent to something like:
        @foo[ list do { my $tmp = start(); $tmp ..^ $tmp+$len } ]
    In other words, operators of numeric and other ordered types are
    generally overloaded to do something sensible on "Range" objects.
Chained comparisons
    Perl 6 supports the natural extension to the comparison operators,
    allowing multiple operands:
        if 1 < $a < 100 { say "Good, you picked a number *between* 1 and 100." }
        if 3 < $roll <= 6              { print "High roll" }
        if 1 <= $roll1 == $roll2 <= 6  { print "Doubles!" }
    A chain of comparisons short-circuits if the first comparison fails:
        1 > 2 > die("this is never reached");
    Each argument in the chain will evaluate at most once:
        1 > $x++ > 2    # $x increments exactly once
    Note: any operator beginning with "<" must have whitespace in front of
    it, or it will be interpreted as a hash subscript instead.
Smart matching
    Here is the table of smart matches for standard Perl 6 (that is, the
    dialect of Perl in effect at the start of your compilation unit). Smart
    matching is generally done on the current "topic", that is, on $_. In
    the table below, $_ represents the left side of the "~~" operator, or
    the argument to a "given", or to any other topicalizer. "X" represents
    the pattern to be matched against on the right side of "~~", or after a
    "when". (And, in fact, the "~~" operator works as a small topicalizer;
    that is, it binds $_ to the value of the left side for the evaluation of
    the right side. Use the underlying ".ACCEPTS" form to avoid this
    topicalization.)
    The first section contains privileged syntax; if a match can be done via
    one of those entries, it will be. These special syntaxes are dispatched
    by their form rather than their type. Otherwise the rest of the table is
    used, and the match will be dispatched according to the normal method
    dispatch rules. The optimizer is allowed to assume that no additional
    match operators are defined after compile time, so if the pattern types
    are evident at compile time, the jump table can be optimized. However,
    the syntax of this part of the table is still somewhat privileged,
    insofar as the "~~" operator is one of the few operators in Perl that
    does not use multiple dispatch. Instead, type-based smart matches singly
    dispatch to an underlying method belonging to the "X" pattern object.
    In other words, smart matches are dispatched first on the basis of the
    pattern's form or type (the "X" below), and then that pattern itself
    decides whether and how to pay attention to the type of the topic ($_).
    So the second column below is really the primary column. The "Any"
    entries in the first column indicate a pattern that either doesn't care
    about the type of the topic, or that picks that entry as a default
    because the more specific types listed above it didn't match.
        $_          X         Type of Match Implied   Match if (given $_)
        ======      =====     =====================   ===================
        Any         True      ~~ True                 (parsewarn on literal token)
        Any         False     ~~ False match          (parsewarn on literal token)
        Any         Match     ~~ Successful match     (parsewarn on literal token)
        Any         Nil       ~~ Benign failure       (parsewarn on literal token)
        Any         Failure   Failure type check      (okay, matches against type)
        Any         *         block signature match   block successfully binds to |$_
        Any         Callable:($)  item sub truth          X($_)
        Any         Callable:()   simple closure truth    X() (ignoring $_)
        Any         Bool      simple truth            X (treats Bool value as success/failure)
        Positional  List      lists are comparable    $_ »~~« X (but dwims ** wildcards!)
        Any         Match     match success           X (treats Match value as success)
        Any         Nil       benign failure          X (treats Nil value as failure)
        Any         Failure   malign failure          X (passes Failure object through)
        Any         Numeric   numeric equality        +$_ == X
        Any         Stringy   string equality         ~$_ eq X
        Any         Whatever  always matches          True
        Associative Pair      test hash mapping       $_{X.key} ~~ X.value
        Any         Pair      test object attribute   ?."{X.key}" === ?X.value (e.g. filetests)
        Set         Set       identical sets          $_ === X
        Any         Setty     force set comparison    $_.Set === X.Set
        Bag         Bag       identical bags          $_ === X
        Any         Baggy     force bag comparison    $_.Bag === X.Bag
        Mix         Mix       identical bags          $_ === X
        Any         Mixy      force mix comparison    $_.Mix === X.Mix
        Associative Array     keys/list are comparable +X == +$_ and $_{X.all}:exists
        Callable    Positional list vs predicate      so $_(X)
        Any         Positional lists are comparable   $_[] «===» X[]
        Hash        Hash      hash mapping equivalent $_ eqv X
        Associative Hash      force hash comparison   $_.Hash eqv X
        Callable    Hash      hash vs predicate       so $_(X)
        Positional  Hash      attempted any/all       FAIL, point user to [].any and [].all for LHS
        Pair        Hash      hash does mapping       X{.key} ~~ .value
        Any         Hash      hash contains object    X{$_}:exists
        Str         Regex     string pattern match    .match(X)
        Associative Regex     attempted reverse dwim  FAIL, point user to any/all vs keys/values/pairs
        Positional  Regex     attempted any/all/cat   FAIL, point user to any/all/cat/join for LHS
        Any         Regex     pattern match           .match(X)
        Range       Range     subset range            !$_ or .bounds.all ~~ X (mod ^'s)
        Any         Range     in real range           X.min <= $_ <= X.max (mod ^'s)
        Any         Range     in stringy range        X.min le $_ le X.max (mod ^'s)
        Any         Range     in generic range        [!after] X.min,$_,X.max (etc.)
        Any         Type      type membership         $_.does(X)
        Signature   Signature sig compatibility       $_ is a subset of X      ???
        Callable    Signature sig compatibility       $_.sig is a subset of X  ???
        Capture     Signature parameters bindable     $_ could bind to X (doesn't!)
        Any         Signature parameters bindable     |$_ could bind to X (doesn't!)
        Signature   Capture   parameters bindable     X could bind to $_
        Any         Any       scalars are identical   $_ === X
    The final rule is applied only if no other pattern type claims X.
    All smartmatch types are "itemized"; both "~~" and "given"/"when"
    provide item contexts to their arguments, and autothread any junctive
    matches so that the eventual dispatch to ".ACCEPTS" never sees anything
    "plural". So both $_ and "X" above are potentially container objects
    that are treated as scalars. (You may hyperize "~~" explicitly, though.
    In this case all smartmatching is done using the type-based dispatch to
    ".ACCEPTS", not the form-based dispatch at the front of the table.)
    The exact form of the underlying type-based method dispatch is:
        X.ACCEPTS($_)
    As a single dispatch call this pays attention only to the type of "X"
    initially. The "ACCEPTS" method interface is defined by the "Pattern"
    role. Any class composing the "Pattern" role may choose to provide a
    single "ACCEPTS" method to handle everything, which corresponds to those
    pattern types that have only one entry with an "Any" on the left above.
    Or the class may choose to provide multiple "ACCEPTS" multi-methods
    within the class, and these will then redispatch within the class based
    on the type of $_.
    The smartmatch table is primarily intended to reflect forms and types
    that are recognized at compile time. To avoid an explosion of entries,
    the table assumes the following types will behave similarly:
        Actual type                 Use entries for
        ===========                 ===============
        Iterator Array              List
        named values created with
          Class, Enum, or Role,
          or generic type binding   Type
        Cat                         Str
        Int UInt etc.               Num
        Buf                         Str or Array of Int
    (Note, however, that these mappings can be overridden by explicit
    definition of the appropriate "ACCEPTS" methods. If the redefinition
    occurs at compile time prior to analysis of the smart match then the
    information is also available to the optimizer.)
    A "Buf" type containing any bytes or integers outside the ASCII range
    may silently promote to a "Str" type for pattern matching if and only if
    its relationship to Unicode is clearly declared or typed. This type
    information might come from an input filehandle, or the "Buf" role may
    be a parametric type that allows you to instantiate buffers with various
    known encodings. In the absence of such typing information, you may
    still do pattern matching against the buffer, but (apart from assuming
    the lowest 7 bits represent ASCII) any attempt to treat the buffer as
    other than a sequence of integers is erroneous, and warnings may be
    generously issued.
    Matching against a "Grammar" treats the grammar as a typename, not as a
    grammar. You need to use the ".parse" or ".parsefile" methods to invoke
    a grammar.
    Matching against a "Signature" does not actually bind any variables, but
    only tests to see if the signature *could* bind. To really bind to a
    signature, use the "*" pattern to delegate binding to the "when"
    statement's block instead. Matching against "*" is special in that it
    takes its truth from whether the subsequent block is bound against the
    topic, so you can do ordered signature matching:
        given $capture {
            when * -> Int $a, Str $b { ... }
            when * -> Str $a, Int $b { ... }
            when * -> $a, $b         { ... }
            when *                   { ... }
    This can be useful when the unordered semantics of multiple dispatch are
    insufficient for defining the "pecking order" of code. Note that you can
    bind to either a bare block or a pointy block. Binding to a bare block
    conveniently leaves the topic in $_, so the final form above is
    equivalent to a "default". (Placeholder parameters may also be used in
    the bare block form, though of course their types cannot be specified
    that way.)
    There is no pattern matching defined for the "Any" pattern, so if you
    find yourself in the situation of wanting a reversed smartmatch test
    with an "Any" on the right, you can almost always get it by an explicit
    call to the underlying "ACCEPTS" method using $_ as the pattern. For
    example:
        $_      X    Type of Match Wanted   What to use on the right
        ======  ===  ====================   ========================
        Callable Any  item sub truth         .ACCEPTS(X) or .(X)
        Range   Any  in range               .ACCEPTS(X)
        Type    Any  type membership        .ACCEPTS(X) or .does(X)
        Regex   Any  pattern match          .ACCEPTS(X)
        etc.
    Similar tricks will allow you to bend the default matching rules for
    composite objects as long as you start with a dotted method on $_:
        given $somethingordered {
            when .values.'[<=]'     { say "increasing" }
            when .values.'[>=]'     { say "decreasing" }
    In a pinch you can define a macro to do the "reversed when":
        my macro statement_control:<ACCEPTS> () { "when .ACCEPTS: " }
        given $pattern {
            ACCEPTS $a      { ... }
            ACCEPTS $b      { ... }
            ACCEPTS $c      { ... }
    Various proposed-but-deprecated smartmatch behaviors may be easily (and
    we hope, more readably) emulated as follows:
        $_      X      Type of Match Wanted   What to use on the right
        ======  ===    ====================   ========================
        Array   Num    array element truth    .[X]
        Array   Num    array contains number  *,X,*
        Array   Str    array contains string  *,X,*
        Array   List   array begins /w List   X,*
        Array   List   array contains List    *,X,*
        Array   List   array ends with List   *,X
        Hash    Str    hash element truth     .{X}
        Hash    Str    hash key existence     .{X}:exists
        Hash    Num    hash element truth     .{X}
        Hash    Num    hash key existence     .{X}:exists
        Buf     Int    buffer contains int    .match(X)
        Str     Str    string contains string .match(X)
        Array   Scalar array contains item    .any === X
        Str     Array  array contains string  X.any
        Num     Array  array contains number  X.any
        Scalar  Array  array contains object  X.any
        Hash    Array  hash slice exists      .{X.all}:exists .{X.any}:exists
        Set     Set    subset relation        .{X.all}:exists
        Set     Hash   subset relation        .{X.all}:exists
        Any     Set    subset relation        .Set.{X.all}:exists
        Any     Hash   subset relation        .Set.{X.all}:exists
        Any     Set    superset relation      X.{.all}:exists
        Any     Hash   superset relation      X.{.all}:exists
        Any     Set    sets intersect         .{X.any}:exists
        Set     Array  subset relation        X,*          # (conjectured)
        Array   Regex  match array as string  .Cat.match(X)  cat(@$_).match(X)
    (Note that the ".cat" method and the "Cat" type coercion both take a
    single object, unlike the "cat" function which, as a list operator,
    takes a syntactic list (or multilist) and flattens it. All of these
    return a "Cat" object, however.)
    Boolean expressions are those known to return a boolean value, such as
    comparisons, or the unary "?" operator. They may reference $_ explicitly
    or implicitly. If they don't reference $_ at all, that's okay too--in
    that case you're just using the switch structure as a more readable
    alternative to a string of elsifs. Note, however, that this means you
    can't write:
        given $boolean {
            when True  {...}
            when False {...}
    because it will always choose the "True" case. Instead use something
    like a conditional context uses internally:
            when .Bool == 1 {...}
            when .Bool == 0 {...}
    Better, just use an "if" statement. In any case, if you try to
    smartmatch with "~~" or "when", it will recognize "True" or "False"
    syntactically and warn you that it won't do what you expect. The
    compiler is also allowed to warn about any other boolean construct that
    does not test $_, to the extent it can detect that.
    In a similar vein, any function (such as "grep") that takes a "Matcher"
    will not accept an argument of type "Bool", since that almost always
    indicates a programming error. (One may always use "*" to match
    anything, if that's what you really want. Or use a closure that returns
    a constant boolean value.)
    Note also that regex matching does *not* return a "Bool", but merely a
    "Match" object (or a "Nil") that can be used as a boolean value. Use an
    explicit "?" or "so" to force a "Bool" value if desired. A "Match"
    object represents a successful match and is treated by smartmatching the
    same as a "True", Similarly, a "Nil" represents a failure, and cannot be
    used directly on the right side of a smartmatch. Test for definedness
    instead, or use "* === Nil".
    Regex matches with modifiers such as ":g" that wish to return multiple
    matches do so using a "List". As with any list, the value evaluates to
    true if there are 1 or more entries. If there are no matches, an empty
    list is returned, which evaluates to false in a Boolean context.
    For the purpose of smartmatching, all "Set", "Bag", and "Mix" values are
    considered equivalent to the corresponding hash type, "SetHash",
    "BagHash", and "MixHash", that is, "Hash" containers where the keys
    represent the unique objects and the values represent the replication
    count of those unique keys. (Obviously, a "Set" can have only 0 or 1
    replication because of the guarantee of uniqueness). So all of these
    "Mixy" types only compare keys, not values. Use "eqv" instead to test
    the equivalence of both keys and values.
    Despite the need for an implementation to examine the bounds of a range
    in order to perform smartmatching, the result of smartmatching two
    "Range" objects is not actually defined in terms of bounds, but rather
    as a subset relationship between two (potentially infinite) sets of
    values encompassed by the intervals involved, for any orderable type
    such as real numbers, strings, or versions. The result is defined as
    true if and only if all potential elements that would be matched by the
    left range are also matched by the right range. Hence it does not matter
    to what extent the bounds of an empty range are "overspecified". If the
    left range is empty, it always matches, because there exists no value to
    falsify it. If the right range is empty, it can match only if the left
    range is also empty.
    The "Cat" type allows you to have an infinitely extensible string. You
    can match an array or iterator by feeding it to a "Cat", which is
    essentially a "Str" interface over an iterator of some sort. Then a
    "Regex" can be used against it as if it were an ordinary string. The
    "Regex" engine can ask the string if it has more characters, and the
    string will extend itself if possible from its underlying iterator.
    (Note that such strings have an indefinite number of characters, so if
    you use ".*" in your pattern, or if you ask the string how many
    characters it has in it, or if you even print the whole string, it may
    feel compelled to slurp in the rest of the string, which may or may not
    be expeditious.)
    The "cat" operator takes a (potentially lazy) list and returns a "Cat"
    object. In string context this coerces each of its elements to strings
    lazily, and behaves as a string of indeterminate length. You can search
    a gather like this:
        my $lazystr := cat gather for @foo { take .bar }
        $lazystr ~~ /pattern/;
    The "Cat" interface allows the regex to match element boundaries with
    the "<,>" assertion, and the "Match" objects provide a way to get both
    the element's index and the position within that list element. If the
    underlying data structure is a mutable array, changes to the array (such
    as by "shift" or "pop") are tracked by the "Cat" so that the element
    numbers remain correct. Strings, arrays, lists, sequences, captures, and
    tree nodes can all be pattern matched by regexes or by signatures more
    or less interchangeably.
Invocant marker
    An appended ":" marks the invocant when using the indirect-object syntax
    for Perl 6 method calls. The following two statements are equivalent:
        $hacker.feed('Pizza and cola');
        feed $hacker: 'Pizza and cola';
    A colon may also be used on an ordinary method call to indicate that it
    should be parsed as a list operator:
        $hacker.feed: 'Pizza and cola';
    This colon is a separate token. A colon prefixing an adverb is not a
    separate token. Therefore, under the longest-token rule,
        $hacker.feed:xxx('Pizza and cola');
    is tokenized as an adverb applying to the method as its "toplevel
    preceding operator":
        $hacker.feed :xxx('Pizza and cola');
    not as an xxx sub in the argument list of .feed:
        $hacker.feed: xxx('Pizza and cola');  # wrong
    If you want both meanings of colon in order to supply both an adverb and
    some positional arguments, you have to put the colon twice:
        $hacker.feed: :xxx('Pizza and cola'), 1,2,3;
    (For similar reasons it's required to put whitespace after the colon of
    a label.)
    Note in particular that because of adverbial precedence:
        1 + $hacker.feed :xxx('Pizza and cola');
    will apply the ":xxx" adverb to the "+" operator, not the method call.
    This is not likely to succeed.
Feed operators
    The new operators "==>" and "<==" are akin to UNIX pipes, but work with
    functions or statements that accept and return lists. Since these lists
    are composed of discrete objects and not liquids, we call these *feed*
    operators rather than pipes. For example,
         @result = map { floor($^x / 2) },
                     grep { /^ \d+ $/ },
                       @data;
    can also now be written with rightward feeds as:
         @data ==> grep { /^ \d+ $/ }
               ==> map { floor($^x / 2) }
               ==> @result;
    or with leftward feeds as:
         @result <== map { floor($^x / 2) }
                 <== grep { /^ \d+ $/ }
                 <== @data;
    Either form more clearly indicates the flow of data. See S06 for more of
    the (less-than-obvious) details on these two operators.
Meta operators
    Perl 6's operators have been greatly regularized, for instance, by
    consistently prefixing numeric, stringwise, and boolean operators with
    "+", "~" and "?" respectively to indicate whether the bitwise operation
    is done on a number, a string, or a single bit. But that's just a naming
    convention, and if you wanted to add a new bitwise "¬" operator, you'd
    have to add the "+¬", "~¬", and "?¬" operators yourself. Similarly, the
    carets that exclude the endpoints on ranges are there by convention
    only.
    In contrast to that, Perl 6 has eight standard metaoperators for turning
    a given existing operator into a related operator that is more powerful
    (or at least differently powerful). These differ from a mere naming
    convention in that Perl automatically generates these new operators from
    user-defined operators as well as from builtins. In fact, you're not
    generally supposed to define the individual metaoperations--their
    semantics are supposed to be self-evident by the transformation of the
    base operator. In other words, these metaoperators are really just
    shorthand for higher-order functions (functions that take other
    functions as arguments).
    Constructs containing metaoperators are considered "metatokens", by
    which we mean that they are not subject to ordinary longest-token
    matching rules, although their components are. Like ordinary tokens,
    however, metatokens do not allow whitespace between their subparts.
  Assignment operators
    Assignment operators are already familiar to C and Perl programmers.
    (Though the ".=" operator now means to call a mutating method on the
    object on the left, and "~=" is string concatenation.) Most
    non-relational infix operators may be turned into their corresponding
    assignment operator by suffixing with "=". The limitation is actually
    based on whether the left side can function both as an rvalue and an
    lvalue by the usual correspondence:
        A op= B;
        A = A op B;
    Existing forms ending in "=" may not be modified with this metaoperator.
    Regardless of the precedence of the base operator, the precedence of any
    assignment operator is forced to be the same as that of ordinary
    assignment. If the base operator is tighter than comma, the expression
    is parsed as item assignment. If the base operator is the same or looser
    than comma, the expression is parsed as a list assignment:
        $a += 1, $b += 2    # two separate item assignments
        @foo ,= 1,2,3       # same as push(@foo,1,2,3)
        @foo Z= 1,2,3       # same as @foo = @foo Z 1,2,3
    Note that metaassignment to a list does not automatically distribute the
    right argument over the assigned list unless the base operator does (as
    in the "Z" case above). Hence if you want to say:
        ($a,$b,$c) += 1;    # ILLEGAL
    you must instead use a hyperoperator (see below):
        ($a,$b,$c) »+=» 1;  # add one to each of three variables
    If you apply an assignment operator to a container containing a type
    object (which is undefined), it is assumed that you are implementing
    some kind of notional "reduction" to an accumulator variable. To that
    end, the operation is defined in terms of the corresponding reduction
    operator, where the type object autovivifies to the operator's identity
    value. So if you say:
        $x -= 1;
    it is more or less equivalent to:
        $x = [-]() unless defined $x;  # 0 for [-]()
        $x = $x - 1;
    and $x ends up with -1 in it, as expected.
    Hence you may correctly write:
        my Num $prod;
        for @factors -> $f {
            $prod *= $f;
    While this may seem marginally useful in the scalar variable case, it's
    much more important for it to work this way when the modified location
    may have only just been created by autovivification. In other words, if
    you write:
        %prod{$key} *= $f
    you need not worry about whether the hash element exists yet. If it does
    not, it will simply be initialized with the value of $f.
  Negated relational operators
    Any infix relational operator returning type "Bool" may be transformed
    into its negative by prefixing with "!". A couple of these have
    traditional shortcuts:
        Full form   Shortcut
        ---------   --------
        !==         !=
        !eq         ne
    but most of them do not:
        !~~
        !<
        !>=
        !ge
        !===
        !eqv
        !=:=
    To avoid visual confusion with the "!!" operator, you may not modify any
    operator already beginning with "!".
    The precedence of any negated operator is the same as the base operator.
    You may negate only those operators that return a "Bool". Note that
    logical operators such as "||" and "^^" do not return a "Bool", but
    rather one of the operands.
  Reversed operators
    Any infix operator may be called with its two arguments reversed by
    prefixing with "R". For instance, to do reversed comparisons:
        Rcmp
        Rleg
        R<=>
    The precedence of any reversed operator is the same as the base
    operator. The associativity, however, is reversed, so
        [R-] 1,2,3   # produces 0 from 3 - 2 - 1
        [R**] 2,3,4   # produces 262144 from 4 ** 3 ** 2
    Using both left and right associativity at the same precedence level is
    not prohibited, but is likely to drive you mad, unless of course you
    were mad in the first place, which seems almost a certainty by this
    point.
  Hyper operators
    The Unicode characters "»" ("U+00BB") and "«" ("U+00AB") and their ASCII
    digraphs ">>" and "<<" are used to denote a "list operation" that
    operates on each element of its list (or array) argument (or arguments)
    and returns a single list (or array) of the results. In other words, a
    hyper operator evaluates its arguments in item context but then
    distributes the operator over them as lists.
    When writing a hyper operator, spaces are not allowed on the inside,
    that is, between any "hyper" marker and the operator it's modifying. On
    the outside the spacing policy is the same as the base operator.
    Likewise the precedence of any hyperoperator is the same as its base
    operator. This means that you must parenthesize your comma lists for
    most operators. For example:
         -« (1,2,3);                   # (-1, -2, -3)
         (1,1,2,3,5) »+« (1,2,3,5,8);  # (2,3,5,8,13)
    (If you find yourself doing this, ask yourself whether you are really
    working with objects or lists; in the latter case, there may be other
    metaoperators such as "Z" or "X" that are more appropriate, and will not
    require parens.)
    A unary hyper operator (either prefix or postfix) has only one hyper
    marker, located on its argument side, while an infix operator always has
    one on each side to indicate there are two arguments.
   Unary hyper operators
    The meaning of a unary hyper operator depends on whether the operator is
    considered to be a structural dereferencing operator. Most operators are
    not structural.
   Non-structural unary hyper operators
    Non-structural unary hyper operators produce a hash or array of exactly
    the same shape as the single argument. The hyper will descend into
    nested lists and hashes to distribute over the lower-level values just
    as they distribute over the top-level values that are leaves in the
    tree. Non-structural unary hypers do not care whether the nesting is
    achieved by declaration in the case of shaped arrays, or by mere
    incorporation of sublists and subhashes dynamically. In any case the
    operator is applied only to the leaves of the structure.
   Structural unary hyper operators
    There are a few operators that are deemed to be structural, however, and
    will produce counterintuitive results if treated as ordinary operators.
    These include the dereferencing operators such as subscripts, as well as
    any method whose least-derived variant (or proto, in the case of a multi
    method) is declared or autogenerated in a class derived from Iterable.
    Additionally, structural methods include any method placed in class
    "Any" with the intent of treating items as lists of one item. So
    ".elems" is considered structural, but a "prefix:<+"> that happens to
    call ".elems" internally is not considered structural.
    These operations are marked by declaring them with the "is nodal"
    property, which is available by inspection to the hyper controller when
    it examines the function it was passed. (Hypers are just one form of
    higher-order programming, after all, and functions are also objects with
    properties.) So this declaration is to be placed on the top-level
    declaration of the operator, a proto declaration when there are multiple
    candidates, or the candidate itself when there is only one candidate. If
    the "is nodal" trait is declared, the hyper controller will consider it
    to be structural.
    [Conjecture: we can assume "is nodal" on methods declared in a class
    that is "Iterable", to save having to mark every method as nodal. Or we
    provide a pragma within a lexical scope that assumes "is nodal", so we
    can use it inside "Any" as well.]
    [Conjecture: we might revise this be a "does Nodal" role instead of a
    trait, if the implementors decide that makes more sense.]
    For structural hypers, we never implicitly follow references to
    substructures, since the operator itself wants to deal with the
    structure. So these operators distribute only over the top level of the
    structure.
    For arrays or hashes declared with a shape (see S09), this top level may
    be multidimensional; unary hypers consider shaped arrays to really be
    one-dimensional (and indeed, for compactly stored multidimensional
    arrays, multidimensional subscripts can just be calculations into an
    underlying linear representation, which can be optimized to run on a
    GPU, so this makes implementational sense).
    If the item is not declared with a shape, only the top dimension is
    mapped, equivalent to a normal ".map" method. (To map deeper dimensions
    than provided for by hypers, use the either ".duckmap" or ".deepmap"
    method, depending on whether you want to give the item mapping or the
    substructure first shot at each node.)
   Binary hyper operators
    In contrast to unary operators that allows for (a few) structural
    operators, infix operators are never considered structural, so the hyper
    infix controller will always consider the dynamic shape as potentially
    traversable in addition to any static shape. That is, it is allowed to
    follow references from any parent node to dynamically nested structures.
    (Whether it actually follows a particular reference depends on the
    relative shapes of the two arguments.)
    When infix operators are presented with two lists or arrays of identical
    shape, a result of that same shape is produced. Otherwise the result
    depends on how you write the hyper markers.
    For an infix operator, if either argument is insufficiently dimensioned,
    Perl "upgrades" it, but only if you point the "sharp" end of the
    hypermarker at it.
         (3,8,2,9,3,8) >>->> 1;          # (2,7,1,8,2,7)
         @array »+=» 42;                 # add 42 to each element
    In fact, an upgraded scalar is the only thing that will work for an
    unordered type such as a "Bag":
         Bag(3,8,2,9,3,8) >>->> 1;       # Bag(2,7,1,8,2,7) === Bag(1,2,2,7,7,8)
    In other words, pointing the small end at an argument tells the
    hyperoperator to "dwim" on that side. If you don't know whether one side
    or the other will be underdimensioned, you can dwim on both sides:
        $left «*» $right
    [Note: if you are worried about Perl getting confused by something like
    this:
        func «*»
    then you shouldn't worry about it, because unlike previous versions,
    Perl 6 never guesses whether the next thing is a term or operator. In
    this case it is always expecting a term unless "func" is predeclared to
    be a type or value name.]
    The upgrade never happens on the "blunt" end of a hyper. If you write
        $bigger «*« $smaller
        $smaller »*» $bigger
    an exception is thrown, and if you write
        $foo »*« $bar
    you are requiring the shapes to be identical, or an exception will be
    For all hyper dwimminess, if a scalar is found where the other side
    expects a list, the scalar is considered to be a list of one element
    repeated "*" times.
    Once we have two lists to process, we have to decide how to put the
    elements into correspondence. If both sides are dwimmy, the short list
    will have be repeated as many times as necessary to make the appropriate
    number of elements.
    If only one side is dwimmy, then the list on that side only will be
    grown or truncated to fit the list on the non-dwimmy side.
    Regardless of whether the dwim is forced or emergent from the shapes of
    the arrays, once the side to dwim on has been chosen, the dwim semantics
    on the dwimmy side are always:
        (@dwimmyside xx *).batch(@otherside.elems)
    This produces a list the same length as the corresponding dimension on
    the other side. The original operator is then recursively applied to
    each corresponding pair of elements, in case there are more dimensions
    to handle.
    Here are some examples:
        (1,2,3,4) »+« (1,2)   # always error
        (1,2,3,4) «+» (1,2)   # 2,4,4,6     rhs dwims to 1,2,1,2
        (1,2,3)   «+» (1,2)   # 2,4,4       rhs dwims to 1,2,1
        (1,2,3,4) «+« (1,2)   # 2,4         lhs dwims to 1,2
        (1,2,3,4) »+» (1,2)   # 2,4,4,6     rhs dwims to 1,2,1,2
        (1,2,3)   »+» (1,2)   # 2,4,4       rhs dwims to 1,2,1
        (1,2,3)   »+» 1       # 2,3,4       rhs dwims to 1,1,1
    Another way to look at it is that the dwimmy list's elements are indexed
    modulo its number of elements so as to produce as many or as few
    elements as necessary.
    Note that each element of a dwimmy list may in turn be expanded into
    another dimension if necessary, so you can, for instance, add one to all
    the elements of a matrix regardless of its dimensionality:
        @fancy »+=» 1
    On the non-dwimmy side, any scalar value that does not know how to do
    "Iterable" will be treated as a list of one element, and for infix
    operators must be matched by an equivalent one-element list on the other
    side. That is, a hyper operator is guaranteed to degenerate to the
    corresponding scalar operation when all its arguments are non-list
    When using a unary operator, you always aim the blunt end at the single
    operand, because no replicative dwimmery ever happens:
         @negatives = -« @positives;
         @positions»++;            # Increment all positions
         @positions.»++;           # Same thing, dot form
         @positions».++;           # Same thing, dot form
         @positions.».++;          # Same thing, dot form
         @positions\  .»\  .++;    # Same thing, unspace form
         @objects.».run();
         ("f","oo","bar").>>.chars;   # (1,2,3)
    Note that method calls are really postfix operators, not infix, so you
    shouldn't put a "«" after the dot.
    Hyper operators are defined recursively on nested arrays, so:
        -« [[1, 2], 3]               #    [-«[1, 2], -«3]
                                     # == [[-1, -2], -3]
    Likewise the dwimminess of dwimmy infixes propagates:
        [[1, 2], 3] «+» [4, [5, 6]]  #    [[1,2] «+» 4, 3 «+» [5, 6]]
                                     # == [[5, 6], [8, 9]]
    More generally, a dwimmy hyper operator works recursively for any object
    matching the "Iterable" role even if the object itself doesn't support
    the operator in question:
        Bag(3,8,[2,(9,3)],8) >>->> 1;      # Bag(2,7,[1,(8,2)],7)
        (3,8,[2,(9,3)],8) >>->> (1,1,2,1); # (2,7,[0,(7,1)],7)
    In particular, tree node types with "Iterable" semantics enable
    visitation:
        $node.».foo;
    which means something like:
        my $type = $node.WHAT;
        $node.?foo // $type($node.map: { .».foo })
    You are not allowed to define your own hyper operators, because they are
    supposed to have consistent semantics derivable entirely from the
    modified scalar operator. If you're looking for a mathematical vector
    product, this isn't where you'll find it. A hyperoperator is one of the
    ways that you can promise to the optimizer that your code is
    parallelizable. (The tree visitation above is allowed to have side
    effects, but it is erroneous for the meaning of those side effects to
    depend on the order of visitation in any way. Hyper tree visitation is
    not required to follow DAG semantics, at least by default.)
    Even in the absence of hardware that can do parallel processing,
    hyperoperators may be faster than the corresponding scalar operators if
    they can factor out looping overhead to lower-level code, or can apply
    loop-unrolling optimizations, or can factor out some or all of the MMD
    dispatch overhead, based on the known types of the operands (and also
    based on the fact that hyper operators promise no interaction among the
    "iterations", whereas the corresponding scalar operator in a loop cannot
    make the same promise unless all the operations within the loop are
    known to be side-effect free.)
    In particular, infix hyperops on two "int" or "num" arrays need only do
    a single MMD dispatch to find the correct function to call for all
    pairs, and can further bypass any type-checking or type-coercion entry
    points to such functions when there are known to be low-level entry
    points of the appropriate type. (And similarly for unary "int" or "num"
    ops.)
    Application-wide analysis of finalizable object types may also enable
    such optimizations to be applied to "Int", "Num", and such. In the
    absence of that, run-time analysis of partial MMD dispatch may save some
    MMD searching overhead. Or particular object arrays might even keep
    track of their own run-time type purity and cache partial MMD dispatch
    tables when they know they're likely to be used in hyperops.
    Beyond all that, "array of scalar" types are known at compile time not
    to need recursive hypers, so the operations can be vectorized
    aggressively.
    Hypers may be applied to hashes as well as to lists. In this case
    "dwimminess" says whether to ignore keys that do not exist in the other
    hash, while "non-dwimminess" says to use all keys that are in either
    hash. That is,
        %foo «+» %bar;
    gives you the intersection of the keys, while
        %foo »+« %bar;
    gives you the union of the keys. Asymmetrical hypers are also useful;
    for instance, if you say:
        %outer »+» %inner;
    only the %inner keys that already exist in %outer will occur in the
    result. Note, however, that you want
        %outer »+=« %inner;
    in order to pass accumulated statistics up a tree, assuming you want
    %outer to have the union of keys.
    Unary hash hypers and binary hypers that have only one hash operand will
    apply the hyper operator to just the values but return a new hash value
    with the same set of keys as the original hash.
    For any kind of zip or dwimmy hyper operator, any list ending with "*"
    is assumed to be infinitely extensible by taking its final element and
    replicating it:
        @array, *
    is short for something like:
        @array[0..^@array], @array[*-1] xx *
    Note that hypers promise that you don't care in what order the
    processing happens, only that the resulting structure ends up in a form
    consistent with the inputs. There is no promise from the system that the
    operation *will* be parallelized. Effective parallelization requires
    some means of partitioning the work without doing more extra work than
    you save. This will differ from structure to structure. In particular,
    infinite structures cannot be completely processed, and the system is
    allowed to balance out the demands of laziness with parallel processing.
    For instance, an algorithm that wants to divide a list into two equal
    sublists will not work if you have to calculate the length in advance,
    since you can't always calculate the length. Various approaches can be
    taken: handing off batches to be processed in parallel on demand, or
    interleaving roundrobin with a set of N processors, or whatever. In the
    limit, a simple, non-parallel, item-by-item lazy implementation is
    within spec, but unlikely to use multiple cores efficiently. Outside of
    performance requirements, if the algorithm depends on which of these
    approaches is taken, it is erroneous.
  Reduction operators
    Any infix operator (except for non-associating operators) can be
    surrounded by square brackets in term position to create a list operator
    that reduces using that operation:
        [+] 1, 2, 3;      # 1 + 2 + 3 = 6
        my @a = (5,6);
        [*] @a;           # 5 * 6 = 30
    As with all the metaoperators, space is not allowed inside a metatoken.
    A reduction operator has the same precedence as a list prefix. In fact,
    a reduction operator really is a list prefix, and is invoked as one.
    Hence, you can implement a reduction operator in one of two ways. Either
    you can write an explicit list operator:
        multi prefix:<[+]> (*@args) is default {
            my $accum = 0;
            while (@args) {
                $accum += @args.shift();
            return $accum;
    or you can let the system autogenerate one for you based on the
    corresponding infix operator, probably by priming:
        &prefix:<[*]> ::= &reduce.assuming(&infix:<*>, 1);
        &prefix:<[**]> ::= &reducerev.assuming(&infix:<**>);
    If the reduction operator is defined separately from the infix operator,
    it must associate the same way as the operator used:
        [-] 4, 3, 2;      # 4-3-2 = (4-3)-2 = -1
        [**] 4, 3, 2;     # 4**3**2 = 4**(3**2) = 262144
    For list-associative operator (the ones with X in the precedence table),
    the implementation must take into account the listiness of the
    arguments; that is, if repeatedly applying a binary version of the
    operator would produce the wrong results, then it cannot be implemented
    that way. For instance:
        [^^] $a, $b, $c;  # means ($a ^^ $b ^^ $c), NOT (($a ^^ $b) ^^ $c)
    For chain-associative operators (like "<"), all arguments are taken
    together, just as if you had written it out explicitly:
        [<] 1, 3, 5;      # 1 < 3 < 5
    For list infix operators, flattening is not done on the input list, so
    that multiple lists may be passed in as comma-separated arguments:
        [X~] (1,2), <a b>;  # 1,2 X~ <a b>
    If fewer than two arguments are given, a dispatch is still attempted
    with whatever arguments are given, and it is up to the receiver of that
    dispatch to deal with fewer than two arguments. Note that the default
    list operator signature is the most general, so you are allowed to
    define different ways to handle the one argument case depending on type:
        multi prefix:<[foo]> (Int $x) { 42 }
        multi prefix:<[foo]> (Str $x) { fail "Can't foo a single Str" }
    However, the zero argument case cannot be defined this way, since there
    is no type information to dispatch on. Operators that wish to specify an
    identity value should do so by specifying a multi variant that takes
    zero arguments:
        multi prefix:<[foo]> () { 0 }
    Among the builtin operators, "[+]()" returns 0 and "[*]()" returns 1,
    for instance.
    By default, if there is one argument, the built-in reduce operators
    return that one argument. However, this default doesn't make sense for
    operators like "<" that don't return the same type as they take, so
    these kinds of operators overload the single-argument case to return
    something more meaningful. To be consistent with chaining semantics, all
    the comparison operators return "Bool::True" for 1 or 0 arguments.
    You can also make a reduce operator of the comma operator. This is just
    the list operator form of the "circumfix:<[ ]>" anonymous array
        [1,2,3]     # make new Array: 1,2,3
        [,] 1,2,3   # same thing
    Builtin reduce operators return the following identity values:
        [**]()      # 1     (arguably nonsensical)
        [*]()       # 1
        [/]()       # fail  (reduce is nonsensical)
        [%]()       # fail  (reduce is nonsensical)
        [x]()       # fail  (reduce is nonsensical)
        [xx]()      # fail  (reduce is nonsensical)
        [+&]()      # -1    (from +^0, the 2's complement in arbitrary precision)
        [+<]()      # fail  (reduce is nonsensical)
        [+>]()      # fail  (reduce is nonsensical)
        [~&]()      # fail  (sensical but 1's length indeterminate)
        [~<]()      # fail  (reduce is nonsensical)
        [~>]()      # fail  (reduce is nonsensical)
        [+]()       # 0
        [-]()       # 0
        [~]()       # ''
        [+|]()      # 0
        [+^]()      # 0
        [~|]()      # ''    (length indeterminate but 0's default)
        [~^]()      # ''    (length indeterminate but 0's default)
        [&]()       # all()
        [|]()       # any()
        [^]()       # one()
        [!==]()     # Bool::True    (also for 1 arg)
        [==]()      # Bool::True    (also for 1 arg)
        [before]()  # Bool::True    (also for 1 arg)
        [after]()   # Bool::True    (also for 1 arg)
        [<]()       # Bool::True    (also for 1 arg)
        [<=]()      # Bool::True    (also for 1 arg)
        [>]()       # Bool::True    (also for 1 arg)
        [>=]()      # Bool::True    (also for 1 arg)
        [~~]()      # Bool::True    (also for 1 arg)
        [!~~]()     # Bool::True    (also for 1 arg)
        [eq]()      # Bool::True    (also for 1 arg)
        [!eq]()     # Bool::True    (also for 1 arg)
        [lt]()      # Bool::True    (also for 1 arg)
        [le]()      # Bool::True    (also for 1 arg)
        [gt]()      # Bool::True    (also for 1 arg)
        [ge]()      # Bool::True    (also for 1 arg)
        [=:=]()     # Bool::True    (also for 1 arg)
        [!=:=]()    # Bool::True    (also for 1 arg)
        [===]()     # Bool::True    (also for 1 arg)
        [!===]()    # Bool::True    (also for 1 arg)
        [eqv]()     # Bool::True    (also for 1 arg)
        [!eqv]()    # Bool::True    (also for 1 arg)
        [&&]()      # Bool::True
        [||]()      # Bool::False
        [^^]()      # Bool::False
        [//]()      # Any
        [min]()     # +Inf
        [max]()     # -Inf
        [=]()       # Nil    (same for all assignment operators)
        [,]()       # []
        [Z]()       # []
    User-defined operators may define their own identity values, but there
    is no explicit identity property. The value is implicit in the behavior
    of the 0-arg reduce, so mathematical code wishing to find the identity
    value for an operation can call "prefix:["[$opname]"]()" to discover it.
    To call some other non-infix function as a reduce operator, you may
    define an alias in infix form. The infix form will parse the right
    argument as an item even if the aliased function would have parsed it as
    a list:
        &infix:<dehash> ::= &postcircumfix:<{ }>;
        $x = [dehash] $a,'foo','bar';  # $a<foo><bar>, not $a<foo bar>
    Alternately, just define your own "prefix:<[dehash]>" routine.
    Note that, because a reduce is a list operator, the argument list is
    evaluated in list context. Therefore the following would be incorrect:
        $x = [dehash] %a,'foo','bar';
    You'd instead have to say one of:
        $x = [dehash] \%a,'foo','bar';
        $x = [dehash] %a<foo>,'bar';
    On the plus side, this works without a star:
        @args = (\%a,'foo','bar');
        $x = [dehash] @args;
    Likewise, from the fact that list context flattens inner arrays and
    lists, it follows that a reduced assignment does no special syntactic
    dwimmery, and hence only scalar assignments are supported. Therefore
        [=] $x, @y, $z, 0
        [+=] $x, @y, $z, 1
        $x = @y[0] = @y[1] = @y[2] ... @y[*-1] = $z = 0
        $x += @y[0] += @y[1] += @y[2] ... @y[*-1] += $z += 1
        $x = @y = $z = 0;
        $x += @y += $z += 1;
    (And, in fact, the latter are already easy to express anyway, and more
    obviously nonsensical.)
    Similarly, list-associative operators that have the thunk-izing
    characteristics of macros (such as short-circuit operators) lose those
    macro-like characteristics. You can say
        [||] a(), b(), c(), d()
    to return the first true result, but the evaluation of the list is
    controlled by the semantics of the list, not the semantics of "||". The
    operator still short-circuits, but only in the sense that it does not
    need to examine all the values returned by the list. This is still quite
    useful for performance, especially if the list could be infinite.
    Most reduce operators return a simple scalar value, and hence do not
    care whether they are evaluated in item or list context. However, as
    with other list operators and functions, a reduce operator may return a
    list that will automatically be interpolated into list context, so you
    may use it on infix operators that operate over lists as well as
    scalars:
        my ($min, $max) = [minmax] @minmaxpairs;
    A variant of the reduction metaoperator is pretty much guaranteed to
    produce a list; to lazily generate all intermediate results along with
    the final result, you can backslash the operator:
        say [\+] 1..*  #  (1, 3, 6, 10, 15, ...)
    The visual picture of a triangle is not accidental. To produce a
    triangular list of lists, you can use a "triangular comma":
        [\,] 1..5
        [1],
        [1,2],
        [1,2,3],
        [1,2,3,4],
        [1,2,3,4,5]
    If there is ambiguity between a triangular reduce and an infix operator
    beginning with backslash, the infix operator is chosen, and an extra
    backslash indicates the corresponding triangular reduce. As a
    consequence, defining an infix operator beginning with backslash,
    "infix:<\x>" say, would cause "[\x]" to mean the normal reduction of
    "infix:<\x>", not the triangular reduction of "infix:<x>". To
    disambiguate, the syntax "[\[x]]" can be used to reduce with
    "infix:<x>", while "[\\x]" or "[\[\x]]" could be used for triangular
    reduce with "infix:<\x>".
    Triangular reductions of chaining operators always consist of one or
    more "True" values followed by 0 or more "False" values.
  Cross operators
    The cross metaoperator, "X", may be followed by any infix operator. It
    applies the modified operator across all groupings of its list arguments
    as returned by the ordinary "infix:<X>" operator. All generated cross
    operators are of list infix precedence, and are list associative.
    The string concatenating form is:
        <a b> X~ 1,2           #  'a1', 'a2', 'b1', 'b2'
    The "X~" operator desugars to:
        (<a b>; 1,2).crosswith(&[~])
    which in turn means
        (<a b>; 1,2).cross.lol.map { .reduce(&[~]) }
    Note that
        <a b> X~ 1,2 X+ 3,4
    could mean something like
        (<a b>; 1,2; 3,4).cross.lol.map { .reduce({$^a ~ $^b + $^c}) }
    but it is currently illegal as a non-identical list associative
    operator, which is considered non-associative. You can, however, always
    use parens to be explicit:
        <a b> X~ (1,2 X+ 3,4)
    The list concatenating form, "X,", when used like this:
        <a b> X, 1,2 X, <x y>
    produces
        ('a', 1, 'x'),
        ('a', 1, 'y'),
        ('a', 2, 'x'),
        ('a', 2, 'y'),
        ('b', 1, 'x'),
        ('b', 1, 'y'),
        ('b', 2, 'x'),
        ('b', 2, 'y')
    The "X," operator is perhaps more clearly written as "X[,]". However,
    this list form is common enough to have a shortcut, the ordinary infix
    "X" operator described earlier.
    For the general form, any existing, non-mutating infix operator may be
    used.
        1,2 X* 3,4               # 3,4,6,8
    (Note that "<==" and "==>" are considered mutating, as well as all
    assignment operators.)
    If the underlying operator is non-associating, so is the cross operator:
        @a Xcmp @b Xcmp @c       # ILLEGAL
        @a Xeq @b Xeq @c         # ok
    In fact, though the "X" operators are all list associative
    syntactically, the underlying operator is always applied with its own
    associativity, just as the corresponding reduce operator would do.
    Note that only the first term of an "X" operator may reasonably be an
    infinite list.
    All lists are assumed to be flat; multidimensional lists are handled by
    treating the first dimension as the only dimension.
  Zip operators
    The zip metaoperator, "Z", may be followed by any infix operator. It
    as returned by the ordinary "infix:<Z>" operator. All generated zip
        <a b> Z~ 1,2           #  'a1', 'b2'
    The "Z~" operator desugars to:
        (<a b>; 1,2).zipwith(&[~])
        (<a b>; 1,2).zip.lol.map: { .reduce(&[~]) }
        <a b> Z~ 1,2 Z+ 3,4
        (<a b>; 1,2; 3,4).zip.lol.map: { .reduce({$^a ~ $^b + $^c}) }
        <a b> Z~ (1,2 Z+ 3,4)
    [Conjecture: another approach would involve giving "X" and "Z"
    metaoperators a subprecedence within listop precedence corresponding to
    the original operator's precedence, so that "Z~" and "Z+" actually have
    different precedences within listop precedence. Then the above would
    parse as if you'd said "<a b> Z~ ( 1,2 Z+ 3,4> )", but the lists would
    still parse at list infix precedence, with comma tighter than the zips.
    (This would actually be fairly trivial to implement, given how we
    represent our precedence as strings.) Also, though it's complicated to
    explain, subprecedence within "Z" might be exactly what the naive user
    expects.]
    The list concatenating form, "Z,", when used like this:
        <a b> Z, 1,2 Z, <x y>
    The "Z," operator is perhaps more clearly written as "Z[,]". However,
    "Z" operator described earlier.
        1,2 Z* 3,4               # 3,8
        @a Zcmp @b Zcmp @c       # ILLEGAL
        @a Zeq @b Zeq @c         # ok
    In fact, though the "Z" operators are all list associative
    The zip operation terminates when either of its lists terminates. (Do
    not use "Zeq" or "Z==" to compare two arrays, for instance, unless you
    want to know if one array is a prefix of the other. Use "»eq«" or "»==«"
    for that. Or better, just use "eqv".)
    Note that, unlike the "X" operator, all the terms of a "Z" operator may
    reasonably be infinite lists, since zipping is lazy.
  Sequential operators
    The sequence metaoperator, "S", may be followed by any non-fiddly infix
    operator. It suppresses any explicit or implicit parallelism, and
    prevents the optimizer from reordering the operand evaluations. The 'S'
    can be thought of as standing for Sequential, Serial, Synchronous,
    Short-circuit, Single-thread, and Safe. Among other things. In
    particular, we can have:
        a S& b S& c         short-circuited AND junction
        a S| b S| c         short-circuited OR junction
        a S^ b S^ c         short-circuited XOR junction
        a S»op« b           single-threaded hyperop
        a SX* b             single-threaded X*
        a SX[*] b           single-threaded X*
        a S[X*] b           single-threaded X*
        a S+ b              suppress arg reordering by ignorant optimizer
    This metaoperator has the same precedence and associativity as its base
    operator. The compiler is free to discard any "S" metaoperator that is
    provably redundant, such as the one in "S||". The compiler is free to
    intuit an "S" on any operator involving known volatile operands where
    that does not otherwise change the semantics of the operator.
    [Conjectural: since metaoperators are notionally applied from inside to
    outside, the semantics of serializing and reversing depends on the order
    of the metaoperators:
        a SR/ b             evaluates b, then a, then does b/a
        a RS/ b             evaluates a, then b, then does b/a
        a RSR/ b            evaluates b, then a, then does a/b
    ...maybe. Can argue it all the other way too...]
  Nesting of metaoperators
    Anywhere you may use an ordinary infix operator, you may use the infix
    operator enclosed in square brackets with the same meaning. (No
    whitespace is allowed.) You may therefore use square brackets within a
    metatoken to disambiguate sequences that might otherwise be
    misinterpreted, or to force a particular order of application when there
    are multiple metaoperators in the metatoken:
        @a [X+]= @b
        @a X[+=] @b
    Since metatokens may never be disambiguated with internal whitespace,
    use of brackets is especially useful when the operator and its
    associated metaoperator share characters that would be confusing to the
    reader, even if not to the compiler:
        @a >>>>> $b        # huh?
        @a >>[>]>> $b      # oh yeah
  Turning an infix operator into a noun
    Any infix function may be referred to as a noun either by the normal
    long form or a short form using square brackets directly after the "&"
    sigil:
        &infix:<+>
        &[+]
    This is convenient for function application:
        1, 1, &[+] ... *       # fibonacci sequence
        sort &[Rleg], @list    # reverse sort as strings
    The "&[op]" form always refers to a binary function of the operator,
    even if it is underlyingly defined as a variadic list-associative
    operator.
    There is no corresponding form for unary operators, but those may
    usually be constructed by applying an operator to "*":
        sort -*, @list        # sort reversed numerically
  Turning a binary function into an infix
    By using the noun form of a binary function inside square brackets, it
    is possible to turn any function that accepts at least two arguments
    into an infix operator. For instance:
        $y [&atan2] $x        # same as atan2($y, $x)
    By itself this may seem relatively useless, but note that it allows
    composition of normal 2-arg functions with all the infix metaoperators.
    Since it is primarily intended for composition with metaoperators, this
    form always assumes a binary function, even if the function could accept
    more arguments; functions that accept more than 2 arguments do not
    thereby accept multiple arguments on the right side. You must use the
    normal functional form to pass three or more positional arguments.
    This form of operator is parsed with a precedence of addition. The next
    character after "&" must be either alphabetic or a left parenthesis.
    Otherwise a normal infix operator starting with that character will be
    assumed. Hence "[&&]" parses as a form of the "&&" operator.
Declarators
    The list of variable declarators has expanded from "my" and "our" to
        my $foo             # ordinary lexically scoped variable
        our $foo            # lexically scoped alias to package variable
        has $foo            # object attribute
        state $foo          # persistent lexical (cloned with closures)
    Variable declarators such as "my" now take a *signature* as their
    argument. (The syntax of function signatures is described more fully in
    S06.)
    The parentheses around the signature may be omitted for a simple
    declaration that declares a single variable, along with its associated
    type, traits and the initializer:
        my Dog $foo is woof = 123;    # okay: initializes $foo to 123
        my (Dog $foo is woof = 123);  # same thing (with explicit parens)
        my :(Dog $foo is woof = 123); # same thing (full Signature form)
    The "constant" declarator can declare either variables or names as
    compile-time constants:
        constant $foo = 1;      # compile-time constant variable
        constant bar = 2;       # compile-time constant symbol
    Because it can declare names in "type" space, the "constant" declarator
    may not declare using the signature, which would be ambiguous.
    Each declarator can take an initializer following an equals sign (which
    should not be confused with a normal assignment, because the timing of
    the initialization depends on the natural lifetime of the container,
    which in turn depends on which declarator you use).
        my $foo = 1;         # happens at execute time, like normal assignment
        our $foo = 1;        # happens at INIT time
        has $foo = 1;        # happens at BUILD time
        state $foo = 1;      # happens at execute time, but only once
        constant $foo = 1;   # happens at BEGIN time
    (Note that the semantics of "our" are different from Perl 5, where the
    initialization happens at the same time as a "my". To get the same
    effect in Perl 6 you'd have to say ""(our $foo) = 1;"" instead.)
    If you do not initialize a container, it starts out undefined at the
    beginning of its natural lifetime. (In other words, you can't use the
    old Perl 5 trick of ""my $foo if 0"" to get a static variable, because a
    "my" variable starts out uninitialized every time through in Perl 6
    rather than retaining its previous value.) Native integer containers
    that do not support the concept of undefined should be initialized to 0
    instead. (Native floating-point containers are by default initialized to
    "NaN".) Typed object containers start out containing an undefined type
    object of the correct type.
    List-context pseudo-assignment is supported for simple declarations but
    not for signature defaults:
        my @foo = 1,2,3;      # okay: initializes @foo to (1,2,3)
        my (@foo = 1,2,3);    # wrong: 2 and 3 are not variable names
    When parentheses are omitted, you may use any infix assignment operator
    instead of "=" as the initializer. In that case, the left hand side of
    the infix operator will be the variable's prototype object:
        my Dog $fido .= new;      # okay: a Dog object
        my Dog $fido = Dog.new;   # same thing
        my Dog $fido = $fido.new; # okay: valid self-reference
        my (Dog $fido .= new);    # wrong: cannot use .= inside signature
    Note that very few mutating operators make sense on a type object,
    however, since type objects are a kind of undefined object. (Those
    operators with an identity value are an exception, as noted above.)
    Parentheses must always be used when declaring multiple parameters:
        my $a;                  # okay
        my ($b, $c);            # okay
        my ($b = 1, $c = 2);    # okay - "my" initializers assign at runtime
        my $b, $c;              # wrong: "Use of undeclared variable: $c"
    Types occurring between the declarator and the signature are distributed
    into each variable:
        my Dog ($b, $c);
        my (Dog $b, Dog $c);    # same thing
    [XXX the following probably belongs in S06.] The syntax for constructing
    a "Signature" object when the parser isn't already expecting one is:
        :(Dog $a, *@c)
    This might be used like this:
        my $sig = :(Dog $a, *@c);
    Signatures are expected after declarators such as "my", "sub", "method",
    "rule", etc. In such declarators the colon may be omitted. But it's also
    legal to use it:
        my :($b, $c);               # okay
        sub foo :($a,$b) {...}      # okay
    The "->" "pointy block" token also introduces a signature, but in this
    case you must omit both the colon and the parens. For instance, if
    you're defining the "loop variable" of a loop block:
        for @dogpound -> Dog $fido { ... }
    If a signature is assigned to (whether declared or colon form), the
    signature is converted to a list of lvalue variables and the ordinary
    rules of assignment apply, except that the evaluation of the right side
    and the assignment happens at time determined by the declarator. (With
    "my" this is always when an ordinary assignment would happen.) If the
    signature is too complicated to convert to an assignment, a compile-time
    error occurs. Assignment to a signature makes the same item/list
    distinction as ordinary assignment, so
        my $a = foo();      # foo in item context
        my ($a) = foo();    # foo in list context
    If a signature is bound to an argument list, then the binding of the
    arguments proceeds as if the signature were the formal parameters for a
    function, except that, unlike in a function call, the parameters are
    bound "rw" by default rather than "readonly". See Binding above.
    Note that "temp" and "let" are *not* variable declarators, because their
    effects only take place at runtime. Therefore, they take an ordinary
    lvalue object as their argument. See S04 for more details.
    There are a number of other declarators that are not variable
    declarators. These include both type declarators:
        package Foo
        module Foo
        class Foo
        role Foo
        subset Foo
        enum Foo
        constant Foo
    and code declarators:
        sub foo
        method foo
        submethod foo
        multi foo
        proto foo
        macro foo
        quote qX
        regex foo
        rule foo
        token foo
    These all have their uses and are explained in subsequent Synopses.
    Note that since "constant" is parsed as a type declarator (essentially
    declaring a type with a single value), it can actually take a scope
    declarator in front:
        my constant companion = 'Fido';
        has constant $.pi = 22/7;
        state constant $latch = snapshot(); # careful with this!
    However, the constant declarator is intended to create values the
    compiler can inline, so it always evaluates its value at "BEGIN" time.
    Thus, while the extra scope declarator may say where the value is stored
    and when that storage is initialized, it cannot change the value of that
    from instance to instance. In general, if you want something that
    doesn't vary over the normal lifetime of a scope declarator, initialize
    it to a readonly value using "::=" rather than declaring it as a
    constant. Then each time the scope declarator is used, it can initialize
    to a different readonly value:
        state $latch ::= snapshot();  # each clone gets its own value of $latch
Argument List Interpolating
    Perl 5 forced interpolation of a function's argument list by use of the
    "&" prefix. That option is no longer available in Perl 6, so instead the
    "|" prefix operator serves as an interpolator, by casting its operand to
    a "Capture" object and inserting the capture's parts into the current
    argument list. This operator can be used to interpolate an "Array" or
    "Hash" into the current call, as positional and named arguments
    respectively.
    Note that the resulting arguments still must comply with the
    subroutine's signature, but the presence of "|" defers that test until
    run time for that argument (and for any subsequent arguments):
        my $args = \(@foo, @bar);
        push |$args;
        push @foo, @bar;
    However,
        my $args = \(@foo: @bar);
    is instead equivalent to:
        @foo.push(@bar);
    "|" does not turn its argument into an "Array", but instead directly
    converts its argument into a "Capture":
        my @args = \$x, 1, 2, 3;
        say |@args;     # say(\$x, 1, 2, 3);
    Because of this, "|%args" always produces named arguments, and "|@args"
    always produces positional arguments.
    In list context, a "Scalar" holding an "Array" object does not flatten.
    Hence
        $bar = @bar;
        @foo.push($bar);
    merely pushes a single "Array" object onto @foo. You can explicitly
    flatten it in one of these ways:
        @foo.push(@$bar);
        @foo.push($bar[]);
        @foo.push(|$bar);
    Those three forms work because the slurpy array in "push"'s signature
    flattens the "Array" object into a list argument.
    Note that the first two forms also allow you to specify list context on
    assignment:
        @$bar = 1,2,3;
        $bar[] = 1,2,3;
    For long expressions that need to be cast to an array lvalue, the second
    form can keep the "arrayness" of the lvalue close to the assignment
        $foo.bar.baz.bletch.whatever.attr[] = 1,2,3;
    The empty "[]" and ".[]" postfix operators are interpreted as a
    zero-dimensional subscript returning the entire array, not as a
    one-dimensional null slice returning no elements. Likewise for "{}" and
    ".{}" on hashes, as well as the "<>", ".<>", "«»", and ".«»" constant
    and interpolating slice subscripting forms.
    The "|" operator interpolates lazily for "Array" and "Range" objects. To
    get an immediate interpolation like Perl 5 does, add the "eager" list
        func(|(1..Inf));       # works fine
        func(|eager 1..Inf);   # never terminates (well, actually...)
    To interpolate a function's return value, you can say:
        push |func();
    Within such an argument list, function return values are automatically
    exploded into their various parts, as if you'd said:
        my $capture = \(func());
        push $$capture: @$capture, %$capture;
    or some such. The "|" then handles the various zones appropriately
    depending on the context. An invocant only makes sense as the first
    argument to the outer function call. An invocant inserted anywhere else
    just becomes a positional argument at the front of its list, as if its
    colon changed back to a comma.
    If you already have a capture variable, you can interpolate all of its
    bits at once using the "prefix:<|>" operator:
        my (|$capture) := func();
        push |$capture;
Traversing arrays in parallel
    In order to support parallel iteration over multiple arrays, Perl 6 has
    a "zip" function that builds a list of "List" objects from the elements
    of two or more arrays. In ordinary list context this behaves as a list
    of "Captures" and automatically flattens.
        for zip(@names; @codes) -> $name, $zip {
            print "Name: $name;   Zip code: $zip\n";
    "zip" has an infix synonym, the "Z" operator.
    In an explicitly multidimensional list context, however, the sequences
    turn into subarrays, and each element would then have to be unpacked by
    the signature:
        for lol(zip(@names; @codes)) -> [$name, $zip] {
    By default the "zip" function reads to the end of the shortest list, but
    a short list may always be extended arbitrarily by putting "*" after the
    final value, which replicates the final value as many times as
    necessary. If instead of supplying a default value for short lists, you
    just wish to skip missing entries, use "roundrobin" instead:
        for roundrobin(@queue1; @queue2; @queue3) -> $next {
Minimal whitespace DWIMmery
    Whitespace is no longer allowed before the opening bracket of an array
    or hash subscript, or the opening parenthesis of an argument list. That
    is:
        @deadbeef[$x]         # okay
        @a       [$b]         # WRONG
        %monsters{'cookie'}   # okay
        %people  {'john'}     # WRONG
        saymewant('cookie')   # okay
        mewant   ('cookie')   # WRONG
    One of the several useful side-effects of this restriction is that
    parentheses are no longer required around the condition of control
    constructs:
        if $value eq $target {
            print "Bullseye!";
        while $i < 10 { $i++ }
    It is, however, still possible to align subscripts and other postfix
    operators by explicitly using the *unspace* syntax (see S02):
         %squirrels{'fluffy'} = Squirrel.new;
         %monsters.{'cookie'} = Monster.new;
         %beatles\.{'ringo'}  = Beatle.new;
         %people\ .{'john'}   = Person.new;
    Whitespace is in general required between any keyword and any opening
    bracket that is *not* introducing a subscript or function arguments. Any
    keyword followed directly by parentheses will be taken as a function
    call instead.
        if $a == 1 { say "yes" }            # preferred syntax
        if ($a == 1) { say "yes" }          # P5-ish if construct
        if($a,$b,$c)                        # if function call
    It is possible for "if()" to also invoke a macro call, but if so, it's a
    "prefix:<if>" macro rather than a "statement_control:<if>" macro.
Sequence points
    Certain operators are guaranteed to provide *sequence points*. Sequence
    points are guaranteed whenever some thunk (a lazy chunk of code) is
    conditionally evaluated based on the result of some other evaluation, so
    the short-circuit and conditional operators all provide sequence points.
    Certain other operators guarantee the *absence* of sequence points,
    including junctional operators, hyperoperators, and feed operators.
    These operators promise the compiler that you consider the bits of code
    not to be dependent on each other so that they can operate in parallel
    if they like.
    A large number of operators (such as "+") are stuck in the middle, and
    may exhibit sequential behavior today, but might not tomorrow. A program
    that relies on either sequential or parallel behavior for one of these
    operators is erroneous. As we get more feedback from people writing
    parallelizing optimizers, we reserve the right to classify various of
    the unclassified operators into one of the two specified sets. (We need
    to give these three sets of operators good names.)
Non-declarative metaoperator names
    When a metaoperator is mentioned non-declaratively, such as in "&[Rop]",
    "&infix:<op=>", or "prefix:<[op]>(@list)", if the metaoperator name
    lookup fails, the operator is automatically generated just as if the
    metaoperator had been used in its normal location.
        Luke Palmer <luke@luqui.org>
        Darren Duncan <darren@darrenduncan.net>
    Synopsis 4: Blocks and Statements
        Created: 19 Aug 2004
        Version: 141
    This document summarizes Apocalypse 4, which covers the block and
    statement syntax of Perl.
The Relationship of Lexical and Dynamic Scopes
    Control flow is a dynamic feature of all computer programming languages,
    but languages differ in the extent to which control flow is attached to
    declarative features of the language, which are often known as "static"
    or "lexical". We use the phrase "lexical scoping" in its
    industry-standard meaning to indicate those blocks that surround the
    current textual location. More abstractly, any declarations associated
    with those textual blocks are also considered to be part of the lexical
    scope, and this is where the term earns the "lexical" part of its name,
    in the sense that lexical scoping actually does define the "lexicon" for
    the current chunk of code, insofar as the definitions of variables and
    routines create a local domain-specific language.
    We also use the term "dynamic scoping" in the standard fashion to
    indicate the nested call frames that are created and destroyed every
    time a function or method is called. In most interesting programs the
    dynamic scopes are nested quite differently from the lexical scopes, so
    it's important to distinguish carefully which kind of scoping we're
    talking about.
    Further compounding the difficulty is that every dynamic scope's outer
    call frame is associated with a lexical scope somewhere, so you can't
    just consider one kind of scoping or the other in isolation. Many
    constructs define a particular interplay of lexical and dynamic
    features. For instance, unlike normal lexically scope variables, dynamic
    variables search up the dynamic call stack for a variable of a
    particular name, but at each "stop" along the way, they are actually
    looking in the lexical "pad" associated with that particular dynamic
    scope's call frame.
    In Perl 6, control flow is designed to do what the user expects most of
    the time, but this implies that we must consider the declarative nature
    of labels and blocks and combine those with the dynamic nature of the
    call stack. For instance, a "return" statement always returns from the
    lexically scoped subroutine that surrounds it. But to do that, it may
    eventually have to peel back any number of layers of dynamic call frames
    internal to the subroutine's current call frame. The lexical scope
    supplies the declared target for the dynamic operation. There does not
    seem to be a prevailing term in the industry for this, so we've coined
    the term *lexotic* to refer to these strange operations that perform a
    dynamic operation with a lexical target in mind. Lexotic operators in
    Perl 6 include:
        return
        next
        last
        redo
        goto
    Some of these operators also fall back to a purely dynamic
    interpretation if the lexotic interpretation doesn't work. For instance,
    "next" with a label will prefer to exit a loop lexotically, but if there
    is no loop with an appropriate label in the lexical context, it will
    then scan upward dynamically through the call frames for any loop with
    the appropriate label, even though that loop will not be lexically
    visible. ("next" without a label is purely dynamic.) Lexotic and dynamic
    control flow is implemented by a system of control exceptions. For the
    lexotic return of "next", the control exception will contain the
    identity of the loop scope to be exited (since the label was already
    "used up" to discover that identity), but for the dynamic fallback, the
    exception will contain only the loop label to be matched dynamically.
    See "Control Exceptions" below.
    The "redo" operator, as a variant of "goto", directly transfers control
    to the first statement of the lexotically enclosed loop. Essentially,
    the compiler turns it into a "goto" with an implicitly generated
    (secret) label on that first statement. In order to know when that
    implicit label must be generated, we restrict "redo" to the current
    outer lexical scope. It may not be used dynamically. (If you find
    yourself wanting the dynamic variant, please use "goto" with an explicit
    label instead, so the compiler can know to pessimize any unrolling of
    that loop.)
The Relationship of Blocks and Declarations
    Every block is a closure. (That is, in the abstract, they're all
    anonymous subroutines that take a snapshot of their lexical
    environment.) How a block is invoked and how its results are used are
    matters of context, but closures all work the same on the inside.
    Blocks are delimited by curlies, or by the beginning and end of the
    current compilation unit (either the current file or the current "EVAL"
    string). Unlike in Perl 5, there are (by policy) no implicit blocks
    around standard control structures. (You could write a macro that
    violates this, but resist the urge.) Variables that mediate between an
    outer statement and an inner block (such as loop variables) should
    generally be declared as formal parameters to that block. There are
    three ways to declare formal parameters to a closure.
        $func = sub ($a, $b) { .print if $a eq $b };  # standard sub declaration
        $func = -> $a, $b { .print if $a eq $b };     # a "pointy" block
        $func = { .print if $^a eq $^b }              # placeholder arguments
    A bare closure (except the block associated with a conditional
    statement) without placeholder arguments that uses $_ (either explicitly
    or implicitly) is treated as though $_ were a formal parameter:
        $func = { .print if $_ };   # Same as: $func = <-> $_ { .print if $_ };
        $func("printme");
    In any case, all formal parameters are the equivalent of "my" variables
    within the block. See S06 for more on function parameters.
    Except for such formal parameter declarations, all lexically scoped
    declarations are visible from the point of declaration to the end of the
    enclosing block. Period. Lexicals may not "leak" from a block to any
    other external scope (at least, not without some explicit aliasing
    action on the part of the block, such as exportation of a symbol from a
    module). The "point of declaration" is the moment the compiler sees ""my
    $foo"", not the end of the statement as in Perl 5, so
        my $x = $x;
    will no longer see the value of the outer $x; you'll need to say either
        my $x = $OUTER::x;
        my $x = OUTER::<$x>;
    If you declare a lexical twice in the same scope, it is the same
    lexical:
        my $x;
    By default the second declaration will get a compiler warning. You may
    suppress this by modifying the first declaration with "proto":
        my proto $x;
        while my $x = @x.shift {...}              # no warning
    If you've referred to $x prior to the first declaration, and the
    compiler tentatively bound it to $OUTER::x, then it's an error to
    declare it, and the compiler is required to complain at that point. If
    such use can't be detected because it is hidden in an "EVAL", then it is
    erroneous, since the "EVAL()" compiler might bind to either $OUTER::x or
    the subsequently declared ""my $x"".
    As in Perl 5, ""our $foo"" introduces a lexically scoped alias for a
    variable in the current package.
    The new "constant" declarator introduces a compile-time constant, either
    a variable or named value, which may be initialized with a
    pseudo-assignment:
        constant $pi of Int = 3;
        my Num constant π = atan2(2,2) * 4;
    The initializing expression is evaluated at "BEGIN" time. Constants (and
    enums) default to "our" scoping so they can be accessed from outside the
    package.
    There is a new "state" declarator that introduces a lexically scoped
    variable like "my" does, but with a lifetime that persists for the life
    of the closure, so that it keeps its value from the end of one call to
    the beginning of the next. Separate clones of the closure get separate
    state variables. However, recursive calls to the same clone use the same
    state variable.
    Perl 5's ""local"" function has been renamed to "temp" to better reflect
    what it does. There is also a "let" prefix operator that sets a
    hypothetical value. It works exactly like "temp", except that the value
    will be restored only if the current block exits unsuccessfully. (See
    Definition of Success below for more.) "temp" and "let" temporize or
    hypotheticalize the value or the variable depending on whether you do
    assignment or binding. One other difference from Perl 5 is that the
    default is not to undefine a variable. So
        temp $x;
    causes $x to start with its current value. Use
        undefine temp $x;
    to get the Perl 5 behavior.
    Note that temporizations that are undone upon scope exit must be
    prepared to be redone if a continuation within that scope is taken.
The Relationship of Blocks and Statements
    In the absence of explicit control flow terminating the block early, the
    return value of a block is the value of its final statement. This is
    defined as the textually last statement of its top-level list of
    statements; any statements embedded within those top-level statements
    are in their own lower-level list of statements and, while they may be a
    final statement in their subscope, they're not considered the final
    statement of the outer block in question.
    This is subtly different from Perl 5's behavior, which was to return the
    value of the last expression evaluated, even if that expression was just
    a conditional. Unlike in Perl 5, if a final statement in Perl 6 is a
    conditional that does not execute any of its branches, it doesn't matter
    what the value of the conditional is, the value of that conditional
    statement is always "()". If there are no statements in the block at
    all, the result is also "()".
Statement-ending blocks
    A line ending with a closing brace ""}"", followed by nothing but
    whitespace or comments, will terminate a statement if an end of
    statement can occur there. That is, these two statements are equivalent:
        my $x = sub { 3 }
        my $x = sub { 3 };
    Since bracketed expressions consider their insides to be statements,
    this works out consistently even where you might expect problems:
        my $x = [
            sub { 3 },  # this comma is not optional
            sub { 3 }   # the statement inside [] terminates here
        ];
        my $hash = {
            1 => { 2 => 3, 4 => 5 },  # OK
            2 => { 6 => 7, 8 => 9 }   # OK, terminates inner statement
        };
    Because subroutine declarations are expressions, not statements, this is
    now invalid:
        sub f { 3 } sub g { 3 }     # two terms occur in a row
    But these two are valid:
        sub f { 3 }; sub g { 3 };
        sub f { 3 }; sub g { 3 }    # the trailing semicolon is optional
    Though certain control statements could conceivably be parsed in a
    self-contained way, for visual consistency all statement-terminating
    blocks that end in the middle of a line *must* be terminated by
    semicolon unless they are naturally terminated by some other statement
    terminator:
        while yin() { yang() }  say "done";      # ILLEGAL
        while yin() { yang() }; say "done";      # okay, explicit semicolon
        @yy := [ while yin() { yang() } ];       # okay within outer [...]
        while yin() { yang() } ==> sort          # okay, ==> separates statements
Conditional statements
    The "if" and "unless" statements work much as they do in Perl 5.
    However, you may omit the parentheses on the conditional:
        if $foo == 123 {
        elsif $foo == 321 {
        else {
    The result of a conditional statement is the result of the block chosen
    to execute. If the conditional does not execute any branch, the return
    value is "()".
    The "unless" statement does not allow an "elsif" or "else" in Perl 6.
    The value of the conditional expression may be optionally bound to a
    closure parameter:
        if    testa() -> $a { say $a }
        elsif testb() -> $b { say $b }
        else          -> $b { say $b }
    Note that the value being evaluated for truth and subsequently bound is
    not necessarily a value of type "Bool". (All normal types in Perl may be
    evaluated for truth. In fact, this construct would be relatively useless
    if you could bind only boolean values as parameters, since within the
    closure you already know whether it evaluated to true or false.) Binding
    within an "else" automatically binds the value tested by the previous
    "if" or "elsif", which, while known to be false, might nevertheless be
    an *interesting* value of false. (By similar reasoning, an "unless"
    allows binding of a false parameter.)
    An explicit placeholder may also be used:
        if blahblah() { return $^it }
    However, use of $_ with a conditional or conditionally repeating
    statement's block is *not* considered sufficiently explicit to turn a
    0-ary block into a 1-ary function, so all these methods use the same
    invocant:
        if .haste { .waste }
        while .haste { .waste }
    (Contrast with a non-conditional statement such as:
        for .haste { .waste }
    where each call to the block would bind a new invocant for the ".waste"
    method, each of which is likely different from the original invocant to
    the ".haste" method.)
    Conditional statement modifiers work as in Perl 5. So do the implicit
    conditionals implied by short-circuit operators. Note though that the
    contents of parens or brackets is parsed as a statement, so you can say:
        @x = 41, (42 if $answer), 43;
    and that is equivalent to:
        @x = 41, ($answer ?? 42 !! Slip), 43
    (Only a single statement is allowed inside parens or brackets; otherwise
    it will be interpreted as a LoL composer. See "Multidimensional slices
    and lists" in S02.)
  The "with" and "without" statements
    The "with" statement is like "if" but tests for definedness rather than
    truth. In addition, it topicalizes on the condition, much like "given":
        with "abc".index("a") { .say }      # prints 0
    These may be cascaded:
        with   $s.index("a") { "Found a at $_" }
        orwith $s.index("b") { "Found b at $_" }
        orwith $s.index("c") { "Found c at $_" }
        else                 { "Didn't find a, b or c" }
    You may intermix "if"-based and "with"-based clauses.
    As with "unless", you may use "without" to check for undefinedness, but
    you may not add an "else" clause:
        without $answer { fail "Got: $_" }
    There are also "with" and "without" statement modifiers:
        return 42 with $answer;
        .throw without $answer;
Loop statements
    Looping statement modifiers are the same as in Perl 5 except that, for
    ease of writing list comprehensions, a looping statement modifier is
    allowed to contain a single conditional statement modifier:
        @evens = ($_ * 2 if .odd for 0..100);
    Loop modifiers "next", "last", and "redo" also work much as in Perl 5.
    However, the labeled forms can use method call syntax: "LABEL.next",
    etc. The ".next" and ".last" methods take an optional argument giving
    the final value of that loop iteration. So the old "next LINE" syntax is
    still allowed but really does something like "LINE.next(())" underneath.
    Any block object can be used, not just labels, so to return a value from
    this iteration of the current block you can say:
        &?BLOCK.next($retval);
    [Conjecture: a bare "next($retval)" function could be taught to do the
    same, as long as $retval isn't a loop label. Presumably multiple
    dispatch could sort this out.]
    With a target object or label, loop modifiers search lexotically for the
    scope to modify. Without a target, however, they are purely dynamic, and
    choose the innermost dynamic loop, which may well be a "map" or other
    implicitly looping function, including user-defined functions.
    There is no longer a "continue" block. Instead, use a "NEXT" block
    within the body of the loop. See below.
    The value of a loop statement is the list of values from each iteration.
    Each iteration's value is returned as a single object, only "Slip"s
    flatten into the return list.
    For finer-grained control of which iterations return values, use
    "gather" and "take".
  The "while" and "until" statements
    The "while" and "until" statements work as in Perl 5, except that you
    may leave out the parentheses around the conditional:
        while $bar < 100 {
    As with conditionals, you may optionally bind the result of the
    conditional expression to a parameter of the block:
        while something() -> $thing {
        while something() { ... $^thing ... }
    Nothing is ever bound implicitly, however, and many conditionals would
    simply bind "True" or "False" in an uninteresting fashion. This
    mechanism is really only good for objects that know how to return a
    boolean value and still remain themselves. In general, for most iterated
    solutions you should consider using a "for" loop instead (see below). In
    particular, we now generally use "for" to iterate filehandles.
  The "repeat" statement
    Unlike in Perl 5, applying a statement modifier to a "do" block is
    specifically disallowed:
        do {
        } while $x < 10;    # ILLEGAL
    Instead, you should write the more Pascal-like "repeat" loop:
        repeat {
        } while $x < 10;
        } until $x >= 10;
    Unlike Perl 5's "do-while" loop, this is a real loop block now, so
    "next", "last", and "redo" work as expected. The loop conditional on a
    "repeat" block is required, so it will be recognized even if you put it
    on a line by its own:
        repeat
        while $x < 10;
    However, that's likely to be visually confused with a following "while"
    loop at the best of times, so it's also allowed to put the loop
    conditional at the front, with the same meaning. (The "repeat" keyword
    forces the conditional to be evaluated at the end of the loop, so it's
    still C's "do-while" semantics.) Therefore, even under GNU style rules,
    the previous example may be rewritten into a very clear:
        repeat while $x < 10
          {
          }
        repeat until $x >= 10
    As with an ordinary "while", you may optionally bind the result of the
        repeat -> $thing {
        } while something();
        repeat while something() -> $thing {
    Since the loop executes once before evaluating the condition, the bound
    parameter will be undefined that first time through the loop.
  The general loop statement
    The "loop" statement is the C-style "for" loop in disguise:
        loop ($i = 0; $i < 10; $i++) {
    As in C, the parentheses are required if you supply the 3-part spec;
    however, the 3-part loop spec may be entirely omitted to write an
    infinite loop. That is,
        loop {...}
    is equivalent to the C-ish idiom:
        loop (;;) {...}
  The "for" statement
    There is no "foreach" statement any more. It's always spelled "for" in
    Perl 6, so it always takes a list as an argument:
        for @foo { .print }
    As mentioned earlier, the loop variable is named by passing a parameter
    to the closure:
        for @foo -> $item { print $item }
    Multiple parameters may be passed, in which case the list is traversed
    more than one element at a time:
        for %hash.kv -> $key, $value { print "$key => $value\n" }
    To process two arrays in parallel use the "zip" function to generate a
    list that can be bound to the corresponding number of parameters:
        for zip(@a, @b) -> ($a, $b) { print "[$a, $b]\n" }
        for @a Z @b -> ($a, $b) { print "[$a, $b]\n" }        # same thing
    The list is evaluated lazily by default, so instead of using a "while"
    to read a file a line at a time as you would in Perl 5:
        while (my $line = <STDIN>) {...}
    in Perl 6 you should use a "for" instead:
        for $*IN.lines -> $line {...}
    This has the added benefit of limiting the scope of the $line parameter
    to the block it's bound to. (The "while"'s declaration of $line
    continues to be visible past the end of the block. Remember, no implicit
    block scopes.) It is also possible to write
        while $*IN.get -> $line {...}
    However, this is likely to fail on autochomped filehandles, so use the
    "for" loop instead.
    Note also that Perl 5's special rule causing
        while (<>) {...}
    to automatically assign to $_ is not carried over to Perl 6. That should
    now be written:
        for lines() {...}
    which is short for
        for lines($*ARGFILES) {...}
    Arguments bound to the formal parameters of a pointy block are by
    default readonly within the block. You can declare a parameter
    read/write by including the ""is rw"" trait. The following treats every
    other value in @values as modifiable:
        for @values -> $even is rw, $odd { ... }
    In the case where you want all your parameters to default to "rw", you
    may use the visually suggestive double-ended arrow to indicate that
    values flow both ways:
        for @values <-> $even, $odd { ... }
    This is equivalent to
        for @values -> $even is rw, $odd is rw { ... }
    If you rely on $_ as the implicit parameter to a block, then $_ is
    considered read/write by default. That is, the construct:
        for @foo {...}
    is actually short for:
        for @foo <-> $_ {...}
    so you can modify the current list element in that case.
    When used as statement modifiers on implicit blocks (thunks), "for" and
    "given" privately temporize the current value of $_ for the left side of
    the statement and restore the original value at loop exit:
        $_ = 42;
        .say             # 42
        .say for 1,2,3;  # 1,2,3
        .say;            # 42
    The previous value of $_ is not available within the loop. If you want
    it to be available, you must rewrite it as an explicit block using
    curlies:
        { say OUTER::<$_>, $_ } for 1,2,3;  # 421,422,423
    No temporization is necessary with the explicit form since $_ is a
    formal parameter to the block. Likewise, temporization is never needed
    for "statement_control:<for>" because it always calls a closure.
  The do-once loop
    In Perl 5, a bare block is deemed to be a do-once loop. In Perl 6, the
    bare block is not a do-once. Instead "do {...}" is the do-once loop
    (which is another reason you can't put a statement modifier on it; use
    "repeat" for a test-at-the-end loop).
    For any statement, prefixing with a "do" allows you to return the value
    of that statement and use it in an expression:
        $x = do if $a { $b } else { $c };
    This construct only allows you to attach a single statement to the end
    of an expression. If you want to continue the expression after the
    statement, or if you want to attach multiple statements, you must either
    use the curly form or surround the entire expression in brackets of some
    sort:
        @primesquares = (do $_ if .is-prime for 1..100) »**» 2;
    Since a bare expression may be used as a statement, you may use "do" on
    an expression, but its only effect is to function as an unmatched left
    parenthesis, much like the "$" operator in Haskell. That is, precedence
    decisions do not cross a "do" boundary, and the missing "right paren" is
    assumed at the next statement terminator or unmatched bracket. A "do" is
    unnecessary immediately after any opening bracket as the syntax inside
    brackets expects a statement, so the above can in fact be written:
        @primesquares = ($_ if .is-prime for 1..100) »**» 2;
    This basically gives us list comprehensions as rvalue expressions:
        (for 1..100 { $_ if .is-prime }).say
    Another consequence of this is that any block just inside a left
    parenthesis is immediately called like a bare block, so a
    multidimensional list comprehension may be written using a block with
    multiple parameters fed by a "for" modifier:
        @names = (-> $name, $num { "$name.$num" } for 'a'..'zzz' X 1..100);
    or equivalently, using placeholders:
        @names = ({ "$^name.$^num" } for 'a'..'zzz' X 1..100);
    Since "do" is defined as going in front of a statement, it follows that
    it can always be followed by a statement label. This is particularly
    useful for the do-once block, since it is officially a loop and can take
    therefore loop control statements.
  Loops at the statementlist level vs the statement level
    In any sequence of statements, only the value of the final statement is
    returned, so all prior statements are evaluated in sink context, which
    is automatically eager, to force the evaluation of side effects. (Side
    effects are the only reason to execute such statements in the first
    place, and Perl will, in fact, warn you if you do something that is
    "useless" in sink context.) A loop in sink context not only evaluates
    itself eagerly, but can optimize away the production of any values from
    the loop.
    The final statement of a statement list is not a sink context, and can
    return any value including a lazy list. However, to support the
    expectations of imperative programmers (the vast majority of us, it
    turns out), any explicit loop found as the final statement of a
    statement list is automatically forced to use sink semantics so that the
    loop executes to completion before returning from the block.
    This forced sink context is applied to loops *only* at the statement
    list level, that is, at the top level of a compilation unit, or directly
    inside a block. Constructs that parse a single statement or semilist as
    an argument are presumed to want the results of that statement, so such
    constructs remain lazy even when that statement is a loop. Assuming each
    of the following statements is the final statement in a block, "sunk"
    loops such as these may be indicated:
        for LIST { ... }
        ... if COND for LIST
        loop { ... }
        ... while COND
        while COND { ... }
        repeat until COND { ... }
    but lazy loops can be indicated by putting the loop in parens or
        (... if COND for LIST)      # lazy list comprehension
        [for LIST { ... }]
        (loop { ... })
    or by use of either a statement prefix or a phaser in statement form:
        lazy for LIST { ... }
        ENTER for LIST { ... }
    Note that the corresponding block forms put the loop into a statement
    list, so these loops are evaluated in sink context:
        lazy { for LIST { ... } }   # futile use of 'lazy' here
        ENTER { for LIST { ... } }
    It doesn't matter that there is only one statement there; what matters
    is that a sequence of statements is expected there by the grammar.
    An eager loop may likewise be indicated by using the "eager" statement
    prefix:
        eager for LIST { ... }
        eager ... if COND for LIST
        eager loop { ... }
        eager ... while COND
        eager while COND { ... }
        eager repeat until COND { ... }
    It is erroneous to write an eager loop without a loop exit, since that
    will chew up all your memory.
    Note that since "do" is considered a one-time loop, it is always
    evaluated eagerly, despite being a statement prefix. This is no great
    hardship; the "lazy" prefix is better documentation in any case. And
    surely the verb "do" ought to imply some degree of getting it done
    eagerly.
    The "given" construct is not considered a loop, and just returns
    normally.
  Statement-level bare blocks
    Although a bare block occurring as a single statement is no longer a
    do-once loop, as with loops when used in a statement list, it still
    executes immediately as in Perl 5, as if it were immediately
    dereferenced with a ".()" postfix, so within such a block "CALLER::"
    refers to the dynamic scope associated with the lexical scope
    surrounding the block.
    If you wish to return a closure from a function, you must use an
    explicit prefix such as "return" or "sub" or "->".
        sub f1
            # lots of stuff ...
            { say "I'm a closure." }
        my $x1= f1;  # fall-off return is result of the say, not the closure.
        sub f2
            return { say "I'm a closure." }
        my $x2= f2;  # returns a Block object.
    Use of a placeholder parameter in statement-level blocks triggers a
    syntax error, because the parameter is not out front where it can be
    seen. However, it's not an error when prefixed by a "do", or when
    followed by a statement modifier:
        # Syntax error: Statement-level placeholder block
        { say $^x };
        # Not a syntax error, though $x doesn't get the argument it wants
        do { say $^x };
        # Not an error: Equivalent to "for 1..10 -> $x { say $x }"
        { say $^x } for 1..10;
        # Not an error: Equivalent to "if foo() -> $x { say $x }"
        { say $^x } if foo();
    It's not an error to pass parameters to such a block either:
        { say $^x + $^x }(5);
    But as always, you must use them all:
        # Syntax error: Too many positional parameters passed
        { say $^x + $^x }(5,6);
  The "gather" statement prefix
    A variant of "do" is "gather". Like "do", it is followed by a statement
    or block, and executes it once. Unlike "do", it evaluates the statement
    or block in sink (void) context; its return value is instead specified
    by calling the "take" list prefix operator one or more times within the
    scope (either lexical or dynamic) of the "gather". The "take" function's
    signature is like that of "return"; while having the syntax of a list
    operator, it merely returns a single item or "argument" (see S02 for
    definition).
    The "take" function is lexotic if there is a visible outer "gather", but
    falls back to purely dynamic if not. Well, it doesn't really fall back,
    since a "take" knows at compile time whether it is being used lexically
    or dynamically. Less obviously, so does a "gather"; if a "gather"
    lexically contains any "take" calls, it is marked as lexotic-only, and
    it will be invisible to a dynamic "take". If the "gather" contains no
    "take" lexically, it by definition cannot be the lexotic target of any
    "take", so it can only harvest dynamic "take" calls. The only remaining
    difficulty arises if both the user and a library writer attempt to use
    dynamic gather with user-defined callbacks that contain "take". So we
    will say that it is erroneous for a library writer to mix dynamic gather
    with callbacks unless those callbacks are somehow "ungathered" to the
    outer dynamic scope. [Conjecture: there should either be an
    "callergather" primitive that does this, or we should allow labeled
    "gather"/"take" for such a situation, and dynamic "take" must match the
    "gather"'s label (or lack thereof) exactly. (Using the term "label"
    loosely, to include other solutions besides the label syntax, such as
    .gather and .take methods on some identity object.)]
    If you take multiple items in a comma list (since it is, after all, a
    list operator), they will be wrapped up in a "List" object for return as
    the next argument. No additional context is applied by the "take"
    operator, since all context is lazy in Perl 6. The flattening or slicing
    of any such returned list will be dependent on how the "gather"'s return
    iterator is iterated (with ".get" vs ".getarg").
    The value returned by the "take" to the "take"'s own context is that
    same returned argument (which is ignored when the "take" is in sink
    context). Regardless of the "take"'s immediate context, the object
    returned is also added to the list of values being gathered, which is
    returned by the "gather" as a lazy list (that is, an iterator, really),
    with each argument element of that list corresponding to one "take".
    Any sublists in the returned list are normally flattened when bound into
    flat context. When bound into a slice context, however, the sublist
    objects keep their identity as discrete sublists. The eventual binding
    context thus determines whether to throw away or keep the groupings
    resulting from each individual "take" call. Most list contexts are flat
    rather than sliced, so the boundaries between individual "take" calls
    usually disappear. (FLAT is an acronym meaning Flat Lists Are Typical.
    :)
    Because "gather" evaluates its block or statement in sink context, this
    typically causes the "take" function to be evaluated in sink context.
    However, a "take" function that is not in sink context gathers its
    return objects *en passant* and also returns them unchanged. This makes
    it easy to keep track of what you last "took":
        my @squished = gather for @list {
            state $previous = take $_;
            next if $_ === $previous;
            $previous = take $_;
    The "take" function essentially has two contexts simultaneously, the
    context in which the "gather" is operating, and the context in which the
    "take" is operating. These need not be identical contexts, since they
    may bind or coerce the resulting lists differently:
        my @y;
        my @x = gather for 1..2 {            # flat context for list of lists
            my ($y) := \(take $_, $_ * 10);  # binding forces item context
            push @y, $y;
        # @x contains 4 Ints:    1,10,2,20 flattened by list assignment to @x
        # @y contains 2 Lists:   $(1,10),$(2,20) sliced by binding to positional $y
    Likewise, we can just remember the gather's result list by binding and
    later coercing it:
        my ($c) := \(gather for 1..2 {
            take $_, $_ * 10;
        });
        # $c.flat produces 1,10,2,20 -- flatten fully into a list of Ints.
        # $c.lol produces LoL.new($(1,10),$(2,20)) -- list of Lists, a 2-D list.
        # $c.item produces $((1,10),(2,20)) -- a list of Lists, as an item.
    Note that the "take" itself is in sink context in this example because
    the "for" loop is in the sink context provided inside the gather.
    A "gather" is not considered a loop, but it is easy to combine with a
    loop statement as in the examples above.
    The "take" operation may be defined internally using resumable control
    exceptions, or dynamic variables, or pigeons carrying clay tablets. The
    choice any particular implementation makes is specifically *not* part of
    the definition of Perl 6, and you should not rely on it in portable
    code.
  Other "do"-like forms
    Other similar forms, where a keyword is followed by code to be
    controlled by it, may also take bare statements, including "try",
    "once", "quietly", "start", "lazy", and "sink". These constructs
    establish a dynamic scope without necessarily establishing a lexical
    scope. (You can always establish a lexical scope explicitly by using the
    block form of argument.) As statement introducers, all these keywords
    must be followed by whitespace. (You can say something like
    "try({...})", but then you are calling the "try()" function using
    function call syntax instead, and since Perl does not supply such a
    function, it will be assumed to be a user-defined function.) For
    purposes of flow control, none of these forms are considered loops, but
    they may easily be applied to a normal loop.
    Note that any construct in the statement_prefix category defines special
    syntax. If followed by a block it does not parse as a list operator or
    even as a prefix unary; it will never look for any additional expression
    following the block. In particular,
        foo( try {...}, 2, 3 )
    calls the "foo" function with three arguments. And
        do {...} + 1
    add 1 to the result of the do block. On the other hand, if a
    statement_prefix is followed by a non-block statement, all nested
    blockless statement_prefixes will terminate at the same statement
    ending:
        do do do foo(); bar 43;
    is parsed as:
        do { do { do { foo(); }}}; bar(43);
Switch statements
    A switch statement is a means of topicalizing, so the switch keyword is
    the English topicalizer, "given". The keyword for individual cases is
    "when":
        given EXPR {
            when EXPR { ... }
            default { ... }
    The current topic is always aliased to the special variable $_. The
    "given" block is just one way to set the current topic. A "for" loop is
    another convenient form (assuming one of its loop variables is bound to
    $_). However, since every block that doesn't explicitly take a $_
    parameter or declare $_ will get an implicit $_, you can set that and
    use the "when" and "default" keywords in it:
        sub seek-the-answer() {
            $_ = (^100).pick;
            when 42 { say "The answer!" }
            default { say "A number" }
    So switching behavior is actually caused by the "when" statements in the
    block, not by the nature of the block itself. A "when" statement
    implicitly does a "smart match" between the current topic ($_) and the
    argument of the "when". If the smart match succeeds, "when"'s associated
    block is executed, and the innermost surrounding block is automatically
    broken out of. (If that is not the block you wish to leave, you must use
    the "LABEL.leave" method (or some other control exception such as
    "return" or "next") to be more specific.) The value of the inner block
    is returned as the value of the outer block.
    If the smart match fails, control proceeds to the next statement
    normally, which may or may not be a "when" statement. Since "when"
    statements are presumed to be executed in order like normal statements,
    it's not required that all the statements in a switch block be "when"
    statements (though it helps the optimizer to have a sequence of
    contiguous "when" statements, because then it can arrange to jump
    directly to the first appropriate test that might possibly match.)
    The default case:
        default {...}
    is exactly equivalent to
        when * {...}
    Because "when" statements are executed in order, the default must come
    last. You don't have to use an explicit default--you can just fall off
    the last "when" into ordinary code. But use of a "default" block is good
    documentation.
    If you use a "for" loop with a parameter named $_ (either explicitly or
    implicitly), that parameter can function as the topic of any "when"
    statements within the loop.
    You can explicitly break out of a "when" block (and its surrounding
    block) early using the "succeed" verb. More precisely, it first scans
    outward (lexically) for the innermost containing "when" block. If that
    "when" block is itself directly inside of a "when" block, the scan also
    skips over that, so you can do nesting such as:
        when * > 2 {
            when 4 { 'four!' }
            default { 'huge' }
        default {
            'little'
    The surrounding frame is then left, returning the value provided to
    "succeed". Breaking out of a block with "succeed" is also considered a
    successful return for the purposes of "KEEP" and "UNDO".
    The implicit break of a normal "when" block works the same way,
    returning the value of the entire block (normally from its last
    statement) via an implicit "succeed".
    You can explicitly leave a "when" block and go to the next statement
    following the "when" by using "proceed". (Note that, unlike C's idea of
    "falling through", subsequent "when" conditions are evaluated. To jump
    into the next "when" block without testing its condition, you must use a
    "goto". But generally that means you should refactor instead.)
    If you have a switch that is the main block of a "for" loop that uses $_
    as its loop variable, and you break out of the switch either implicitly
    or explicitly (that is, the switch "succeeds"), control merely goes to
    the end of that block, and thence on to the next iteration of the loop.
    You must use "last" (or some more violent control exception such as
    "return") to break out of the entire loop early. Of course, an explicit
    "next" might be clearer than a "succeed" if you really want to go
    directly to the next iteration. On the other hand, "succeed" can take an
    optional argument giving the value for that iteration of the loop. As
    with the ".leave" method, there is also a ".succeed" method to break
    from a labelled block functioning as a switch:
        OUTER.succeed($retval)
    There is a "when" statement modifier, but it does not have any breakout
    semantics; it is merely a smartmatch against the current topic. That is,
        doit() when 42;
        doit() if $_ ~~ 42;
    This is particularly useful for list comprehensions:
        @lucky = ($_ when /7/ for 1..100);
Exception handlers
    Unlike many other languages, Perl 6 specifies exception handlers by
    placing a "CATCH" block *within* that block that is having its
    exceptions handled.
    The Perl 6 equivalent to Perl 5's "eval {...}" is "try {...}". (Perl 6's
    "EVAL" function only evaluates strings, not blocks, and does not catch
    exceptions.) A "try" block by default has a "CATCH" block that handles
    all fatal exceptions by ignoring them. If you define a "CATCH" block
    within the "try", it replaces the default "CATCH". It also makes the
    "try" keyword redundant, because any block can function as a "try" block
    if you put a "CATCH" block within it. To prevent lazy lists from leaking
    out unexpectedly, the inside of a "try" is always considered an eager
    context, unless the "try" itself is in a sink context, in which case the
    inside of "try" is also in sink context.
    Additionally, the "try" block or statement implicitly enforces a "use
    fatal" context such that failures are immediately thrown as exceptions.
    (See below.)
    An exception handler is just a switch statement on an implicit topic
    that happens to be the current exception to be dealt with. Inside the
    "CATCH" block, the exception in question is bound to $_. Because of
    smart matching, ordinary "when" statements are sufficiently powerful to
    pattern match the current exception against classes or patterns or
    numbers without any special syntax for exception handlers. If none of
    the cases in the "CATCH" handles the exception, the exception will be
    rethrown. To ignore all unhandled exceptions, use an empty "default"
    case. (In other words, there is an implicit ".die" just inside the end
    of the "CATCH" block. Handled exceptions break out past this implicit
    rethrow.) Hence, "CATCH" is unlike all other switch statements in that
    it treats code inside a "default" block differently from code that's
    after all the "when" blocks but not in a "default" block.
    More specifically, when you write:
        CATCH {
            when Mumble {...}
            default {...}
    you're really calling into a *catch lambda* that works something like
        -> *@! {
            my @handled = ();
            my @unhandled = ();
            my @*undead = ();
            for @! {
                # note, fails current iteration, continues with loop
                SIMPLECATCH { push @*undead, $_; push @unhandled, OUTER::<$_>; }
                .handled = True;
                when Mumble {...}
                default {...}
                .handled = False;
                push @unhandled, $_;
                KEEP { push @handled, $_ if .handled }
            push @unhandled, @*undead;
            # no point in setting their $! if we're gonna blow past
            set_outer_caller's_bang(@handled) unless @unhandled;
            @unhandled;
    Whenever an exception occurs during the execution of a handler, it is
    pushed onto the end of the @*undead array for later processing by an
    outer handler. If there are any unhandled "@!" exceptions, or if any
    exceptions were caught by the inner SIMPLECATCH (which does nothing but
    runs its push code, which should not produce any exceptions), then the
    CATCH block returns them to the exception thrower.
    The exception thrower looks up the call stack for a catch lambda that
    returns () to indicate all exceptions are handled, and then it is happy,
    and unwinds the stack to that point. If any exceptions are returned as
    not handled, the exception thrower keeps looking for a higher dynamic
    scope for a spot to unwind to. Note that any "die" in the catch lambda
    eventually rethrows outside the lambda as a new exception, but not until
    the current exception handler has a chance to handle all exceptions that
    came in via "@!".
    Resumable exceptions may or may not leave normally depending on the
    implementation. If continuations are used, the ".resume" call will
    simply goto the continuation in question, and the lambda's callframe is
    abandoned. Resumable exceptions may also be implemented by simply
    marking the current exception as "resumed", in which case the original
    exception thrower simply returns to the code that threw the resumable
    exception, rather than unwinding before returning. This could be done by
    pushing the resumed exception onto the unhandled list, and then the
    thrower checking to see if there is only a single resumed exception in
    the "unhandled" list. The unhandled list is a dynamic variable so that
    it's easy for .resume to manipulate it.
    A "CATCH" block sees the lexical scope in which it was defined, but its
    caller is the dynamic location that threw the exception. That is, the
    stack is not unwound until some exception handler chooses to unwind it
    by "handling" the exception in question. So logically, if the "CATCH"
    block throws its own exception, you would expect the "CATCH" block to
    catch its own exception recursively forever. However, a "CATCH" must not
    behave that way, so we say that a "CATCH" block never attempts to handle
    any exception thrown within its own dynamic scope. (Otherwise any "die"
    would cause an infinite loop.) Instead we treasure them up and rethrow
    them to a handler further up.
    Unlike "try", the presence of a "CATCH" block does not imply "use fatal"
    semantics for failures; you may, however, use either an explicit "try"
    block around the "CATCH" or an explicit "use fatal" to guarantee that
    failures are thrown eagerly rather than lazily.
Control Exceptions
    All abnormal control flow is, in the general case, handled by the
    exception mechanism (which is likely to be optimized away in specific
    cases.) Here "abnormal" means any transfer of control outward that is
    not just falling off the end of a block. A "return", for example, is
    considered a form of abnormal control flow, since it can jump out of
    multiple levels of closures to the end of the scope of the current
    subroutine definition. Loop commands like "next" are abnormal, but
    looping because you hit the end of the block is not. The implicit break
    (what "succeed" does explicitly) of a "when" block is abnormal.
    A "CATCH" block handles only "bad" exceptions, and lets control
    exceptions pass unhindered. Control exceptions may be caught with a
    "CONTROL" block. Generally you don't need to worry about this unless
    you're defining a control construct. You may have one "CATCH" block and
    one "CONTROL" block, since some user-defined constructs may wish to
    supply an implicit "CONTROL" block to your closure, but let you define
    your own "CATCH" block.
    A "return" always exits from the lexically surrounding sub or method
    definition (that is, from a function officially declared with the "sub",
    "method", or "submethod" keywords). Pointy blocks and bare closures are
    transparent to "return", in that the "return" statement still means
    "&?ROUTINE.leave" from the "Routine" that existed in dynamic scope when
    the closure was cloned.
    It is illegal to return from the closure if that "Routine" no longer
    owns a call frame in the current call stack.
    To return a value (to the dynamical caller) from any pointy block or
    bare closure, you either just let the block return the value of its
    final expression, or you can use "leave", which comes in both function
    and method forms. The function (or listop) form always exits from the
    innermost block, returning its arguments as the final value of the block
    exactly as "return" does. The method form will leave any block in the
    dynamic scope that can be named as an object and that responds to the
    ".leave" method.
    Hence, the "leave" function:
        leave(1,2,3)
    is really just short for:
        &?BLOCK.leave(1,2,3)
    To return from your immediate caller, you can say:
        caller.leave(1,2,3)
    Further call frames up the caller stack may be located by use of the
    "callframe" function:
        callframe({ .labels.any eq 'LINE' }).leave(1,2,3);
    By default the innermost call frame matching the selection criteria will
    be exited. This can be a bit cumbersome, so in the particular case of
    labels, the label that is already visible in the current lexical scope
    is considered a kind of pseudo object specifying a potential dynamic
    context. If instead of the above you say:
        LINE.leave(1,2,3)
    it was always exit from your lexically scoped "LINE" loop, even if some
    inner dynamic scope you can't see happens to also have that label. (In
    other words, it's lexotic.) If the "LINE" label is visible but you
    aren't actually in a dynamic scope controlled by that label, an
    exception is thrown. (If the "LINE" is not visible, it would have been
    caught earlier at compile time since "LINE" would likely be a bareword.)
    In theory, any user-defined control construct can catch any control
    exception it likes. However, there have to be some culturally enforced
    standards on which constructs capture which exceptions. Much like
    "return" may only return from an "official" subroutine or method, a loop
    exit like "next" should be caught by the construct the user expects it
    to be caught by. (Always assuming the user expects the right thing, of
    course...) In particular, if the user labels a loop with a specific
    label, and calls a loop control from within the lexical scope of that
    loop, and if that call mentions the outer loop's label, then that outer
    loop is the one that must be controlled. In other words, it first tries
    this form:
    If there is no such lexically scoped outer loop in the current
    subroutine, then a fallback search is made outward through the dynamic
    scopes in the same way Perl 5 does. (The difference between Perl 5 and
    Perl 6 in this respect arises only because Perl 5 didn't have
    user-defined control structures, hence the sub's lexical scope was
    *always* the innermost dynamic scope, so the preference to the lexical
    scope in the current sub was implicit. For Perl 6 we have to make this
    preference for lexotic behavior explicit.)
    Warnings are produced in Perl 6 by throwing a resumable control
    exception to the outermost scope, which by default prints the warning
    and resumes the exception by extracting a resume continuation from the
    exception, which must be supplied by the "warn()" function (or
    equivalent). Exceptions are not resumable in Perl 6 unless the exception
    object does the "Resumable" role. (Note that fatal exception types can
    do the "Resumable" role even if thrown via "fail()"--when uncaught they
    just hit the outermost fatal handler instead of the outermost warning
    handler, so some inner scope has to explicitly treat them as warnings
    and resume them.)
    Since warnings are processed using the standard control exception
    mechanism, they may be intercepted and either suppressed or fatalized
    anywhere within the dynamic scope by supplying a suitable "CONTROL"
    block. This dynamic control is orthogonal to any lexically scoped
    warning controls, which merely decide whether to call "warn()" in the
    first place.
    As with calls to "return", the warning control exception is an
    abstraction that the compiler is free to optimize away (along with the
    associated continuation) when the compiler or runtime can determine that
    the semantics would be preserved by merely printing out the error and
    going on. Since all exception handlers run in the dynamic scope of the
    throw, that reduces to simply returning from the "warn" function most of
    the time. See previous section for discussion of ways to return from
    catch lambdas. The control lambda is logically separate from the catch
    lambda, though an implementation is allowed to combine them if it is
    careful to retain separate semantics for catch and control exceptions.
    One additional level of control is the notion of *lazy warnings*. If,
    instead of throwing a warning directly, the program calls "fail()" with
    a resumable exception, the throwing of the warning is delayed until
    first use (or the caller's policy) requires it to be thrown. If the
    warning exception supports the ".resume_value" method, that will be the
    value of the failure after it has resumed. Otherwise the value will be
    the null string. Numeric and string conversions use these lazy warnings
    to allow (but not require) failsoft semantics.
The goto statement
    In addition to "next", "last", and "redo", Perl 6 also supports "goto".
    As with ordinary loop controls, the label is searched for first
    lexically within the current subroutine, then dynamically outside of it.
    Unlike with loop controls, however, scanning a scope includes a scan of
    any lexical scopes included within the current candidate scope. As in
    Perl 5, it is possible to "goto" into a lexical scope, but only for
    lexical scopes that require no special initialization of parameters.
    (Initialization of ordinary variables does not count--presumably the
    presence of a label will prevent code-movement optimizations past the
    label.) So, for instance, it's always possible to "goto" into the next
    case of a "when" or into either the "then" or "else" branch of a
    conditional. You may not go into a "given" or a "for", though, because
    that would bypass a formal parameter binding (not to mention list
    generation in the case of "for"). (Note: the implicit default binding of
    an outer $_ to an inner $_ can be emulated for a bare block, so that
    doesn't fall under the prohibition on bypassing formal binding.)
    Because it is possible to go to a label that is after the operation, and
    because Perl 6 does one-pass parsing, any "goto" to a label that has not
    been yet declared (or is declared outside the outward lexical scope of
    the "goto") must enclose the label in quotes.
Exceptions
    As in Perl 5, many built-in functions simply return an undefined value
    when you ask for a value out of range, or the function fails somehow.
    Perl 6 has "Failure" objects, known as "unthrown exceptions" (though
    really a "Failure" merely contains an unthrown exception), which know
    whether they have been handled or not. $! is a convenient link to the
    last failure, and only ever contains one exception, the most recent.
    [Conjecture: all unhandled exceptions within a routine could be stored
    in "@!", with the most recent first. $! would then be sugar for "@![0]".
    (Or we use push semantics and $! means "@![*-1]".) This might be more
    robust than merely making "@!" a parameter to CATCH. However, the new
    semantics of autothrowing when sink eats a Failure means we won't have
    many unthrown exceptions waiting around to be handled at the end of the
    block anymore. We should probably at least issue warnings, though, if
    the GC eventually collects a failure that was never handled. We can't
    really rely on end-of-routine cleanup to deal with failures that are
    returned as normal data, unless we go with the overhead of a lexical
    "@!" variable.]
    If you test a "Failure" for ".defined" or ".Bool", the "Failure" marks
    itself as *handled*; the exception acts as a relatively harmless
    undefined value thereafter. Any other use of the "Failure" object to
    extract a normal value will throw its associated exception immediately.
    (The "Failure" may, however, be stored in any container whose type
    allows the "Failure" role to be mixed in.) The ".handled" method returns
    "False" on failures that have not been handled. It returns "True" for
    handled exceptions and for all non-"Failure" objects. (That is, it is a
    "Mu" method, not a "Failure" method. Only "Failure" objects need to
    store the actual status however; other types just return "True".)
    The ".handled" method is "rw", so you may mark an exception as handled
    by assigning "True" to it. Note however that
        $!.handled = 1;
    marks only the last exception as handled. To mark them all as handled
    you must access them individually via the implicit loop of a CATCH
    block.
    A bare "die"/"fail" takes $! as the default argument specifying the
    exception to be thrown or propagated outward to the caller's $!.
    You can cause built-ins to automatically throw exceptions on failure
    using
        use fatal;
    The "fail" function responds to the caller's "use fatal" state. It
    either returns an unthrown exception, or throws the exception. Before
    you get too happy about this pragma, note that Perl 6 contains various
    parallel processing primitives that will tend to get blown up
    prematurely by thrown exceptions. Unthrown exceptions are meant to
    provide a failsoft mechanism in which failures can be treated as data
    and dealt with one by one, without aborting execution of what may be
    perfectly valid parallel computations. If you *don't* deal with the
    failures as data, then sink context will automatically throw any
    unhandled "Failure" that you try to discard.
    In any case, the overriding design principle here is that no unhandled
    exception is ever dropped on the floor, but propagated outward until it
    is handled. If no explicit handler handles it, the implicit outermost
    exception handler will eventually decide to abort and print all
    unhandled exceptions passed in as its current "@!" list.
    It is possible to fail with a resumable exception, such as a warning. If
    the failure throws its exception and the exception resumes, the thrower
    by default returns the null string ('') to whatever caused the failure
    to throw its exception. This may be overridden by attaching a
    ".resume_value" to the warning. Hence numeric coercions such as
    "+"42foo"" can be forced to return 42 after issuing a warning.
Phasers
    A "CATCH" block is just a trait of the closure containing it, and is
    automatically called at the appropriate moment. These auto-called blocks
    are known as *phasers*, since they generally mark the transition from
    one phase of computing to another. For instance, a "CHECK" block is
    called at the end of compiling a compilation unit. Other kinds of
    phasers can be installed as well; these are automatically called at
    various times as appropriate, and some of them respond to various
    control exceptions and exit values. Phasers marked with a "*" can be
    used for their return value.
          BEGIN {...}*      at compile time, ASAP, only ever runs once
          CHECK {...}*      at compile time, ALAP, only ever runs once
           LINK {...}*      at link time, ALAP, only ever runs once
           INIT {...}*      at run time, ASAP, only ever runs once
            END {...}       at run time, ALAP, only ever runs once
          ENTER {...}*      at every block entry time, repeats on loop blocks.
          LEAVE {...}       at every block exit time (even stack unwinds from exceptions)
           KEEP {...}       at every successful block exit, part of LEAVE queue
           UNDO {...}       at every unsuccessful block exit, part of LEAVE queue
          FIRST {...}*      at loop initialization time, before any ENTER
           NEXT {...}       at loop continuation time, before any LEAVE
           LAST {...}       at loop termination time, after any LEAVE
            PRE {...}       assert precondition at every block entry, before ENTER
           POST {...}       assert postcondition at every block exit, after LEAVE
          CATCH {...}       catch exceptions, before LEAVE
        CONTROL {...}       catch control exceptions, before LEAVE
        COMPOSE {...}       when a role is composed into a class
    Some of the statement prefixes also behave a little bit like phasers,
    but they run in-line with the executable code, so they are spelled in
    lowercase. They parse the same as phasers:
             do {...}*      run a block or statement as a term
           once {...}*      run only once, suppressing additional evaluations
         gather {...}*      start a co-routine thread
          eager {...}*      evaluate statement eagerly
           lazy {...}*      defer actual evaluation till value is fetched
           sink {...}*      evaluate eagerly but throw results away
            try {...}*      evaluate and trap exceptions (implies 'use fatal')
        quietly {...}*      evaluate and suppress warnings
          start {...}*      start computation of a promised result
    Constructs marked with a "*" have a run-time value, and if evaluated
    earlier than their surrounding expression, they simply save their result
    for use in the expression later when the rest of the expression is
    evaluated:
        my $compiletime = BEGIN { now };
        our $temphandle = ENTER { maketemp() };
    As with other statement prefixes, these value-producing constructs may
    be placed in front of either a block or a statement:
        my $compiletime = BEGIN now;
        our $temphandle = ENTER maketemp();
    In fact, most of these phasers will take either a block or a thunk
    (known as a *blast* in the vernacular). The statement form can be
    particularly useful to expose a lexically scoped declaration to the
    surrounding lexical scope without "trapping" it inside a block.
    Hence these declare the same variables with the same scope as the
    preceding example, but run the statements as a whole at the indicated
        BEGIN my $compiletime = now;
        ENTER our $temphandle = maketemp();
    (Note, however, that the value of a variable calculated at compile time
    may not persist under run-time cloning of any surrounding closure.)
    Most of the non-value-producing phasers may also be so used:
        END say my $accumulator;
    Note, however, that
        END say my $accumulator = 0;
    sets the variable to 0 at "END" time, since that is when the "my"
    declaration is actually executed. Only argumentless phasers may use the
    statement form. This means that "CATCH" and "CONTROL" always require a
    block, since they take an argument that sets $_ to the current topic, so
    that the innards are able to behave as a switch statement. (If bare
    statements were allowed, the temporary binding of $_ would leak out past
    the end of the "CATCH" or "CONTROL", with unpredictable and quite
    possibly dire consequences. Exception handlers are supposed to reduce
    uncertainty, not increase it.)
    Code that is generated at run time can still fire off "CHECK" and "INIT"
    phasers, though of course those phasers can't do things that would
    require travel back in time. You need a wormhole for that.
    The compiler is free to ignore "LINK" phasers compiled at run time since
    they're too late for the application-wide linking decisions.
    Some of these phasers also have corresponding traits that can be set on
    variables. These have the advantage of passing the variable in question
    into the closure as its topic:
        our $h will enter { .rememberit() } will undo { .forgetit() };
    Only phasers that can occur multiple times within a block are eligible
    for this per-variable form.
    Apart from "CATCH" and "CONTROL", which can only occur once, most of
    these can occur multiple times within the block. So they aren't really
    traits, exactly--they add themselves onto a list stored in the actual
    trait. So if you examine the "ENTER" trait of a block, you'll find that
    it's really a list of phasers rather than a single phaser.
    When multiple phasers are scheduled to run at the same moment, the
    general tiebreaking principle is that initializing phasers execute in
    order declared, while finalizing phasers execute in the opposite order,
    because setup and teardown usually want to happen in the opposite order
    from each other. When phasers are in different modules, the "INIT" and
    "END" phasers are treated as if declared at "use" time in the using
    module. (It is erroneous to depend on this order if the module is used
    more than once, however, since the phasers are only installed the first
    time they're noticed.)
    The semantics of "INIT" and "once" are not equivalent to each other in
    the case of cloned closures. An "INIT" only runs once for all copies of
    a cloned closure. A "once" runs separately for each clone, so separate
    clones can keep separate state variables:
        our $i = 0;
        $func = once { state $x { $x = $i++ }; dostuff($i) };
    But "state" automatically applies "once" semantics to any initializer,
    so this also works:
        $func = { state $x = $i++; dostuff($i) }
    Each subsequent clone gets an initial state that is one higher than the
    previous, and each clone maintains its own state of $x, because that's
    what "state" variables do.
    Even in the absence of closure cloning, "INIT" runs before the mainline
    code, while "once" puts off the initialization till the last possible
    moment, then runs exactly once, and caches its value for all subsequent
    calls (assuming it wasn't called in sink context, in which case the
    "once" is evaluated once only for its side effects). In particular, this
    means that "once" can make use of any parameters passed in on the first
    call, whereas "INIT" cannot.
    All of these phaser blocks can see any previously declared lexical
    variables, even if those variables have not been elaborated yet when the
    closure is invoked (in which case the variables evaluate to an undefined
    value.)
    Note: Apocalypse 4 confused the notions of "PRE"/"POST" with
    "ENTER"/"LEAVE". These are now separate notions. "ENTER" and "LEAVE" are
    used only for their side effects. "PRE" and "POST" return boolean values
    which, if false, trigger a runtime exception. "KEEP" and "UNDO" are just
    variants of "LEAVE", and for execution order are treated as part of the
    queue of "LEAVE" phasers.
    It is conjectured that "PRE" and "POST" submethods in a class could be
    made to run as if they were phasers in any public method of the class.
    This feature is awaiting further exploration by means of a "ClassHOW"
    extension.
    "FIRST", "NEXT", and "LAST" are meaningful only within the lexical scope
    of a loop, and may occur only at the top level of such a loop block. A
    "NEXT" executes only if the end of the loop block is reached normally,
    or an explicit "next" is executed. In distinction to "LEAVE" phasers, a
    "NEXT" phaser is not executed if the loop block is exited via any
    exception other than the control exception thrown by "next". In
    particular, a "last" bypasses evaluation of "NEXT" phasers.
    [Note: the name "FIRST" used to be associated with "state" declarations.
    Now it is associated only with loops. See the "once" above for "state"
    semantics.]
    Except for "CATCH" and "CONTROL" phasers, which run while an exception
    is looking for a place to handle it, all block-leaving phasers wait
    until the call stack is actually unwound to run. Unwinding happens only
    after some exception handler decides to handle the exception that way.
    That is, just because an exception is thrown past a stack frame does not
    mean we have officially left the block yet, since the exception might be
    resumable. In any case, exception handlers are specified to run within
    the dynamic scope of the failing code, whether or not the exception is
    resumable. The stack is unwound and the phasers are called only if an
    exception is not resumed.
    So "LEAVE" phasers for a given block are necessarily evaluated after any
    "CATCH" and "CONTROL" phasers. This includes the "LEAVE" variants,
    "KEEP" and "UNDO". "POST" phasers are evaluated after everything else,
    to guarantee that even "LEAVE" phasers can't violate postconditions.
    Likewise "PRE" phasers fire off before any "ENTER" or "FIRST" (though
    not before "BEGIN", "CHECK", "LINK", or "INIT", since those are done at
    compile or process initialization time).
    The "POST" block can be defined in one of two ways. Either the
    corresponding "POST" is defined as a separate phaser, in which case
    "PRE" and "POST" share no lexical scope. Alternately, any "PRE" phaser
    may define its corresponding "POST" as an embedded phaser block that
    closes over the lexical scope of the "PRE".
    If exit phasers are running as a result of a stack unwind initiated by
    an exception, this information needs to be made available. In any case,
    the information as to whether the block is being exited successfully or
    unsuccessfully needs to be available to decide whether to run "KEEP" or
    "UNDO" blocks (also see "Definition of Success"). How this information
    is made available is implementation dependent.
    An exception thrown from an "ENTER" phaser will abort the "ENTER" queue,
    but one thrown from a "LEAVE" phaser will not. The exceptions thrown by
    failing "PRE" and "POST" phasers cannot be caught by a "CATCH" in the
    same block, which implies that "POST" phaser are not run if a "PRE"
    phaser fails.
    If a "POST" fails or any kind of "LEAVE" block throws an exception while
    the stack is unwinding, the unwinding continues and collects exceptions
    to be handled. When the unwinding is completed all new exceptions are
    thrown from that point.
    For phasers such as "KEEP" and "POST" that are run when exiting a scope
    normally, the return value (if any) from that scope is available as the
    current topic within the phaser.
    The topic of the block outside a phaser is still available as
    "OUTER::<$_>". Whether the return value is modifiable may be a policy of
    the phaser in question. In particular, the return value should not be
    modified within a "POST" phaser, but a "LEAVE" phaser could be more
    liberal.
    Any phaser defined in the lexical scope of a method is a closure that
    closes over "self" as well as normal lexicals. (Or equivalently, an
    implementation may simply turn all such phasers into submethods whose
    primed invocant is the current object.)
Statement parsing
    In this statement:
    parentheses aren't necessary around "EXPR" because the whitespace
    between "EXPR" and the block forces the block to be considered a block
    rather than a subscript, provided the block occurs where an infix
    operator would be expected. This works for all control structures, not
    just the new ones in Perl 6. A top-level bare block is always considered
    a statement block if there's a term and a space before it:
        if $foo { ... }
        elsif $bar { ... }
        else { ... }
        while $more { ... }
        for 1..10 { ... }
    You can still parenthesize the expression argument for old times' sake,
    as long as there's a space between the closing paren and the opening
    brace. (Otherwise it will be parsed as a hash subscript.)
    Note that the parser cannot intuit how many arguments a list operator is
    taking, so if you mean 0 arguments, you must parenthesize the argument
    list to force the block to appear after a term:
        if caller {...}    # WRONG, parsed as caller({...})
        if caller() {...}  # okay
        if (caller) {...}  # okay
    Note that common idioms work as expected though:
        for map { $^a + 1 }, @list { .say }
    Unless you are parsing a statement that expects a block argument, it is
    illegal to use a bare closure where an operator is expected because it
    will be considered to be two terms in row. (Remove the whitespace if you
    wish it to be a postcircumfix.)
    Anywhere a term is expected, a block is taken to be a closure definition
    (an anonymous subroutine). If a closure has arguments, it is always
    taken as a normal closure. (In addition to standard formal parameters,
    placeholder arguments also count, as do the underscore variables.
    Implicit use of $_ with ".method" also counts as an argument.)
    However, if an argumentless closure is empty, or appears to contain
    nothing but a comma-separated list starting with a pair or a hash
    (counting a single pair or hash as a list of one element), the closure
    will be immediately executed as a hash composer, as if called with
    ".()".
        $hash = { };
        $hash = { %stuff };
        $hash = { "a" => 1 };
        $hash = { "a" => 1, $b, $c, %stuff, @nonsense };
        $code = { %_ };                            # use of %_
        $code = { "a" => $_ };                     # use of $_
        $code = { "a" => 1, $b, $c, %stuff, @_ };  # use of @_
        $code = { ; };
        $code = { @stuff };
        $code = { "a", 1 };
        $code = { "a" => 1, $b, $c ==> print };
    If you wish to be less ambiguous, the "hash" list operator will
    explicitly evaluate a list and compose a hash of the returned value,
    while "sub" or "->" introduces an anonymous subroutine:
        $code = -> { "a" => 1 };
        $code = sub { "a" => 1 };
        $hash = hash("a" => 1);
        $hash = hash("a", 1);
    Note that the closure in a "map" will never be interpreted as a hash,
    since such a closure always takes arguments, and use of placeholders
    (including underscore variables) is taken as evidence of arguments.
    If a closure is the right argument of the dot operator, the closure is
    interpreted as a hash subscript.
        $code = {$x};       # closure because term expected
        if $term{$x}        # subscript because postfix expected
        if $term {$x}       # expression followed by statement block
        if $term.{$x}       # valid subscript with dot
        if $term\  {$x}     # valid subscript with "unspace"
    Similar rules apply to array subscripts:
        $array = [$x];      # array composer because term expected
        if $term[$x]        # subscript because postfix expected
        if $term [$x]       # syntax error (two terms in a row)
        if $term.[$x]       # valid subscript with dot
        if $term\  [$x]     # valid subscript with "unspace"
    And to the parentheses delimiting function arguments:
        $scalar = ($x);     # grouping parens because term expected
        if $term($x)        # function call because operator expected
        if $term ($x)       # syntax error (two terms in a row)
        if $term.($x)       # valid function call with explicit dot deref
        if $term\  .($x)    # valid function call with "unspace" and dot
    Outside of any kind of expression brackets, a final closing curly on a
    line (not counting whitespace or comments) always reverts to the
    precedence of semicolon whether or not you put a semicolon after it. (In
    the absence of an explicit semicolon, the current statement may continue
    on a subsequent line, but only with valid statement continuators such as
    "else" that cannot be confused with the beginning of a new statement.
    Anything else, such as a statement modifier (on, say, a "loop"
    statement) must continue on the same line, unless the newline be escaped
    using the "unspace" construct--see S02.)
    Final blocks on statement-level constructs always imply semicolon
    precedence afterwards regardless of the position of the closing curly.
    Statement-level constructs are distinguished in the grammar by being
    declared in the "statement_control" category:
        macro statement_control:<if> ($expr, &ifblock) {...}
        macro statement_control:<while> ($expr, &whileblock) {...}
        macro statement_control:<BEGIN> (&beginblock) {...}
    Statement-level constructs may start only where the parser is expecting
    the start of a statement. To embed a statement in an expression you must
    use something like "do {...}" or "try {...}".
        $x =  do { given $foo { when 1 {2}; when 3 {4} } } + $bar;
        $x = try { given $foo { when 1 {2}; when 3 {4} } } + $bar;
    The existence of a "statement_control:<BEGIN>" does not preclude us from
    also defining a "prefix:<BEGIN>" that *can* be used within an
        macro prefix:<BEGIN> (&beginblock) { beginblock().repr }
    Then you can say things like:
        $recompile_by = BEGIN { time } + $expiration_time;
    But "statement_control:<BEGIN>" hides "prefix:<BEGIN>" at the start of a
    statement. You could also conceivably define a "prefix:<if>", but then
    you may not get what you want when you say:
        die if $foo;
    since "prefix:<if>" would hide "statement_modifier:<if>".
    Built-in statement-level keywords require whitespace between the keyword
    and the first argument, as well as before any terminating loop. In
    particular, a syntax error will be reported for C-isms such as these:
        if(...) {...}
        while(...) {...}
        for(...) {...}
Definition of Success
    Hypothetical variables are somewhat transactional--they keep their new
    values only on successful exit of the current block, and otherwise are
    rolled back to their original values.
    It is, of course, a failure to leave the block by propagating an error
    exception, though returning a defined value after catching an exception
    is okay.
    In the absence of error exception propagation, a successful exit is one
    that returns a defined value or list. (A defined list may contain
    undefined values.) So any Perl 6 function can say
        fail "message";
    and not care about whether the function is being called in item or list
    context. To return an explicit scalar undef, you can always say
        return Mu;          # like "return undef" in Perl 5
    Then in list context, you're returning a list of length 1, which is
    defined (much like in Perl 5). But generally you should be using "fail"
    in such a case to return an exception object. In any case, returning an
    unthrown exception is considered failure from the standpoint of "let".
    Backtracking over a closure in a regex is also considered failure of the
    closure, which is how hypothetical variables are managed by regexes.
    (And on the flip side, use of "fail" within a regex closure initiates
    backtracking of the regex.)
When is a closure not a closure
    Everything is conceptually a closure in Perl 6, but the optimizer is
    free to turn unreferenced closures into mere blocks of code. It is also
    free to turn referenced closures into mere anonymous subroutines if the
    block does not refer to any external lexicals that should themselves be
    cloned. (When we say "clone", we mean the way the system takes a
    snapshot of the routine's lexical scope and binds it to the current
    instance of the routine so that if you ever use the current reference to
    the routine, it gets the current snapshot of its world in terms of the
    lexical symbols that are visible to it.)
    All remaining blocks are conceptually cloned into closures as soon as
    the lexical scope containing them is entered. (This may be done lazily
    as long as consistent semantics are preserved, so a block that is never
    executed and never has a reference taken can avoid cloning altogether.
    Execution or reference taking forces cloning in this case--references
    are not allowed to be lazily cloned, since no guarantee can be made that
    the scope needed for cloning will remain in existence over the life of
    the reference.)
    In particular, package subroutines are a special problem when embedded
    in a changing lexical scope (when they make reference to it). The
    binding of such a definition to a name within a symbol table counts as
    taking a reference, so at compile time there is an initial binding to
    the symbol table entry in question. For "global" bindings to symbol
    tables visible at compile time, this binds to the compile-time view of
    the lexical scopes. (At run-time, the initial run-time view of these
    scopes is copied from the compiler's view of them, so that
    initializations carry over, for instance.) At run time, when such a
    subroutine is cloned, an additional binding is done at clone time to the
    same symbol table entry that the original was bound to. (The binding is
    not restored on exit from the current lexical scope; this binding
    records the *last* cloning, not the currently in-use cloning, so any use
    of the global reference must take into consideration that it is
    functioning only as a cache of the most recent cloning, not as a
    surrogate for the current lexical scope.)
    Matters are more complicated if the package in question is lexically
    defined. In such cases, the package must be cloned as if it were a sub
    on entry to the corresponding lexical scope. All runtime instances of a
    single package declaration share the same set of compile-time declared
    functions, however, the runtime instances can have different lexical
    environments as described in the preceding paragraph. If multiple
    conflicting definitions of a sub exist for the same compile-time
    package, an error condition exists and behavior is not specified for
    Perl 6.0.
    Methods in classes behave functionally like package subroutines, and
    have the same binding behavior if the classes are cloned. Note that a
    class declaration, even an augment, is fundamentally a compile-time
    operation; composition only happens once and the results are recorded in
    the prototype class. Runtime typological manipulations are limited to
    reseating "OUTER::" scopes of methods.
    Lexical names do not share this problem, since the symbol goes out of
    scope synchronously with its usage. Unlike global subs, they do not need
    a compile-time binding, but like global subs, they perform a binding to
    the lexical symbol at clone time (again, conceptually at the entry to
    the outer lexical scope, but possibly deferred.)
        sub foo {
            # conceptual cloning happens to both blocks below
            my $x = 1;
            my sub bar { print $x }         # already conceptually cloned, but can be lazily deferred
            my &baz := { bar(); print $x }; # block is cloned immediately, forcing cloning of bar
            my $code = &bar;                # this would also force bar to be cloned
            return &baz;
    In particular, blocks of inline control flow need not be cloned until
    called. [Note: this is currently a potential problem for user-defined
    constructs, since you have to take references to blocks to pass them to
    whatever is managing the control flow. Perhaps the laziness can be
    deferred through "Capture"s to binding time, so a slurpy of block refs
    doesn't clone them all prematurely. On the other hand, this either means
    the "Capture" must be smart enough to keep track of the lexical scope it
    came from so that it can pass the info to the cloner, or it means that
    we need some special fat not-cloned-yet references that can carry the
    info lazily. Neither approach is pretty.]
    Some closures produce "Block" objects at compile time that cannot be
    cloned, because they're not attached to any runtime code that can
    actually clone them. "BEGIN", "CHECK", "LINK", "INIT", and "END" blocks
    fall into this category. Therefore you can't reliably refer to run-time
    variables from these closures even if they appear to be in the scope.
    (The compile-time closure may, in fact, see some kind of permanent copy
    of the variable for some storage classes, but the variable is likely to
    be undefined when the closure is run in any case.) It's only safe to
    refer to package variables and file-scoped lexicals from such a routine.
    On the other hand, it is required that "CATCH" and "LEAVE" blocks be
    able to see transient variables in their current lexical scope, so their
    cloning status depends at least on the cloning status of the block
    they're in.
    Synopsis 5: Regexes and Rules
        Created: 24 Jun 2002
        Last Modified: 12 May 2015
        Version: 180
    This document summarizes Apocalypse 5, which is about the new regex
    syntax. We now try to call them *regex* rather than "regular
    expressions" because they haven't been regular expressions for a long
    time, and we think the popular term "regex" is in the process of
    becoming a technical term with a precise meaning of: "something you do
    pattern matching with, kinda like a regular expression". On the other
    hand, one of the purposes of the redesign is to make portions of our
    patterns more amenable to analysis under traditional regular expression
    and parser semantics, and that involves making careful distinctions
    between which parts of our patterns and grammars are to be treated as
    declarative, and which parts as procedural.
    In any case, when referring to recursive patterns within a grammar, the
    terms *rule* and *token* are generally preferred over *regex*.
    In essence, Perl 6 natively implements Parsing Expression Grammars
    (PEGs) as an extension of regular expression notation. PEGs require that
    you provide a "pecking order" for ambiguous parses. Perl 6's pecking
    order is determined by a multi-level tie-breaking test:
        1) Most-derived only/proto hides less-derived of the same name
        2) Longest token matching: food\s+ beats foo by 2 or more positions
        3) Longest literal prefix: food\w* beats foo\w* by 1 position
        4) For a given proto, multis from a more-derived grammar win
        5) Within a given compilation unit, the earlier alternative or multi wins
    Tiebreaker #3 will treat any initial sequence of literals as the longest
    literal prefix. If there is an alternation embedded in the longest token
    matching, those alternations can extend a literal prefix provided
    everything was literal up to the alternation. If all of the alternations
    are totally literal, then the literal can also extend beyond the end of
    the alternation when they rejoin. Otherwise the end of the alternation
    terminates all longest literal prefixes, even the branches that are
    totally literal. For example:
        / a [ 1 | 2 ] b /   # longest literals are 'a1b' and 'a2b'
        / a [ 1 | 2\w ] b / # longest literals are 'a1 and 'a2'
        / a <[ 1 2 ]> b /   # longest literal is only 'a'
    Note that in this case, a character class is not treated the same as an
    alternation. All character classes are considered too generic to include
    in a longest literal string.
    As with longest token matching, longest literal prefixes are transitive
    through subrules. If a subrule is a protoregex, it is treated just as
    alternation with "|" is, and follows the same rules about extending or
    terminating the longest literal prefix.
    In addition to this pecking order, if any rule chosen under the pecking
    backtracks, the next best rule is chosen. That is, the pecking order
    determines a candidate list; just because one candidate is chosen does
    not mean the rest are thrown away. They may, however, be explicitly
    thrown away by an appropriate backtracking control (sometimes called a
    "cut" operator, but Perl 6 has several of them, depending on how much
    you want to cut).
    Also, any rule chosen to execute under #1 may choose to delegate to its
    ancestors; PEG backtracking has no control over this.
New match result and capture variables
    The underlying match object is now available via the $/ variable, which
    is implicitly lexically scoped. All user access to the most recent match
    is through this variable, even when it doesn't look like it. The
    individual capture variables (such as $0, $1, etc.) are just elements of
    $/.
    By the way, unlike in Perl 5, the numbered capture variables now start
    at $0 instead of $1. See below.
    In order to detect accidental use of Perl 5's unrelated $/ variable,
    Perl 6's $/ variable may not be assigned to directly.
        $/ = $x;   # "Unsupported use of $/ variable as input record separator"
        $/ := $x;  # OK, binding
        $/ RR= $x; # OK, metaoperator
        ($/) = $x; # OK, list assignment
Unchanged syntactic features
    The following regex features use the same syntax as in Perl 5:
    *   Capturing: (...)
    *   Repetition quantifiers: *, +, and ?
    *   Alternatives: |
    *   Backslash escape: \
    *   Minimal matching suffix: ??, *?, +?
    While the syntax of "|" does not change, the default semantics do change
    slightly. We are attempting to concoct a pleasing mixture of declarative
    and procedural matching so that we can have the best of both. In short,
    you need not write your own tokener for a grammar because Perl will
    write one for you. See the section below on "Longest-token matching".
Simplified lexical parsing of patterns
    Unlike traditional regular expressions, Perl 6 does not require you to
    memorize an arbitrary list of metacharacters. Instead it classifies
    characters by a simple rule. All glyphs (graphemes) whose base
    characters are either the underscore ("_") or have a Unicode
    classification beginning with 'L' (i.e. letters) or 'N' (i.e. numbers)
    are always literal (i.e. self-matching) in regexes. They must be escaped
    with a "\" to make them metasyntactic (in which case that single
    alphanumeric character is itself metasyntactic, but any immediately
    following alphanumeric character is not).
    All other glyphs--including whitespace--are exactly the opposite: they
    are always considered metasyntactic (i.e. non-self-matching) and must be
    escaped or quoted to make them literal. As is traditional, they may be
    individually escaped with "\", but in Perl 6 they may be also quoted as
    follows.
    Sequences of one or more glyphs of either type (i.e. any glyphs at all)
    may be made literal by placing them inside single quotes. (Double quotes
    are also allowed, with the same interpolative semantics as the current
    language in which the regex is lexically embedded.) Quotes create a
    quantifiable atom, so while
        moose*
    quantifies only the 'e' and matches "mooseee", saying
        'moose'*
    quantifies the whole string and would match "moosemoose".
    Here is a table that summarizes the distinctions:
                     Alphanumerics        Non-alphanumerics         Mixed
     Literal glyphs   a    1    _        \*  \$  \.   \\   \'       K\-9\!
     Metasyntax      \a   \1   \_         *   $   .    \    '      \K-\9!
     Quoted glyphs   'a'  '1'  '_'       '*' '$' '.' '\\' '\''     'K-9!'
    In other words, identifier glyphs are literal (or metasyntactic when
    escaped), non-identifier glyphs are metasyntactic (or literal when
    escaped), and single quotes make everything inside them literal.
    Note, however, that not all non-identifier glyphs are currently
    meaningful as metasyntax in Perl 6 regexes (e.g. "\1" "\_" "-" "!"). It
    is more accurate to say that all unescaped non-identifier glyphs are
    *potential* metasyntax, and reserved for future use. If you use such a
    sequence, a helpful compile-time error is issued indicating that you
    either need to quote the sequence or define a new operator to recognize
    it.
    The semicolon character is specifically reserved as a non-meaningful
    metacharacter; if an unquoted semicolon is seen, the compiler will
    complain that the regex is missing its terminator.
Modifiers
    *   The extended syntax ("/x") is no longer required...it's the default.
        (In fact, it's pretty much mandatory--the only way to get back to
        the old syntax is with the ":Perl5"/":P5" modifier.)
    *   There are no "/s" or "/m" modifiers (changes to the meta-characters
        replace them - see below).
    *   There is no "/e" evaluation modifier on substitutions; instead use:
             s/pattern/{ doit() }/
        or:
             s[pattern] = doit()
        Instead of "/ee" say:
             s/pattern/{ EVAL doit() }/
             s[pattern] = doit().EVAL
    *   Modifiers are now placed as adverbs at the *start* of a
        match/substitution:
             m:g:i/\s* (\w*) \s* ,?/;
        Every modifier must start with its own colon. The delimiter must be
        separated from the final modifier by whitespace if it would
        otherwise be taken as an argument to the preceding modifier (which
        is true if and only if the next character is a left parenthesis.)
    *   The single-character modifiers also have longer versions:
                 :i        :ignorecase
                 :m        :ignoremark
                 :g        :global
                 :r        :ratchet
    *   The ":i" (or ":ignorecase") modifier causes case distinctions to be
        ignored in its lexical scope, but not in its dynamic scope. That is,
        subrules always use their own case settings. The amount of case
        folding depends on the current context. In byte and codepoint mode,
        level 1 case folding is required (as defined in TR18 section 2.4).
        In grapheme mode level 2 is required.
        The ":ii" (or ":samecase") variant may be used on a substitution to
        change the substituted string to the same case pattern as the
        matched string. It implies the same pattern semantics as ":i" above,
        so it is not necessary to put both ":i" and ":ii".
        If the pattern is matched without the ":sigspace" modifier, case
        info is carried across on a character by character basis. If the
        right string is longer than the left one, the case of the final
        character is replicated. Titlecase is carried across if possible
        regardless of whether the resulting letter is at the beginning of a
        word or not; if there is no titlecase character available, the
        corresponding uppercase character is used. (This policy can be
        modified within a lexical scope by a language-dependent Unicode
        declaration to substitute titlecase according to the orthographic
        rules of the specified language.) Characters that carry no case
        information leave their corresponding replacement character
        unchanged.
        If the pattern is matched with ":sigspace", then a slightly smarter
        algorithm is used which attempts to determine if there is a uniform
        capitalization policy over each matched word, and applies the same
        policy to each replacement word. If there doesn't seem to be a
        uniform policy on the left, the policy for each word is carried over
        word by word, with the last pattern word replicated if necessary. If
        a word does not appear to have a recognizable policy, the
        replacement word is translated character for character as in the
        non-sigspace case. Recognized policies include:
            lc()
            uc()
            tc()
            tclc()
        In any case, only the officially matched string part of the pattern
        match counts, so any sort of lookahead or contextual matching is not
        included in the analysis.
    *   The ":m" (or ":ignoremark") modifier scopes exactly like
        ":ignorecase" except that it ignores marks (accents and such)
        instead of case. It is equivalent to taking each grapheme (in both
        target and pattern), converting both to NFD (maximally decomposed)
        and then comparing the two base characters (Unicode non-mark
        characters) while ignoring any trailing mark characters. The mark
        characters are ignored only for the purpose of determining the truth
        of the assertion; the actual text matched includes all ignored
        characters, including any that follow the final base character.
        The ":mm" (or ":samemark") variant may be used on a substitution to
        change the substituted string to the same mark/accent pattern as the
        matched string. It implies the same pattern semantics as ":m" above,
        so it is not necessary to put both ":m" and ":mm".
        Mark info is carried across on a character by character basis. If
        the right string is longer than the left one, the remaining
        characters are substituted without any modification. (Note that
        NFD/NFC distinctions are usually immaterial, since Perl encapsulates
        that in grapheme mode.) Under ":sigspace" the preceding rules are
        applied word by word.
    *   The ":c" (or ":continue") modifier causes the pattern to continue
        scanning from the specified position (defaulting to "($/ ?? $/.to !!
        0)"):
             m:c($p)/ pattern /     # start scanning at position $p
        Note that this does not automatically anchor the pattern to the
        starting location. (Use ":p" for that.) The pattern you supply to
        "split" has an implicit ":c" modifier.
    *   The ":p" (or ":pos") modifier causes the pattern to try to match
        only at the specified string position:
             m:pos($p)/ pattern /  # match at position $p
        If the argument is omitted, it defaults to "($/ ?? $/.to !! 0)".
        (Unlike in Perl 5, the string itself has no clue where its last
        match ended.) All subrule matches are implicitly passed their
        starting position. Likewise, the pattern you supply to a Perl
        macro's "is parsed" trait has an implicit ":p" modifier.
        Note that
             m:c($p)/pattern/
        is roughly equivalent to
             m:p($p)/.*? <( pattern )> /
        All of ":g", ":ov", ":nth", and ":x" are incompatible with ":p" and
        will fail, recommending use of ":c" instead. The ":ex" modifier is
        allowed but will produce only matches at that position.
    *   The new ":s" (":sigspace") modifier causes certain whitespace
        sequences to be considered "significant"; they are replaced by a
        whitespace matching rule, "<.ws>". Only whitespace sequences
        immediately following a matching construct (atom, quantified atom,
        or assertion) are eligible. Initial whitespace is ignored at the
        front of any regex, to make it easy to write rules that can
        participate in longest-token-matching alternations. Trailing space
        inside the regex delimiters is significant.
        That is,
             m:s/ next cmd '='   <condition>/
        is the same as:
             m/ next <.ws> cmd <.ws> '=' <.ws> <condition>/
        which is effectively the same as:
             m/ next \s+ cmd \s* '=' \s* <condition>/
        But in the case of
             m:s{(a|\*) (b|\+)}
        or equivalently,
             m { (a|\*) <.ws> (b|\+) }
        "<.ws>" can't decide what to do until it sees the data. It still
        does the right thing. If not, define your own "ws" and ":sigspace"
        will use that.
        Whitespace is ignored not just at the front of any rule that might
        participate in longest-token matching, but in the front of any
        alternative within an explicit alternation as well, for the same
        reason. If you want to match sigspace before a set of alternatives,
        place your whitespace outside of the brackets containing the
        alternation.
        When you write
            rule TOP { ^ <stuff> $ }
        this is the same as
            token TOP { ^ <.ws> <stuff> <.ws> $ <.ws> }
        but note that the final "<.ws>" always matches the null string,
        since "$" asserts end of string. Also, if your "TOP" rule does not
        anchor with "^", it might not match initial whitespace.
        Specifically, the following constructs turn following whitespace
        into sigspace:
            any atom or quantified atom
            $foo @bar
            'a' "$b"
            ^ $ ^^ $$
            (...) [...] <...> as a whole atoms
            (...)* [...]* <...>* as quantified atoms
            <( and )>
            « and » (but don't use « that way!)
        and these do not:
            opening ( or [
            | or ||
            & or &&
            ** % or %%
            :foo declarations, including :my and :sigspace itself
            {...}
        When we say sigspace can follow either an atom or a quantified atom,
        we mean that it can come between an atom and its quantifier:
            ms/ <atom> * /      # means / [<atom><.ws>]* /
        (If each atom matches whitespace, then it doesn't need to match
        after the quantifier.)
        In general you don't need to use ":sigspace" within grammars because
        the parser rules automatically handle whitespace policy for you. In
        this context, whitespace often includes comments, depending on how
        the grammar chooses to define its whitespace rule. Although the
        default "<.ws>" subrule recognizes no comment construct, any grammar
        is free to override the rule. The "<.ws>" rule is not intended to
        mean the same thing everywhere.
        It's also possible to pass an argument to ":sigspace" specifying a
        completely different subrule to apply. This can be any rule, it
        doesn't have to match whitespace. When discussing this modifier, it
        is important to distinguish the significant whitespace in the
        pattern from the "whitespace" being matched, so we'll call the
        pattern's whitespace *sigspace*, and generally reserve *whitespace*
        to indicate whatever "<.ws>" matches in the current grammar. The
        correspondence between sigspace and whitespace is primarily
        metaphorical, which is why the correspondence is both useful and
        (potentially) confusing.
        The ":ss" (or ":samespace") variant may be used on substitutions to
        do smart space mapping in addition to smart space matching. (That
        is, ":ss" implies ":s".) For each sigspace-induced call to "<ws>" on
        the left, the matched whitespace is copied over to the corresponding
        slot on the right, as represented by a single whitespace character
        in the replacement string wherever space replacement is desired. If
        there are more whitespace slots on the right than the left, those
        righthand characters remain themselves. If there are not enough
        whitespace slots on the right to map all the available whitespace
        slots from the match, the algorithm tries to minimize information
        loss by randomly splicing "common" whitespace characters out of the
        list of whitespace. From least valuable to most, the pecking order
            spaces
            tabs
            all other horizontal whitespace, including Unicode
            newlines (including crlf as a unit)
            all other vertical whitespace, including Unicode
        The primary intent of these rules is to minimize format disruption
        when substitution happens across line boundaries and such. There is,
        of course, no guarantee that the result will be exactly what a human
        would do.
        The ":s" modifier is considered sufficiently important that match
        variants are defined for them:
            ms/match some words/                        # same as m:sigspace
            ss/match some words/replace those words/    # same as s:samespace
        Note that "ss///" is defined in terms of ":ss", so:
            $_ = "a b\nc\td";
            ss/b c d/x y z/;
        ends up with a value of ""a x\ny\tz"".
    *   New modifiers specify Unicode level:
             m:bytes  / .**2 /       # match two bytes
             m:codes  / .**2 /       # match two codepoints
             m:graphs / .**2 /       # match two language-independent graphemes
             m:chars  / .**2 /       # match two characters at current max level
        There are corresponding pragmas to default to these levels. Note
        that the ":chars" modifier is always redundant because dot always
        matches characters at the highest level allowed in scope. This
        highest level may be identical to one of the other three levels, or
        it may be more specific than ":graphs" when a particular language's
        character rules are in use. Note that you may not specify
        language-dependent character processing without specifying *which*
        language you're depending on. [Conjecture: the ":chars" modifier
        could take an argument specifying which language's rules to use for
        this match.]
    *   The new ":Perl5"/":P5" modifier allows Perl 5 regex syntax to be
        used instead. (It does not go so far as to allow you to put your
        modifiers at the end.) For instance,
             m:P5/(?mi)^(?:[a-z]|\d){1,2}(?=\s)/
        is equivalent to the Perl 6 syntax:
            m/ :i ^^ [ <[a..z]> || \d ] ** 1..2 <?before \s> /
    *   Any integer modifier specifies a count. What kind of count is
        determined by the character that follows.
    *   If followed by an "x", it means repetition. Use :x(4) for the
        general form. So
             s:4x [ (<.ident>) '=' (\N+) $$] = "$0 => $1";
             s:x(4) [ (<.ident>) '=' (\N+) $$] = "$0 => $1";
        which is almost the same as:
             s:c[ (<.ident>) '=' (\N+) $$] = "$0 => $1" for 1..4;
        except that the string is unchanged unless all four matches are
        found. However, ranges are allowed, so you can say ":x(1..4)" to
        change anywhere from one to four matches.
    *   If the number is followed by an "st", "nd", "rd", or "th", it means
        find the *N*th occurrence. Use :nth(3) for the general form. So
             s:3rd/(\d+)/@data[$0]/;
             s:nth(3)/(\d+)/@data[$0]/;
        which is the same as:
             m/(\d+)/ && m:c/(\d+)/ && s:c/(\d+)/@data[$0]/;
        The argument to ":nth" is allowed to be a list of integers, but such
        a list should be monotonically increasing. (Values which are less
        than or equal to any previous value will be ignored.) So:
            :nth(2,4,6...*)    # return only even matches
            :nth(1,1,*+*...*)  # match only at 1,2,3,5,8,13...
        This option is no longer required to support smartmatching. You can
        grep a list of integers if you really need that capability:
            :nth(grep *.oracle, 1..*)
        If both ":nth" and ":x" are present, the matching routine looks for
        submatches that match with ":nth". If the number of post-nth matches
        is compatible with the constraint in ":x", the whole match succeeds
        with the highest possible number of submatches. The combination of
        ":nth" and ":x" typically only makes sense if ":nth" is not a single
        scalar.
    *   With the new ":ov" (":overlap") modifier, the current regex will
        match at all possible character positions (including overlapping)
        and return all matches in list context, or a disjunction of matches
        in item context. The first match at any position is returned. The
        matches are guaranteed to be returned in left-to-right order with
        respect to the starting positions.
             $str = "abracadabra";
             if $str ~~ m:overlap/ a (.*) a / {
                 @substrings = slice @();    # bracadabr cadabr dabr br
             }
    *   With the new ":ex" (":exhaustive") modifier, the current regex will
        match every possible way (including overlapping) and return a list
        of all matches.
        The matches are guaranteed to be returned in left-to-right order
        with respect to the starting positions. The order within each
        starting position is not guaranteed and may depend on the nature of
        both the pattern and the matching engine. (Conjecture: or we could
        enforce backtracking engine semantics. Or we could guarantee no
        order at all unless the pattern starts with "::" or some such to
        suppress DFAish solutions.)
             if $str ~~ m:exhaustive/ a (.*?) a / {
                 say "@()";    # br brac bracad bracadabr c cad cadabr d dabr br
        Note that the "~~" above can return as soon as the first match is
        found, and the rest of the matches may be performed lazily by "@()".
    *   The new ":rw" modifier causes this regex to *claim* the current
        string for modification rather than assuming copy-on-write
        semantics. All the captures in $/ become lvalues into the string,
        such that if you modify, say, $1, the original string is modified in
        that location, and the positions of all the other fields modified
        accordingly (whatever that means). In the absence of this modifier
        (especially if it isn't implemented yet, or is never implemented),
        all pieces of $/ are considered copy-on-write, if not read-only.
        [Conjecture: this should really associate a pattern with a string
        variable, not a (presumably immutable) string value.]
    *   The new ":r" or ":ratchet" modifier causes this regex to not
        backtrack by default. (Generally you do not use this modifier
        directly, since it's implied by "token" and "rule" declarations.)
        The effect of this modifier is to imply a ":" after every atom,
        including but not limited to "*", "+", and "?" quantifiers, as well
        as alternations. Explicit backtracking modifiers on quantified
        atoms, such as "**", will override this. (Note: for portions of
        patterns subject to longest-token analysis, a ":" is ignored in any
        case, since there will be no backtracking necessary.)
    *   The ":i", ":m", ":r", ":s", ":dba", ":Perl5", and Unicode-level
        modifiers can be placed inside the regex (and are lexically scoped):
             m/:s alignment '=' [:i left|right|cent[er|re]] /
        As with modifiers outside, only parentheses are recognized as valid
        brackets for args to the adverb. In particular:
            m/:foo[xxx]/        Parses as :foo [xxx]
            m/:foo{xxx}/        Parses as :foo {xxx}
            m/:foo<xxx>/        Parses as :foo <xxx>
    *   User-defined modifiers will be possible:
                 m:fuzzy/pattern/;
    *   User-defined modifiers can also take arguments, but only in
        parentheses:
                 m:fuzzy('bare')/pattern/;
    *   To use parens for your delimiters you have to separate:
                 m:fuzzy (pattern);
        or you'll end up with:
                 m:fuzzy(fuzzyargs); pattern ;
    *   Any grammar regex is really just a kind of method, and you may
        declare variables in such a routine using a colon followed by any
        scope declarator parsed by the Perl 6 grammar, including "my",
        "our", "state", and "constant". (As quasi declarators, "temp" and
        "let" are also recognized.) A single statement (up through a
        terminating semicolon or line-final closing brace) is parsed as
        normal Perl 6 code:
            token prove-nondeterministic-parsing {
                :my $threshold = rand;
                'maybe' \s+ <it($threshold)>
        Such declarations do not terminate longest-token-matching, so an
        otherwise useless declaration may be used as a peg to hang side
        effects on without changing how the subsequent pattern matches:
            rule breaker {
                :state $ = say "got here at least once";
  Allowed modifiers
    Some modifiers are allowed in all possible places where modifiers can
    occur, but not all of them.
    In general, a modifier that affects the compilation of a regex (like
    ":i") must be known at compile time. A modifier that affects only the
    calling behaviour, and not the regex itself (eg. ":pos", ":overlap",
    :x(4)) may only appear on constructs that involve a call (like "m//" and
    "s///"), and not on "rx//". Finally overlapping is disallowed on
    substitutions, while adverbs that affect modifications (eg. ":samecase")
    are only allowed on substitutions.
    These principle result in the following rules:
    *   The ":ignorecase", ":ignoremark", ":sigspace", ":ratchet" and
        ":Perl5" modifiers and their short forms are allowed everywhere:
        inside a regex, and on "m//", "rx//" and "s///" constructs. An
        implementation may require that their value is known at compile
        time, and give a compile-time error message if that is not the case.
            rx:i/ hello /           # OK
            rx:i(1) /hello/         # OK
            my $i = 1;
            rx:i($i) /hello/        # may error out at compile time
    *   The ":samecase", ":samespace" and ":samemark" modifiers (and their
        short forms) are only allowed on substitutions ("s///" and "s[] =
        ...").
    *   The ":overlap" and ":exhaustive" modifiers (and their short forms)
        are only allowed on matches (ie "m//"), not on substitutions or
        regex quotes.
    *   The ":pos", ":continue", ":x" and ":nth" modifiers and their aliases
        are only allowed on constructs that involve immediate calls, eg.
        "m//" and "s///" (but not on "rx//").
    *   The ":dba" adverb is only allowed inside a regex.
Changed metacharacters
    *   A dot "." now matches *any* character including newline. (The "/s"
        modifier is gone.)
    *   "^" and "$" now always match the start/end of a string, like the old
        "\A" and "\z". (The "/m" modifier is gone.) On the right side of an
        embedded "~~" or "!~~" operator they always match the start/end of
        the indicated submatch because that submatch is logically being
        treated as a separate string.
    *   A "$" no longer matches an optional preceding "\n" so it's necessary
        to say "\n?$" if that's what you mean.
    *   "\n" now matches a logical (platform independent) newline, not just
        "\x0a". See TR18 section 1.6 for a list of logical newlines.
    *   The "\A", "\Z", and "\z" metacharacters are gone.
New metacharacters
    *   Because "/x" is default:
        *   An unquoted "#" now always introduces a comment. If followed by
            a backtick and an opening bracket character, it introduces an
            embedded comment that terminates with the closing bracket.
            Otherwise the comment terminates at the newline.
        *   Whitespace is now always metasyntactic, i.e. used only for
            layout and not matched literally (but see the ":sigspace"
            modifier described above).
    *   "^^" and $$ match line beginnings and endings. (The "/m" modifier is
        gone.) They are both zero-width assertions. $$ matches before any
        "\n" (logical newline), and also at the end of the string if the
        final character was *not* a "\n". "^^" always matches the beginning
        of the string and after any "\n" that is not the final character in
        the string.
    *   "." matches an *anything*, while "\N" matches an *anything except
        what "\n" matches*. (The "/s" modifier is gone.) In particular, "\N"
        matches neither carriage return nor line feed.
    *   The new "&" metacharacter separates conjunctive terms. The patterns
        on either side must match with the same beginning and end point.
        Note: if you don't want your two terms to end at the same point,
        then you really want to use a lookahead instead.
        As with the disjunctions "|" and "||", conjunctions come in both "&"
        and "&&" forms. The "&" form is considered declarative rather than
        procedural; it allows the compiler and/or the run-time system to
        decide which parts to evaluate first, and it is erroneous to assume
        either order happens consistently. The "&&" form guarantees
        left-to-right order, and backtracking makes the right argument vary
        faster than the left. In other words, "&&" and "||" establish
        sequence points. The left side may be backtracked into when
        backtracking is allowed into the construct as a whole.
        The "&" operator is list associative like "|", but has slightly
        tighter precedence. Likewise "&&" has slightly tighter precedence
        than "||". As with the normal junctional and short-circuit
        operators, "&" and "|" are both tighter than "&&" and "||".
    *   The "~~" and "!~~" operators cause a submatch to be performed on
        whatever was matched by the variable or atom on the left. String
        anchors consider that submatch to be the entire string. So, for
        instance, you can ask to match any identifier that does not contain
        the word "moose":
            <ident> !~~ 'moose'
        In contrast
            <ident> !~~ ^ 'moose' $
        would allow any identifier (including any identifier containing
        "moose" as a substring) as long as the identifier as a whole is not
        equal to "moose". (Note the anchors, which attach the submatch to
        the beginning and end of the identifier as if that were the entire
        match.) When used as part of a longer match, for clarity it might be
        good to use extra brackets:
            [ <ident> !~~ ^ 'moose' $ ]
        The precedence of "~~" and "!~~" fits in between the junctional and
        sequential versions of the logical operators just as it does in
        normal Perl expressions (see S03). Hence
            <ident> !~~ 'moose' | 'squirrel'
        parses as
            <ident> !~~ [ 'moose' | 'squirrel' ]
        while
            <ident> !~~ 'moose' || 'squirrel'
            [ <ident> !~~ 'moose' ] || 'squirrel'
    *   The "~" operator is a helper for matching nested subrules with a
        specific terminator as the goal. It is designed to be placed between
        an opening and closing bracket, like so:
            '(' ~ ')' <expression>
        However, it mostly ignores the left argument, and operates on the
        next two atoms (which may be quantified). Its operation on those
        next two atoms is to "twiddle" them so that they are actually
        matched in reverse order. Hence the expression above, at first
        blush, is merely shorthand for:
            '(' <expression> ')'
        But beyond that, when it rewrites the atoms it also inserts the
        apparatus that will set up the inner expression to recognize the
        terminator, and to produce an appropriate error message if the inner
        expression does not terminate on the required closing atom. So it
        really does pay attention to the left bracket as well, and it
        actually rewrites our example to something more like:
            $<OPEN> = '(' <SETGOAL: ')'> <expression> [ $GOAL || <FAILGOAL> ]
        Note that you can use this construct to set up expectations for a
        closing construct even when there's no opening bracket:
            <?> ~ ')' \d+
        Here <?> returns true on the first null string.
        By default the error message uses the name of the current rule as an
        indicator of the abstract goal of the parser at that point. However,
        often this is not terribly informative, especially when rules are
        named according to an internal scheme that will not make sense to
        the user. The ":dba("doing business as")" adverb may be used to set
        up a more informative name for what the following code is trying to
        parse:
            token postfix:sym<[ ]> {
                :dba('array subscript')
                '[' ~ ']' <expression>
        Then instead of getting a message like:
            Unable to parse expression in postfix:sym<[ ]>; couldn't find final ']'
        you'll get a message like:
            Unable to parse expression in array subscript; couldn't find final ']'
        (The ":dba" adverb may also be used to give names to alternations
        and alternatives, which helps the lexer give better error messages.)
Bracket rationalization
    *   "(...)" still delimits a capturing group. However the ordering of
        these groups is hierarchical rather than linear. See "Nested
        subpattern captures".
    *   "[...]" is no longer a character class. It now delimits a
        non-capturing group.
        A character class is now specified using "<[...]>". See also
        "Extensible metasyntax ("<...>")".
    *   "{...}" is no longer a repetition quantifier. It now delimits an
        embedded closure. It is always considered procedural rather than
        declarative; it establishes a sequence point between what comes
        before and what comes after. (To avoid this use the "<?{...}>"
        assertion syntax instead.) A closure within a regex establishes its
        own lexical scope.
    *   You can call Perl code as part of a regex match by using a closure.
        Embedded code does not usually affect the match--it is only used for
        side-effects:
             / (\S+) { print "string not blank\n"; $text = $0; }
                \s+  { print "but does contain whitespace\n" }
             /
        An explicit reduction using the "make" function generates the
        *abstract syntax tree* object (*abstract object* or *ast* for short)
        for this match:
                / (\d) { make $0.sqrt } Remainder /;
        This has the effect of capturing the square root of the numified
        string, instead of the string. The "Remainder" part is matched and
        returned as part of the "Match" object but is not returned as part
        of the abstract object. Since the abstract object usually represents
        the top node of an abstract syntax tree, the abstract object may be
        extracted from the "Match" object by use of the ".made" method.
        A second call to "make" overrides any previous call to "make".
        "make" is also available as a method on each match object.
        Within a closure, the instantaneous position within the search is
        denoted by the "$¢.pos" method. As with all string positions, you
        must not treat it as a number unless you are very careful about
        which units you are dealing with.
        The "Cursor" object can also return the original item that we are
        matching against; this is available from the ".orig" method.
        The closure is also guaranteed to start with a $/ "Match" object
        representing the match so far. However, if the closure does its own
        internal matching, its $/ variable will be rebound to the result of
        *that* match until the end of the embedded closure. (The match will
        actually continue with the current value of the $¢ object after the
        closure. $/ and $¢ just start out the same in your closure.)
    *   It can affect the match if it calls "fail":
             / (\d+) { $0 < 256 or fail } /
        Since closures establish a sequence point, they are guaranteed to be
        called at the canonical time even if the optimizer could prove that
        something after them can't match. (Anything before is fair game,
        however. In particular, a closure often serves as the terminator of
        a longest-token pattern.)
    *   The general repetition specifier is now "**" for greedy matching,
        with a corresponding "**?" for frugal matching. (All such quantifier
        modifiers now go directly after the "**".) Space is allowed on
        either side of the complete quantifier, but only the space before
        the "**" will be considered significant under ":sigspace" and match
        between repetitions. (Sigspace after the entire construct matches
        once after the all repetitions are found.)
        The next token constrains how many times the pattern on the left
        must match.
        If the next thing is an integer, then it is parsed as either as an
        exact count or a range:
            . ** 42                  # match exactly 42 times
            <item> ** 3..*           # match 3 or more times
        This form is considered declarational.
        If you supply a closure, it should return either an "Int" or a
        "Range" object.
            'x' ** {$m}              # exact count returned from closure
            <foo> ** {$m..$n}        # range returned from closure
            / value was (\d **? {1..6}) with ([ <alpha>\w* ]**{$m..$n}) /
        It is illegal to return a list, so this easy mistake fails:
            / [foo] ** {1,3} /
        The closure form is always considered procedural, so the item it is
        modifying is never considered part of the longest token.
        For backwards compatibility with previous versions of Perl 6, if the
        token following ** is not a closure or literal integer, it is
        interpreted as +% with a warning:
           / x ** y /                # same as / x+ % y /
           / x ** $y /               # same as / x [$y x]* /
        No check is made to see if $y contains an integer or range value.
        This compatibility feature is not guaranteed to exist forever.
    *   Negative range values are allowed, but only when modifying a
        reversible pattern (such as "after" could match). For example, to
        search the surrounding 200 characters as defined by 'dot', you could
            / . ** -100..100 <element> /
        Similarly, you can back up 50 characters with:
            / . ** -50 <element> /
        [Conjecture: A negative quantifier forces the construct to be
        considered procedural rather than declarational.]
    *   Any quantified atom may be modified by an additional constraint that
        specifies the separator to look for between repeats of the left
        side. This is indicated by use of a "%" between the quantifier and
        the separator. The initial item is iterated only as long as the
        separator is seen between items:
            <alt>+ % '|'            # repetition controlled by presence of character
            <addend>+ % <addop>     # repetition controlled by presence of subrule
            <item>+ % [ \!?'==' ]   # repetition controlled by presence of operator
            <file>+%\h+             # repetition controlled by presence of whitespace
        Any quantifier may be so modified:
            <a>* % ','              # 0 or more comma-separated elements
            <a>+ % ','              # 1 or more
            <a>? % ','              # 0 or 1 (but ',' never used!?!)
            <a> ** 2..* % ','       # 2 or more
        The "%" modifier may only be used on a quantifier; any attempt to
        use it on a bare term will result in a parse error (to minimize
        possible confusion with any hash notations we choose to support in
        Perl 6 regexes).
        A successful match of a "%" construct generally ends "in the middle"
        at the "%", that is, after the initial item but before the next
        separator. Therefore
            / <ident>+ % ',' /
        can match
            foo
            foo,bar
            foo,bar,baz
        but never
            foo,
            foo,bar,
        The only time such a match doesn't end in the middle is if the left
        side can match 0 times (and does so), in which case the whole
        construct matches the null string.
            '' ~~ / <ident>* % ',' /  # matches because of the *
        If you wish to allow the match to end after either side, use "%%"
        instead. Therefore
            / <ident>+ %% ',' /
        can match any of
            foo,bar,baz,
        If you wish to quantify each match on the left individually, you
        must place it in brackets:
            [<a>*]+ % ','
        It is legal for the separator to be zero-width as long as the
        pattern on the left progresses on each iteration:
            .+ % <?same>   # match sequence of identical characters
        The separator never matches independently of the next item; if the
        separator matches but the next item fails, it backtracks all the way
        back through the separator. Likewise, this matching of the separator
        does not count as "progress" under ":ratchet" semantics unless the
        next item succeeds.
        When significant space is used under ":sigspace", each matching
        element enables the immediately following whitespace to be
        considered significant. Space after the "%" does nothing. If you
        write:
            ms/ <element> +  %  ',' /
              #1        #2 #3 #4  #5
        it ignores whitespace #1 and #4, and rewrites the rest to:
            / [ <element> <.ws> ]+ % [ ',' <.ws> ] <.ws> /
                            #2               #5      #3
        Since #3 is redundant with #2 (because "+" requires an element), it
        suffices to supply either #2 or #3:
            ms/ <element>+ % ',' /    # ws after comma and at end
            ms/ <element> +% ',' /    # ws after comma and any element
        So the first
        is like
            / <element>[','<.ws><element>]*<.ws> /
        while the second
            / <element><.ws>[','<.ws><element><.ws>]* /
            ms/ <element>+% ','/
        excludes all significant whitespace like this:
            / <element>[','<element>]* /
        Note that with a "*" instead of a "+", space #3 would not be
        redundant with #2, since if 0 elements are matched, the space
        associated with it (#2) is not matched. In that case it makes sense
        to put space on both sides of the "*":
            ms/ <element> * % ',' /
    *   "<...>" are now extensible metasyntax delimiters or *assertions*
        (i.e. they replace Perl 5's crufty "(?...)" syntax).
Variable (non-)interpolation
    *   In Perl 6 regexes, variables don't interpolate.
    *   Instead they're passed *raw* to the regex engine, which can then
        decide how to handle them (more on that below).
    *   The default way in which the engine handles a string scalar is to
        match it as a "..." literal (i.e. it does not treat the interpolated
        string as a subpattern). In other words, a Perl 6:
             / $var /
        is like a Perl 5:
             / \Q$var\E /
        To interpolate a "Regex" object, use "<$var>" instead.
        If $var is undefined, a warning is issued and the match fails.
        When matching against a Stringy type that is not Str, the variable
        must be interpretable as a value of that Stringy type (or a related
        type that can be coerced to that type). For example, when regex
        matching a Buf type, the variable will be matched under the Buf
        type's semantics, not Str semantics.
        [Conjecture: when we allow matching against non-string types, doing
        a type match on the current node will require the syntax of an
        embedded signature, not just a bare variable, so there is no need to
        account for a variable containing a type object, which is by
        definition undefined, and hence fails to match by the above rule.]
        However, a variable used as the left side of an alias or submatch
        operator is not used for matching.
            $x = <.ident>
            $0 ~~ <.ident>
        If you do want to match $0 again and then use that as the submatch,
        you can force the match using double quotes:
            "$0" ~~ <.ident>
        On the other hand, it is non-sensical to alias to something that is
        not a variable:
            "$0" = <.ident>     # ERROR
            $0 = <.ident>       # okay
            $x = <.ident>       # okay, temporary capture
            $<x> = <.ident>     # okay, persistent capture
            <x=.ident>          # same thing
        Variables declared in capture aliases are lexically scoped to the
        rest of the regex. You should not confuse this use of "=" with
        either ordinary assignment or ordinary binding. You should read the
        "=" more like the pseudoassignment of a declarator than like normal
        assignment. It's more like the ordinary ":=" operator, since at the
        level regexes work, strings are immutable, so captures are really
        just precomputed substr values. Nevertheless, when you eventually
        use the values independently, the substr may be copied, and then
        it's more like it was an assignment originally.
        Capture variables of the form "$<ident>" may persist beyond the
        lexical scope; if the match succeeds they are remembered in the
        "Match" object's hash, with a key corresponding to the variable
        name's identifier. Likewise bound numeric variables persist as $0,
        You may capture to existing lexical variables; such variables may
        already be visible from an outer scope, or may be declared within
        the regex via a ":my" declaration.
            my $x; / $x = [...] /            # capture to outer lexical $x
            / :my $x; $x = [...] /           # capture to our own lexical $x
    *   An interpolated array:
             / @cmds /
        is matched as if it were an alternation of its literal elements.
        Ordinarily it matches using junctive semantics:
             / [ $(@cmds[0]) | $(@cmds[1]) | $(@cmds[2]) | ... ] /
        However, if it is a direct member of a "||" list, it uses sequential
        matching semantics, even it's the only member of the list.
        Conveniently, you can put "||" before the first member of an
        alternation, hence
             / || @cmds /
             / [ $(@cmds[0]) || $(@cmds[1]) || $(@cmds[2]) || ... ] /
        Or course, you can also
             / | @cmds /
        to be clear that you mean junctive semantics.
        Note the usage of $(...) to prevent the subscripts from being parsed
        as regex syntax rather than an actual subscript.
        Since $x is interpolated as if you'd said "$x", if $x contains a
        list, it is stringified first. To get alternation you must use the
        @$x or "@($x)" form to indicate that you're intending the scalar
        variable to be treated as a list.
        An interpolated array using junctive semantics is declarative
        (participates in external longest token matching) only if it's known
        to be constant at the time the regex is compiled.
        As with a scalar variable, each element is matched as a literal. All
        such values pay attention to the current ":ignorecase" and
        ":ignoremark" settings.
        When you get tired of writing:
            token sigil { '$' | '@' | '%' | '&' | '::' }
        you can write:
            token sigil { < $ @ % & :: > }
        as long as you're careful to put a space after the initial angle so
        that it won't be interpreted as a subrule. With the space it is
        parsed like angle quotes in ordinary Perl 6 and treated as a literal
        array value.
    *   Alternatively, if you predeclare a proto regex, you can write
        multiple regexes for the same category, differentiated only by the
        symbol they match. The symbol is specified as part of the "long
        name". It may also be matched within the rule using "<sym>", like
        this:
            proto token sigil {*}
            multi token sigil:sym<$>  { <sym> }
            multi token sigil:sym<@>  { <sym> }
            multi token sigil:sym<%>  { <sym> }
            multi token sigil:sym<&>  { <sym> }
            multi token sigil:sym<::> { <sym> }
        (The "multi" is optional and generally omitted with a grammar.)
        This can be viewed as a form of multiple dispatch, except that it's
        based on longest-token matching rather than signature matching. The
        advantage of writing it this way is that it's easy to add additional
        rules to the same category in a derived grammar. All of them will be
        matched in parallel when you try to match "/<sigil>/".
        If there are formal parameters on multi regex methods, matching
        still proceeds via longest-token rules first. If that results in a
        tie, a normal multiple dispatch is made using the arguments to the
        remaining variants, assuming they can be differentiated by type.
        The "proto" calls into the subdispatcher when it sees a "*" that
        cannot be a quantifier and is the only thing in its block. Therefore
        you can put items before and after the subdispatch by putting the
        "*" into curlies:
            proto token foo { <prestuff> {*} <poststuff> }
        This works only in a proto. See S06 for a discussion of the
        semantics of "{*}". (Unlike a proto sub, a proto regex automatically
        remembers the return values from "{*}" because they are carried
        along with the match cursor.)
    *   The use of a hash variable in patterns is reserved.
    *   Variable matches are considered declarative if and only if the
        variable is known to represent a constant, Otherwise they are
        procedural. Note that role parameters (if readonly) are considered
        constant declarations for this purpose despite the absence of an
        explicit "constant" declarator, since roles themselves are
        immutable, and will presumably be replacing the parameter with a
        constant value when composed (if the value passed is a constant).
        Macros instantiated with constants would also make those constants
        eligible for declarative treatment.
Extensible metasyntax ("<...>")
    Both "<" and ">" are metacharacters, and are usually (but not always)
    used in matched pairs. (Some combinations of metacharacters function as
    standalone tokens, and these may include angles. These are described
    below.) Most assertions are considered declarative; procedural
    assertions will be marked as exceptions.
    For matched pairs, the first character after "<" determines the nature
    of the assertion:
    *   If the first character is whitespace, the angles are treated as an
        ordinary "quote words" array literal.
            < adam & eve >   # equivalent to [ 'adam' | '&' | 'eve' ]
        Note that the space before the ending > is optional and therefore <
        adam & eve> would be acceptable.
    *   A leading alphabetic character means it's a capturing grammatical
        assertion (i.e. a subrule or a named character class - see below):
             / <sign>? <mantissa> <exponent>? /
        The first character after the identifier determines the treatment of
        the rest of the text before the closing angle. The underlying
        semantics is that of a function or method call, so if the first
        character is a left parenthesis, it really is a call to either a
        method or function:
            <foo('bar')>
        If the first character after the identifier is an "=", then the
        identifier is taken as an alias for what follows. In particular,
            <foo=bar>
        is just shorthand for
            $<foo> = <bar>
        Note that this aliasing does not modify the original "<bar>"
        capture. To rename an inherited method capture without using the
        original name, use the dot form described below on the capture you
        wish to suppress. That is,
            <foo=.bar>
        desugars to:
            $<foo> = <.bar>
        Likewise, to rename a lexically scoped regex explicitly, use the "&"
        form described below. That is,
            <foo=&bar>
            $<foo> = <&bar>
        Multiple aliases are allowed, so
            <foo=pub=bar>
        is short for
            $<foo> = $<pub> = <bar>
        Similarly, you can alias other assertion, e.g.:
            <foo=[abc]>    # a character class, same as $<foo>=<[abc]>
            <foo=:Letter>  # a Unicode property, same as $<foo>=:Letter>
            <foo=:!Letter> # a negated Unicode property lookup
        If the first character after the identifier is whitespace, the
        subsequent text (following any whitespace) is passed as a regex, so:
            <foo bar>
        is more or less equivalent to
            <foo(/bar/)>
        To pass a regex with leading whitespace you must use the
        parenthesized form.
        If the first character is a colon followed by whitespace, the rest
        of the text is taken as a list of arguments to the method, just as
        in ordinary Perl syntax. So these mean the same thing:
            <foo('foo', $bar, 42)>
            <foo: 'foo', $bar, 42>
        No other characters are allowed after the initial identifier.
        Subrule matches are considered declarative to the extent that the
        front of the subrule is itself considered declarative. If a subrule
        contains a sequence point, then so does the subrule match.
        Longest-token matching does not proceed past such a subrule, for
        instance.
        This form always gives preference to a lexically scoped regex
        declaration, dispatching directly to it as if it were function. If
        there is no such lexical regex (or lexical method) in scope, the
        call is dispatched to the current grammar, assuming there is one.
        That is, if there is a "my regex foo" visible from the current
        lexical scope, then
            <foo(1,2,3)>
        means the same as
            <foo=&foo(1,2,3)>
        However, if there is no such lexically scoped regex (and note that
        within a grammar, regexes are installed as methods which have no
        lexical alias by default), then the call is dispatched as a normal
        method on the current "Cursor" (which will fail if you're not
        currently within a grammar). So in that case:
        means the same as:
            <foo=.foo(1,2,3)>
        A call to "<foo>" will fail if there is neither any lexically scoped
        routine of that name it can call, nor any method of that name that
        be reached via method dispatch. (The decision of which dispatcher to
        use is made at compile time, not at run time; the method call is not
        a fallback mechanism.)
    *   A leading "." explicitly calls a method as a subrule; the fact that
        the initial character is not alphanumeric also causes the named
        assertion to not capture what it matches (see "Subrule captures".
        For example:
             / <ident>  <ws>  /      # $/<ident> and $/<ws> both captured
             / <.ident> <ws>  /      # only $/<ws> captured
             / <.ident> <.ws> /      # nothing captured
        The assertion is otherwise parsed identically to an assertion
        beginning with an identifier, provided the next thing after the dot
        is an identifier. As with the identifier form, any extra arguments
        pertaining to the matching engine are automatically supplied to the
        argument list via the implicit "Cursor" invocant. If there is no
        current class/grammar, or the current class is not derived from
        "Cursor", the call is likely to fail.
        If the dot is not followed by an identifier, it is parsed as a
        "dotty" postfix of some type, such as an indirect method call:
            <.$indirect(@args)>
        As with all regex matching, the current match state (some derivative
        of "Cursor") is passed as the first argument, which in this case is
        simply the method's invocant. The method is expected to return a
        lazy list of new match state objects, or "Nil" if the match fails
        entirely. Ratcheted routines will typically return a list containing
        only one match.
    *   Whereas a leading "." unambiguously calls a method, a leading "&"
        unambiguously calls a routine instead. Such a regex routine must be
        declared (or imported) with "my" or "our" scoping to make its name
        visible to the lexical scope, since by default a regex name is
        installed only into the current class's metaobject instance, just as
        with an ordinary method. The routine serves as a kind of private
        submethod, and is called without any consideration of inheritance.
        It must still take a "Cursor" as its first argument (which it can
        think of as an invocant if it likes), and must return the new match
        state as a cursor object. Hence,
             <&foo(1,2,3)>
        is sugar for something like:
             <.gather { take foo($¢,1,2,3) }>
        where $¢ represents the current incoming match state, and the
        routine must return "Nil" for failure, or a lazy list of one or more
        match states ("Cursor"-derived objects) for successful matches.
        As with the "." form, an explicit "&" suppresses capture.
        Note that all normal "Regex" objects are really such routines in
        disguise. When you say:
            rx/stuff/
        you're really declaring an anonymous method, something like:
            my $internal = anon regex :: ($¢: ) { stuff }
        and then passing that object off to someone else who will call it
        indirectly. In this case, the method is installed neither into a
        class nor into a lexical scope, but as long as the value stays live
        somehow, it can still be called indirectly (see below).
    *   A leading "$" indicates an indirect subrule call. The variable must
        contain either a "Regex" object (really an anonymous method--see
        above), or a string to be compiled as the regex. The string is never
        matched literally.
        If the compilation of the string form fails, the error message is
        converted to a warning and the assertion fails.
        The indirect subrule assertion is not captured. (No assertion with
        leading punctuation is captured by default.) You may always capture
        it explicitly, of course:
            / <name=$rx> /
        An indirect subrule is always considered procedural, and may not
        participate in longest-token matching.
    *   A leading "::" indicates a symbolic indirect subrule:
             / <::($somename)> /
        The variable must contain the name of a subrule. By the rules of
        single method dispatch this is first searched for in the current
        grammar and its ancestors. If this search fails an attempt is made
        to dispatch via MMD, in which case it can find subrules defined as
        multis rather than methods. This form is not captured by default. It
        is always considered procedural, not declarative.
    *   A leading "@" matches like a bare array except that each element is
        treated as a subrule (string or "Regex" object) rather than as a
        literal. That is, a string is forced to be compiled as a subrule
        instead of being matched literally. (There is no difference for a
        "Regex" object.)
        This assertion is not automatically captured.
    *   The use of a hash as an assertion is reserved.
    *   A leading "{" indicates code that produces a regex to be
        interpolated into the pattern at that point as a subrule:
             / (<.ident>)  <{ %cache{$0} //= get_body_for($0) }> /
        The closure is guaranteed to be run at the canonical time; it
        declares a sequence point, and is considered to be procedural.
    *   In any case of regex interpolation, if the value already happens to
        be a "Regex" object, it is not recompiled. If it is a string, the
        compiled form is cached with the string so that it is not recompiled
        next time you use it unless the string changes. (Any external
        lexical variable names must be rebound each time though.) Subrules
        may not be interpolated with unbalanced bracketing. An interpolated
        subrule keeps its own inner match results as a single item, so its
        parentheses never count toward the outer regexes groupings. (In
        other words, parenthesis numbering is always lexically scoped.)
    *   A leading "?{" or "!{" indicates a code assertion:
             / (\d**1..3) <?{ $0 < 256 }> /
             / (\d**1..3) <!{ $0 < 256 }> /
        Similar to:
             / (\d**1..3) { $0 < 256 or fail } /
             / (\d**1..3) { $0 < 256 and fail } /
        Unlike closures, code assertions are considered declarative; they
        are not guaranteed to be run at the canonical time if the optimizer
        can prove something later can't match. So you can sneak in a call to
        a non-canonical closure that way:
             token { foo .* <?{ do { say "Got here!" } or 1 }> .* bar }
        The "do" block is unlikely to run unless the string ends with
        ""bar"".
    *   A leading "[" indicates an enumerated character class. Ranges in
        enumerated character classes are indicated with "".."" rather than
        ""-"".
             / <[a..z_]>* /
        Whitespace is ignored within square brackets:
             / <[ a .. z _ ]>* /
        A reversed range is illegal. In directly compiled code it's a
        compile-time error to say
            / <[ z .. a ]> /  # Reversed range is not allowed
        In indirectly compiled code, a similar warning is issued and the
        assertion fails:
            $rx = '<[ z .. a ]>';
            / <$rx> /;  # warns and never matches
    *   A leading "-" indicates a complemented character class:
             / <-[a..z_]> <-alpha> /
             / <- [a..z_]> <- alpha> /  # whitespace allowed after -
        This is essentially the same as using negative lookahead and dot:
            / <![a..z_]> . <!alpha> . /
        Whitespace is ignored after the initial "-".
    *   A leading "+" may also be supplied to indicate that the following
        character class is to be matched in a positive sense.
             / <+[a..z_]>* /
             / <+[ a..z _ ]>* /
             / <+ [ a .. z _ ] >* /      # whitespace allowed after +
    *   Character classes can be combined (additively or subtractively)
        within a single set of angle brackets. Whitespace is ignored. For
        example:
             / <[a..z] - [aeiou] + xdigit> /      # consonant or hex digit
        A named character class may be used by itself:
            <alpha>
        However, in order to combine classes you must prefix a named
        character class with "+" or "-". Whitespace is required before any
        "-" that would be misparsed as an identifier extender.
    *   One can use character classes as assertions. The following two
        expressions are equivalent and match a variable that does not start
        with a sigil assuming that "<variable>" can also match a sigil less
        variable.
           <?[$@%&]> <variable>
           <?before <[$@%&]> > <variable>
    *   Unicode properties are indicated by use of pair notation in place of
        a normal rule name:
            <:Letter>   # a letter
            <:!Letter>  # a non-letter
        Properties with arguments are passed as the argument to the pair:
            <:East_Asian_Width<Narrow>>
            <:!Blk<ASCII>>
        The pair value is smartmatched against the value in the Unicode
        Character Database.
            <:Nv(0 ^..^ 1)>     # the char has a proper fractional value
        As a particular case of smartmatching, TR18 section 2.6 is satisfied
        with a pattern as the argument:
            <:name(/^LATIN LETTER.*P$/)>
    *   Multiple of these terms may be combined with pluses and minuses:
            <+ :HexDigit - :Upper >
        Terms may also be combined using "&" for set intersection, "|" for
        set union, and "^" for symmetric set difference. Parens may be used
        for grouping. (Square brackets always quote literal characters
        (including backslashed literal forms), and may not be nested, unlike
        the suggested notation in TR18 section 1.3.) The precedence of the
        operators is the same as the correspondingly named operators in
        "Operator precedence" in S03, even though they have somewhat
        different semantics.
    *   Extra long characters may be entered by quoting them and including
        them via intersection. Any quoted characters will be treated as
        "longest tokens" when appropriate. Here 'll' would be recognized in
        preference to 'l':
            / <[ a..z ] | 'ñ' | 'ch' | 'll' | 'rr'>
        Note that a negated character class containing "long characters"
        always advances by a single character.
    *   When any character constructor such as "\c", "\x", or "\o" contains
        multiple values separated by commas, these are treated as "long
        characters". So you could add a "\c[13,10]" to the list above to
        match CRLF as a long character.
        A consequence of this is that the negated form advances by a single
        position (matching as "." does) when the long character doesn't
        match as a whole. Hence, this matches:
            "\c[13,13,10,10]" ~~ /\C[13,10]* \c[13,10] \C[13,10]/;
        If you want it to mean \C13\C10 instead, then you can just write it
        that way.
    *   A leading "!" indicates a negated meaning (always a zero-width
        assertion):
             / <!before _ > /    # We aren't before an _
        Note that "<!alpha>" is different from "<-alpha>". "/<-alpha>/" is a
        complemented character class equivalent to "/<!before <alpha>> ./",
        whereas "<!alpha>" is a zero-width assertion equivalent to a
        "/<!before <alpha>>/" assertion.
        Note also that as a metacharacter "!" doesn't change the parsing
        rules of whatever follows (unlike, say, "+" or "-").
    *   A leading "?" indicates a positive zero-width assertion, and like
        "!" merely reparses the rest of the assertion recursively as if the
        "?" were not there. In addition to forcing zero-width, it also
        suppresses any named capture:
            <alpha>     # match a letter and capture to $alpha (eventually $<alpha>)
            <.alpha>    # match a letter, don't capture
            <?alpha>    # match null before a letter, don't capture
        The special named assertions include:
             / <?before pattern> /    # lookahead
             / <?after pattern> /     # lookbehind
             / <?same> /              # true between two identical characters
             / <.ws> /                # match "whitespace":
                                      #   \s+ if it's between two \w characters,
                                      #   \s* otherwise
             / <?at($pos)> /          # match only at a particular position
                                      # short for <?{ .pos === $pos }>
                                      # (considered declarative until $pos changes)
        It is legal to use any of these assertions as named captures by
        omitting the punctuation at the front. However, capture entails some
        overhead in both memory and computation, so in general you want to
        suppress that for data you aren't interested in preserving.
        The "after" assertion implements lookbehind by reversing the syntax
        tree and looking for things in the opposite order going to the left.
        It is illegal to do lookbehind on a pattern that cannot be reversed.
        Note: the effect of a forward-scanning lookbehind at the top level
        can be achieved with:
            / .*? prestuff <( mainpat )> /
    *   A leading "*" indicates that the following pattern allows a partial
        match. It always succeeds after matching as many characters as
        possible. (It is not zero-width unless 0 characters match.) For
        instance, to match a number of abbreviations, you might write any
        of:
            s/ ^ G<*n|enesis>     $ /gen/  or
            s/ ^ Ex<*odus>        $ /ex/   or
            s/ ^ L<*v|eviticus>   $ /lev/  or
            s/ ^ N<*m|umbers>     $ /num/  or
            s/ ^ D<*t|euteronomy> $ /deut/ or
            / (<* < foo bar baz > >) /
            / <short=*@abbrev> / and return %long{$<short>} || $<short>;
        The pattern is restricted to declarative forms that can be rewritten
        as nested optional character matches. Sequence information may not
        be discarded while making all following characters optional. That
        is, it is not sufficient to rewrite:
            <*xyz>
            x? y? z?            # bad, would allow xz
        Instead, it must be implemented as:
            [x [y z?]?]?        # allow only x, xy, xyz (and '')
        Explicit quantifiers are allowed on single characters, so this:
            <* a b+ c | ax*>
        is rewritten as something like:
            [a [b+ c?]?]? | [a x*]?
        In the latter example we're assuming the DFA token matcher is going
        to give us the longest match regardless. It's also possible that
        quantified multi-character sequences can be recursively remapped:
            <* 'ab'+>     # match a, ab, ababa, etc. (but not aab!)
            ==> [ 'ab'* <*ab> ]
            ==> [ 'ab'* [a b?]? ]
        [Conjecture: depending on how fancy we get, we might (or might not)
        be able to autodetect ambiguities in "<*@abbrev>" and refuse to
        generate ambiguous abbreviations (although exact match of a shorter
        abbrev should always be allowed even if it's the prefix of a longer
        abbreviation). If it is not possible, then the user will have to
        check for ambiguities after the match. Note also that the array form
        is assuming the array doesn't change often. If it does, the
        longest-token matcher has to be recalculated, which could get
        expensive.]
    *   A leading "~~" indicates a recursive call back into some or all of
        the current rule. An optional argument indicates which subpattern to
        re-use, and if provided must resolve to a single subpattern. If
        omitted, the entire pattern is called recursively:
            <~~>       # call myself recursively
            <~~0>      # match according to $0's pattern
            <~~foo>    # match according to $<foo>'s pattern
        Note that this rematches the pattern associated with the name, not
        the string matched. So
            $_ = "foodbard"
            / ( foo | bar ) d $0 /      # fails; doesn't match "foo" literally
            / ( foo | bar ) d <$0> /    # fails; doesn't match /foo/ as subrule
            / ( foo | bar ) d <~~0> /   # matches using rule associated with $0
        The last is equivalent to
            / ( foo | bar ) d ( foo | bar ) /
        Note that the "self" call of
            / <term> <operator> <~~> /
        calls back into this anonymous rule as a subrule, and is implicitly
        anchored to the end of the operator as any other subrule would be.
        Despite the fact that the outer rule scans the string, the inner
        call to it does not.
        Note that a consequence of the previous section is that you also get
            <!~~>
        for free, which fails if the current rule would match again at this
        location.
    *   A leading "|" indicates some kind of a zero-width boundary. You can
        refer to backslash sequences with this syntax; "<|h>" will match
        between a "\h" and a "\H", for instance. Some examples:
            <|w> word boundary
            <|g> grapheme boundary (always matches in grapheme mode)
            <|c> codepoint boundary (always matches in grapheme/codepoint mode)
    The following tokens include angles but are not required to balance:
    *   A "<(" token indicates the start of the match's overall capture,
        while the corresponding ")>" token indicates its endpoint. When
        matched, these behave as assertions that are always true, but have
        the side effect of setting the ".from" and ".to" attributes of the
        match object. That is:
            / foo <( \d+ )> bar /
        is equivalent to:
            / <?after foo> \d+ <?before bar> /
        except that the scan for ""foo"" can be done in the forward
        direction, while a lookbehind assertion would presumably scan for
        "\d+" and then match ""foo"" backwards. The use of "<(...)>" affects
        only the positions of the beginning and ending of the match, and
        anything calculated based on those positions. For instance, after
        the match above, "$()" contains only the digits matched, and "$/.to"
        is pointing to after the digits. Other captures (named or numbered)
        are unaffected and may be accessed through $/.
        When used directly within quantifiers (that is, within quantified
        square brackets), there is only one "Match" object to set
        ".from"/".to" on, so the "<(" token always sets ".from" to the
        leftmost matching position, while ")>" always sets ".to" to the
        rightmost position. However, the situation is different for
        capturing parentheses. When used within parentheses (whether or not
        the parens are quantified), the "Match" being generated by each
        dynamic capture serves as the target, so each such capturing group
        sets its own ".from"/".to". Hence, if the group is quantified, each
        capture sets its own boundaries independently.
        These tokens are considered declarative.
    *   A "«" or "<<" token indicates a left word boundary. A "»" or ">>"
        token indicates a right word boundary. (As separate tokens, these
        need not be balanced.) Perl 5's "\b" is replaced by a "<|w>" "word
        boundary" assertion, while "\B" becomes "<!|w>". (None of these are
        dependent on the definition of "<.ws>", but only on the "\w"
        definition of "word" characters. Non-space mark characters are
        ignored in calculating word properties of the preceding character.
        See TR18 1.4.)
  Predefined Subrules
    These are some of the predefined subrules for any grammar or regex:
    *   ident
        Match an identifier.
    *   upper
        Match a single uppercase character.
    *   lower
        Match a single lowercase character.
    *   alpha
        Match a single alphabetic character, or an underscore.
        To match Unicode alphabetic characters without the underscore, use
        "<:alpha>".
    *   digit
        Match a single digit.
    *   xdigit
        Match a single hexadecimal digit.
    *   print
        Match a single printable character.
    *   graph
        Match a single "graphical" character.
    *   cntrl
        Match a single "control" character (equivalent to the <:Cc>
        property). A control character is usually one that doesn't produce
        output as such but instead controls the terminal somehow: for
        example newline and backspace are control characters. All characters
        with ord() less than 32 are usually classified as control characters
        (assuming ASCII, the ISO Latin character sets, and Unicode), as is
        the character with the ord() value of 127 (DEL). The characters from
        128 to 159 are also control characters.
    *   punct
        Match a single punctuation character (that is, any character from
        the Unicode General Category "Punctuation").
    *   alnum
        Match a single alphanumeric character. This is equivalent to <+alpha
        +digit> .
    *   wb
        Returns a zero-width match that is true at word boundaries. A word
        boundary is a spot with a "\w" on one side and a "\W" on the other
        side (in either order), counting the beginning and end of the string
        as matching "\W".
    *   ww
        Matches between two word characters (zero-width match).
    *   ws
        Matches required whitespace between two word characters, optional
        whitespace otherwise. This is roughly equivalent to "<!ww> \s*"
        ("ws" isn't required to use the "ww" subrule).
    *   space
        Match a single whitespace character (same as " \s " ).
    *   blank
        Match a single "blank" character -- in most locales, this
        corresponds to space and tab.
    *   before "pattern"
        Perform lookahead -- i.e., check if we're at a position where
        "pattern" matches. Returns a zero-width "Match" object on success.
    *   after "pattern"
        Perform lookbehind -- i.e., check if the string before the current
        position matches <pattern> (anchored at the end). Returns a
        zero-width "Match" object on success.
    *   <?>
        Match a null string, viz., always returns true
    *   <!>
        Inverse of <?>, viz., always returns false.
Backslash reform
    *   Many "\p" and "\P" properties become intrinsic grammar rules such as
        ("<alpha>" and "<-alpha>"). They may be combined using the
        above-mentioned character class notation: "<[-]+alpha+digit>".
        Regardless of the higher-level character class names, all low-level
        Unicode properties are always available with a prefix of colon, that
        is, in pair notation within the angle brackets. Hence, "<+:Lu+:Lt>"
        is equivalent to "<+upper+title>".
    *   The "\L...\E", "\U...\E", and "\Q...\E" sequences are gone. The
        single-character case modifiers "\l" and "\u" are also gone. In the
        rare cases that need them you can use "<{ lc $regex }>", "<{tc
        $word}>", etc.
    *   As mentioned above, the "\b" and "\B" word boundary assertions are
        gone, and are replaced with "<|w>" (or <wb>) and "<!|w>" (or <!wb>)
        zero-width assertions.
    *   The "\G" sequence is gone. Use ":p" instead. (Note, however, that it
        makes no sense to use ":p" within a pattern, since every internal
        pattern is implicitly anchored to the current position.) See the
        "at" assertion below.
    *   Backreferences (e.g. "\1", "\2", etc.) are gone; $0, $1, etc. can be
        used instead, because variables are no longer interpolated.
        Numeric variables are assumed to change every time and therefore are
        considered procedural, unlike normal variables.
    *   New backslash sequences, "\h" and "\v", match horizontal and
        vertical whitespace respectively, including Unicode. Horizontal
        whitespace is defined as anything matching "\s" that doesn't also
        match "\v". Vertical whitespace is defined as any of:
            U+000A  LINE FEED (LF)
            U+000B  LINE TABULATION
            U+000C  FORM FEED (FF)
            U+000D  CARRIAGE RETURN (CR)
            U+0085  NEXT LINE (NEL)
            U+2028  LINE SEPARATOR
            U+2029  PARAGRAPH SEPARATOR
        Note that "U+000D" (CARRIAGE RETURN) is considered vertical
        whitespace despite the fact that it only moves the "carriage"
        horizontally.
    *   "\s" now matches any Unicode whitespace character.
    *   The new backslash sequence "\N" matches anything except a logical
        newline; it is the negation of "\n".
    *   Other new capital backslash sequences are also the negations of
        their lowercase counterparts:
        *   "\H" matches anything but horizontal whitespace.
        *   "\V" matches anything but vertical whitespace.
        *   "\T" matches anything but a tab.
        *   "\R" matches anything but a return.
        *   "\F" matches anything but a formfeed.
        *   "\E" matches anything but an escape.
        *   "\X..." matches anything but the specified character (specified
            in hexadecimal).
        *   Backslash escapes for literal characters in ordinary strings are
            allowed in regexes ("\a", "\x", etc.). However, the exception to
            this rule is "\b", which is disallowed in order to avoid
            conflict with its former use as a word boundary assertion. To
            match a literal backspace, use "\c8", "\x8", or a double-quoted
            "\b".
  Character class shortcuts
    For historical and convenience reasons, the following character classes
    are available as backslash sequences:
       \d      <digit>    A digit
       \D      <-digit>   A nondigit
       \w      <alnum>    A word character
       \W      <-alnum>   A non-word character
       \s      <sp>       A whitespace character
       \S      <-sp>      A non-whitespace character
       \h                 A horizontal whitespace
       \H                 A non-horizontal whitespace
       \v                 A vertical whitespace
       \V                 A non-vertical whitespace
Regexes constitute a first-class language, rather than just being strings
    *   The Perl 5 "qr/pattern/" regex constructor is gone.
    *   The Perl 6 equivalents are:
             regex { pattern }    # always takes {...} as delimiters
             rx    / pattern /    # can take (almost) any chars as delimiters
        You may not use whitespace or alphanumerics for delimiters. Space is
        optional unless needed to distinguish from modifier arguments or
        function parens. So you may use parens as your "rx" delimiters, but
        only if you interpose whitespace:
             rx ( pattern )      # okay
             rx( 1,2,3 )         # tries to call rx function
        (This is true for all quotelike constructs in Perl 6.)
        The "rx" form may be used directly as a pattern anywhere a normal
        "//" match can. The "regex" form is really a method definition, and
        must be used in such a way that the grammar class it is to be used
        in is apparent.
    *   If either form needs modifiers, they go before the opening
        delimiter:
             $regex = regex :s:i { my name is (.*) };
             $regex = rx:s:i     / my name is (.*) /;    # same thing
        Space is necessary after the final modifier if you use any
        bracketing character for the delimiter. (Otherwise it would be taken
        as an argument to the modifier.)
    *   You may not use colons for the delimiter. Space is allowed between
        modifiers:
             $regex = rx :s :i / my name is (.*) /;
    *   The name of the constructor was changed from "qr" because it's no
        longer an interpolating quote-like operator. "rx" is short for
        *regex*, (not to be confused with regular expressions, except when
        they are).
    *   As the syntax indicates, it is now more closely analogous to a "sub
        {...}" constructor. In fact, that analogy runs *very* deep in Perl
        6.
    *   Just as a raw "{...}" is now always a closure (which may still
        execute immediately in certain contexts and be passed as an object
        in others), so too a raw "/.../" is now always a "Regex" object
        (which may still match immediately in certain contexts and be passed
        as an object in others).
    *   Specifically, a "/.../" matches immediately in a value context
        (sink, Boolean, string, or numeric), or when it is an explicit
        argument of a "~~". Otherwise it's a "Regex" constructor identical
        to the explicit "regex" form. So this:
             $var = /pattern/;
        no longer does the match and sets $var to the result. Instead it
        assigns a "Regex" object to $var.
    *   The two cases can always be distinguished using "m{...}" or
        "rx{...}":
             $match = m{pattern};    # Match regex immediately, assign result
             $regex = rx{pattern};   # Assign regex expression itself
    *   Note that this means that former magically lazy usages like:
             @list = split /pattern/, $str;
        are now just consequences of the normal semantics.
    *   It's now also possible to set up a user-defined subroutine that acts
        like "grep":
             sub my_grep($selector, *@list) {
                 given $selector {
                     when Regex { ... }
                     when Code  { ... }
                     when Hash  { ... }
                     # etc.
                 }
        When you call "my_grep", the first argument is bound in item
        context, so passing "{...}" or "/.../" produces a "Code" or "Regex"
        object, which the switch statement then selects upon. (Normal "grep"
        just lets a smartmatch operator do all the work.)
    *   Just as "rx" has variants, so does the "regex" declarator. In
        particular, there are two special variants for use in grammars:
        "token" and "rule".
        A token declaration:
            token ident { [ <alpha> | \- ] \w* }
        never backtracks by default. That is, it likes to commit to whatever
        it has scanned so far. The above is equivalent to
            regex ident { [ <alpha>: | \-: ]: \w*: }
        but rather easier to read. The bare "*", "+", and "?" quantifiers
        never backtrack in a "token". In normal regexes, use *:, "+:", or
        "?:" to prevent any backtracking into the quantifier. If you want to
        explicitly backtrack, append either a "?" or a "!" to the
        quantifier. The "?" forces frugal matching as usual, while the "!"
        forces greedy matching. The "token" declarator is really just short
        for
            regex :ratchet { ... }
        The other is the "rule" declarator, for declaring non-terminal
        productions in a grammar. Like a "token", it also does not backtrack
        by default. In addition, a "rule" regex also assumes ":sigspace". A
        "rule" is really short for:
            regex :ratchet :sigspace { ... }
    *   The Perl 5 "?...?" syntax (*succeed once*) was rarely used and can
        be now emulated more cleanly with a state variable:
            $result = do { state $x ||= m/ pattern /; }    # only matches first time
        To reset the pattern, simply say "$x = 0". Though if you want $x
        visible you'd have to avoid using a block:
            $result = state $x ||= m/ pattern /;
            $x = 0;
Backtracking control
    Within those portions of a pattern that are considered procedural rather
    than declarative, you may control the backtracking behavior.
    *   By default, backtracking is greedy in "rx", "m", "s", and the like.
        It's also greedy in ordinary "regex" declarations. In "rule" and
        "token" declarations, backtracking must be explicit.
    *   To force the preceding atom to do frugal backtracking (also
        sometimes known as "eager matching" or "minimal matching"), append a
        ":?" or "?" to the atom. If the preceding token is a quantifier, the
        ":" may be omitted, so "*?" works just as in Perl 5.
    *   To force the preceding atom to do greedy backtracking in a spot that
        would default otherwise, append a ":!" to the atom. If the preceding
        token is a quantifier, the ":" may be omitted. (Perl 5 has no
        corresponding construct because backtracking always defaults to
        greedy in Perl 5.)
    *   To force the preceding atom to do no backtracking, use a single ":"
        without a subsequent "?" or "!". Backtracking over a single colon
        causes the regex engine not to retry the preceding atom:
             ms/ \( <expr> [ , <expr> ]*: \) /
        (i.e. there's no point trying fewer "<expr>" matches, if there's no
        closing parenthesis on the horizon)
        When modifying a quantifier, a "+" may be used instead of a ":", in
        which case the quantifier is often known as a *possessive*
        quantifier.
             ms/ \( <expr> [ , <expr> ]*+ \) /  # same thing
        To force all the atoms in an expression not to backtrack by default,
        use ":ratchet" or "rule" or "token".
    *   Evaluating a double colon throws away all saved choice points in the
        current LTM alternation.
             ms/ [ if :: <expr> <block>
                 | for :: <list> <block>
                 | loop :: <loop_controls>? <block>
                 ]
        (i.e. there's no point trying to match a different keyword if one
        was already found but failed).
        The "::" also has the effect of hiding any declarative match on the
        right from "longest token" processing by "|". Only the left side is
        evaluated for determinacy.
        "::" does nothing if there is no current LTM alternation. "Current"
        is defined dynamically, not lexically. A "::" in a subrule will
        affect the enclosing alternation.
    *   Evaluating a "::>" throws away all saved choice points in the
        current innermost temporal alternation. It thus acts as a "then".
            ms/ [
                || <?{ $a == 1 }> ::> <foo>
                || <?{ $a == 2 }> ::> <bar>
                || <?{ $a == 3 }> ::> <baz>
                ]
            /
        Note that you can still back into the "then" part of such an
        alternation, so you may also need to put ":" after it if you also
        want to disable that. If an explicit or implicit ":ratchet" has
        disabled backtracking by supplying an implicit ":", you need to put
        an explicit "!" after the alternation to enable backing into, say,
        the "<foo>" rule above.
        "::>" does nothing if there is no current temporal alternation.
        "Current" is defined dynamically, not lexically. A "::>" in a
        subrule will affect the enclosing alternation.
    *   Evaluating a triple colon throws away all saved choice points since
        the current regex was entered. Backtracking to (or past) this point
        will fail the rule outright (no matter where in the regex it
        occurs):
             regex ident {
                   ( [<alpha>|\-] \w* ) ::: { fail if %reserved{$0} }
                 || " [<alpha>|\-] \w* "
             ms/ get <ident>? /
        (i.e. using an unquoted reserved word as an identifier is not
        permitted)
    *   Evaluating a "<commit>" assertion throws away all saved choice
        points since the start of the entire match. Backtracking to (or
        past) this point will fail the entire match, no matter how many
        subrules down it happens:
             regex subname {
                 ([<alpha>|\-] \w*) <commit> { fail if %reserved{$0} }
             ms/ sub <subname>? <block> /
        (i.e. using a reserved word as a subroutine name is instantly fatal
        to the *surrounding* match as well)
        If commit is given an argument, it's the name of a calling rule that
        should be committed:
            <commit('infix')>
    *   A "<cut>" assertion always matches successfully, and has the side
        effect of logically deleting the parts of the string already
        matched. Whether this actually frees up the memory immediately may
        depend on various interactions among your backreferences, the string
        implementation, and the garbage collector. In any case, the string
        will report that it has been chopped off on the front. It's illegal
        to use "<cut>" on a string that you do not have write access to.
        Attempting to backtrack past a "<cut>" causes the complete match to
        fail (like backtracking past a "<commit>"). This is because there's
        now no preceding text to backtrack into. This is useful for throwing
        away successfully processed input when matching from an input stream
        or an iterator of arbitrary length.
Regex Routines, Named and Anonymous
    *   The analogy between "sub" and "regex" extends much further.
    *   Just as you can have anonymous subs and named subs...
    *   ...so too you can have anonymous regexes and *named* regexes (and
        tokens, and rules):
             token ident { [<alpha>|\-] \w* }
             # and later...
             @ids = grep /<ident>/, @strings;
    *   As the above example indicates, it's possible to refer to named
        regexes, such as:
             regex serial_number { <[A..Z]> \d**8 }
             token type { alpha | beta | production | deprecated | legacy }
        in other regexes as named assertions:
             rule identification { [soft|hard]ware <type> <serial_number> }
        These keyword-declared regexes are officially of type "Method",
        which is derived from "Routine".
        In general, the anchoring of any subrule call is controlled by its
        calling context. When a regex, token, or rule method is called as a
        subrule, the front is anchored to the current position (as with
        ":p"), while the end is not anchored, since the calling context will
        likely wish to continue parsing. However, when such a method is
        smartmatched directly, it is automatically anchored on both ends to
        the beginning and end of the string. Thus, you can do direct pattern
        matching by using an anonymous regex routine as a standalone
        pattern:
            $string ~~ regex { \d+ }
            $string ~~ token { \d+ }
            $string ~~ rule { \d+ }
        and these are equivalent to
            $string ~~ m/^ \d+ $/;
            $string ~~ m/^ \d+: $/;
            $string ~~ m/^ <.ws> \d+: <.ws> $/;
        The basic rule of thumb is that the keyword-defined methods never do
        implicit ".*?"-like scanning, while the "m//" and "s///" quotelike
        forms do such scanning in the absence of explicit anchoring.
        The "rx//" and "//" forms can go either way: they scan when used
        directly within a smartmatch or boolean context, but when called
        indirectly as a subrule they do not scan. That is, the object
        returned by "rx//" behaves like "m//" when used directly, but like
        "regex" "{}" when used as a subrule:
            $pattern = rx/foo/;
            $string ~~ $pattern;                  # equivalent to m/foo/;
            $string ~~ /'[' <$pattern> ']'/       # equivalent to /'[foo]'/
Nothing is illegal
    *   The empty pattern is now illegal.
    *   To match the zero-width string, you must use some explicit
        representation of the null match:
            / '' /;
            / <?> /;
             split /''/, $string
        splits between characters. But then, so does this:
             split '', $string
    *   Likewise, to match an empty alternative, use something like:
             /a|b|c|<?>/
             /a|b|c|''/
        This makes it easier to catch errors like this:
            /a|b|c|/
        As a special case, however, the first null alternative in a match
        like
             ms/ [
                 | if :: <expr> <block>
        is simply ignored. Only the first alternative is special that way.
        If you write:
                     if :: <expr> <block>              |
                     for :: <list> <block>             |
                     loop :: <loop_controls>? <block>  |
        it's still an error.
    *   However, it's okay for a non-null syntactic construct to have a
        degenerate case matching the null string:
             $something = "";
             /a|b|c|$something/;
        In particular, "<?>" always matches the null string successfully,
        and "<!>" always fails to match anything.
Longest-token matching
    Since "longest-token matching" is a long phrase, we will usually refer
    to this idea as LTM. The basic notion is that LTM is how people tend to
    parse text in their heads, so the computer ought to try to do the same.
    And parsing with LTM is all about how the computer decides which
    alternative of a set of alternatives is going to match.
    Instead of representing temporal alternation as it does in Perl 5, in
    Perl 6 "|" represents logical alternation with declarative longest-token
    semantics. (You may now use "||" to indicate the old temporal
    alternation. That is, "|" and "||" now work within regex syntax much the
    same as they do outside of regex syntax, where they represent junctional
    and short-circuit OR. This includes the fact that "|" has tighter
    precedence than "||".)
    Historically regex processing has proceeded in Perl via a backtracking
    NFA algorithm. This is quite powerful, but many parsers work more
    efficiently by processing rules in parallel rather than one after
    another, at least up to a point. If you look at something like a yacc
    grammar, you find a lot of pattern/action declarations where the
    patterns are considered in parallel, and eventually the grammar decides
    which action to fire off. While the default Perl view of parsing is
    essentially top-down (perhaps with a bottom-up "middle layer" to handle
    operator precedence), it is extremely useful for user understanding if
    at least the token processing proceeds deterministically. So for regex
    matching purposes we define token patterns as those patterns that can be
    matched without potential side effects or self-reference. (Since
    whitespace often has side effects at line transitions, it is usually
    excluded from such patterns, give or take a little lookahead.)
    Basically, Perl automatically derives a lexer from the grammar without
    you having to write one yourself.
    To that end, every regex in Perl 6 is required to be able to distinguish
    its "pure" patterns from its actions, and return its list of initial
    token patterns (transitively including the token patterns of any subrule
    called by the "pure" part of that regex, but not including any subrule
    more than once, since that would involve self reference, which is not
    allowed in traditional regular expressions). A logical alternation using
    "|" then takes two or more of these lists and dispatches to the
    alternative that matches the longest token prefix. This may or may not
    be the alternative that comes first lexically.
    However, if two alternatives match at the same length, the tie is broken
    first by specificity. The alternative that starts with the longest fixed
    string wins; that is, an exact match counts as closer than a match made
    using character classes. If that doesn't work, the tie is broken by one
    of two methods. If the alternatives are in different grammars, standard
    MRO (method resolution order) determines which one to try first. If the
    alternatives are in the same grammar file, the textually earlier
    alternative takes precedence. (If a grammar's rules are defined in more
    than one file, the order is undefined, and an explicit assertion must be
    used to force failure if the wrong one is tried first.)
    This longest token prefix corresponds roughly to the notion of "token"
    in other parsing systems that use a lexer, but in the case of Perl this
    is largely an epiphenomenon derived automatically from the grammar
    definition. However, despite being automatically calculated, the set of
    tokens can be modified by the user; various constructs within a regex
    declaratively tell the grammar engine that it is finished with the
    pattern part and starting in on the side effects, so by inserting such
    constructs the user controls what is considered a token and what is not.
    The constructs deemed to terminate a token declaration and start the
    "action" part of the pattern include:
    *   Any :: or ::: backtracking control (but not the : possessive
        modifier).
    *   Any atom that is quantified with a frugal match (using the "?"
    *   Any "{...}" action, but not an assertion containing a closure. (The
        empty closure "{}" is customarily used to explicitly terminate the
        pure part of the pattern.) The closure form of the general "**{...}"
        quantifier also terminates the longest token, but the closureless
        forms of quantifier do not.
    *   Any sequential control flow operator such as "||" or "&&".
    *   As a consequence of the previous point, and because the standard
        grammar's "<ws>" rule defines whitespace using "||", the longest
        token is also terminated by any part of the regex or rule that
        *might* match whitespace using that rule, including whitespace
        implicitly matched via ":sigspace". (However, token declarations are
        specifically allowed to recognize whitespace within a token by using
        such lower-level primitives as "\h+" or other character classes.)
    Subpatterns (captures) specifically do not terminate the token pattern,
    but may require a reparse of the token to find the location of the
    subpatterns. Likewise assertions may need to be checked out after the
    longest token is determined. (Alternately, if DFA semantics are
    simulated in any of various ways, such as by Thompson NFA, it may be
    possible to know when to fire off the assertions without backchecks.)
    Greedy quantifiers and character classes do not terminate a token
    pattern. Zero-width assertions such as word boundaries are also okay.
    Because such assertions can be part of the token, the lexer engine must
    be able to recover from the failure of such an assertion and backtrack
    to the next best token candidate, which might be the same length or
    shorter, but can never be longer than the current candidate.
    For a pattern that contains a positive lookahead assertion such as
    "<?foo>" or "<?before \s>", the assertion is assumed to be more specific
    than the subsequent pattern, so the lookahead's pattern is counted as
    the final part of the longest token; the longest-token matcher will be
    smart enough to treat the extra bit as 0-width, that is, to rematch any
    text traversed by the lookahead when (and if) it continues the match.
    (Indeed, if the entire lookahead is pure enough to participate in LTM,
    the rematcher may simply optimize away the rematching, since the
    lookahead already matched in the LTM engine.)
    However, for a pattern that contains a negative lookahead assertion such
    as "<!foo>" or "<!before \s>", just the opposite is true: the subsequent
    pattern is assumed to be more specific than the assertion's. So LTM
    completely ignores negative lookaheads, and continues to look for pure
    patterns in whatever follows the negative lookahead. You might say that
    positive lookaheads are opaque to LTM, but negative lookaheads are
    transparent to LTM. As a consequence, if you wish to write a positive
    lookahead that is transparent to LTM, you may indicate this with a
    double negation: "<!!foo>". (The optimizer is free to remove the double
    negation, but not the transparency.)
    Oddly enough, the "token" keyword specifically does not determine the
    scope of a token, except insofar as a token pattern usually doesn't do
    much matching of whitespace, and whitespace is the prototypical way of
    terminating tokens.
    The initial token matcher must take into account case sensitivity (or
    any other canonicalization primitives) and do the right thing even when
    propagated up to rules that don't have the same canonicalization. That
    is, they must continue to represent the set of matches that the lower
    rule would match.
    The "||" form has the old short-circuit semantics, and will not attempt
    to match its right side unless all possibilities (including all "|"
    possibilities) are exhausted on its left. The first "||" in a regex
    makes the token patterns on its left available to the outer
    longest-token matcher, but hides any subsequent tests from longest-token
    matching. Every "||" establishes a new longest-token matcher. That is,
    if you use "|" on the right side of "||", that right side establishes a
    new top level scope for longest-token processing for this subexpression
    and any called subrules. The right side's longest-token automaton is
    invisible to the left of the "||" or outside the regex containing the
    "||".
Return values from matches
  Match objects
    *   A successful match always returns a "Match" object, which is
        generally also put into $/, a dynamic lexical declared in the outer
        routine that is calling the regex. (A named "regex", "token", or
        "rule" is a routine, and hence declares its own lexical $/ variable,
        which always refers to the most recent submatch within the rule, if
        any.) The current match state is kept in the regex's $¢ variable
        which will eventually get bound to the user's $/ variable when the
        match completes.
        An unsuccessful match returns "Nil" (and sets $/ to "Nil" if the
        match would have set it).
    *   Notionally, a match object contains (among other things) a boolean
        success value, an array of ordered submatch objects, and a hash of
        named submatch objects. (It also optionally carries an *abstract
        object* normally used to build up an abstract syntax tree,) To
        provide convenient access to these various values, the match object
        evaluates differently in different contexts:
        *   In boolean context it evaluates as true or false (i.e. did the
            match succeed?):
                 if /pattern/ {...}
                 # or:
                 /pattern/; if $/ {...}
            With ":global" or ":overlap" or ":exhaustive" the boolean is
            allowed to return true on the first match. The "Match" object
            can produce the rest of the results lazily if evaluated in list
            context.
        *   In string context it evaluates to the stringified value of its
            match, which is usually the entire matched string:
                 print %hash{ "{$text ~~ /<.ident>/}" };
                 # or equivalently:
                 $text ~~ /<.ident>/  &&  print %hash{~$/};
            But generally you should say "~$/" if you mean "~$/".
        *   In numeric context it evaluates to the numeric value of its
                 $sum += /\d+/;
                 /\d+/; $sum = $sum + $/;
        *   When used as a scalar, a "Match" object evaluates to itself.
            However, sometimes you would like an alternate scalar value to
            ride along with the match. The "Match" object itself describes a
            concrete parse tree, so this extra value is called an *abstract*
            object; it rides along as an attribute of the "Match" object.
            The ".made" method by default returns an undefined value. "$()"
            is a shorthand for "$($/.made // ~$/)".
            Therefore "$()" is usually just the entire match string, but you
            can override that by calling "make" inside a regex:
                my $moose = $(m[
                    <antler> <body>
                    { make Moose.new( body => $<body>.attach($<antler>) ) }
                    # match succeeds -- ignore the rest of the regex
                ]);
            This puts the new abstract node into "$/.made". An AST node may
            be of any type. Using the "make"/".made" mechanism, it is
            convenient to build up an abstract syntax tree of arbitrary node
            types.
            However, the "make" function is not limited to be used for
            storing AST nodes and building abstract syntax trees only. This
            is just a specific Perl 6 internal use of this functionality.
            Nor does the "make" function impose any item or list context
            onto its argument, so if you say something ambiguously listy
            like
                make ()
                make @array
                make foo()
            the value returned from ".made" will interpolate into a list. To
            suppress this, use one of these:
                make ().item
                make []
                make $@array
                make [@array]
                make foo().item
                make $(foo())
            or use ".made.item" or a "$" variable on the receiving end.
            The ".ast" method is a synonym ".made" with no differing
            behavior. It exists both for historical reasons and as a way to
            indicate to those reading your code a more AST-like use of the
            "made"/".make" mechanism.
        *   You may also capture a subset of the match using the "<(...)>"
            construct:
                "foo123bar" ~~ / foo <( \d+ )> bar /
                say $();    # says 123
            In this case "$()" is always a string when doing string
            matching, and a list of one or more elements when doing list
            matching. This construct does not set the ".made" attribute.
        *   When used as an array, a "Match" object pretends to be an array
            of all its positional captures. Hence
                 ($key, $val) = ms/ (\S+) '=>' (\S+)/;
            can also be written:
                 $result = ms/ (\S+) '=>' (\S+)/;
                 ($key, $val) = @$result;
            To get a single capture into a string, use a subscript:
                 $mystring = "{ ms/ (\S+) '=>' (\S+)/[0] }";
            To get all the captures into a string, use a *zen* slice:
                 $mystring = "{ ms/ (\S+) '=>' (\S+)/[] }";
            Or cast it into an array:
                 $mystring = "@( ms/ (\S+) '=>' (\S+)/ )";
            Note that, as a scalar variable, $/ doesn't automatically
            flatten in list context. Use "@()" as a shorthand for "@($/)" to
            flatten the positional captures under list context. Note that a
            "Match" object is allowed to evaluate its match lazily in list
            context. Use "eager @()" to force an eager match.
        *   When used as a hash, a "Match" object pretends to be a hash of
            all its named captures. The keys do not include any sigils, so
            if you capture to variable "@<foo>" its real name is $/{'foo'}
            or "$/<foo>". However, you may still refer to it as "@<foo>"
            anywhere $/ is visible. (But it is erroneous to use the same
            name for two different capture datatypes.)
            flatten in list context. Use "%()" as a shorthand for "%($/)" to
            flatten as a hash, or bind it to a variable of the appropriate
            type. As with "@()", it's possible for "%()" to produce its
            pairs lazily in list context.
        *   The numbered captures may be treated as named, so "$<0 1 2>" is
            equivalent to $/[0,1,2]. This allows you to write slices of
            intermixed named and numbered captures.
        *   The ".keys", ".values" and ".kv" methods act both on the list
            and hash part, with the list part coming first.
                'abcd' ~~ /(.)(.)**2 <alpha>/;
                say ~$/.keys;           # 0 1 alpha
        *   In ordinary code, variables $0, $1, etc. are just aliases into
            $/[0], $/[1], etc. Hence they will all be undefined if the last
            match failed (unless they were explicitly bound in a closure
            without using the "let" keyword).
    *   "Match" objects have methods that provide additional information
        about the match. For example:
             if m/ def <ident> <codeblock> / {
                 say "Found sub def from index $/.from.bytes ",
                     "to index $/.to.bytes";
        The currently defined methods are
            $/.from      # the initial match position
            $/.to        # the final match position
            $/.chars     # $/.to - $/.from
            $/.orig      # the original match string
            $/.Str       # substr($/.orig, $/.from, $/.chars)
            $/.made      # the abstract result associated with this node (from make)
            $/.ast       # same as $/.made
            $/.caps      # sequential captures
            $/.chunks    # sequential tokenization
            $/.prematch  # $/.orig.substr(0, $/.from)
            $/.postmatch # $/.orig.substr($/.to)
        Within the regex the current match state $¢ also provides
            .pos        # the current match position
        This last value may correspond to either "$¢.from" or "$¢.to"
        depending on whether the match is proceeding in a forward or
        backward direction (the latter case arising inside an "<?after ...>"
        assertion).
    *   As described above, a "Match" in list context returns its positional
        captures. However, sometimes you'd rather get a flat list of tokens
        in the order they occur in the text. The ".caps" method returns a
        list of every capture in order, regardless of how it was otherwise
        bound into named or numbered captures. (Other than order, there is
        no new information here; all the elements of the list are the very
        same "Match" objects that bound elsewhere.) The bindings are
        actually returned as key/value pairs where the key is the name or
        number under which the match object was bound, and the value is the
        match object itself.
        In addition to returning those captured "Match" objects, the
        ".chunks" method also returns all the interleaved "noise" between
        the captures. As with ".caps", the list elements are in the order
        they were originally in the text. The interleaved bits are also
        returned as pairs, where the key is '~' and the value is a simple
        "Match" object containing only the string, even if unbound subrules
        such as ".ws" were called to traverse the text in the first place.
        Calling ".made" on such a "Match" object always returns a "Str".
        A warning will be issued if either ".caps" or ".chunks" discovers
        that it has overlapping bindings. In the absence of such overlap,
        ".chunks" guarantees to map every part of its matched string
        (between ".from" and ".to") to exactly one element of its returned
        matches, so coverage is complete.
        [Conjecture: we could also have ".deepcaps" and ".deepchunks" that
        recursively expand any capture containing submatches. Presumably the
        keys of such returned chunks would indicate the "pedigree" of
        bindings in the parse tree.]
    *   All match attempts--successful or not--against any regex, subrule,
        or subpattern (see below) return an object that can be evaluated as
        a boolean. (This object will be either a "Match" or a "Nil".) That
             $match_obj = $str ~~ /pattern/;
             say "Matched" if $match_obj;
    *   This returned object is also automatically bound to the lexical $/
        variable of the current surroundings regardless of success. That is:
             $str ~~ /pattern/;
             say "Matched" if $/;
    *   Inside a regex, the $¢ variable holds the current regex's incomplete
        "Match" object, known as a match state (of type "Cursor"). Generally
        this should not be modified unless you know how to create and
        propagate match states. All regexes actually return match states
        even when you think they're returning something else, because the
        match states keep track of the successes and failures of the pattern
        for you.
        Fortunately, when you just want to return a different abstract
        result along with the default concrete "Match" object, you may
        associate your return value with the current match state using the
        "make" function, which works something like a "return", but doesn't
        clobber the match state:
            $str ~~ / foo                 # Match 'foo'
                       { make 'bar' }     # But pretend we matched 'bar'
                     /;
            say $();                      # says 'bar'
        The value of any "Match" object (such as an abstract object) is
        available via the ".made" method. Hence these abstract objects can
        be managed independently of the returned cursor objects.
        The current cursor object must always be derived from "Cursor", or
        the match will not work. However, within that constraint, the actual
        type of the current cursor defines which language you are currently
        parsing. When you enter the top of a grammar, this cursor generally
        starts out as an object whose type is the name of the grammar you
        are in, but the current language can be modified by various methods
        as they mutate the current language by returning cursor objects
        blessed into a different type, which may or may not be derived from
        the current grammar.
  Subpattern captures
    *   Any part of a regex that is enclosed in capturing parentheses is
        called a *subpattern*. For example:
                #               subpattern
                #  _________________/\___________________
                # |                                      |
                # |       subpattern  subpattern         |
                # |          __/\__    __/\__            |
                # |         |      |  |      |           |
              ms/ (I am the (walrus), ( khoo )**2  kachoo) /;
    *   Each subpattern in a regex produces a "Match" object if it is
        successfully matched.
    *   Each subpattern is either explicitly assigned to a named destination
        or implicitly added to an array of matches.
        For each subpattern that is not explicitly given a name, the
        subpattern's "Match" object is pushed onto the array inside the
        outer "Match" object belonging to the surrounding scope (known as
        its *parent "Match" object*). The surrounding scope may be either
        the innermost surrounding subpattern (if the subpattern is nested)
        or else the entire regex itself.
    *   Like all captures, these assignments to the array are hypothetical,
        and are undone if the subpattern is backtracked.
    *   For example, if the following pattern matched successfully:
                #                subpat-A
                #  _________________/\__________________
                # |                                     |
                # |         subpat-B  subpat-C          |
                # |          __/\__    __/\__           |
                # |         |      |  |      |          |
              ms/ (I am the (walrus), ( khoo )**2 kachoo) /;
        then the "Match" objects representing the matches made by *subpat-B*
        and *subpat-C* would be successively pushed onto the array inside
        *subpat- A*'s "Match" object. Then *subpat-A*'s "Match" object would
        itself be pushed onto the array inside the "Match" object for the
        entire regex (i.e. onto $/'s array).
    *   As a result of these semantics, capturing parentheses in Perl 6 are
        hierarchical, not linear (see "Nested subpattern captures").
  Accessing captured subpatterns
    *   The array elements of a "Match" object are referred to using either
        the standard array access notation (e.g. $/[0], $/[1], $/[2], etc.)
        or else via the corresponding lexically scoped numeric aliases (i.e.
        $0, $1, $2, etc.) So:
             say "$/[1] was found between $/[0] and $/[2]";
             say "$1 was found between $0 and $2";
    *   Note that, in Perl 6, the numeric capture variables start from $0,
        not $1, with the numbers corresponding to the element's index inside
        $/.
    *   The array elements of the regex's "Match" object (i.e. $/) store
        individual "Match" objects representing the substrings that were
        matched and captured by the first, second, third, etc. *outermost*
        (i.e. unnested) subpatterns. So these elements can be treated like
        fully fledged match results. For example:
             if m/ (\d\d\d\d)-(\d\d)-(\d\d) (BCE?|AD|CE)?/ {
                   ($yr, $mon, $day) = $/[0..2];
                   $era = "$3" if $3;                    # stringify/boolify
                   @datepos = ( $0.from() .. $2.to() );  # Call Match methods
  Nested subpattern captures
    *   Substrings matched by *nested* subpatterns (i.e. nested capturing
        parens) are assigned to the array inside the nested subpattern's
        parent "Match" object, not to the array of $/.
    *   This behavior is quite different from Perl 5 semantics:
              # Perl 5...
              #
              # $1---------------------  $4---------  $5------------------
              # |   $2---------------  | |          | | $6----  $7------  |
              # |   |         $3--   | | |          | | |     | |       | |
              # |   |         |   |  | | |          | | |     | |       | |
             m/ ( A (guy|gal|g(\S+)  ) ) (sees|calls) ( (the|a) (gal|guy) ) /x;
    *   In Perl 6, nested parens produce properly nested captures:
              # Perl 6...
              # $0---------------------  $1---------  $2------------------
              # |   $0[0]------------  | |          | | $2[0]-  $2[1]---  |
              # |   |       $0[0][0] | | |          | | |     | |       | |
             m/ ( A (guy|gal|g(\S+)  ) ) (sees|calls) ( (the|a) (gal|guy) ) /;
  Quantified subpattern captures
    *   If a subpattern is directly quantified with "?", it either produces
        a single "Match" object, or "Nil". If a subpattern is directly
        quantified using any other quantifier, it never produces a single
        "Match" object. Instead, it produces a list of "Match" objects
        corresponding to the sequence of individual matches made by the
        repeated subpattern. If we need to distinguish the two categories,
        "?" is an *item quantifier*, while "*", "+", and "**" are called
        *list quantifiers*.
        If 0 values match, the captured value depends on which quantifier is
        used. If the quantifier is "?", a "Nil" is captured if it matched 0
        times. If the quantifier is "*", the empty list, "()", is captured
        instead. (Nothing is captured by the "+" quantifier if it matches 0
        times, since it causes backtracking, but the capture variable should
        return "Nil" if an attempt is made to use it after an unsuccessful
        match.) A "**" quantifier returns () as "*" does if it the minimum
        of its range is 0, and backtracks otherwise.
        Note that "** 0..1" is always considered a list quantifier, unlike
        "?".
        The rationale for treating "?" as an item quantifier is to make it
        consistent with how "$object.?meth" is defined, and to reduce the
        need for gratuitous ".[0]" subscripts, which is surprising to most
        people. Now that "Nil" is considered undefined rather than a synonym
        for "()", it's easy to use "$0 // "default"" or some such to
        dereference a capture safely.
    *   Because a list-quantified subpattern returns a list of "Match"
        objects, the corresponding array element for the quantified capture
        will store a (nested) array rather than a single "Match" object. For
             if m/ (\w+) \: (\w+ \s+)* / {
                 say "Key:    $0";         # Unquantified --> single Match
                 say "Values: @($1)";      # Quantified   --> array of Match
  Indirectly quantified subpattern captures
    *   A subpattern may sometimes be nested inside a quantified
        non-capturing structure:
              #       non-capturing       quantifier
              #  __________/\____________  __/\__
              # |                        ||      |
              # |   $0         $1        ||      |
              # |  _^_      ___^___      ||      |
              # | |   |    |       |     ||      |
             m/ [ (\w+) \: (\w+ \h*)* \n ] ** 2..* /
        Non-capturing brackets *don't* create a separate nested lexical
        scope, so the two subpatterns inside them are actually still in the
        regex's top-level scope, hence their top-level designations: $0 and
        $1.
    *   However, because the two subpatterns are inside a quantified
        structure, $0 and $1 will each contain an array. The elements of
        that array will be the submatches returned by the corresponding
        subpatterns on each iteration of the non-capturing parentheses. For
             my $text = "foo:food fool\nbar:bard barb";
                       #   $0--     $1------
                       #   |   |    |       |
             $text ~~ m/ [ (\w+) \: (\w+ \h*)* \n ] ** 2..* /;
             # Because they're in a quantified non-capturing block...
             # $0 contains the equivalent of:
             #
             #       [ Match.new(str=>'foo'), Match.new(str=>'bar') ]
             # and $1 contains the equivalent of:
             #       [ Match.new(str=>'food '),
             #         Match.new(str=>'fool' ),
             #         Match.new(str=>'bard '),
             #         Match.new(str=>'barb' ),
             #       ]
    *   In contrast, if the outer quantified structure is a *capturing*
        structure (i.e. a subpattern) then it *will* introduce a nested
        lexical scope. That outer quantified structure will then return an
        array of "Match" objects representing the captures of the inner
        parens for *every* iteration (as described above). That is:
                       # $0-----------------------
                       # |                        |
                       # | $0[0]    $0[1]---      |
                       # | |   |    |       |     |
             $text ~~ m/ ( (\w+) \: (\w+ \h*)* \n ) ** 2..* /;
             # Because it's in a quantified capturing block,
             #       [ Match.new( str=>"foo:food fool\n",
             #                    arr=>[ Match.new(str=>'foo'),
             #                           [
             #                               Match.new(str=>'food '),
             #                               Match.new(str=>'fool'),
             #                           ]
             #                         ],
             #                  ),
             #         Match.new( str=>'bar:bard barb',
             #                    arr=>[ Match.new(str=>'bar'),
             #                               Match.new(str=>'bard '),
             #                               Match.new(str=>'barb'),
             # and there is no $1
    *   In other words, quantified non-capturing parens collect their
        components into handy flattened lists, whereas quantified capturing
        parens collect their components in a handy hierarchical structure.
        Additionally, the sublists are kept "in sync" with each other, as
        each empty match, in the case of $0[1] in our example if a ":" is
        followed by a newline character, will have a corresponding Nil in
        the given list.
  Subpattern numbering
    *   The index of a given subpattern can always be statically determined,
        but is not necessarily unique nor always monotonic. The numbering of
        subpatterns restarts in each lexical scope (either a regex, a
        subpattern, or the branch of an alternation).
    *   In particular, the index of capturing parentheses restarts after
        each "|" or "||" (but not after each "&" or "&&"). Hence:
                          # $0      $1    $2   $3    $4           $5
             $tune_up = rx/ ("don't") (ray) (me) (for) (solar tea), ("d'oh!")
                          # $0      $1      $2    $3        $4
                          | (every) (green) (BEM) (devours) (faces)
                          /;
        This means that if the second alternation matches, the list value of
        the match will contain "('every', 'green', 'BEM', 'devours',
        'faces')" rather than Perl 5's "(undef, undef, undef, undef, undef,
        undef, 'every', 'green', 'BEM', 'devours', 'faces')".
    *   Note that it is still possible to mimic the monotonic Perl 5 capture
        indexing semantics. See "Numbered scalar aliasing" below for
  Subrule captures
    *   Any call to a named "<regex>" within a pattern is known as a
        *subrule*, whether that regex is actually defined as a "regex" or
        "token" or "rule" or even an ordinary "method" or "multi".
    *   Any bracketed construct that is aliased (see "Aliasing" below) to a
        named variable is also a subrule.
    *   For example, this regex contains three subrules:
              # subrule       subrule     subrule
              #  __^__    _______^_____    __^__
              # |     |  |             |  |     |
             m/ <ident>  $<spaces>=(\s*)  <digit>+ /
    *   Just like subpatterns, each successfully matched subrule within a
        regex produces a "Match" object. But, unlike subpatterns, that
        "Match" object is not assigned to the array inside its parent
        "Match" object. Instead, it is assigned to an entry of the hash
        inside its parent "Match" object. For example:
              #  .... $/ .....................................
              # :                                             :
              # :              .... $/[0] ..................  :
              # :             :                             : :
              # : $/<ident>   :        $/[0]<ident>         : :
              # :   __^__     :           __^__             : :
              # :  |     |    :          |     |            : :
              ms/  <ident> \: ( known as <ident> previously ) /
  Accessing captured subrules
    *   The hash entries of a "Match" object can be referred to using any of
        the standard hash access notations ($/{'foo'}, "$/<bar>", "$/«baz»",
        etc.), or else via corresponding lexically scoped aliases ("$<foo>",
        "$«bar»", "$<baz>", etc.) So the previous example also implies:
              #    $<ident>             $0<ident>
              #     __^__                 __^__
              #    |     |               |     |
    *   Note that it makes no difference whether a subrule is
        angle-bracketed ("<ident>") or aliased internally ("<ident=.name>")
        or aliased externally ("$<ident>=(<.alpha>\w*)"). The name's the
        thing.
  Repeated captures of the same subrule
    *   If a subrule appears two (or more) times in any branch of a lexical
        scope (i.e. twice within the same subpattern and alternation), or if
        the subrule is list-quantified anywhere within a given scope (that
        is, by any quantifier other than "?"), then its corresponding hash
        entry is always assigned an array of "Match" objects rather than a
        single "Match" object.
    *   Successive matches of the same subrule (whether from separate calls,
        or from a single quantified repetition) append their individual
        "Match" objects to this array. For example:
             if ms/ mv <file> <file> / {
                 $from = $<file>[0];
                 $to   = $<file>[1];
        (Note, for clarity we are ignoring whitespace subtleties here--the
        normal sigspace rules would require space only between alphanumeric
        characters, which is wrong. Assume that our file subrule deals with
        whitespace on its own.)
        Likewise, with a quantified subrule:
             if ms/ mv <file> ** 2 / {
        And with a mixture of both:
             if ms/ mv <file>+ <file> / {
                 $to   = pop @($<file>);
                 @from = @($<file>);
    *   To avoid name collisions, you may suppress the original name by use
        of a leading dot, and then use an alias to give the capture a
        different name:
             if ms/ mv <file> <dir=.file> / {
                 $from = $<file>;  # Only one subrule named <file>, so scalar
                 $to   = $<dir>;   # The Capture Formerly Known As <file>
        Likewise, neither of the following constructions causes "<file>" to
        produce an array of "Match" objects, since none of them has two or
        more "<file>" subrules in the same lexical scope:
             if ms/ (keep) <file> | (toss) <file> / {
                 # Each <file> is in a separate alternation, therefore <file>
                 # is not repeated in any one scope, hence $<file> is
                 # not an Array object...
                 $action = $0;
                 $target = $<file>;
             if ms/ <file> \: (<file>|none) / {
                 # Second <file> nested in subpattern which confers a
                 # different scope...
                 $actual  = $/<file>;
                 $virtual = $/[0]<file> if $/[0]<file>;
    *   On the other hand, unaliased square brackets don't confer a separate
        scope (because they don't have an associated "Match" object). So:
             if ms/ <file> \: [<file>|none] / { # Two <file>s in same scope
                 $actual  = $/<file>[0];
                 $virtual = $/<file>[1] if $/<file>[1];
  Aliasing
    Aliases can be named or numbered. They can be scalar-, array-, or
    hash-like. And they can be applied to either capturing or non-capturing
    constructs. The following sections highlight special features of the
    semantics of some of those combinations.
   Named scalar aliasing to subpatterns
    *   If a named scalar alias is applied to a set of *capturing* parens:
                #         _____/capturing parens\_____
                #        |                            |
              ms/ $<key>=( (<[A..E]>) (\d**3..6) (X?) ) /;
        then the outer capturing parens no longer capture into the array of
        $/ as unaliased parens would. Instead the aliased parens capture
        into the hash of $/; specifically into the hash element whose key is
        the alias name.
    *   So, in the above example, a successful match sets "$<key>" (i.e.
        "$/<key>"), but *not* $0 (i.e. not $/[0]).
    *   More specifically:
        *   "$/<key>" will contain the "Match" object that would previously
            have been placed in $/[0].
        *   "$/<key>[0]" will contain the A-E letter,
        *   "$/<key>[1]" will contain the digits,
        *   "$/<key>[2]" will contain the optional X.
    *   Another way to think about this behavior is that aliased parens
        create a kind of lexically scoped named subrule; that the contents
        of the parentheses are treated as if they were part of a separate
        subrule whose name is the alias.
   Named scalar aliases applied to non-capturing brackets
    *   If a named scalar alias is applied to a set of *non-capturing*
        brackets:
                #         __/non-capturing brackets\__
              ms/ $<key>=[ (<[A..E]>) (\d**3..6) (X?) ] /;
        then the corresponding "$/<key>" "Match" object contains only the
        string matched by the non-capturing brackets.
    *   In particular, the array of the "$/<key>" entry is empty. That's
        because square brackets do not create a nested lexical scope, so the
        subpatterns are unnested and hence correspond to $0, $1, and $2, and
        *not* to "$/<key>[0]", "$/<key>[1]", and "$/<key>[2]".
    *   In other words:
        *   "$/<key>" will contain the complete substring matched by the
            square brackets (in a "Match" object, as described above),
        *   $0 will contain the A-E letter,
        *   $1 will contain the digits,
        *   $2 will contain the optional X.
   Named scalar aliasing to subrules
    *   If a subrule is aliased, it assigns its "Match" object to the hash
        entry whose key is the name of the alias, as well as to the original
        name.
             if m/ ID\: <id=ident> / {
                 say "Identified as $/<id> and $/<ident>";    # both names defined
        To suppress the original name, use the dot form:
             if m/ ID\: <id=.ident> / {
                 say "Identified as $/<id>";    # $/<ident> is undefined
    *   Hence aliasing a dotted subrule *changes* the destination of the
        subrule's "Match" object. This is particularly useful for
        differentiating two or more calls to the same subrule in the same
        scope. For example:
             if ms/ mv <file>+ <dir=.file> / {
                 $to   = $<dir>;
   Numbered scalar aliasing
    *   If a numbered alias is used instead of a named alias:
             m/ $1=(<-[:]>*) \:  $0=<ident> /   # captures $<ident> too
             m/ $1=(<-[:]>*) \:  $0=<.ident> /  # doesn't capture $<ident>
        the behavior is exactly the same as for a named alias (i.e. the
        various cases described above), except that the resulting "Match"
        object is assigned to the corresponding element of the appropriate
        array rather than to an element of the hash.
    *   If any numbered alias is used, the numbering of subsequent unaliased
        subpatterns in the same scope automatically increments from that
        alias number (much like enum values increment from the last explicit
        value). That is:
              #  --$1---    -$2-    --$6---    -$7-
              # |       |  |    |  |       |  |    |
             m/ $1=(food)  (bard)  $6=(bazd)  (quxd) /;
    *   This *follow-on* behavior is particularly useful for reinstituting
        Perl 5 semantics for consecutive subpattern numbering in
        alternations:
                          | $6 = (every) (green) (BEM) (devours) (faces)
                          #              $7      $8    $9        $10
    *   It also provides an easy way in Perl 6 to reinstitute the unnested
        numbering semantics of nested Perl 5 subpatterns:
              #               $1
              #  _____________/\___________
              # |    $2        $3      $4  |
              # |  __/\___   __/\___   /\  |
              # | |       | |       | |  | |
             m/ ( ( [A-E] ) (\d{3,6}) (X?) ) /x;
              #                $0
              #  ______________/\______________
              # |   $0[0]       $0[1]    $0[2] |
              # |  ___/\___   ____/\____   /\  |
              # | |        | |          | |  | |
             m/ ( (<[A..E]>) (\d ** 3..6) (X?) ) /;
              # Perl 6 simulating Perl 5...
              #                 $1
              #  _______________/\________________
              # |        $2          $3       $4  |
              # |     ___/\___   ____/\____   /\  |
              # |    |        | |          | |  | |
             m/ $1=[ (<[A..E]>) (\d ** 3..6) (X?) ] /;
        The non-capturing brackets don't introduce a scope, so the
        subpatterns within them are at regex scope, and hence numbered at
        the top level. Aliasing the square brackets to $1 means that the
        next subpattern at the same level (i.e. the "(<[A..E]>)") is
        numbered sequentially (i.e. $2), etc.
   Scalar aliases applied to quantified constructs
    *   All of the above semantics apply equally to aliases which are bound
        to quantified structures.
    *   The only difference is that, if the aliased construct is a subrule
        or subpattern, that quantified subrule or subpattern will have
        returned a list of "Match" objects (as described in "Quantified
        subpattern captures" and "Repeated captures of the same subrule").
        So the corresponding array element or hash entry for the alias will
        contain an array, instead of a single "Match" object.
    *   In other words, aliasing and quantification are completely
        orthogonal. For example:
             if ms/ mv $0=<.file>+ / {
                 # <file>+ returns a list of Match objects,
                 # so $0 contains an array of Match objects,
                 # one for each successful call to <file>
                 # $/<file> does not exist (it's suppressed by the dot)
             if m/ mv \s+ $<from>=(\S+ \s+)* / {
                 # Quantified subpattern returns a list of Match objects,
                 # so $/<from> contains an array of Match
                 # objects, one for each successful match of the subpattern
                 # $0 does not exist (it's pre-empted by the alias)
    *   Note, however, that a set of quantified *non-capturing* brackets
        always returns a single "Match" object which contains only the
        complete substring that was matched by the full set of repetitions
        of the brackets (as described in "Named scalar aliases applied to
        non-capturing brackets"). For example:
             "coffee fifo fumble" ~~ m/ $<effs>=[f <-[f]> ** 1..2 \s*]+ /;
             say $<effs>;    # prints "fee fifo fum"
   Array aliasing
    *   An alias can also be specified using an array as the alias instead
        of a scalar. For example:
             m/ mv \s+ @<from>=[(\S+) \s+]* <dir> /;
    *   Using the "@alias=" notation instead of a "$alias=" mandates that
        the corresponding hash entry or array element *always* receives an
        array of "Match" objects, even if the construct being aliased would
        normally return a single "Match" object. This is useful for creating
        consistent capture semantics across structurally different
        alternations (by enforcing array captures in all branches):
             ms/ Mr?s? @<names>=<ident> W\. @<names>=<ident>
                | Mr?s? @<names>=<ident>
                /;
             # Aliasing to @names means $/<names> is always
             # an Array object, so...
             say @($/<names>);
    *   For convenience and consistency, "@<key>" can also be used outside a
        regex, as a shorthand for "@( $/<key> )". That is:
             say @<names>;
    *   If an array alias is applied to a quantified pair of non-capturing
        brackets, it captures the substrings matched by each repetition of
        the brackets into separate elements of the corresponding array. That
             ms/ mv $<files>=[ f.. \s* ]* /; # $/<files> assigned a single
                                             # Match object containing the
                                             # complete substring matched by
                                             # the full set of repetitions
                                             # of the non-capturing brackets
             ms/ mv @<files>=[ f.. \s* ]* /; # $/<files> assigned an array,
                                             # each element of which is a
                                             # Match object containing
                                             # the substring matched by Nth
                                             # repetition of the non-
                                             # capturing bracket match
    *   If an array alias is applied to a quantified pair of capturing
        parens (i.e. to a subpattern), then the corresponding hash or array
        element is assigned a list constructed by concatenating the array
        values of each "Match" object returned by one repetition of the
        subpattern. That is, an array alias on a subpattern flattens and
        collects all nested subpattern captures within the aliased
        subpattern. For example:
             if ms/ $<pairs>=( (\w+) \: (\N+) )+ / {
                 # Scalar alias, so $/<pairs> is assigned an array
                 # of Match objects, each of which has its own array
                 # of two subcaptures...
                 for @($<pairs>) -> $pair {
                     say "Key: $pair[0]";
                     say "Val: $pair[1]";
             if ms/ @<pairs>=( (\w+) \: (\N+) )+ / {
                 # Array alias, so $/<pairs> is assigned an array
                 # of Match objects, each of which is flattened out of
                 # the two subcaptures within the subpattern
                 for @($<pairs>) -> $key, $val {
                     say "Key: $key";
                     say "Val: $val";
    *   Likewise, if an array alias is applied to a quantified subrule, then
        the hash or array element corresponding to the alias is assigned a
        list containing the array values of each "Match" object returned by
        each repetition of the subrule, all flattened into a single array:
             rule pair { (\w+) \: (\N+) \n }
             if ms/ $<pairs>=<pair>+ / {
                 # Scalar alias, so $/<pairs> contains an array of
                 # Match objects, each of which is the result of the
                 # <pair> subrule call...
             if ms/ mv @<pairs>=<pair>+ / {
                 # Array alias, so $/<pairs> contains an array of
                 # Match objects, all flattened down from the
                 # nested arrays inside the Match objects returned
                 # by each match of the <pair> subrule...
    *   In other words, an array alias is useful to flatten into a single
        array any nested captures that might occur within a quantified
        subpattern or subrule. Whereas a scalar alias is useful to preserve
        within a top-level array the internal structure of each repetition.
    *   It is also possible to use a numbered variable as an array alias.
        The semantics are exactly as described above, with the sole
        difference being that the resulting array of "Match" objects is
        assigned into the appropriate element of the regex's match array
        rather than to a key of its match hash. For example:
             if m/ mv  \s+  @0=((\w+) \s+)+  $1=((\W+) (\s*))* / {
                 #          |                |
                 #          |                 \_ Scalar alias, so $1 gets an
                 #          |                    array, with each element
                 #          |                    a Match object containing
                 #          |                    the two nested captures
                 #          |
                 #           \___ Array alias, so $0 gets a flattened array of
                 #                just the (\w+) captures from each repetition
                 @from     = @($0);      # Flattened list
                 $to_str   = $1[0][0];   # Nested elems of
                 $to_gap   = $1[0][1];   #    unflattened list
    *   Note again that, outside a regex, @0 is simply a shorthand for
        "@($0)", so the first assignment above could also have been written:
             @from = @0;
   Hash aliasing
    *   An alias can also be specified using a hash as the alias variable,
        instead of a scalar or an array. For example:
             m/ mv %<location>=( (<ident>) \: (\N+) )+ /;
    *   A hash alias causes the corresponding hash or array element in the
        current scope's "Match" object to be assigned a (nested) Hash object
        (rather than an "Array" object or a single "Match" object).
    *   If a hash alias is applied to a subrule or subpattern then the first
        nested numeric capture becomes the key of each hash entry and any
        remaining numeric captures become the values (in an array if there
        is more than one).
    *   As with array aliases it is also possible to use a numbered variable
        as a hash alias. Once again, the only difference is where the
        resulting "Match" object is stored:
             rule one_to_many {  (\w+) \: (\S+) (\S+) (\S+) }
             if ms/ %0=<one_to_many>+ / {
                 # $/[0] contains a hash, in which each key is provided by
                 # the first subcapture within C<one_to_many>, and each
                 # value is an array containing the
                 # subrule's second, third, fourth, etc. subcaptures...
                 for %($/[0]) -> $pair {
                     say "One:  $pair.key()";
                     say "Many: { @($pair.value) }";
    *   Outside the regex, %0 is a shortcut for "%($0)":
                 for %0 -> $pair {
                     say "Many: @($pair.value)";
   External aliasing
    *   Instead of using internal aliases like:
             m/ mv  @<files>=<ident>+  $<dir>=<ident> /
        the name of an ordinary variable can be used as an *external* alias,
        like so:
             m/ mv  @OUTER::files=<ident>+  $OUTER::dir=<ident> /
    *   In this case, the behavior of each alias is exactly as described in
        the previous sections, except that any resulting capture is bound
        directly (but still hypothetically) to the variable of the specified
        name that must already exist in the scope in which the regex is
        declared.
  Capturing from repeated matches
    *   When an entire regex is successfully matched with repetitions
        (specified via the ":x" or ":g" flag) or overlaps (specified via the
        ":ov" or ":ex" flag), it will usually produce a sequence of distinct
        matches.
    *   A successful match under any of these flags still returns a single
        "Match" object in $/. However, this object may represent a partial
        evaluation of the regex. Moreover, the values of this match object
        are slightly different from those provided by a non-repeated match:
        *   The boolean value of $/ after such matches is true or false,
            depending on whether the pattern matched.
        *   The string value is the substring from the start of the first
            match to the end of the last match (*including* any intervening
            parts of the string that the regex skipped over in order to find
            later matches).
        *   Subcaptures are returned as a multidimensional list, which the
            user can choose to process in either of two ways. If you refer
            to "@().flat" (or just use "@()" in a flat list context), the
            multidimensionality is ignored and all the matches are returned
            flattened (but still lazily). If you refer to "lol()", you can
            get each individual sublist as a "List" object. As with any
            multidimensional list, each sublist can be lazy separately.
             if $text ~~ ms:g/ (\S+:) <rocks> / {
                 say "Full match context is: [$/]";
        But the list of individual match objects corresponding to each
        separate match is also available:
                 say "Matched { +lol() } times";    # Note: forced eager here by +
                 for lol() -> $m {
                     say "Match between $m.from() and $m.to()";
                     say 'Right on, dude!' if $m[0] eq 'Perl';
                     say "Rocks like $m<rocks>";
Grammars
    *   Your private "ident" rule shouldn't clobber someone else's "ident"
        rule. So some mechanism is needed to confine rules to a namespace.
    *   If subs are the model for rules, then modules/classes are the
        obvious model for aggregating them. Such collections of rules are
        generally known as *grammars*.
    *   Just as a class can collect named actions together:
             class Identity {
                 method name { "Name = $!name" }
                 method age  { "Age  = $!age"  }
                 method addr { "Addr = $!addr" }
                 method desc {
                     print &.name(), "\n",
                           &.age(),  "\n",
                           &.addr(), "\n";
                 # etc.
        so too a grammar can collect a set of named rules together:
             grammar Identity {
                 rule name { Name '=' (\N+) }
                 rule age  { Age  '=' (\d+) }
                 rule addr { Addr '=' (\N+) }
                 rule desc {
                     <name> \n
                     <age>  \n
                     <addr> \n
    *   Like classes, grammars can inherit:
             grammar Letter {
                 rule text     { <greet> $<body>=<line>+? <close> }
                 rule greet    { [Hi|Hey|Yo] $<to>=\S+? ',' }
                 rule close    { Later dude ',' $<from>=.+ }
                 token line    { \N* \n}
             grammar FormalLetter is Letter {
                 rule greet { Dear $<to>=\S+? ',' }
                 rule close { Yours sincerely ',' $<from>=.+ }
    *   Just like the methods of a class, the rule definitions of a grammar
        are inherited (and polymorphic!). So there's no need to respecify
        "text", "line", etc.
    *   Perl 6 will come with at least one grammar predefined:
             grammar STD {    # Perl's own standard grammar
                 rule prog { <statement>* }
                 rule statement {
                           | <decl>
                           | <loop>
                           | <label> [<cond>|<sideff>|';']
                 rule decl { <sub> | <class> | <use> }
                 # etc. etc. etc.
    *   Hence:
             $parsetree = STD.parse($source_code)
    *   To switch to a different grammar in the middle of a regex, you may
        use the ":lang" adverb. For example, to match an expression <expr>
        from $funnylang that is embedded in curlies, say:
            token funnylang { '{' [ :lang($funnylang.unbalanced('}')) <expr> ] '}' }
    *   A string can be matched against a grammar by calling ".parse" or
        ".parsefile" on the grammar, and optionally pass an *actions* object
        to that grammar:
            MyGrammar.parse($string, :actions($action-object))
            MyGrammar.parsefile($filename, :actions($action-object))
        This creates a "Grammar" object, whose type denotes the current
        language being parsed, and from which other grammars may be derived
        as extended languages. All grammar objects are derived from
        "Cursor", so every grammar object's value embodies the current state
        of the current match. This new grammar object is then passed as the
        invocant to the "TOP" method (regex, token, or rule) of "MyGrammar".
        The default rule name to call can be overridden with the ":rule"
        named argument of the "parse" method. This is useful for unit
        testing the rules of a grammar. As methods, rules can have
        arguments, so the ":args" named argument is used to pass such
        arguments as a list if necessary.
        Grammar objects are considered immutable, so every match returns a
        different match state, and multiple match states may exist
        simultaneously. Each such match state is considered a hypothesis on
        how the pattern will eventually match. A backtrackable choice in
        pattern matching may be easily represented in Perl 6 as a lazy list
        of match state cursors; backtracking consists of merely throwing
        away the front value of the list and continuing to match with the
        next value. Hence, the management of these match cursors controls
        how backtracking works, and falls naturally out of the lazy list
        paradigm.
        The ".parse" and ".parsefile" methods anchor to the beginning and
        ending of the text, and fail if the end of text is not reached. (The
        "TOP" rule can check against "$" itself if it wishes to produce its
        own error message.)
        If you wish to parse a portion of a text, then use the ".subparse"
        method instead. You may pass a ":pos" argument to start parsing at
        some position other than 0. You may pass a ":rule" argument to
        specify which subrule you're wanting to call. The final position can
        be determined by examining the returned "Match" object.
Action objects
    Action objects (provided via the ":actions" named argument in
    "Grammar.parse") are objects whose methods correspond to the rules in a
    grammar. When a rule in a grammar matches, any method in the actions
    object with the same name (if there is one) is used to build the AST for
    the "Match" the grammar is building. Action methods should have a single
    parameter (by convention, $/) that contains the "Match" object for the
    rule. Action methods are invoked as soon as the corresponding rule has a
    successful match, regardless of if the match occurs in a zero-width
    match or in a backtracking branch that may eventually fail, so state
    should be tracked via the AST and side effects may cause unexpected
    behavior.
    Action methods are called within the call frame for the rule, so dynamic
    variables set in the rule are passed along to the action method.
Syntactic categories
    For writing your own backslash and assertion subrules, you may augment
    (your copy of) the Regex sublanguage, using the following syntactic
    categories:
        augment slang Regex {
            token backslash:sym<y> { ... }   # define your own \y and \Y
            token assertion:sym<*> { ... }   # define your own <*stuff>
            token metachar:sym<,> { ... }    # define a new metacharacter
            multi method tweak (:$x) {...}   # define your own :x modifier
Pragmas
    Various pragmas may be used to control various aspects of regex
    compilation and usage not otherwise provided for. These are tied to the
    particular declarator in question:
        use s :foo;         # control s defaults
        use m :foo;         # control m defaults
        use rx :foo;        # control rx defaults
        use regex :foo;     # control regex defaults
        use token :foo;     # control token defaults
        use rule :foo;      # control rule defaults
    (It is a general policy in Perl 6 that any pragma designed to influence
    the surface behavior of a keyword is identical to the keyword itself,
    unless there is good reason to do otherwise. On the other hand, pragmas
    designed to influence deep semantics should not be named identically,
    though of course some similarity is good.)
Transliteration
    *   The "tr///" quote-like operator now also has a method form called
        "trans()". Its argument is a list of pairs. You can use anything
        that produces a pair list:
             $str.trans( %mapping.pairs );
        Use the ".=" form to do a translation in place:
             $str.=trans( %mapping.pairs );
        (Perl 6 does not support the "y///" form, which was only in "sed"
        because they were running out of single letters.)
    *   The two sides of any pair can be strings interpreted as "tr///"
        would:
             $str.=trans( 'A..C' => 'a..c', 'XYZ' => 'xyz' );
        As a degenerate case, each side can be individual characters:
             $str.=trans( 'A'=>'a', 'B'=>'b', 'C'=>'c' );
        Whitespace characters are taken literally as characters to be
        translated from or to. The ".." range sequence is the only
        metasyntax recognized within a string, though you may of course use
        backslash interpolations in double quotes. If the right side is too
        short, the final character is replicated out to the length of the
        left string. If there is no final character because the right side
        is the null string, the result is deletion instead.
    *   Either or both sides of the pair may also be Array objects:
             $str.=trans( ['A'..'C'] => ['a'..'c'], <X Y Z> => <x y z> );
        The array version is the underlying primitive form: the semantics of
        the string form is exactly equivalent to first doing ".." expansion
        and then splitting the string into individual characters and then
        using that as an array.
    *   The array version can map one-or-more characters to one-or-more
        characters:
             $str.=trans( [' ',      '<',    '>',    '&'    ] =>
                          ['&nbsp;', '&lt;', '&gt;', '&amp;' ]);
        In the case that more than one sequence of input characters matches,
        the longest one wins. In the case of two identical sequences the
        first in order wins.
        As with the string form, missing righthand elements replicate the
        final element, and a null array results in deletion instead.
    *   The recognition done by the string and array forms is very basic. To
        achieve greater power, any recognition element of the left side may
        be specified by a regex that can do character classes, lookahead,
            $str.=trans( [/ \h /,   '<',    '>',    '&'    ] =>
                         ['&nbsp;', '&lt;', '&gt;', '&amp;' ]);
            $str.=trans( / \s+ / => ' ' );  # squash all whitespace to one space
            $str.=trans( / <-alpha> / => '' );  # delete all non-alpha
        These submatches are mixed into the overall match in exactly the
        same way that they are mixed into parallel alternation in ordinary
        regex processing, so longest token rules apply across all the
        possible matches specified to the transliteration operator. Once a
        match is made and transliterated, the parallel matching resumes at
        the new position following the end of the previous match, even if it
        matched multiple characters.
    *   If the right side of the arrow is a closure, it is evaluated to
        determine the replacement value. If the left side was matched by a
        regex, the resulting match object is available within the closure.
Substitution
    There are also method forms of "m//" and "s///":
         $str.match(/pat/);
         $str.subst(/pat/, "replacement");
         $str.subst(/pat/, {"replacement"});
         $str.=subst(/pat/, "replacement");
         $str.=subst(/pat/, {"replacement"});
    The ".match" and ".subst" methods support the adverbs of "m//" and
    "s///" as named arguments, so you can write
        $str.match(/pat/, :g)
    as an equivalent to
        $str.comb(/pat/, :match)
    There is no syntactic sugar here, so in order to get deferred evaluation
    of the replacement you must put it into a closure. The syntactic sugar
    is provided only by the quotelike forms. First there is the standard
    "triple quote" form:
        s/pattern/replacement/
    Only non-bracket characters may be used for the "triple quote". The
    right side is always evaluated as if it were a double-quoted string
    regardless of the quote chosen.
    As with Perl 5, a bracketing form is also supported, but unlike Perl 5,
    Perl 6 uses the brackets *only* around the pattern. The replacement is
    then specified as if it were an ordinary item assignment, with ordinary
    quoting rules. To pick your own quotes on the right just use one of the
    "q" forms. The substitution above is equivalent to:
        s[pattern] = "replacement"
        s[pattern] = qq[replacement]
    This is not a normal assignment, since the right side is evaluated each
    time the substitution matches (much like the pseudo-assignment to
    declarators can happen at strange times). It is therefore treated as a
    "thunk", that is, it will be called as a chunk of code that creates a
    dynamic scope but not a lexical scope. (You can also think of a thunk as
    a closure that uses the current lexical scope parasitically.) In fact,
    it makes no sense at all to say
        s[pattern] = { doit }
    because that would try to substitute a closure into the string.
    Any scalar assignment operator may be used; the substitution macro knows
    how to turn
        $target ~~ s:g[pattern] op= expr
    into something like:
        $target.=subst(rx[pattern], { $() op expr }, :g)
    (The actual implementation of "s///" must return a "Match" to make
    smartmatch work right. The rewrite above merely returns the changed
    string.)
    So, for example, you can multiply every dollar amount by 2 with:
        s:g[\$ <( \d+ )>] *= 2
    (Of course, the optimizer is free to do something faster than an actual
    method call.)
    You'll note from the last example that substitutions only happen on the
    "official" string result of the match, that is, the portion of the
    string between the "$/.from" and "$/.to" positions. (Here we set those
    explicitly using the "<(...)>" pair; otherwise we would have had to use
    lookbehind to match the "$".)
    Please note that the ":ii"/":samecase" and ":mm"/":samemark" switches
    are really two different modifiers in one, and when the compiler
    desugars the quote-like forms it distributes semantics to both the
    pattern and the replacement. That is, ":ii" on the replacement implies a
    ":i" on the pattern, and ":mm" implies ":m". The proper method
    equivalents to:
        s:ii/foo/bar/
        s:mm/boo/far/
    are not:
        .subst(/foo/, 'bar', :ii)   # WRONG
        .subst(/boo/, 'far', :mm)   # WRONG
    but rather:
        .subst(rx:i/foo/, 'bar', :ii)   # okay
        .subst(rx:m/boo/, 'far', :mm)   # okay
    It is specifically *not* required of an implementation that it treat the
    regexes as generic with respect to case and mark. Retroactive
    recompilation is considered harmful. If an implementation does do lazy
    generic case and mark semantics, it is erroneous and non-portable for a
    program to depend on it.
    One other difference between the "s///" and ".subst" forms is that,
    while ".subst" returns the modified string (and cannot, therefore, be
    used as a smart matcher), the "s///" form always returns either a
    "Match" object to indicate to smartmatch that it was successful, or a
    "Nil" value to indicate that it was not.
    Likewise, for both "m:g" matches and "s:g" substitutions, there may be
    multiple matches found. These constructs must still continue to work
    under smartmatching while returning a list of matches. Fortunately,
    "List" is one of the distinguished types that a matcher may return to
    indicate success or failure. So these construct simply return the list
    of successful matches, which will be empty (and hence false) if no
    matches occurred.
Positional matching, fixed width types
    *   To anchor to a particular position in the general case you can use
        the "<at($pos)>" assertion to say that the current position is the
        same as the position object you supply. You may set the current
        match position via the ":c" and ":p" modifiers.
        However, please remember that in Perl 6 string positions are
        generally *not* integers, but objects that point to a particular
        place in the string regardless of whether you count by bytes or
        codepoints or graphemes. If used with an integer, the "at" assertion
        will assume you mean the current lexically scoped Unicode level, on
        the assumption that this integer was somehow generated in this same
        lexical scope. If this is outside the current string's allowed
        Unicode abstraction levels, an exception is thrown. See S02 for more
        discussion of string positions.
    *   "Buf" types are based on fixed-width cells and can therefore handle
        integer positions just fine, and treat them as array indices. In
        particular, "buf8" (also known as "buf") is just an old-school byte
        string. Matches against "Buf" types are restricted to ASCII
        semantics in the absence of an *explicit* modifier asking for the
        array's values to be treated as some particular encoding such as
        UTF-32. (This is also true for those compact arrays that are
        considered isomorphic to "Buf" types.) Positions within "Buf" types
        are always integers, counting one per unit cell of the underlying
        array. Be aware that "from" and "to" positions are reported as being
        between elements. If matching against a compact array @foo, a final
        position of 42 indicates that @foo[42] was the first element *not*
        included.
Matching against non-strings
    *   Anything that can be tied to a string can be matched against a
        regex. This feature is particularly useful with input streams:
             my $stream := cat $fh.lines;       # tie scalar to filehandle
             $stream ~~ m/pattern/;         # match from stream
    *   Any non-compact array of mixed strings or objects can be matched
        against a regex as long as you present them as an object with the
        "Str" interface, which does not preclude the object having other
        interfaces such as "Array". Normally you'd use "cat" to generate
        such an object:
            @array.cat ~~ / foo <,> bar <elem>* /;
        The special "<,>" subrule matches the boundary between elements. The
        "<elem>" assertion matches any individual array element. It is the
        equivalent of the "dot" metacharacter for the whole element.
        If the array elements are strings, they are concatenated virtually
        into a single logical string. If the array elements are tokens or
        other such objects, the objects must provide appropriate methods for
        the kinds of subrules to match against. It is an assertion failure
        to match a string-matching assertion against an object that doesn't
        provide a stringified view. However, pure object lists can be parsed
        as long as the match (including any subrules) restricts itself to
        assertions like:
             <.isa(Dog)>
             <.does(Bark)>
             <.can('scratch')>
        It is permissible to mix objects and strings in an array as long as
        they're in different elements. You may not embed objects in strings,
        however. Any object may, of course, pretend to be a string element
        if it likes, and so a "Cat" object may be used as a substring with
        the same restrictions as in the main string.
        Please be aware that the warnings on ".from" and ".to" returning
        opaque objects goes double for matching against an array, where a
        particular position reflects both a position within the array and
        (potentially) a position within a string of that array. Do not
        expect to do math with such values. Nor should you expect to be able
        to extract a substr that crosses element boundaries. [Conjecture: Or
        should you?]
    *   To match against every element of an array, use a hyper operator:
             @array».match($regex);
    *   To match against any element of the array, it suffices to use
        ordinary smartmatching:
            @array ~~ $regex;
When $/ is valid
    To provide implementational freedom, the $/ variable is not guaranteed
    to be defined until the pattern reaches a sequence point that requires
    it (such as completing the match, or calling an embedded closure, or
    even evaluating a submatch that requires a Perl expression for its
    argument). Within regex code, $/ is officially undefined, and references
    to $0 or other capture variables may be compiled to produce the current
    value without reference to $/. Likewise a reference to "$<foo>" does not
    necessarily mean "$/<foo>" within the regex proper. During the execution
    of a match, the current match state is actually stored in a $¢ variable
    lexically scoped to an appropriate portion of the match, but that is not
    guaranteed to behave the same as the $/ object, because $/ is of type
    "Match", while the match state is of a type derived from "Cursor".
    In any case this is all transparent to the user for simple matches; and
    outside of regex code (and inside closures within the regex) the $/
    variable is guaranteed to represent the state of the match at that
    point. That is, normal Perl code can always depend on "$<foo>" meaning
    "$/<foo>", and $0 meaning $/[0], whether that code is embedded in a
    closure within the regex or outside the regex after the match completes.
        Damian Conway <damian@conway.org>
        Allison Randal <al@shadowed.net>
        Patrick Michaud <pmichaud@pobox.com>
    Synopsis 6: Subroutines
        Created: 21 Mar 2003
        Version: 169
    This document summarizes Apocalypse 6, which covers subroutines and the
    new type system.
Subroutines and other code objects
    "Routine" is the parent type of all keyword-declared code blocks. All
    routines are born with undefined values of $_, $!, and $/, unless the
    routine declares them otherwise explicitly. A compilation unit, such as
    a module file or an "EVAL" string, is also considered a routine, or you
    would not be able to reference $! or $/ in them.
    Non-routine code "Block"s, declared with "->" or with bare curlies, are
    born only with $_, which is aliased to its OUTER::<$_> unless bound as a
    parameter. A block generally uses the $! and $/ defined by the innermost
    enclosing routine, unless $! or $/ is explicitly declared in the block.
    A thunk is a piece of code that may not execute immediately, for
    instance because it is part of a conditional operator, or a default
    initialization of an attribute. It has no scope of its own, so any new
    variables defined in a thunk, will leak to the scope that they're in.
    Note however that any and all lazy constructs, whether block-based or
    thunk-based, such as gather or start or "==>" should declare their own
    $/ and $! so that the user's values for those variables cannot be
    clobbered asynchronously.
    Subroutines (keyword: "sub") are non-inheritable routines with parameter
    lists.
    Methods (keyword: "method") are inheritable routines which always have
    an associated object (known as their invocant) and belong to a
    particular kind or class.
    Submethods (keyword: "submethod") are non-inheritable methods, or
    subroutines masquerading as methods. They have an invocant and belong to
    a particular kind or class.
    Regexes (keyword: "regex") are methods (of a grammar) that perform
    pattern matching. Their associated block has a special syntax (see
    Synopsis 5). (We also use the term "regex" for anonymous patterns of the
    traditional form.)
    Tokens (keyword: "token") are regexes that perform low-level
    non-backtracking (by default) pattern matching.
    Rules (keyword: "rule") are regexes that perform non-backtracking (by
    default) pattern matching (and also enable rules to do whitespace
    dwimmery).
    Macros (keyword: "macro" or "slang") are routines or methods that are
    installed such that they will be called as part of the compilation
    process, and which can therefore take temporary control of the
    subsequent compilation to cheat in any of the ways that a compiler might
    cheat.
Routine modifiers
    Multis (keyword: "multi") are routines that can have multiple variants
    that share the same name, selected by arity, types, or some other
    constraints.
    Prototypes (keyword: "proto") specify the commonalities (such as
    parameter names, fixity, and associativity) shared by all multis of that
    name in the scope of the "proto" declaration. Abstractly, the "proto" is
    a generic wrapper around the dispatch to the "multi"s. Each "proto" is
    instantiated into an actual dispatcher for each scope that needs a
    different candidate list.
    Only (keyword: "only") routines do not share their short names with
    other routines. This is the default modifier for all routines, unless a
    "proto" of the same name was already in scope. (For subs, the governing
    "proto" must have been declared in the same file, so "proto"
    declarations from the setting or other modules don't have this effect
    unless explicitly imported.)
    A modifier keyword may occur before the routine keyword in a named
    routine:
        only sub foo {...}
        proto sub foo {...}
        dispatch sub foo {...}      # internal
        multi sub foo {...}
        only method bar {...}
        proto method bar {...}
        dispatch method bar {...}   # internal
        multi method bar {...}
    If the routine keyword is omitted, it defaults to "sub".
    Modifier keywords cannot apply to anonymous routines.
    A "proto" is a generic dispatcher, which any given scope with a unique
    candidate list will instantiate into a "dispatch" routine. Hence a
    "proto" is never called directly, much like a "role" can't be used as an
    instantiated object.
    When you call any routine (or method, or rule) that may have multiple
    candidates, the basic dispatcher is really only calling an "only" sub or
    method--but if there are multiple candidates, the "only" that will be
    found is really a dispatcher. This instantiated "dispatch" is always
    called first (at least in the abstract--this can often be optimized
    away). In essence, a "dispatch" is dispatched exactly like an "only"
    sub, but the "dispatch" itself may delegate to any of the candidates it
    is "managing".
    It is the "dispatch"'s responsibility to first vet the arguments for all
    the candidates; any call that does not successfully bind the
    "dispatch"'s signature fails outright. (Its signature is a copy of one
    belonging to the "proto" from which it was instantiated.) The "dispatch"
    does not necessarily send the original capture to its candidates,
    however. Named arguments that bind to positionals in the "dispatch" sig
    will become positionals for all subsequent calls to its managed multis.
    The dispatch then considers its list of managed candidates from the
    viewpoint of the caller or object, sorts them into some order, and
    dispatches them according to the rules of multiple dispatch as defined
    for each of the various dispatchers. In the case of multi subs, the
    candidate list is known at compile time. In the case of multi methods,
    it may be necessary to generate (or regenerate) the candidate list at
    run time, depending on what is known when about the inheritance tree.
    This default dispatch behavior is symbolized within the original "proto"
    by a block containing of a single "*" (that is, a "whatever"). Hence the
    typical "proto" will simply have a body of "{*}".
        proto method bar {*}
    (We don't use "..." for that because it would fail at run time, and the
    proto's instantiated "dispatch" blocks are not stubs, but are intended
    to be executed.)
    Other statements may be inserted before and after the "{*}" statement to
    capture control before or after the multi dispatch:
        proto foo ($a,$b) { say "Called with $a $b"; {*}; say "Returning"; }
    (That "proto" is only good for "multi"s with side effects and no return
    value, since it returns the result of "say", which might not be what you
    want. See below for how to fix that.)
    The syntactic form &foo (without a modifying signature) can never refer
    to a "multi" candidate or a generic "proto". It may only refer to the
    single "only" or "dispatch" routine that would first be called by
    "foo()". Individual "multi"s may be named by appending a signature to
    the noun form: "&foo:($,$,*@)".
    We used the term "managed" loosely above to indicate the set of "multi"s
    in question; the "managed set" is more accurately defined as the
    intersection of all the "multi"s in the "proto"'s downward scope with
    all the "multi"s that are visible to the caller's upward-looking scope.
    For ordinary routines this means looking down lexical scopes and looking
    up lexical scopes. [This is more or less how "multi"s already behave.]
    For methods this means looking down or up the inheritance tree; "managed
    set" in this case translates to the intersection of all methods in the
    "proto"'s class or its subclasses with all "multi" methods visible to
    the object in its parent classes, that is, the parent classes of the
    object's actual type on whose behalf the method was called. [Note, this
    is a change from prior multi method semantics, which restricted
    multimethods to a single class; the old semantics is equivalent to
    defining a "proto" in every class that has multimethods. The new way
    gives the user the ability to intermix "multi"s at different inheritance
    levels].
    Also, the old semantics of "proto" providing the most-default "multi"
    body is hereby deprecated. Default "multi"s should be marked with ""is
    default"".
    It is still possible to provide default behavior in the "proto",
    however, by using it as a wrapper:
        my proto sub foo (@args) {
            do-something-before(@args);
            {*}       # call into the managed set, then come back
            do-something-after(@args);
    Note that this returns the value of do-something-after(), not the
    "multi". There are two ways to get around that. Here's one way:
            ENTER do-something-before(@args);
            {*}
            LEAVE do-something-after(@args);
    Alternately, you can spell out what "{*}" is actually sugar for, which
    would be some dispatcher macro such as:
        my proto sub foo (|cap (@args)) {
            my \retcap = MULTI-DISPATCH-CALLWITH(&?ROUTINE, cap);
            return retcap;
    which optimizes (we hope) to an inlined multidispatcher to locate all
    the candidates for these arguments (hopefully memoized), create the
    dynamic scope of a dispatch, start the dispatch, manage "callnext" and
    "lastcall" semantics, and return the result of whichever "multi"
    succeeded, if any.
    Which is why we have "{*}" instead.
    Another common variant would be to propagate control to the outer/higher
    routine that would have been found if this one didn't exist:
        my proto method foo { {*}; UNDO nextsame; }  # failover to super foo
    Note that, in addition to making "multi"s work similarly to each other,
    the new "proto" semantics greatly simplify top-level dispatchers, which
    never have to worry about "multi"s, because "multi"s are always in the
    second half of the double dispatch (again, just in the abstract, since
    the first dispatch can often be optimized away, as if the "proto" were
    inlined). So in the abstract, "foo()" only ever calls a single
    "only"/"proto" routine, and we know which one it is at compile time.
    This is less of a shift for method dispatch, which already assumed that
    there is something like a single proto in each class that redispatches
    inside the class. Here the change is that multi-method dispatcher needs
    to look more widely for its candidates than the current class. But note
    that our semantics were inconsistent before, insofar as regex methods
    already had to look for this larger managed set in order to do
    transitive LTM correctly. Now the semantics of normal method "proto"s
    and regex "proto"s are nearly identical, apart from the fact that regex
    candidate lists naturally have fancier tiebreaking rules involving
    longest token matching.
    A "dispatch" must be generated for every scope that contains one or more
    "multi" declaration. This is done by searching backwards and outwards
    (or up the inheritance chain for methods) for a "proto" to instantiate.
    If no such "proto" is found, a "most generic" "proto" will be generated,
        proto sub foo (*@, *%) {*}
        proto method foo (*@, *%) {*}
    Obviously, no named-to-positional remapping can be done in this case.
    [Conjecture: we could instead autogen a more specific signature for each
    such autogenerated "dispatch" once we know its exact candidate set, such
    that consistent use of positional parameter names is rewarded with
    positional names in the generated signature, which could remap named
    parameters.]
  Named subroutines
    The general syntax for named subroutines is any of:
         my RETTYPE sub NAME ( PARAMS ) TRAITS {...}    # lexical only
                    sub NAME ( PARAMS ) TRAITS {...}    # same as "my"
        our RETTYPE sub NAME ( PARAMS ) TRAITS {...}    # package-scoped
    The return type may also be put inside the parentheses:
        sub NAME (PARAMS --> RETTYPE) {...}
    Unlike in Perl 5, named subroutines are considered expressions, so this
    is valid Perl 6:
        my @subs = (sub foo { ... }, sub bar { ... });
    Another difference is that subroutines default to "my" scope rather than
    "our" scope. However, subroutine dispatch searches lexical scopes
    outward, and subroutines are also allowed to be *postdeclared* after
    their use, so you won't notice this much. A subroutine that is not
    declared yet may be called using parentheses around the arguments, in
    the absence of parentheses, the subroutine call is assumed to take
    multiple arguments in the form of a list operator.
  Anonymous subroutines
    The general syntax for anonymous subroutines is:
        sub ( PARAMS ) TRAITS {...}
    But one can also use the "anon" scope modifier to introduce the return
    type first:
        anon RETTYPE sub ( PARAMS ) TRAITS {...}
    When an anonymous subroutine will be assigned to a scalar variable, the
    variable can be declared with the signature of the routines that will be
    assigned to it:
        my $grammar_factory:(Str, int, int --> Grammar);
        $grammar_factory = sub (Str $name, int $n, int $x --> Grammar) { ... };
    Covariance allows a routine (that has a more derived return type than
    what is defined in the scalar's signature) to be assigned to that
    scalar. Contravariance allows a routine (with parameter types that are
    less derived than those in the scalar's signature) to be assigned to
    that scalar. The compiler may choose to enforce (by type-checking) such
    assignments at compile-time, if possible. Such type annotations are
    intended to help the compiler optimize code to the extent such
    annotations are included and/or to the extent they aid in type
    inference.
    The same signature can be used to mark the type of a closure parameter
    to another subroutine:
        sub (int $n, &g_fact:(Str, int, int --> Grammar) --> Str) { ... }
    Trait is the name for a compile-time ("is") property. See "Properties
    and traits".
  Perl5ish subroutine declarations
    You can declare a sub without parameter list, as in Perl 5:
        sub foo {...}
    This is equivalent to one of:
        sub foo () {...}
        sub foo (*@_) {...}
        sub foo (*%_) {...}
        sub foo (*@_, *%_) {...}
    depending on whether either or both of those variables are used in the
    body of the routine.
    Positional arguments implicitly come in via the @_ array, but unlike in
    Perl 5 they are "readonly" aliases to actual arguments:
        sub say { print qq{"@_[]"\n}; }   # args appear in @_
        sub cap { $_ = uc $_ for @_ }   # Error: elements of @_ are read-only
    Also unlike in Perl 5, Perl 6 has true named arguments, which come in
    via %_ instead of @_.
    If you need to modify the elements of @_ or %_, declare the array or
    hash explicitly with the "is rw" trait:
        sub swap (*@_ is rw, *%_ is rw) { @_[0,1] = @_[1,0]; %_<status> = "Q:S"; }
    Note: the "rw" container trait is automatically distributed to the
    individual elements by the slurpy star even though there is no actual
    array or hash passed in. More precisely, the slurpy star means the
    declared formal parameter is *not* considered readonly; only its
    elements are. See "Parameters and arguments" below.
    Note also that if the sub's block contains placeholder variables (such
    as "$^foo" or $:bar), those are considered to be formal parameters
    already, so in that case @_ or %_ fill the role of sopping up unmatched
    arguments. That is, if those containers are explicitly mentioned within
    the body, they are added as slurpy parameters. This allows you to easily
    customize your error message on unrecognized parameters. If they are not
    mentioned in the body, they are not added to the signature, and normal
    dispatch rules will simply fail if the signature cannot be bound.
  Blocks
    Raw blocks are also executable code structures in Perl 6.
    Every block defines an object of type "Block" (which "does Callable"),
    which may either be executed immediately or passed on as a "Block"
    object. How a block is parsed is context dependent.
    A bare block where an operator is expected terminates the current
    expression and will presumably be parsed as a block by the current
    statement-level construct, such as an "if" or "while". (If no statement
    construct is looking for a block there, it's a syntax error.) This form
    of bare block requires leading whitespace because a bare block where a
    postfix is expected is treated as a hash subscript.
    A bare block where a term is expected merely produces a "Block" object.
    If the term bare block occurs in a list, it is considered the final
    element of that list unless followed immediately by a comma or colon
    (intervening "\h*" or "unspace" is allowed).
  "Pointy blocks"
    Semantically the arrow operator "->" is almost a synonym for the "sub"
    keyword as used to declare an anonymous subroutine, insofar as it allows
    you to declare a signature for a block of code. However, the parameter
    list of a pointy block does not require parentheses, and a pointy block
    may not be given traits. In most respects, though, a pointy block is
    treated more like a bare block than like an official subroutine.
    Syntactically, a pointy block may be used anywhere a bare block could be
    used:
        my $sq = -> $val { $val**2 };
        say $sq(10); # 100
        my @list = 1..3;
        for @list -> $elem {
            say $elem; # prints "1\n2\n3\n"
    It also behaves like a block with respect to control exceptions. If you
    "return" from within a pointy block, the block is transparent to the
    return; it will return from the innermost enclosing "sub" or "method"
    (et al.), not from the block itself. It is referenced by "&?BLOCK", not
    "&?ROUTINE".
    A normal pointy block's parameters default to "readonly", just like
    parameters to a normal sub declaration. However, the double-pointy
    variant defaults parameters to "rw":
        for @list <-> $elem {
            $elem++;
    This form applies "rw" to all the arguments:
        for @kv <-> $key, $value {
            $key ~= ".jpg";
            $value *= 2 if $key ~~ :e;
  Stub declarations
    To predeclare a subroutine without actually defining it, use a "stub
    block":
        sub foo {...}     # Yes, those three dots are part of the actual syntax
    The old Perl 5 form:
        sub foo;
    is a compile-time error in Perl 6 (because it would imply that the body
    of the subroutine extends from that statement to the end of the file, as
    "class" and "module" declarations do). The only allowed use of the
    semicolon form is to declare a "MAIN" sub--see "Declaring a MAIN
    subroutine" below. (And this form requires the "unit" declarator in
    front.)
    Redefining a stub subroutine does not produce an error, but redefining
    an already-defined subroutine does. If you wish to redefine a defined
    sub, you must explicitly use the ""supersede"" declarator. (The compiler
    may refuse to do this if it has already committed to the previous
    definition.)
    The "..." is the "yadayadayada" operator, which is executable but
    returns a failure. You can also use "???" to fail with a warning (a lazy
    one, to be issued only if the value is actually used), or "!!!" to
    always die. These also officially define stub blocks. Any of these yada
    operators will be taken as a stub if used as the main operator of the
    first statement in the block. (Statement modifiers are allowed on that
    statement.) The yada operators differ from their respective named
    functions in that they all default to a message such as: "Unimplemented
    stub of sub foo was executed".
    It has been argued that "..." as literal syntax is confusing when you
    might also want to use it for metasyntax within a document. Generally
    this is not an issue in context; it's never an issue in the program
    itself, and the few places where it could be an issue in the
    documentation, a comment will serve to clarify the intent, as above. The
    rest of the time, it doesn't really matter whether the reader takes
    "..." as literal or not, since the purpose of "..." is to indicate that
    something is missing whichever way you take it.
  Globally scoped subroutines
    Subroutines and variables can be declared in the global namespace (or
    any package in the global namespace), and are thereafter visible
    everywhere in the program via the GLOBAL package (or one of its
    subpackages). They may be made directly visible by importation, but may
    not otherwise be called with a bare identifier, since subroutine
    dispatch only looks in lexical scopes.
    Global subroutines and variables are normally referred to by prefixing
    their identifiers with the "*" twigil, to allow dynamically scoped
    overrides.
        GLOBAL::<$next_id> = 0;
        sub GLOBAL::saith($text)  { say "Yea verily, $text" }
        module A {
            my $next_id = 2;     # hides any global or package $next_id
            &*saith($next_id);   # print the lexical $next_id;
            &*saith($*next_id);  # print the dynamic $next_id;
    To disallow dynamic overrides, you must access the globals directly:
        GLOBAL::saith($GLOBAL::next_id);
    The fact that this is verbose is construed to be a feature. Alternately,
    you may play aliasing tricks like this:
        module B {
            import GLOBAL <&saith $next_id>;
            saith($next_id);    # Unambiguously the global definitions
    Despite the fact that subroutine dispatch only looks in lexical scopes,
    you can always call a package subroutine directly if there's a lexical
    alias to it, as the "our" declarator does:
        unit module C;
        our sub saith($text)  { say "Yea verily, $text" }
        saith("I do!")      # okay
        C::saith("I do!")   # also okay
  Dynamically scoped subroutines
    Similarly, you may define dynamically scoped subroutines:
        my sub myfunc ($x) is dynamic { ... }
        my sub &*myfunc ($x) { ... }        # same thing
    This may then be invoked via the syntax for dynamic variables:
        &*myfunc(42);
  Lvalue subroutines
    Lvalue subroutines return a "proxy" object that can be assigned to. It's
    known as a proxy because the object usually represents the purpose or
    outcome of the subroutine call.
    Subroutines are specified as being lvalue using the "is rw" trait.
    An lvalue subroutine may return a variable:
        my $lastval;
        sub lastval () is rw { return $lastval }
    or the result of some nested call to an lvalue subroutine:
        sub prevval () is rw { return lastval() }
    or a specially tied proxy object, with suitably programmed "FETCH" and
    "STORE" methods:
        sub checklastval ($passwd) is rw {
            return Proxy.new:
                    FETCH => method {
                                return lastval();
                             },
                    STORE => method ($val) {
                                die unless check($passwd);
                                lastval() = $val;
                             };
    Other methods may be defined for specialized purposes such as
    temporizing the value of the proxy.
  Raw subroutines
    If the subroutine doesn't care whether the returned value is a container
    or not, it may declare this with "is raw", to indicate that the return
    value should be returned raw, without attempting any decontainerization.
    This can be useful for routines that wish to process mixed containers
    and non-containers without distinction.
  Operator overloading
    Operators are just subroutines with special names and scoping. An
    operator name consists of a grammatical category name followed by a
    single colon followed by an operator name specified as if it were one or
    more strings. So any of these indicates the same binary addition
        infix:["+"]
    Use the "&" sigil just as you would on ordinary subs.
    Unary operators are defined as "prefix" or "postfix":
        sub prefix:<OPNAME>  ($operand) {...}
        sub postfix:<OPNAME> ($operand) {...}
    Binary operators are defined as "infix":
        sub infix:<OPNAME> ($leftop, $rightop) {...}
    Bracketing operators are defined as "circumfix" where a term is expected
    or "postcircumfix" where a postfix is expected. A two-element slice
    containing the leading and trailing delimiters is the name of the
        sub circumfix:<LEFTDELIM RIGHTDELIM> ($contents) {...}
        sub circumfix:['LEFTDELIM','RIGHTDELIM'] ($contents) {...}
    Contrary to Apocalypse 6, there is no longer any rule about splitting an
    even number of characters. You must use a two-element slice. Such names
    are canonicalized to a single form within the symbol table, so you must
    use the canonical name if you wish to subscript the symbol table
    directly (as in "PKG::{'infix:<+>'}"). Otherwise any form will do.
    (Symbolic references do not count as direct subscripts since they go
    through a parsing process.) The canonical form always uses angle
    brackets and a single space between slice elements. The elements are
    escaped on brackets, so "PKG::circumfix:['<','>']" is canonicalized to
    "PKG::{'circumfix:<\< \>>'}", and decanonicalizing may always be done
    left-to-right.
    Operator names can be any sequence of non-whitespace characters
    including Unicode characters. For example:
        sub infix:<(c)> ($text, $owner) { return $text but Copyright($owner) }
        method prefix:<±> (Num $x --> Num) { return +$x | -$x }
        multi sub postfix:<!> (Int $n) { $n < 2 ?? 1 !! $n*($n-1)! }
        my $document = $text (c) $me;
        my $tolerance = ±7!;
        <!-- This is now a comment -->
    Whitespace may never be part of the name (except as separator within a
    "<...>" or "«...»" slice subscript, as in the example above).
    A null operator name does not define a null or whitespace operator, but
    a default matching subrule for that syntactic category, which is useful
    when there is no fixed string that can be recognized, such as tokens
    beginning with digits. Such an operator *must* supply an "is parsed"
    trait. The Perl grammar uses a default subrule for the ":1st", ":2nd",
    ":3rd", etc. regex modifiers, something like this:
        sub regex_mod_external:<> ($x) is parsed(token { \d+[st|nd|rd|th] }) {...}
    Such default rules are attempted in the order declared. (They always
    follow any rules with a known prefix, by the longest-token-first rule.)
    Although the name of an operator can be installed into any package or
    lexical namespace, the syntactic effects of an operator declaration are
    always lexically scoped. Operators other than the standard ones should
    not be installed into the "GLOBAL::" namespace. Always use exportation
    to make non-standard syntax available to other scopes.
Calling conventions
    In Perl 6 culture, we distinguish the terms *parameter* and *argument*;
    a parameter is the formal name that will attach to an incoming argument
    during the course of execution, while an argument is the actual value
    that will be bound to the formal parameter. The process of attaching
    these values (arguments) to their temporary names (parameters) is known
    as *binding*. (Some C.S. literature uses the terms "formal argument" and
    "actual argument" for these two concepts, but here we try to avoid using
    the term "argument" for formal parameters.)
    Various Perl 6 code objects (either routines or blocks) may be declared
    with parameter lists, either explicitly by use of a signature
    declaration, or implicitly by use of placeholder variables within the
    body of code. (Use of both for the same code block is not allowed.)
Signatures
    A signature consists of a list of zero or more parameter declarations,
    separated by commas. (These are described below.) Signatures are usually
    found inside parentheses (within routine declarations), or after an
    arrow "->" (within block declarations), but other forms are possible for
    specialized cases. A signature may also indicate what the code returns,
    either generally or specifically. This is indicated by placing the
    return specification after a "-->" token. If the return specification
    names a type (that is, an indefinite object), then a successful call to
    the code must always return a value of that type. If the return
    specification returns a definite object, then that value is always
    returned from a successful call. (For this purpose the "Nil" value is
    treated as definite.) An unsuccessful call may always call "fail" to
    return a "Failure" object regardless of the return specification.
    Ordinarily, if the return is specified as a type (or is unspecified),
    the final statement of the block will be evaluated for its return value,
    and this will be the return value of the code block as a whole. (It must
    conform to the return type specification, if provided.) An explicit
    "return" may be used instead to evaluate the "return"'s arguments as the
    code block's return value, and leave the code block immediately,
    short-circuiting the rest of the block's execution.
    If the return specification is a definite immutable value (or "Nil")
    rather than a type, then all top-level statements in the code block are
    evaluated only for their side effects; in other words, all of the
    statements are evaluated in sink context, including the final statement.
    An explicit "return" statement is allowed, but only in argumentless
    form, to indicate that execution is to be short-circuited and the
    *declared* return value is to be returned. No other value may be
    returned in its place.
    If the return specification is definite but not an immutable value, then
    it must be a mutable container (variable) of some sort. The container
    variable is declared as any other parameter would be, but no incoming
    argument will ever be bound to it. It is permitted to supply a default
    value, in which case the return variable will always be initialized with
    that default value. Like other variables declared in a signature, a new
    variable will always be created; any existing variable will
    automatically be shadowed. If you want to have the return variable
    reference an existing variable, you must resort to "OUTER::<foo>"
    hackery. As with value return, all top-level statements are evaluated in
    sink context, and only argumentless "return" is allowed, indicating that
    the current contents of the return value should be returned.
    Note that the default return policy assumes functional semantics, with
    the result that a loop as the final statement would be evaluated as a
    map, which may surprise some people. An implementation is allowed to
    warn when it finds such a loop; this warning may be suppressed by
    supplying a return specification, which will also determine whether the
    final loop statement is evaluated in sink context.
Parameters and arguments
    By default, all Scalar parameters are readonly. When a value is passed,
    it is simply directly bound to the parameter name. When a scalar is
    passed, the value held in the scalar is obtained. It is then assigned
    into another scalar container that will, from that point on, be readonly
    (that is, no further assignments can be made to it). Implementations
    may, as an optimization, also simply bind the value obtained from a
    passed Scalar if they can prove it is not Iterable (and therefore
    elimination of the container would not affect flattening behavior).
    Array and hash parameters are simply bound "as is". (Conjectural: future
    versions of Perl 6 may do static analysis and forbid assignments to
    array and hash parameters that can be caught by it. This will, however,
    only happen with the appropriate "use" declaration to opt in to that
    language version.)
    To allow modification, use the "is rw" trait. This requires a mutable
    object or container as an argument (or some kind of type object that can
    be converted to a mutable object, such as might be returned by an array
    or hash that knows how to autovivify new elements). Otherwise the
    signature fails to bind, and this candidate routine cannot be considered
    for servicing this particular call. (Other multi candidates, if any, may
    succeed if they don't require "rw" for this parameter.) In any case,
    failure to bind does not by itself cause an exception to be thrown; that
    is completely up to the dispatcher.
    To pass-by-copy, use the "is copy" trait. An object container will be
    cloned whether or not the original is mutable, while an (immutable)
    value will be copied into a suitably mutable container. The parameter
    may bind to any argument that meets the other typological constraints of
    the parameter.
    If you have a readonly scalar parameter $ro, it may never be passed on
    to a "rw" scalar parameter of a subcall, since the rw-ness was already
    eliminated. A $ro parameter may also not be rebound; trying to do so
    results in a compile time error.
    Aliases of $ro are also readonly, whether generated explicitly with ":="
    or implicitly within a "Capture" object (which are themselves
    immutable).
    Also, $ro may not be returned from an lvalue subroutine or method.
    Parameters may be required or optional. They may be passed by position,
    or by name. Individual parameters may confer an item or list context on
    their corresponding arguments, but unlike in Perl 5, this is decided
    lazily at parameter binding time.
    Arguments destined for required positional parameters must come before
    those bound to optional positional parameters. Arguments destined for
    named parameters may come before and/or after the positional parameters.
    (To avoid confusion it is highly recommended that all positional
    parameters be kept contiguous in the call syntax, but this is not
    enforced, and custom arg list processors are certainly possible on those
    arguments that are bound to a final slurpy or arglist variable.)
    A signature containing a name collision is considered a compile time
    error. A name collision can occur between positional parameters, between
    named parameters, or between a positional parameter and a named one. The
    sigil is not considered in such a comparison, except in the case of two
    positional parameters -- in other words, a signature in which two or
    more parameters are identical except for the sigil is still OK (but you
    won't be able to pass values by that name).
        :($a, $a)       # wrong, two $a
        :($a, @a)       # OK (but don't do that)
        :($a, :a($b))   # wrong, one $a from positional, one $a from named parameter
        :($a, :a(@b))   # wrong, same
        :(:$a, :@a)     # wrong, can only have one named parameter "a"
  Named arguments
    Named arguments are recognized syntactically at the "comma" level. Since
    parameters are identified using identifiers, the recognized syntaxes are
    those where the identifier in question is obvious. You may use either
    the adverbial form, ":name($value)", or the autoquoted arrow form, "name
    => $value". These must occur at the top "comma" level, and no other
    forms are taken as named pairs by default. Pairs intended as positional
    arguments rather than named arguments may be indicated by extra parens
    or by explicitly quoting the key to suppress autoquoting:
        doit :when<now>,1,2,3;      # always a named arg
        doit (:when<now>),1,2,3;    # always a positional arg
        doit when => 'now',1,2,3;   # always a named arg
        doit (when => 'now'),1,2,3; # always a positional arg
        doit 'when' => 'now',1,2,3; # always a positional arg
    Only bare keys with valid identifier names are recognized as named
    arguments:
        doit when => 'now';         # always a named arg
        doit 'when' => 'now';       # always a positional arg
        doit 123  => 'now';         # always a positional arg
        doit :123<now>;             # always a positional arg
    Going the other way, pairs intended as named arguments that don't look
    like pairs must be introduced with the "|" prefix operator:
        $pair = :when<now>;
        doit $pair,1,2,3;                # always a positional arg
        doit |$pair,1,2,3;               # always a named arg
        doit |get_pair(),1,2,3;          # always a named arg
        doit |('when' => 'now'),1,2,3;   # always a named arg
    Note the parens are necessary on the last one due to precedence.
    Likewise, if you wish to pass a hash and have its entries treated as
    named arguments, you must dereference it with a "|":
        %pairs = (:when<now>, :what<any>);
        doit %pairs,1,2,3;               # always a positional arg
        doit |%pairs,1,2,3;              # always named args
        doit |%(get_pair()),1,2,3;       # always a named arg
        doit |%('when' => 'now'),1,2,3;  # always a named arg
    Variables with a ":" prefix in rvalue context autogenerate pairs, so you
    can also say this:
        $when = 'now';
        doit $when,1,2,3;   # always a positional arg of 'now'
        doit :$when,1,2,3;  # always a named arg of :when<now>
    In other words ":$when" is shorthand for ":when($when)". This works for
    any sigil:
        :$what      :what($what)
        :@what      :what(@what)
        :%what      :what(%what)
        :&what      :what(&what)
    Ordinary hash notation will just pass the value of the hash entry as a
    positional argument regardless of whether it is a pair or not. To pass
    both key and value out of hash as a positional pair, use ":p" instead:
        doit %hash<a>:p,1,2,3;
        doit %hash{'b'}:p,1,2,3;
    The ":p" stands for "pairs", not "positional"--the ":p" adverb may be
    placed on any "Associative" access subscript to make it mean "pairs"
    instead of "values". If you want the pair (or pairs) to be interpreted
    as named arguments, you may do so by prefixing with the "prefix:<|>"
        doit |(%hash<a>:p),1,2,3;
        doit |(%hash{'b'}:p),1,2,3;
    (The parens are required to keep the ":p" adverb from attaching to
    "prefix:<|>" operator.)
    "Pair" constructors are recognized syntactically at the call level and
    put into the named slot of the "Capture" structure. Hence they may be
    bound to positionals only by name, not as ordinary positional "Pair"
    objects. Leftover named arguments can be slurped into a slurpy hash.
    Because named and positional arguments can be freely mixed, the
    programmer always needs to disambiguate pairs literals from named
    arguments with parentheses or quotes:
        # Named argument "a"
        push @array, 1, 2, :a<b>;
        # Pair object (a=>'b')
        push @array, 1, 2, (:a<b>);
        push @array, 1, 2, 'a' => 'b';
    Perl 6 allows multiple same-named arguments, and records the relative
    order of arguments with the same name. When there are more than one
    argument, the "@" sigil in the parameter list causes the arguments to be
    concatenated:
        sub fun (Int :@x) { ... }
        fun( x => 1, x => 2 );              # @x := (1, 2)
        fun( x => (1, 2), x => (3, 4) );    # @x := (1, 2, 3, 4)
    Other sigils bind only to the *last* argument with that name:
        sub fun (Int :$x) { ... }
        fun( x => 1, x => 2 );              # $x := 2
        fun( x => (1, 2), x => (3, 4) );    # $x := (3, 4)
    This means a hash holding default values must come *before* known named
    parameters, similar to how hash constructors work:
        # Allow "x" and "y" in %defaults to be overridden
        f( |%defaults, x => 1, y => 2 );
  Invocant parameters
    A method invocant may be specified as the first parameter in the
    parameter list, with a colon (rather than a comma) immediately after it:
        method get_name ($self:) {...}
        method set_name ($_: $newname) {...}
    The corresponding argument (the invocant) is evaluated in item context
    and is passed as the left operand of the method call operator:
        print $obj.get_name();
        $obj.set_name("Sam");
    The invocant is actually stored as the first positional argument of a
    "Capture" object. It is special only to the dispatcher, otherwise it's
    just a normal positional argument.
    Single-dispatch semantics may also be requested by using the indirect
    object syntax, with a colon after the invocant argument. The colon is
    just a special form of the comma, and has the same precedence:
        set_name $obj: "Sam";
        $obj.set_name("Sam");   # same as the above
    An invocant is the topic of the corresponding method if that formal
    parameter is declared with the name $_. If you have a call of the form:
        foo(|$capture)
    the compiler must defer the decision on whether to treat it as a method
    or function dispatch based on whether the supplied "Capture"'s first
    argument is marked as an invocant. For ordinary calls this can always be
    determined at compile time, however.
  Parameters with type constraints
    Parameters can be constraint to other types than the default simply by
    using the type name in from of the parameter:
        sub double(Numeric $x) { 2 * $x }
    If no explicit type constraint is given, it defaults to the type of the
    surrounding package for method invocants, and to "Any" everywhere else.
    A bare ":D", ":U" or ":_" instead of a type constraint limits the
    default type to definite objects (aka instances), undefined objects (aka
    type objects), or any object, respectively. The default still applies,
    so in
        class Con {
            method man(:U: :D $x)
    the signature is equivalent to "(Con:U: Any:D $x)".
  Longname parameters
    A routine marked with "multi" can mark part of its parameters to be
    considered in the multi dispatch. These are called *longnames*; see S12
    for more about the semantics of multiple dispatch.
    You can choose part of a "multi"'s parameters to be its longname, by
    putting a double semicolon after the last one:
        multi sub handle_event ($window, $event;; $mode) {...}
        multi method set_name ($self: $name;; $nick) {...}
    A parameter list may have at most one double semicolon; parameters after
    it are never considered for multiple dispatch (except of course that
    they can still "veto" if their number or types mismatch).
    [Conjecture: It might be possible for a routine to advertise multiple
    long names, delimited by single semicolons. See S12 for details.]
    If the parameter list for a "multi" contains no semicolons to delimit
    the list of important parameters, then all positional parameters are
    considered important. If it's a "multi method" or "multi submethod", an
    additional implicit unnamed "self" invocant is added to the signature
    list unless the first parameter is explicitly marked with a colon.
  Required parameters
    Required parameters are specified at the start of a subroutine's
    parameter list:
        sub numcmp ($x, $y) { return $x <=> $y }
    Required parameters may optionally be declared with a trailing "!",
    though that's already the default for positional parameters:
        sub numcmp ($x!, $y!) { return $x <=> $y }
    Not passing all of the required arguments to a normal subroutine is a
    fatal error. Passing a named argument that cannot be bound to a normal
    subroutine is also a fatal error. (Methods are different.)
    The number of required parameters a subroutine has can be determined by
    calling its ".arity" method:
        $args_required = &foo.arity;
  Optional parameters
    Optional positional parameters are specified after all the required
    parameters and each is marked with a "?" after the parameter:
        sub my_substr ($str, $from?, $len?) {...}
    Alternately, optional fields may be marked by supplying a default value.
    The "=" sign introduces a default value:
        sub my_substr ($str, $from = 0, $len = Inf) {...}
    Default values can be calculated at run-time. They may even use the
    values of preceding parameters:
        sub xml_tag ($tag, $endtag = matching_tag($tag) ) {...}
    Arguments that correspond to optional parameters are evaluated in item
    context. They can be omitted, passed positionally, or passed by name:
        my_substr("foobar");            # $from is 0, $len is infinite
        my_substr("foobar",1);          # $from is 1, $len is infinite
        my_substr("foobar",1,3);        # $from is 1, $len is 3
        my_substr("foobar",len=>3);     # $from is 0, $len is 3
    Missing optional arguments default to their default values, or to an
    undefined value if they have no default. (A supplied argument that is
    undefined is not considered to be missing, and hence does not trigger
    the default. Use "//=" within the body for that.)
    You may check whether an optional parameter was bound to anything by
    calling "VAR($param).defined".
  Named parameters
    Named-only parameters follow any required or optional parameters in the
    signature. They are marked by a prefix ":":
        sub formalize($text, :$case, :$justify) {...}
    This is actually shorthand for:
        sub formalize($text, :case($case), :justify($justify)) {...}
    If the longhand form is used, the label name and variable name can be
    different:
        sub formalize($text, :case($required_case), :justify($justification)) {...}
    so that you can use more descriptive internal parameter names without
    imposing inconveniently long external labels on named arguments.
    Multiple name wrappings may be given; this allows you to give both a
    short and a long external name:
        sub globalize (:g(:global($gl))) {...}
    Or equivalently:
        sub globalize (:g(:$global)) {...}
    Arguments that correspond to named parameters are evaluated in item
    context. They can only be passed by name, so it doesn't matter what
    order you pass them in:
        $formal = formalize($title, case=>'upper');
        $formal = formalize($title, justify=>'left');
        $formal = formalize($title, :justify<right>, :case<title>);
    See S02 for the correspondence between adverbial form and arrow
    notation.
    While named and position arguments may be intermixed, it is suggested
    that you keep all the positionals in one place for clarity unless you
    have a good reason not to. This is likely bad style:
        $formal = formalize(:justify<right>, $title, :case<title>, $date);
    Named parameters are optional unless marked with a following "!".
    Default values for optional named parameters are defined in the same way
    as for positional parameters, but may depend only on existing values,
    including the values of parameters that have already been bound. Named
    optional parameters default to "Nil" (that is, they set the default of
    the container) if they have no default. Named required parameters fail
    unless an argument pair of that name is supplied.
    Bindings logically happen in declaration order, not call order, so any
    default may reliably depend on formal parameters to its left in the
    signature.
  List parameters
    List parameters capture a variable length list of data. They're used in
    subroutines like "print", where the number of arguments needs to be
    flexible. They're also called "variadic parameters", because they take a
    *variable* number of arguments. But generally we call them "slurpy"
    parameters because they slurp up arguments.
    Slurpy parameters follow any required or optional parameters. They are
    marked by a "*" before the parameter:
        sub duplicate($n, *%flag, *@data) {...}
    Named arguments are bound to the slurpy hash (*%flag in the above
    example). Such arguments are evaluated in item context. Any remaining
    variadic arguments at the end of the argument list are bound to the
    slurpy array (*@data above) and are evaluated in list context.
    For example:
        duplicate(3, reverse => 1, collate => 0, 2, 3, 5, 7, 11, 14);
        duplicate(3, :reverse, :!collate, 2, 3, 5, 7, 11, 14);  # same
        # The @data parameter receives [2, 3, 5, 7, 11, 14]
        # The %flag parameter receives { reverse => 1, collate => 0 }
    Slurpy scalar parameters capture what would otherwise be the first
    elements of the variadic array:
        sub head(*$head, *@tail)         { return $head }
        sub neck(*$head, *$neck, *@tail) { return $neck }
        sub tail(*$head, *@tail)         { return @tail }
        head(1, 2, 3, 4, 5);        # $head parameter receives 1
                                    # @tail parameter receives [2, 3, 4, 5]
        neck(1, 2, 3, 4, 5);        # $head parameter receives 1
                                    # $neck parameter receives 2
                                    # @tail parameter receives [3, 4, 5]
    Slurpy scalars still impose list context on their arguments.
    Single slurpy parameters are treated lazily -- the list is only
    flattened into an array when individual elements are actually accessed:
        @fromtwo = tail(1..Inf);        # @fromtwo contains a lazy [2..Inf]
    [Conjecture: However, if you use two or more slurpy arrays in a
    signature, the list is instead evaluated in hyper context, and will be
    asked to split itself into the number of lists corresponding to the
    number of slurpies so declared. A non-hyperable list will return failure
    for this splitting operation, so the signature should only bind on
    parallelizable list operations. Likewise a list that is "too short to
    split" fails to bind, so a separate signature may match empty lists, and
    perhaps singletons, if we define "too short" that way.]
    You can't bind to the name of a slurpy parameter: the name is just there
    so you can refer to it within the body.
        sub foo(*%flag, *@data) {...}
        foo(:flag{ a => 1 }, :data[ 1, 2, 3 ]);
            # %flag has elements (flag => (a => 1)) and (data => [1,2,3])
            # @data has nothing
    [Conjecture: a future Perl 6 version will allow typed slurpy parameters,
    which will validate the types of the passed arguments.]
  Slurpy block
    It's also possible to declare a slurpy block: *&block. It slurps up any
    nameless block, specified by "{...}", at either the current positional
    location or the end of the syntactic list. Put it first if you want the
    option of putting a block either first or last in the arguments. Put it
    last if you want to force it to come in as the last argument.
  Argument list binding
    The underlying "Capture" object may be bound to a single name marked
    with a "|".
        sub bar ($a,$b,$c,:$mice) { say $mice }
        sub foo (|args) { say args.perl; &bar.nextwith(|args); }
    This prints:
        foo 1,2,3,:mice<blind>;     # says "\(1,2,3,:mice<blind>)" then "blind"
    As demonstrated above, the capture may be interpolated into another
    call's arguments. (The "|" prefix is described below.) Use of "nextwith"
    allows the routine to be called without introducing an official "CALLER"
    frame. For more see "Wrapping" below.
    The "|" parameter takes a snapshot of the current binding state, but
    does not consume any arguments from it. It is allowed to have more
    parameters within the signature:
        sub compare (|args, Num $x, Num $y --> Bool) { ... }
    For all normal declarative purposes (invocants and multiple dispatch
    types, for instance), capture parameters are ignored.
        method addto (|args, $self: @x) { trace(args); $self += [+] @x }
    The extra signature is not required for non-"multi"s since there can
    only be one candidate, but for multiple dispatch the extra signature is
    required at least for its types, or the declaration would not know what
    signature to match against.
        multi foo (|args, Int, Bool?, *@, *%)) { reallyintfoo(args) }
        multi foo (|args, Str, Bool?, *@, *%)) { reallystrfoo(args) }
  Term binding
    When you bind an argument to a sigiled variable, it enforces the
    contract of that sigil, but sometimes you don't want that. It is
    possible to bind an argument to a simple name instead, which represents
    that argument in its rawest form, with no commitment to structure or
    mutability.
        sub foo (\x, \y) { x = y; }    # might or might not succeed
    A "\" parameter effectively declares a new term in the language for the
    rest of the current scope, so when you use that term, it is not parsed
    as a list operator, so it will not look for any subsequent arguments.
        sub foo (\x) { x 42; }    # syntax error; two terms in a row
    Raw parameters make it relatively easy to program in a "sigilless"
    style, if you desire:
        sub say-sins (\angles) {
            for angles -> \𝜃 { say sin 𝜃 }
        my \𝑖 = some-integer; say 𝑖 + 2;
    Note how "𝑖" would be misinterpreted if it treated "+ 2" as an argument,
    but since it's a simple term, it doesn't.
    The term does act like a function call in one way, however. Since it
    returns a raw value, whether it flattens or not depends on the context
    in which it is eventually used. You can use "prefix:<|>" to force
    flattening into an outer argument list, if needed.
    It is possible to alias to a non-identifier by using the "term"
    syntactic category:
        my \term:<∞> = Inf;
    We sometimes call these "sigilless variables", but they differ from
    normal variables in one significant way. Unlike a variable binding, a
    term binding is fixed for the rest of the lexical scope. The term may
    only be rebound be re-entering the scope. This is useful to enforce a
    programming style known as SSA, Single Static Assignment (really
    binding), which, among other benefits, gives the optimizer more
    guarantees about which symbols can be considered "temporarily
    immutable".
  Flattening argument lists
    The unary "|" operator casts its argument to a "Capture" object, then
    splices that capture into the argument list it occurs in. To get the
    same effect on multiple arguments you can use the "|«" hyperoperator.
    "Pair" and "Hash" become named arguments:
        |(x=>1);          # Pair, becomes \(x=>1)
        |{x=>1, y=>2};    # Hash, becomes \(x=>1, y=>2)
    Anything else that is "Iterable" is simply turned into positional
        |(1,2,3);         # List, becomes \(1,2,3)
        |(1..3);          # Range, becomes \(1,2,3)
        |(1..2, 3);       # List, becomes \(1..2,3)
        |([x=>1, x=>2]);  # List (from an Array), becomes \((x=>1), (x=>2))
        sub foo($x, $y, $z) {...}    # expects three scalars
        @onetothree = 1..3;          # array stores three scalars
        foo(1,2,3);                  # okay:  three args found
        foo(@onetothree);            # error: only one arg
        foo(|@onetothree);           # okay:  @onetothree flattened to three args
    The "|" operator flattens lazily -- the array is flattened only if
    flattening is actually required within the subroutine. To flatten before
    the list is even passed into the subroutine, use the "flat" list
        foo(|flat 1,2,3 Z 4,5,6);    # zip list flattened before interpolation
        foo |(1,2,3 Z 4,5,6).flat    # same thing
  Multidimensional argument list binding
    Some functions take more than one list of positional and/or named
    arguments, that they wish not to be flattened into one list. For
    instance, "zip()" wants to iterate several lists in parallel, while
    array and hash subscripts want to process a multidimensional slice. The
    set of underlying argument lists may be bound to a single array
    parameter declared with a double "**" marker:
        sub foo (**@slice) { ... }
    Note that this is different from
        sub foo (|slice) { ... }
    insofar as "|slice" is bound to a single argument-list object that makes
    no commitment to processing its structure (and maybe doesn't even know
    its own structure yet), while **@slice has to create an array that binds
    the incoming dimensional lists to the array's dimensions, and make that
    commitment visible to the rest of the scope via the sigil so that
    constructs expecting multidimensional lists know that
    multidimensionality is the intention.
    It is allowed to specify a return type:
        sub foo (**@slice --> Num) { ... }
    The invocant does not participate in multi-dimensional argument lists,
    so "self" is not present in the **@slice below:
        method foo (**@slice) { ... }
    The "**" marker is just a variant of the "*" marker that ends up
    requesting the arguments at the comma-separated syntax level, rather
    than requesting individual elements as the flattening "*" does.
  Zero-dimensional argument list
    If you call a function without parens and supply no arguments, the
    argument list becomes a zero-dimensional slice. It differs from "\()" in
    several ways:
        sub foo (**@slice) {...}
        foo;        # +@slice == 0
        foo();      # +@slice == 1
        sub bar (|args = \(1,2,3)) {...}
        bar;        # $args === \(1,2,3)
        bar();      # $args === \()
  One-argument slurpy binding
    If you use a "+" character to indicate a slurpy parameter, then it is
    assumed that the rest of the positional arguments are intended to be
    iterated with "single argument" semantics. That is, we will take
    whatever is passed in and iterate the top level of that. If the top
    level is a comma list, then it works just as a "**" slurpy. If the top
    level is a single argument, then that will be iterated.
        sub foo (+args) {...}
        foo;             # +args == 0
        foo();           # +args == 0
        foo((1,2),3,4)   # +args == 3
        foo((1,2))       # +args == 2
        foo($(1,2))      # +args == 1
        foo((1,2).item)  # +args == 1
        foo([1,2],3,4)   # +args == 3
        foo([1,2])       # +args == 2
        foo($[1,2])      # +args == 1
        foo([1,2].item)  # +args == 1
    Basically, this slurpy doesn't care whether the list you hand it was
    made by syntactic commas or by some other means. The other slurpies
    treat syntactic commas as dominant even when there aren't any!
  Feed operators
    The variadic list of a subroutine call can be passed in separately from
    the normal argument list, by using either of the *feed* operators: "<=="
    or "==>". Syntactically, feed operators expect to find a statement on
    either end. Any statement can occur on the source end; however not all
    statements are suitable for use on the sink end of a feed.
    Each operator expects to find a call to a variadic receiver on its
    "sharp" end, and a list of values on its "blunt" end:
        grep { $_ % 2 } <== @data;
        @data ==> grep { $_ % 2 };
    It binds the (potentially lazy) list from the blunt end to the slurpy
    parameter(s) of the receiver on the sharp end. In the case of a receiver
    that is a variadic function, the feed is received as part of its slurpy
    list. So both of the calls above are equivalent to:
        grep { $_ % 2 }, @data;
    Note that all such feeds (and indeed all lazy argument lists) supply an
    implicit promise that the code producing the lists may execute in
    parallel with the code receiving the lists. (Feeds, hyperops, and
    junctions all have this promise of parallelizability in common, but
    differ in interface. Code which violates these promises is erroneous,
    and will produce undefined results when parallelized.)
    However, feeds go a bit further than ordinary lazy lists in enforcing
    the parallel discipline: they explicitly treat the blunt end as a cloned
    closure that starts a subthread (presumably cooperative). The only
    variables shared by the inner scope with the outer scope are those
    lexical variables declared in the outer scope that are visible at the
    time the closure is cloned and the subthread spawned. Use of such shared
    variables will automatically be subject to transactional protection (and
    associated overhead). Package variables are not cloned unless
    predeclared as lexical names with "our". Variables declared within the
    blunt end are not visible outside, and in fact it is illegal to declare
    a lexical on the blunt end that is not enclosed in curlies somehow.
    Because feeds are defined as lazy pipes, a chain of feeds may not begin
    and end with the same array without some kind of eager sequence point.
    That is, this isn't guaranteed to work:
        @data <== grep { $_ % 2 } <== @data;
    either of these do:
        @data <== grep { $_ % 2 } <== eager @data;
        @data <== eager grep { $_ % 2 } <== @data;
    Conjecture: if the cloning process eagerly duplicates @data, it could be
    forced to work. Not clear if this is desirable, since ordinary clones
    just clone the container, not the value.
    Leftward feeds are a convenient way of explicitly indicating the typical
    right-to-left flow of data through a chain of operations:
        @oddsquares = map { $_**2 }, sort grep { $_ % 2 }, @nums;
        # perhaps more clearly written as...
        @oddsquares = do {
            map { $_**2 } <== sort <== grep { $_ % 2 } <== @nums;
    Rightward feeds are a convenient way of reversing the normal data flow
    in a chain of operations, to make it read left-to-right:
            @nums ==> grep { $_ % 2 } ==> sort ==> map { $_**2 };
    Note that something like the "do" is necessary because feeds operate at
    the statement level. Parens would also work, since a statement is
    expected inside:
        @oddsquares = (
        );
    But as described below, you can also just write:
        @nums ==> grep { $_ % 2 } ==> sort ==> map { $_**2 } ==> @oddsquares;
    If the operand on the sharp end of a feed is not a call to a variadic
    operation, it must be something else that can be interpreted as a list
    receiver, or a scalar expression that can be evaluated to produce an
    object that does the "KitchenSink" role, such as an "IO" object. Such an
    object provides ".clear" and ".push" methods that will be called as
    appropriate to send data. (Note that an "IO" object used as a sink will
    force eager evaluation on its pipeline, so the next statement is
    guaranteed not to run till the file is closed. In contrast, an "Array"
    object used as a sink turns into a lazy array.)
    Any non-variadic object (such as an "Array" or "IO" object) used as a
    filter between two feeds is treated specially as a *tap* that merely
    captures data *en passant*. You can safely install such a tap in an
    extended pipeline without changing the semantics. An "IO" object used as
    a tap does not force eager evaluation since the eagerness is controlled
    instead by the downstream feed.
    Any prefix list operator is considered a variadic operation, so
    ordinarily a list operator adds any feed input to the end of its list.
    But sometimes you want to interpolate elsewhere, so any contextualizer
    with "*" as an argument may be used to indicate the target of a feed
    without the use of a temporary array:
        foo() ==> say @(*), " is what I meant";
        bar() ==> @(*).baz();
    Likewise, an "Array" used as a tap may be distinguished from an "Array"
    used as a translation function:
        numbers() ==> @array ==> bar()          # tap
        numbers() ==> @array[@(*)] ==> bar()    # translation
    To append multiple sources to the next sink, double the angle:
        my $sink;
        0..*       ==>  $sink;
        'a'..*     ==>> $sink;
        pidigits() ==>> $sink;
        # outputs "(0, 'a', 3)\n"...
        for $sink.zip { .perl.say }
    Each such append adds another slice element to the sink.
    You may use a variable (or variable declaration) as a receiver, in which
    case the list value is bound as the "todo" of the variable. (The append
    form binds addition todos to the receiver's todo list.) Do not think of
    it as an assignment, nor as an ordinary binding. Think of it as iterator
    creation. In the case of a scalar variable, that variable contains the
    newly created iterator itself. In the case of an array, the new iterator
    is installed as the method for extending the array. As with assignment,
    the old todo list is clobbered; use the append form to avoid that and
    get push semantics. In any case, feeding an array always flattens. You
    must use the scalar form to preserve slice information.
    In general you can simply think of a receiver array as representing the
    results of the chain, so you can equivalently write any of:
        my @oddsquares <== map { $_**2 } <== sort <== grep { $_ % 2 } <== @nums;
        my @oddsquares
            <== map { $_**2 }
            <== sort
            <== grep { $_ % 2 }
            <== @nums;
        @nums ==> grep { $_ % 2 } ==> sort ==> map { $_**2 } ==> my @oddsquares;
        @nums
        ==> grep { $_ % 2 }
        ==> sort
        ==> map { $_**2 }
        ==> my @oddsquares;
    Since the feed iterator is bound into the final variable, the variable
    can be just as lazy as the feed that is producing the values.
    When feeds are bound to arrays with "push" semantics, you can have a
    receiver for multiple feeds:
        my @foo;
        0..2       ==>  @foo;
        'a'..'c'   ==>> @foo;
        say @foo;   # 0,1,2,'a','b','c'
    Note how the feeds are concatenated in @foo so that @foo is a list of 6
    elements. This is the default behavior. However, sometimes you want to
    capture the outputs as a list of two iterators, namely the two iterators
    that represent the two input feeds. You can get at those two iterators
    by using a scalar instead, which will preserve the slice structure,
    which can be fed to any operation that knows how to deal with a list of
    values as a slice, such as "zip":
        0..*       ==>  $foo;
        'a'..*     ==>> $foo;
        pidigits() ==>> $foo;
        for $foo.zip { .say }
            [0,'a',3]
            [1,'b',1]
            [2,'c',4]
            [3,'d',1]
            [4,'e',5]
            [5,'f',9]
    Here $foo is a list of three lists, so
        $foo.zip
    is equivalent to
        my (@a,@b,@c) := |$foo;
        zip(@a; @b; @c)
    A named receiver array is useful when you wish to feed into an
    expression that is not an ordinary list operator, and you wish to be
    clear where the feed's destination is supposed to be:
        picklist() ==> my @baz;
        my @foo = @bar[@baz];
    Various contexts may or may not be expecting multi-dimensional slices or
    feeds. By default, ordinary arrays are flattened in slurpy context, that
    is, they have "list" semantics. If you say
        zip(0..2; 'a'..'c') ==> my @tmp;
        for @tmp { .say }
    then you get 0,1,2,'a','b','c'. If you have a multidimensional array,
    you can ask for flattening semantics explicitly with "flat":
        zip(0..2; 'a'..'c') ==> my $tmp;
        for $tmp.flat { .say }
    As we saw earlier, "zip" produces an interleaved result by taking one
    element from each list in turn, so
        for $tmp.zip { .say }
    produces 0,'a',1,'b',2,'c'.
    If you want the zip's result as a list of subarrays, then you need to
    put the zip itself into a "chunky" "LoL" context instead:
        for $tmp.zip.lol { .say }
    This produces two values on each line. But usually you want the flat
    form so you can just bind it directly to a signature:
        for $tmp.zip -> $i, $a { say "$i: $a" }
    Otherwise you'd have to say this:
        for $tmp.zip.lol -> [$i, $a] { say "$i: $a" }
    Note that with the current definition, the order of feeds is preserved
    left to right in general regardless of the position of the receiver.
    So
        ('a'..*; 0..*) ==> $feed;
         for $feed.zip <== @foo) -> $a, $i, $x { ... }
    is the same as
        'a'..* ==> $feed;
         0..*  ==>> $feed;
    which is the same as
        for zip('a'..*; 0..*; @foo) -> $a, $i, $x { ... }
    Also note that these come out to be identical for ordinary arrays:
        @foo.zip
        @foo.cat
  Closure parameters
    Parameters declared with the "&" sigil take blocks, closures, or
    subroutines as their arguments. Closure parameters can be required,
    optional, named, or slurpy.
        sub limited_grep (Int $count, &block, *@list) {...}
        # and later...
        @first_three = limited_grep 3, {$_<10}, @data;
    (The comma is required after the closure.)
    Within the subroutine, the closure parameter can be used like any other
    lexically scoped subroutine:
        sub limited_grep (Int $count, &block, *@list) {
            if block($nextelem) {...}
    The closure parameter can have its own signature in a type specification
    written with ":(...)":
        sub limited_Dog_grep ($count, &block:(Dog), *@list) {...}
    and even a return type:
        sub limited_Dog_grep ($count, &block:(Dog --> Bool), *@list) {...}
    When an argument is passed to a closure parameter that has this kind of
    signature, the argument must be a "Code" object with a compatible
    parameter list and return type.
  En passant type capture
    Unlike normal parameters, type parameters often come in piggybacked on
    the actual value as "kind", and you'd like a way to capture both the
    value and its kind at once. (A "kind" is a storage type, that is, a
    class or type that an object is allowed to be. An object is not
    officially allowed to take on a constrained or contravariant type.) A
    type variable can be used anywhere a type name can, but instead of
    asserting that the value must conform to a particular type, it captures
    the actual "kind" of the object and also declares a package/type name by
    which you can refer to that kind later in the signature or body. In
    addition, it captures the nominal typing of any associated nominal type.
    For instance, if you wanted to match any two Dogs as long as they were
    of the same kind, you can say:
        sub matchedset (Dog ::T $fido, T $spot) {...}
    This actually turns into something more like
        sub matchedset (Dog ::T $fido, Dog $spot where T) {...}
    Note that "::T" is not required to contain "Dog", only a type that is
    compatible with "Dog". Note also that the nominal type, "Dog", is also
    included in the meaning of "T", along with the notion that the actual
    type must match the storage type of $fido.
    The "::" quasi-sigil is short for "subset" in much the same way that "&"
    is short for "sub". Just as "&" can be used to name any kind of code, so
    too "::" can be used to name any kind of type. Both of them insert a
    bare identifier into the symbol table, though they fill different
    syntactic spots.
    Note that it is not required to capture the object associated with the
    class unless you want it. The sub above could be written as
        sub matchedset (Dog ::T, T) {...}
    if we're not interested in $fido or $spot. Or just
        sub matchedset (::T, T) {...}
    if we don't care about anything but the matching. Note here that the
    second parameter may be more derived than the first. If you need them to
    be identical, you must say something like
        sub matchedset (::T, $ where { $_.WHAT === T }
  Unpacking array parameters
    Instead of specifying an array parameter as an array:
        sub quicksort (@data, $reverse?, $inplace?) {
            my $pivot := shift @data;
    it may be broken up into components in the signature, by specifying the
    parameter as if it were an anonymous array of parameters:
        sub quicksort ([$pivot, *@data], $reverse?, $inplace?) {
    This subroutine still expects an array as its first argument, just like
    the first version.
  Unpacking a single list argument
    To match the first element of the slurpy list, use a "slurpy" scalar:
        sub quicksort (:$reverse, :$inplace, *$pivot, *@data)
  Unpacking tree node parameters
    You can unpack hash values and tree nodes in various dwimmy ways by
    enclosing the bindings of child nodes and attributes in parentheses
    following the declaration of the node itself:
        sub traverse ( BinTree $top ( $left, $right ) ) {
            traverse($left);
            traverse($right);
    In this, $left and $right are automatically bound to the left and right
    nodes of the tree. If $top is an ordinary object, it binds the
    "$top.left" and "$top.right" attributes. If it's a hash, it binds
    "$top<left>" and "$top<right>". If "BinTree" is a signature type and
    $top is a "Capture" (argument list) object, the child types of the
    signature are applied to the actual arguments in the argument list
    object. (Signature types have the benefit that you can view them
    inside-out as constructors with positional arguments, such that the
    transformations can be reversible.)
    However, the full power of signatures can be applied to pattern match
    just about any argument or set of arguments, even though in some cases
    the reverse transformation is not derivable. For instance, to bind to an
    array of children named ".kids" or ".<kids>", use something like:
        proto traverse ($) {*}
        multi traverse ( NAry $top ( :kids [$eldest, *@siblings] ) ) {
            traverse($eldest);
            traverse(:kids(@siblings));  # (binds @siblings to $top)
        multi traverse ( $leaf ) {...}
    The second candidate is called only if the parameter cannot be bound to
    both $top and to the "kids" parsing subparameter.
    Likewise, to bind to a hash element of the node and then bind to keys in
    that hash by name:
        sub traverse ( AttrNode $top ( :%attr{ :$vocalic, :$tense } ) ) {
            say "Has {+%attr} attributes, of which";
            say "vocalic = $vocalic";
            say "tense = $tense";
    You may omit the top variable if you prefix the parentheses with a colon
    to indicate a signature. Otherwise you must at least put the sigil of
    the variable, or we can't correctly differentiate:
        my Dog ($fido, $spot)   := twodogs();       # list of two dogs
        my Dog $ ($fido, $spot) := twodogs();       # one twodog object
        my Dog :($fido, $spot)  := twodogs();       # one twodog object
    Sub signatures can be matched directly within regexes by using ":(...)"
        push @a, "foo";
        push @a, \(1,2,3);
        push @a, "bar";
        my ($i, $j, $k);
        @a ~~ rx/
                <,>                         # match initial elem boundary
                :(Int $i,Int $j,Int? $k)    # match lists with 2 or 3 ints
                <,>                         # match final elem boundary
              /;
        say "i = $<i>";
        say "j = $<j>";
        say "k = $<k>" if defined $<k>;
    If you want a parameter bound into $/, you have to say "$<i>" within the
    signature. Otherwise it will try to bind an external $i instead, and
    fail if no such variable is declared.
    Note that unlike a sub declaration, a regex-embedded signature has no
    associated "returns" syntactic slot, so you have to use "-->" within the
    signature to specify the "of" type of the signature, or match as an
    arglist:
        :(Num, Num --> Coord)
        :(\Coord(Num, Num))
    A consequence of the latter form is that you can match the type of an
    object with ":(\Dog)" without actually breaking it into its components.
    Note, however, that it's not equivalent to say
        :(--> Dog)
    which would be equivalent to
        :(\Dog())
    that is, match a nullary function of type "Dog". Nor is it equivalent to
        :(Dog)
        :(\Any(Dog))
    and match a function taking a single parameter of type Dog.
    Note also that bare "\(1,2,3)" is never legal in a regex since the first
    (escaped) paren would try to match literally.
  Attributive parameters
    If a submethod's parameter is declared with a "." or "!" after the sigil
    (like an attribute):
        submethod initialize($.name, $!age) {}
    then the argument is bound directly to the object's attribute of the
    same name. This avoids the frequent need to write code like:
        submethod initialize($name, $age) {
            $.name = $name;
            $!age  = $age;
    The initialization of attributes requires special care to preserve
    encapsulation; therefore the default for attributive parameters is value
    semantics, that is, as if specified with "is copy". Hence, the submethod
    above is really more like:
        submethod initialize($name is copy, $age is copy) {
            $.name := $name;      # or maybe = here, since it's a parent's attr
            $!age  := $age;       # or maybe only $! parameters work really
    If you wish to allow the user to initialize an attribute by reference,
    you may either write your own initializer submethod explicitly, or
    simply mark the attributes you want to work that way with "is raw":
        has $!age is raw;   # BUILD will automatically use binding, not copy
    To rename an attribute parameter you can use the explicit pair form:
        submethod initialize(:moniker($.name), :youth($!age)) {}
    The ":$name" shortcut may be combined with the "$.name" shortcut, but
    the twigil is ignored for the parameter name, so
        submethod initialize(:$.name, :$!age) {}
    is the same as:
        submethod initialize(:name($.name), :age($!age)) {}
    Note that "$!age" actually refers to the private ""has"" variable that
    can be referred to as either $age or "$!age".
  Placeholder variables
    Even though every bare block is a closure, bare blocks can't have
    explicit parameter lists. Instead, they use "placeholder" variables,
    marked by a caret ("^") or a colon (":") after their sigils. The caret
    marks positional placeholders, while the colon marks named placeholders.
    Using placeholders in a block defines an implicit parameter list. The
    signature is the list of distinct positional placeholder names, sorted
    in Unicode order, following by the named placeholder names in any order.
        { say "woof" if $:dog; $^y < $^z && $^x != 2 }
    is a shorthand for:
        -> $x,$y,$z,:$dog { say "woof" if $dog; $y < $z && $x != 2 }
    Note that placeholder variables syntactically cannot have type
    constraints. Also, it is illegal to use placeholder variables in a block
    that already has a signature, because the autogenerated signature would
    conflict with that. Positional placeholder names consisting of a single
    uppercase letter are disallowed, not because we're mean, but because it
    helps us catch references to obsolete Perl 5 variables such as $^O.
    The $_ variable functions as a placeholder in a block without any other
    placeholders or signature. Any bare block without placeholders really
    has a parameter like this:
        -> $_ is raw = OUTER::<$_> { .mumble }
    (However, statement control "if" notices this and passes no argument, so
    $_ ends up being bound to the outer $_ anyway.)
    A block may also refer to either @_ or %_ or both, each of which will be
    added to generated signature as a normal readonly slurpy parameter:
        { say $:what; warn "bad option: $_\n" for keys %_; }
    turns into
        -> :$what, *%_ { say $what; warn "bad option: $_\n" for keys %_; }
    If not used, they are not added, and a dispatch with mispatched
    parameters will fail.
    The use of a P5ish @_ in a signatureless sub falls naturally out of
        sub sayall { .say for @_ }
    Note that in this case, $_ is not treated as a placeholder because there
    is already the @_ placeholder. And @_ is a placeholder only because the
    sub has no official signature. Otherwise it would be illegal (unless
    explicitly declared).
    Placeholders may also be used in method bodies that have no formal
    signature. The invocant is always removed first, so the first
    placeholder argument always refers to the first non-invocant argument.
    @_ will never contain the invocant. The invocant is always available via
    "self", of course.
    Since the placeholder declares a parameter variable without the twigil,
    the twigil is needed only on the first occurrence of the variable within
    the block. Subsequent mentions of that variable may omit the twigil.
    Within an internal nested block the twigil *must* be omitted, since it
    would wrongly attach to the inner block.
    Note that, unlike in Perl 5, @_ may not be used within an inner block to
    refer to the outer block's arguments:
        sub say-or-print {
            if $SAYIT {
                say @_;     # WRONG
            else {
                print @_;   # WRONG
    because this desugars to:
            if $SAYIT -> *@_ {
                say @_;
            else -> *@_ {
                print @_;
    Translators of Perl 5 will need to bear this in mind.
Properties and traits
    Compile-time properties are called "traits". The "is *NAME* (*DATA*)"
    syntax defines traits on containers and subroutines, as part of their
    declaration:
        constant $pi is Approximated = 3;   # variable $pi has Approximated trait
        my $key is Persistent(:file<.key>);
        sub fib is cached {...}
    The "will *NAME* *BLOCK*" syntax is a synonym for "is *NAME* (*BLOCK*)":
        my $fh will undo { close $fh };    # Same as: my $fh is undo({ close $fh });
    The "but *NAME* (*DATA*)" syntax specifies run-time properties on
    values:
        constant $pi = 3 but Inexact;       # value 3 has Inexact property
        sub system {
            return $error but False if $error;
    Properties are predeclared as roles and implemented as mixins--see S12.
  Subroutine traits
    These traits may be declared on the subroutine as a whole (individual
    parameters take other traits). Trait syntax depends on the particular
    auxiliary you use, but for "is", the subsequent syntax is identical to
    adverbial syntax, except that that colon may be omitted or doubled
    depending on the degree of ambiguity desired:
        sub x() is ::Foo[...]       # definitely a parameterized typename
        sub x() is :Foo[...]        # definitely a pair with a list
        sub x() is Foo[...]         # depends on whether Foo is predeclared as type
    "is signature"
        The signature of a subroutine. Normally declared implicitly, by
        providing a parameter list and/or return type.
    "as"/"is as"
        The "inner" type constraint that a routine imposes on its return
        value.
    "of"/"is of"
        The "of" type that is the official return type of the routine. Or
        you can think of "of" as outer/formal. If there is no inner type,
        the outer type also serves as the inner type to constrain the return
    "will do"
        The block of code executed when the subroutine is called. Normally
        declared implicitly, by providing a block after the subroutine's
        signature definition.
    "is rw"
        Marks a subroutine as returning an lvalue.
    "is raw"
        Marks a subroutine as returning a raw alias.
    "is parsed"
        Specifies the subrule by which a macro call is parsed. The parse
        always starts after the macro's initial token. If the operator has
        two parts (circumfix or postcircumfix), the final token is also
        automatically matched, and should not be matched by the supplied
        regex.
        [This trait and the following are likely to be deprecated in favor
        of slang macros that are aware of the grammar and category in which
        they are installed, and that therefore already know how to parse
        like normal grammar rules. The actions of slang macros, however,
        will be more targeted toward user-level AST production and
        manipulation through use of quasi quoting and unquoting, as well as
        through direct access to some as-yet-unspecified high-level,
        VM-independent AST representation.]
    "is reparsed"
        Also specifies the subrule by which a macro call is parsed, but
        restarts the parse before the macro's initial token, usually because
        you want to parse using an existing rule that expects to traverse
        the initial token. If the operator has two parts (circumfix or
        postcircumfix), the final token must also be explicitly matched by
        the supplied regex.
    "is cached"
        Marks a subroutine as being memoized, or at least memoizable. In the
        abstract, this cache is just a hash where incoming argument
        "Capture"s are mapped to return values. If the "Capture" is found in
        the hash, the return value need not be recalculated. If you use this
        trait, the compiler will assume two things:
        *   A given "Capture" would always calculate the same return value.
            That is, there is no state hidden within the dynamic scope of
            the call.
        *   The cache lookup is likely to be more efficient than
            recalculating the value in at least some cases, because either
            most uncached calls would be slower (and reduce throughput), or
            you're trying to avoid a significant number of pathological
            cases that are unacceptably slow (and increase latency).
        This trait is a suggestion to the compiler that caching is okay. The
        compiler is free to choose any kind of caching algorithm (including
        non-expiring, random, lru, pseudo-lru, or adaptive algorithms, or
        even no caching algorithm at all). The run-time system is free to
        choose any kind of maximum cache size depending on the availability
        of memory and trends in usage patterns. You may suggest a particular
        cache size by passing a numeric argument (representing the maximum
        number of unique "Capture" values allowed), and some of the possible
        algorithms may pay attention to it. You may also pass "*" for the
        size to request a non-expiring cache (complete memoization). The
        compiler is free to ignore this too.
        The intent of this trait is to specify performance hints without
        mandating any exact behavior. Proper use of this trait should not
        change semantics of the program; it functions as a kind of "pragma".
        This trait will not be extended to reinvent other existing ways of
        achieving the same effect. To gain more control, write your own
        trait handler to allow the use of a more specific trait, such as
        ""is lru(42)"". Alternately, just use a state hash keyed on the
        sub's argument capture to write your own memoization with complete
        control from within the subroutine itself, or from within a wrapper
        around your subroutine.
    "is tighter"/"is looser"/"is equiv"
        Specifies the precedence of an operator relative to an existing
        operator. "tighter" and "looser" precedence levels default to being
        left associative. They define a new precedence level slightly
        tighter or looser than the precedence level on which they're based.
        Both "tighter" and "looser" may be specified, in which case the new
        precedence level is generated midway between the specified levels.
        Two different declarations using the same precedence derivation end
        up at the same precedence level, as if "equiv" was specified instead
        of "tighter"/"looser", and the second will clone the associativity
        of the first. If the second explicitly specifies an associativity
        that differs from the first, unexpected parsing conflicts may
        result. (See S03.)
        In addition to cloning the precedence level, "equiv" also clones
        other traits, so it specifies the default associativity to be the
        same as the operator to which the new operator is equivalent. The
        following are the default equivalents for various syntactic
        categories if neither "equiv" nor "assoc" is specified. (Many of
        these have no need of precedence or associativity because they are
        parsed specially. Nevertheless, "equiv" may be useful for cloning
        other traits of these operators.)
            category:<prefix>
            circumfix:<( )>
            dotty:<.>
            infix:<+>
            infix_circumfix_meta_operator:['»','«']
            infix_postfix_meta_operator:<=>
            infix_prefix_meta_operator:<!>
            package_declarator:<class>
            postcircumfix:<( )>
            postfix:<++>
            postfix_prefix_meta_operator:['»']
            prefix:<++>
            prefix_circumfix_meta_operator:['[',']']
            prefix_postfix_meta_operator:['«']
            q_backslash:<\\>
            qq_backslash:<n>
            quote_mod:<c>
            quote:<q>
            regex_assertion:<?>
            regex_backslash:<w>
            regex_metachar:<.>
            regex_mod_internal:<i>
            routine_declarator:<sub>
            scope_declarator:<my>
            sigil:<$>
            special_variable:<$!>
            statement_control:<if>
            statement_mod_cond:<if>
            statement_mod_loop:<while>
            statement_prefix:<do>
            term:<*>
            trait_mod:<is>
            trait_verb:<of>
            twigil:<?>
            type_declarator:<subset>
            version:<v>
        The existing operator may be specified either as a function object
        or as a string argument equivalent to the one that would be used in
        the complete function name. In string form the syntactic category
        will be assumed to be the same as the new declaration. Therefore
        these all have the same effect:
            sub postfix:<!> ($x) is equiv(&postfix:<++>) {...}
            sub postfix:<!> ($x) is equiv<++> {...}
            sub postfix:<!> ($x) {...}      # since equiv<++> is the default
        Prefix operators that are identifiers are handled specially. The
        form with one argument defaults to named unary precedence instead of
        autoincrement precedence:
            sub prefix:<foo> ($x) {...}
            foo 1, 2, 3;        # means foo(1), 2, 3
        Likewise postfix operators that look like method calls are forced to
        default to the precedence of method calls. Any prefix operator that
        requires multiple arguments defaults to listop precedence, even if
        it is not an identifier:
            sub prefix:<☎> ($x,$y) {...}
            ☎ 1;                # ERROR, too few arguments
            ☎ 1, 2;             # okay
            ☎ 1, 2, 3;          # ERROR, too many arguments
        You must use the "prefix:<foo>" form in order to mutate the grammar
        to parse as a named unary operator. Normal function definitions
        never change the grammar, and when called always parse as listops,
        even if defined with a single argument:
            sub foo ($x) {...}  # a listop
            foo(1), 2, 3;       # okay
            (foo 1), 2, 3;      # okay
            foo 1, 2, 3;        # ERROR, too many arguments
        Likewise 0-ary functions parse as listops. Use "term:<foo>" (or a
        constant or enum declaration) to declare a term that expects no
        Because these traits have an immediate declarative effect, it is
        illegal to apply them to a "multi", or to any post-declared
        function. More generally, any such language-bending declaration must
        follow the same lexical scoping rules that a macro does.
    "is assoc"
        Specifies the associativity of an operator explicitly. Valid values
        are:
            Tag         Examples        Meaning of $a op $b op $c       Default equiv
            ===         ========        =========================       =============
            left        + - * / x       ($a op $b) op $c                +
            right       ** =            $a op ($b op $c)                **
            non         cmp <=> ..      ILLEGAL                         cmp
            chain       == eq ~~        ($a op $b) and ($b op $c)       eqv
            list        | & ^ Z         op($a; $b; $c)                  |
        Note that operators ""equiv"" to relationals are automatically
        considered chaining operators. When creating a new precedence level,
        the chaining is determined by the presence or absence of ""is
        assoc<chain>"", and other operators defined at that level are
        required to be the same.
        Specifying an "assoc" without an explicit "equiv" substitutes a
        default "equiv" consistent with the associativity, as shown in the
        final column above.
        Because this trait has an immediate declarative effect, it is
        illegal to apply it to a "multi", or to any post-declared function.
    "PRE"/"POST"
        These phasers declare statements or blocks that are to be
        unconditionally executed before/after the subroutine's "do" block.
        They must return a true value, otherwise an exception is thrown.
        When applied to a method, the semantics provide support for the
        "Design by Contract" style of OO programming: a precondition of a
        particular method is met if all the "PRE" phasers associated with
        that method return true. Otherwise, the precondition is met if "all"
        of the parent classes' preconditions are met (which may include the
        preconditions of *their* parent classes if they fail, and so on
        recursively.)
        In contrast, a method's postcondition is met if all the method's
        "POST" phasers return true *and* all its parents' postconditions are
        also met recursively.
        "POST" phasers (and ""will post"" phaser traits) declared within a
        "PRE" or "ENTER" block are automatically hoisted outward to be
        called at the same time as other "POST" phasers. This conveniently
        gives "circum" semantics by virtue of wrapping the post lexical
        scope within the pre lexical scope. That is, the "POST" closes over
        its outer scope, even if that scope is gone by the time the "POST"
        is run.
            method push ($new_item) {
                ENTER {
                    my $old_height = self.height;
                    POST { self.height == $old_height + 1 }
                $new_item ==> push @.items;
            method pop () {
                    POST { self.height == $old_height - 1 }
                return pop @.items;
        Note that "self" is available in phasers defined within methods.
        Class invariants are declared with "PRE"/"POST" submethods instead
        of phasers.
        Module invariants are declared with "PRE"/"POST" subs or protos.
        [Conjecture: class and module invariants can applied more
        selectively by marking "PRE"/"POST" declarations with a "selective"
        trait that stops it from running on internal calls (which might
        allow temporary violations of invariants), but enforces the
        invariants when any routine of this module is called from "outside"
        the current module or type, however that's defined. There could be
        arguments to this trait that could refine the concept of what is
        foreign.]
    "ENTER"/"LEAVE"/"KEEP"/"UNDO"/etc.
        These phasers supply code that is to be conditionally executed
        before or after the subroutine's "do" block (only if used at the
        outermost level within the subroutine; technically, these are added
        to the block traits on the "do" block, not the subroutine object).
        These phasers are generally used only for their side effects, since
        most return values will be ignored. (Phasers that run before normal
        execution may be used for their values, however.)
  Parameter traits
    The following traits can be applied to many types of parameters.
    "is readonly"
        Specifies that the parameter cannot be modified (e.g. assigned to,
        incremented). It is the default for parameters. On arguments which
        are already immutable values it is a no-op at run time; on mutable
        containers it may need to create an immutable alias to the mutable
        object if the constraint cannot be enforced entirely at compile
        time. Binding to a readonly parameter never triggers
        autovivification.
        Specifies that the parameter can be modified (assigned to,
        incremented, etc). Requires that the corresponding argument is an
        lvalue or can be converted to one. Since this option forces an
        argument to be required, it cannot coexist with the "?" mark to make
        an argument optional. (It may, however, be used with "=" indicating
        a default, but only if the default expression represents something
        that is nameable at compile time and that can bind as an lvalue,
        such as "CALLER::<$/>" or "OUTER::<$_>".)
        When applied to a variadic parameter, the "rw" trait applies to each
        element of the list:
            sub incr (*@vars is rw) { $_++ for @vars }
        (The variadic array as a whole is always modifiable, but such
        modifications have no effect on the original argument list.)
        Specifies that the parameter is passed as a raw alias, an argument
        object that has not yet had a context imposed. In other words, this
        provides for lazy contextualization even through function calls.
        This is important if you wish to pass the parameter onward to
        something else that will determine its context later.
        You may modify the argument, but only if argument is already a
        suitable lvalue since, unlike "rw", no attempt at autovivification
        is made, so unsuitable lvalues will throw an exception if you try to
        modify them within the body of the routine. That is, if
        autovivification happens, it happens at the point of use, not at the
        point of binding.
        For better visual distinction, such a parameter is declared by
        prefixing with a backslash rather than by using "is raw" directly.
        The backslash is also more succinct; the trait is there primarily
        for introspection.
    "is copy"
        Specifies that the parameter receives a distinct, read-writable copy
        of the original argument. This is commonly known as "pass-by-value".
            sub reprint ($text, $count is copy) {
                print $text while $count-- > 0;
        Binding to a copy parameter never triggers autovivification.
    "is dynamic"
        Specifies that the parameter is to be treated as an "environmental"
        variable, that is, a lexical that is accessible from the dynamic
        scope (see S02).
    "as"
        [DEPRECATED] Specifies that the parameter is to be coerced to the
        given type.
          method link(IO::File:D: $name as Str) { ... }
          sub homedir($path as Str, :$test = <r w x>) { ... }
  Signature Introspection
    A "Signature" object can be introspected to find out the details of the
    parameters it is defined as expected. The ".params" method will return a
    "List" of "Parameter" objects, which have the following readonly
    properties:
      name           The name of the lexical variable to bind to, if any
      type           The main type (the one multi-dispatch sorts by)
      constraints    Any further type constraints
      type_captures  List of names the argument type is captured into
      readonly       True if the parameter has C<is readonly> trait
      rw             True if the parameter has C<is rw> trait
      copy           True if the parameter has C<is copy> trait
      named          True if the parameter is to be passed named
      named_names    List of names a named parameter can be passed as
      capture        True if the parameter binds the caller's Capture
      raw            True if the parameter is too lazy to contextualize
      slurpy         True if the parameter is slurpy
      optional       True if the parameter is optional
      default        A closure returning the default value
      invocant       True if the parameter is a method invocant
      multi_invocant True if the parameter is a multi invocant
      signature      A nested signature to bind the argument against
    Note that "constraints" will be something that can be smart-matched
    against if it is defined; if there are many constraints it may be a
    "Junction" of some sort, but if there is just one it may be simply that
    one thing.
    Further, various things that appear in an original written signature
    will have been deconstructed a bit. For example, a signature like:
      :(1)
    Will introspect the same way as:
      :(Int $ where 1)
    And if we have:
      subset Odd of Int where { $^n % 2 };
      sub foo(Odd $x) { ... }
    Then the signature of foo will be equivalent to something like:
      :(Int $x where { $^n % 2 })
    That is, the refinement type will have been deconstructed into the part
    that nominal type that multiple dispatch uses for sorting the candidates
    and an additional constraint.
Advanced subroutine features
  Processing of returned values
    It is a general policy that lvalues should only be returned up the
    dynamic call stack if specifically requested. Therefore, by default the
    returned arguments are processed to enforce this, both for the implicit
    return from the last statement of any block, as well as the explicit
    return done by operators such as:
        leave
        take
    Specifically, this processing involves examining the returned value's
    arguments and dereferencing any container that could be used as an
    lvalue, replacing it with the container's value.
    To override this processing for a routine, it must be declared "rw", or
    the form "return-rw" must be used.
    To override for a "gather", use "gather-rw" instead, or "take-rw" on the
    individual take.
    Since blocks don't generally have traits, you must use "leave-rw" to
    pass an lvalue out of a block.
  The "return" function
    The "return" function notionally throws a control exception that is
    caught by the current lexically enclosing "Routine" to force a return
    through the control logic code of any intermediate block constructs.
    (That is, it must unwind the stack of dynamic scopes to the proper
    lexical scope belonging to this routine.) With normal blocks (those that
    are autoexecuted in place because they're known to the compiler) this
    unwinding can likely be optimized away to a "goto". All "Routine"
    declarations have an explicit declarator such as "sub" or "method"; bare
    blocks and "pointy" blocks are never considered to be routines in that
    sense. To return from a block, use "leave" instead--see below.
    The "return" function preserves its argument list as a "Capture" object,
    and responds to the left-hand "Signature" in a binding. This allows
    named return values if the caller expects one:
        sub f () { return :x<1> }
        sub g ($x) { print $x }
        my $x := |(f);  # binds 1 to $x, via a named argument
        g(|(f));        # prints 1, via a named argument
    To return a literal "Pair" object, always put it in an additional set of
    parentheses:
        return( (:x<1>), (:y<2>) ); # two positional Pair objects
    Note that the postfix parentheses on the function call don't count as
    being "additional". However, as with any function, whitespace after the
    "return" keyword prevents that interpretation and turns it instead into
    a list operator:
        return :x<1>, :y<2>; # two named arguments (if caller uses |)
        return ( :x<1>, :y<2> ); # two positional Pair objects
    If the function ends with an expression without an explicit "return",
    that expression is also taken to be a "Capture", just as if the
    expression were the argument to a "return" list operator (with
    whitespace):
        sub f { :x<1> } # named-argument binding (if caller uses |)
        sub f { (:x<1>) } # always just one positional Pair object
    On the caller's end, the "Capture" is interpolated into any new argument
    list much like an array would be, that is, as an item in item context,
    and as a list in list context. This is the default behavior, but the
    caller may use "prefix:<|>" to inline the returned values as part of the
    new argument list. The caller may also bind the returned "Capture"
    directly.
    A function is called only once at the time the "Capture" object is
    generated, not when it is later bound (which could happen more than
    once).
  The "callframe" and "caller" functions
    The "callframe" function takes a list of matchers and interprets them as
    a navigation path from the current call frame to a location in the call
    stack, either the current call frame itself or some frame from which the
    current frame was called. It returns an object that describes that
    particular call frame, or a false value if there is no such scope.
    Numeric arguments are interpreted as number of frames to skip, while
    non-numeric arguments scan outward for a frame matching the argument as
    a smartmatch.
    The current frame is accessed with a null argument list.
        say " file ", callframe().file,
            " line ", callframe().line;
    which is equivalent to:
        say " file ", DYNAMIC::<$?FILE>,
            " line ", DYNAMIC::<$?LINE>;
    The immediate caller of this frame is accessed by skipping one level:
        say " file ", callframe(1).file,
            " line ", callframe(1).line;
    You might think that that must be the current function's caller, but
    that's not necessarily so. This might return an outer block in our own
    routine, or even some function elsewhere that implements a control
    operator on behalf of our block. To get outside your current routine,
    see "caller" below.
    The "callframe" function may be given arguments telling it which higher
    scope to look for. Each argument is processed in order, left to right.
    Note that "Any" and 0 are no-ops:
        $ctx = callframe();        # currently running frame for &?BLOCK
        $ctx = callframe(Any);     # currently running frame for &?BLOCK
        $ctx = callframe(Any,Any); # currently running frame for &?BLOCK
        $ctx = callframe(1);       # my frame's caller
        $ctx = callframe(2);       # my frame's caller's caller
        $ctx = callframe(3);       # my frame's caller's caller's caller
        $ctx = callframe(1,0,1,1); # my frame's caller's caller's caller
        $ctx = callframe($i);      # $i'th caller
    Note also that negative numbers are allowed as long as you stay within
    the existing call stack:
        $ctx = callframe(4,-1);    # my frame's caller's caller's caller
    Repeating any smartmatch just matches the same frame again unless you
    intersperse a 1 to skip the current level:
        $ctx = callframe(Method);              # nearest frame that is method
        $ctx = callframe(Method,Method);       # nearest frame that is method
        $ctx = callframe(Method,1,Method);     # 2nd nearest method frame
        $ctx = callframe(Method,1,Method,1)    # caller of that 2nd nearest method
        $ctx = callframe(1,Block);             # nearest outer frame that is block
        $ctx = callframe(Sub,1,Sub,1,Sub);     # 3rd nearest sub frame
        $ctx = callframe({ .labels.any eq 'Foo' }); # nearest frame labeled 'Foo'
    Note that this last potentially differs from the answer returned by
        Foo.callframe
    which returns the frame of the innermost "Foo" block in the lexical
    scope rather than the dynamic scope. A call frame also responds to the
    ".callframe" method, so a given frame may be used as the basis for
    further navigation:
        $ctx = callframe(Method,1,Method);
        $ctx = callframe(Method).callframe(1).callframe(Method);     # same
    You must supply args to get anywhere else, since ".callframe" is the
    identity operator when called on something that is already a "Context":
        $ctx = callframe;
        $ctx = callframe.callframe.callframe.callframe;                # same
    The "caller" function is special-cased to go outward just far enough to
    escape from the current routine scope, after first ignoring any inner
    blocks that are embedded, or are otherwise pretending to be "inline":
        &caller ::= &callframe.assuming({ !.inline }, 1);
    Note that this is usually the same as "callframe(&?ROUTINE,1)", but not
    always. A call to a returned closure might not even have "&?ROUTINE" in
    its dynamic scope anymore, but it still has a caller.
    So to find where the current routine was called you can say:
        say " file ", caller.file,
            " line ", caller.line;
        say " file ", CALLER::<$?FILE>,
            " line ", CALLER::<$?LINE>;
    Additional arguments to "caller" are treated as navigational from the
    calling frame. One frame out from your current routine is *not*
    guaranteed to be a "Routine" frame. You must say "caller(Routine)" to
    get to the next-most-inner routine.
    Note that "caller(Routine).line" is not necessarily going to give you
    the line number that your current routine was called from; you're rather
    likely to get the line number of the topmost block that is executing
    within that outer routine, where that block contains the call to your
    routine.
    For either "callframe" or "caller", the returned CallFrame object
    supports at least the following methods:
        .callframe
        .caller
        .leave
        .inline
        .package
        .file
        .line
        .my
        .hints
        .args
    The ".callframe" and ".caller" methods work the same as the functions
    except that they are relative to the frame supplied as invocant. The
    ".leave" method can force an immediate return from the specified call
    frame.
    The ".inline" method says whether this block was entered implicitly by
    some surrounding control structure. Any time you invoke a block or
    routine explicitly with ".()" this is false. However, it is defined to
    be true for any block entered using dispatcher-level primitives such as
    ".callwith", ".callsame", ".nextwith", or ".nextsame".
    The ".my" method provides access to the lexical namespace associated
    with the given call frame's current position. It may be used to look up
    ordinary lexical variables in that lexical scope. It must not be used to
    change any lexical variable that is marked as readonly.
    The ".hints" method gives access to a snapshot of compiler symbols in
    effect at the point of the call when the call was originally compiled.
    (For instance, "caller.hints('&?ROUTINE')" will give you the caller's
    routine object.) Such values are always read-only, though in the case of
    some (like the caller's routine above) may return a fixed object that is
    nevertheless mutable.
  The "want" function
    The "want" function is gone. If you want context specific behavior,
    return an object instead that responds accordingly to the various
    contextual methods.
    (Conjecture: in future we might want to provide some syntactic sugar
    that makes it easier to create such objects. Or maybe a type that takes
    values or code references for the various contexts, so that you can
       return ContextProxy.new:
            Int   => 3,
            item  => { @.list.join(', ') },
            list  => { ...               },
            ;
    or something similar.)
  The "leave" function
    As mentioned above, a "return" call causes the innermost surrounding
    subroutine, method, rule, token, regex (as a keyword) or macro to
    return. Only declarations with an explicit declarator keyword ("sub",
    "submethod", "method", "macro", "regex", "token", and "rule") may be
    returned from. Statement prefixes such a "do" and "try" do not fall into
    that category. You cannot use "return" to escape directly into the
    surrounding context from loops, bare blocks, pointy blocks, or quotelike
    operators such as "rx//"; a "return" within one of those constructs will
    continue searching outward for a "proper" routine to return from. Nor
    may you return from property blocks such as "BEGIN" or "CATCH" (though
    blocks executing within the lexical and dynamic scope of a routine can
    of course return from that outer routine, which means you can always
    return from a "CATCH" or a "FIRST", but never from a "BEGIN" or "INIT".)
    To return from blocks that aren't routines, the "leave" method is used
    instead. (It can be taken to mean either "go away from" or "bequeath to
    your successor" as appropriate.) The object specifies the scope to exit,
    and the method's arguments specify the return value. If the object is
    omitted (by use of the function or listop forms), the innermost block is
    exited. Otherwise you must use something like "callframe" or "&?BLOCK"
    or a dynamic variable to specify the scope you want to exit. A label
    (such as a loop label) previously seen in the lexical scope also works
    as a kind of singleton dynamic object: it names a statement that is
    serving both as an outer lexical scope and as a frame in the current
    dynamic scope.
    As with "return", the arguments are taken to be a "Capture" holding the
    return values.
        leave;                      # return from innermost block of any kind
        callframe(Method).leave;    # return from innermost calling method
        &?ROUTINE.leave(1,2,3);     # Return from current sub. Same as: return 1,2,3
        &?ROUTINE.leave <== 1,2,3;  # same thing, force return as feed
        OUTER.leave;                # Return from OUTER label in lexical scope
        &foo.leave: 1,2,3;          # Return from innermost surrounding call to &foo
    Note that these are equivalent in terms of control flow:
        COUNT.leave;
        last COUNT;
    However, the first form explicitly sets the return value for the entire
    loop, while the second implicitly returns all the previous successful
    loop iteration values as a list comprehension. (It may, in fact, be too
    late to set a return value for the loop if it is being evaluated
    lazily!) A "leave" from the inner loop block, however, merely specifies
    the return value for that iteration:
        for 1..10 { leave $_ * 2 }   # 2..20
    Note that this:
        leave COUNT;
    will always be taken as the function, not the method, so it returns the
    "COUNT" object from the innermost block. The indirect object form of the
    method always requires a colon:
        leave COUNT: ;
  Temporization
    The "temp" macro temporarily replaces the value of an existing variable,
    subroutine, context of a function call, or other object in a given
    scope:
           temp $*foo = 'foo';      # Temporarily replace global $foo
           temp &bar := sub {...};  # Temporarily replace sub &bar
        } # Old values of $*foo and &bar reinstated at this point
    "temp" invokes its argument's ".TEMP" method. The method is expected to
    return a "Callable" object that can later restore the current value of
    the object. At the end of the lexical scope in which the "temp" was
    applied, the subroutine returned by the ".TEMP" method is executed.
    The default ".TEMP" method for variables simply creates a closure that
    assigns the variable's pre-"temp" value back to the variable.
    New kinds of temporization can be created by writing storage classes
    with their own ".TEMP" methods:
        class LoudArray is Array {
            method TEMP {
                print "Replacing $.WHICH() at {caller.location}\n";
                my $restorer = callsame;
                return {
                    print "Restoring $.WHICH() at {caller.location}\n";
                    $restorer();
                };
    You can also modify the behaviour of temporized code structures, by
    giving them a "TEMP" block. As with ".TEMP" methods, this block is
    expected to return a closure, which will be executed at the end of the
    temporizing scope to restore the subroutine to its pre-"temp" state:
        my $next = 0;
        sub next {
            my $curr = $next++;
            TEMP {{ $next = $curr }}  # TEMP block returns the closure { $next = $curr }
            return $curr;
        say next();     # prints 0; $next == 1
        say next();     # prints 1; $next == 2
        say next();     # prints 2; $next == 3
        if ($hiccough) {
            say temp next();  # prints 3; closes $curr at 3; $next == 4
            say next();       # prints 4; $next == 5
            say next();       # prints 5; $next == 6
        }                     # $next = 3
        say next();     # prints 3; $next == 4
        say next();     # prints 4; $next == 5
    Note that "temp" must be a macro rather than a function because the
    temporization must be arranged before the function causes any state
    changes, and if it were a normal argument to a normal function, the
    state change would be happen before "temp" got control.
    Hypothetical variables use the same mechanism, except that the restoring
    closure is called only on failure.
    Note that dynamic variables may be a better solution than temporized
    globals in the face of multithreading.
  Wrapping
    Every "Routine" object has a ".wrap" method. This method expects a
    single "Callable" argument. Within the code, the special "callsame",
    "callwith", "nextsame" and "nextwith" functions will invoke the original
    routine, but do not introduce an official "CALLER" frame:
        sub thermo ($t) {...}   # set temperature in Celsius, returns old value
        # Add a wrapper to convert from Fahrenheit...
        $handle = &thermo.wrap( { callwith( ($^t-32)/1.8 ) } );
    The "callwith" function lets you pass your own arguments to the wrapped
    function. The "callsame" function takes no argument; it implicitly
    passes the original argument list through unchanged. The "callsame" and
    "nextsame" functions are really short for:
        callwith( |callframe(Routine).args )
        nextwith( |callframe(Routine).args )
    The call to ".wrap" replaces the original "Routine"'s "do" property with
    the "Callable" argument, and arranges that any call to "callsame",
    "callwith", "nextsame" or "nextwith" invokes the previous version of the
    routine. In other words, the call to ".wrap" has more or less the same
    effect as:
        my &old_thermo := &thermo;
        &thermo = sub ($t) { old_thermo( ($t-32)/1.8 ) }
    Note that "&thermo.WHICH" stays the same after the ".wrap", as it does
    with the equivalent assignment shown since assignment to a "Routine"
    works like a container, changing the contained "do" property but not the
    container itself.
    The call to ".wrap" returns a unique handle that has a "restore" method
    that will undo the wrapping:
        $handle.restore;
    This does not affect any other wrappings placed to the routine.
    A wrapping can also be restricted to a particular dynamic scope with
    temporization:
        # Add a wrapper to convert from Kelvin
        # wrapper self-unwraps at end of current scope
        temp &thermo.wrap( { callwith($^t + 273.16) } );
    The entire argument list may be captured by binding to a "Capture"
    parameter. It can then be passed to "callwith" using that name:
        # Double the return value for &thermo
        &thermo.wrap( -> |args { callwith(|args) * 2 } );
    In this case only the return value is changed.
    The wrapper is not required to call the original routine; it can call
    another "Callable" object by passing the "Capture" to its "callwith"
    method:
        # Transparently redirect all calls to &thermo to &other_thermo
        &thermo.wrap( sub (|args) { &other_thermo.callwith(|args) } );
    or more briefly:
        &thermo.wrap( { &other_thermo.callsame } );
    Since the method versions of "callsame", "callwith", "nextsame", and
    "nextwith" specify an explicit destination, their semantics do not
    change outside of wrappers. However, the corresponding functions have no
    explicit destination, so instead they implicitly call the
    next-most-likely method or multi-sub; see S12 for details.
    As with any return value, you may capture the returned "Capture" of
    "call" by binding:
        my |retval := callwith(|args);
        ... # postprocessing
        return |retval;
    Alternately, you may prevent any return at all by using the variants
    "nextsame" and "nextwith". Arguments are passed just as with "callsame"
    and "callwith", but a tail call is explicitly enforced; any code
    following the call will be unreached, as if a return had been executed
    there before calling into the destination routine.
    Within an ordinary method dispatch these functions treat the rest of the
    dispatcher's candidate list as the wrapped function, which generally
    works out to calling the same method in one of our parent (or older
    sibling) classes. Likewise within a multiple dispatch the current
    routine may defer to candidates further down the candidate list.
    Although not necessarily related by a class hierarchy, such later
    candidates are considered more generic and hence likelier to be able to
    handle various unforeseen conditions (perhaps).
    Note that all routines are (by default) considered to be candidates for
    inlining and constant folding. The optimizer is allowed to start making
    these optimizations after the main program's "LINK" time, but not
    before. After any routine is "hard" inlined or constant folded, it is
    explicitly retyped as immutable; any attempt to wrap an immutable
    routine will result in failure of the wrap call. An immutable routine is
    so marked by recasting to type "HardRoutine", a subclass of "Routine".
    On the other hand, it is also possible to explicitly mark a routine as
    mutable, and then the ability to wrap it must be preserved even after
    "LINK" time. This is done by recasting to "SoftRoutine". Explicitly
    marking a routine as either mutable or immutable should be considered
    permanent. It is still possible to inline soft routines, but only if the
    possibility of indirection is detected inline as well, and provision
    made (either inline or via external rewriting) for dealing with any
    wrappers.
    Hence, any routine marked as soft before "LINK" time is exempt from hard
    inlining or folding. There are several methods of marking a routine as
    soft, however no method is provided for marking routines as hard, since
    that is the job of the optimizer. A routine may be marked as soft:
    *   if it is declared using "our" explicitly
    *   if it is mentioned in the argument list of a "use soft" pragma,
    *   if its name matches any wildcard pattern (TBD) in a "use soft",
    *   if the module or class in which it is defined is mentioned in a "use
        soft",
    *   or if there is a general "use soft *;" declaration, which basically
        turns on AOP for everything at run time. Be aware that this may turn
        your optimizer into more of a "pessimizer".
    For any normal standalone application, any "use soft" pragma applies to
    the entire program in which it participates, provided it is performed
    before "LINK" time. The optimizer may then harden anything that was not
    requested to remain soft.
    A plug-in system, such as for a web server, may choose either to allow
    individual plug-ins to behave as independent programs by letting the
    optimizer harden individual plug-ins independently, or treat all
    plug-ins as a part of the same program by softening all plug-ins.
    (Similar considerations apply to optimizing classes to closed/final.)
    Note that installing a wrapper before "LINK" time is specifically *not*
    one of the ways to mark a routine as soft. Such a routine may still be
    hardened at "LINK" time despite being wrapped during compile time.
  The "&?ROUTINE" object
    "&?ROUTINE" is always an alias for the lexically innermost "Routine"
    (which may be a "Sub", "Method", or "Submethod"), so you can specify
    recursion on an anonymous sub:
        my $anonfactorial = sub (Int $n) {
                                return 1 if $n<2;
                                return $n * &?ROUTINE($n-1);
                            };
    You can get the current routine name by calling "&?ROUTINE.name".
    Outside of any sub declaration, this call returns failure.
    Note that "&?ROUTINE" refers to the current single sub, even if it is
    declared "multi". To redispatch to the entire suite under a given short
    name, just use the named form to call the "proto", since there are no
    anonymous "multi"s.
  The "&?BLOCK" object
    "&?BLOCK" is always an alias for the current block, so you can specify
    recursion on an anonymous block:
        my $anonfactorial = -> Int $n { $n < 2
                                            ?? 1
                                            !! $n * &?BLOCK($n-1)
                                      };
    "&?BLOCK.labels" contains a list of all labels of the current block.
    This is typically matched by saying
        if &?BLOCK.labels.any eq 'Foo' {...}
    If the innermost lexical block happens to be the main block of a
    "Routine", then "&?BLOCK" just returns the "Block" object, not the
    "Routine" object that contains it.
    [Note: to refer to any $? or "&?" variable at the time the sub or block
    is being compiled, use the "COMPILING::" pseudopackage.]
  Priming
    Every "Callable" object has a ".assuming" method, which does partial
    function application, aka *priming*. This method does a partial binding
    of a set of arguments to a signature and returns a new function that
    takes only the remaining arguments.
        &textfrom := &substr.assuming(str=>$text, len=>Inf);
        &textfrom := &substr.assuming(:str($text) :len(Inf));
    or even:
        &textfrom := &substr.assuming :str($text):len(Inf);
    It returns a "Callable" object that implements the same behaviour as the
    original subroutine, but has the values passed to ".assuming" already
    bound to the corresponding parameters:
        $all  = textfrom(0);   # same as: $all  = substr($text,0,Inf);
        $some = textfrom(50);  # same as: $some = substr($text,50,Inf);
        $last = textfrom(-1);  # same as: $last = substr($text,-1,Inf);
    Position parameters may also be primed. To skip a position argument,
    pass a "*", which is handled specially by ".assuming". Passing a "Nil"
    causes priming with the default argument supplied with the parameter at
    that position in the signature, or the (presumably undefined) default
    value for the container associated with the parameter if the parameter
    in question has no default. "Nil" may also be passed to a named argument
    to force priming to the default.
    The result of a "use" statement is a (compile-time) object that also has
    a ".assuming" method, allowing the user to bind parameters in all the
    module's subroutines/methods/etc. simultaneously:
        (use IO::Logging).assuming(logfile => ".log");
    This special form should generally be restricted to named parameters.
    To prime a particular "multi" variant, it may be necessary to specify
    the type for one or more of its parameters to pick out a single
    function:
        &woof ::= &bark:(Dog).assuming :pitch<low>;
        &pine ::= &bark:(Tree).assuming :pitch<yes>;
  Macros
    Macros are functions or operators that are called by the compiler as
    soon as their arguments are parsed (if not sooner). The syntactic effect
    of a macro declaration or importation is always lexically scoped, even
    if the name of the macro is visible elsewhere. As with ordinary
    operators, macros may be classified by their grammatical category. For a
    given grammatical category, a default parsing rule or set of rules is
    used, but those rules that have not yet been "used" by the time the
    macro keyword or token is seen can be replaced by use of "is parsed"
    trait. (This means, for instance, that an infix operator can change the
    parse rules for its right operand but not its left operand.)
    In the absence of a signature to the contrary, a macro is called as if
    it were a method on the current match object returned from the grammar
    rule being reduced; that is, all the current parse information is
    available by treating "self" as if it were a $/ object. [Conjecture:
    alternate representations may be available if arguments are declared
    with particular AST types.]
    Macros may return either a string to be reparsed, or a syntax tree that
    needs no further parsing. The textual form is handy, but the syntax tree
    form is generally preferred because it allows the parser and debugger to
    give better error messages. Textual substitution on the other hand tends
    to yield error messages that are opaque to the user. Syntax trees are
    also better in general because they are reversible, so things like
    syntax highlighters can get back to the original language and know which
    parts of the derived program come from which parts of the user's view of
    the program. Nevertheless, it's difficult to return a syntax tree for an
    unbalanced construct, and in such cases a textual macro may be a clearer
    expression of the evil thing you're trying to do.
    If you call a macro at runtime, the result of the macro is automatically
    evaluated again, so the two calls below print the same thing:
        macro f { '1 + 1' }
        say f();    # compile-time call to &f
        say &f();   # runtime call to &f
    A compile-time call to a macro before its definition is erroneous.
  Quasiquoting
    In aid of returning syntax tree, Perl provides a "quasiquoting"
    mechanism using the quote "quasi", followed by a block intended to
    represent an AST:
        return quasi { say "foo" };
    Modifiers to the "quasi" can modify the operation:
        :ast(MyAst)         # Default :ast(AST)
        :lang(Ruby)         # Default :lang($?PARSER)
        :unquote<[: :]>     # Default "triple rule"
    Within a quasiquote, variable and function names resolve according to
    the lexical scope of the macro definition. Unrecognized symbols raise
    errors when the macro is being compiled, *not* when it's being used.
    Use of a macro argument in a quasiquote without unquoting should provide
    a warning, as this is very likely to be an error.
        # Oops; size of the AST of the argument
        macro mouse ($arg) { quasi { $arg.elems } }
    To make a symbol resolve to the (partially compiled) scope of the macro
    call, use the "COMPILING::" pseudo-package:
        macro moose () { quasi { $COMPILING::x } }
        moose(); # macro-call-time error
        moose(); # resolves to 'my $x'
    If you want to mention symbols from the scope of the macro call, use the
    import syntax as modifiers to "quasi":
        :COMPILING<$x>      # $x always refers to $x in caller's scope
        :COMPILING          # All free variables fallback to caller's scope
    If those symbols do not exist in the scope of the compiling scope, a
    compile-time exception is thrown at macro call time.
    Similarly, in the macro body you may either refer to the $x declared in
    the scope of the macro call as $COMPILING::x, or bind to them
    explicitly:
        my $x := $COMPILING::x;
    You may also use an import list to bind multiple symbols into the
    macro's lexical scope:
        require COMPILING <$x $y $z>;
    Note that you need to use the run-time "require" form, not "use",
    because the macro caller's compile-time is the macro's runtime.
  Splicing
    Bare AST variables (such as the arguments to the macro) may not be
    spliced directly into a quasiquote because they would be taken as normal
    bindings. Likewise, program text strings to be inserted need to be
    specially marked or they will be bound normally. To insert an "unquoted"
    expression of either type within a quasiquote, use the quasiquote
    delimiter tripled, typically a bracketing quote of some sort:
        return quasi { say $a + {{{ $ast }}} }
        return quasi [ say $a + [[[ $ast ]]] ]
        return quasi < say $a + <<< $ast >>> >
        return quasi ( say $a + ((( $ast ))) )
    The delimiters don't have to be bracketing quotes, but the following is
    probably to be construed as Bad Style:
        return quasi / say $a + /// $ast /// /
    (Note to implementors: this must not be implemented by finding the final
    closing delimiter and preprocessing, or we'll violate our one-pass
    parsing rule. Perl 6 parsing rules are parameterized to know their
    closing delimiter, so adding the opening delimiter should not be a
    hardship. Alternately the opening delimiter can be deduced from the
    closing delimiter. Writing a rule that looks for three opening
    delimiters in a row should not be a problem. It has to be a special
    grammar rule, though, not a fixed token, since we need to be able to
    nest code blocks with different delimiters. Likewise when parsing the
    inner expression, the inner parser subrule is parameterized to know that
    "}}}" or whatever is its closing delimiter.)
    Unquoted expressions are inserted appropriately depending on the type of
    the variable, which may be either a syntax tree or a string. (Again,
    syntax tree is preferred.) The case is similar to that of a macro called
    from within the quasiquote, insofar as reparsing only happens with the
    string version of interpolation, except that such a reparse happens at
    macro call time rather than macro definition time, so its result cannot
    change the parser's expectations about what follows the interpolated
    variable.
    Hence, while the quasiquote itself is being parsed, the syntactic
    interpolation of an unquoted expression into the quasiquote always
    results in the expectation of an operator following the unquote. (You
    must use a call to a submacro if you want to expect something else.) Of
    course, the macro definition as a whole can expect whatever it likes
    afterwards, according to its syntactic category. (Generally, a term
    expects a following postfix or infix operator, and an operator expects a
    following term or prefix operator. This does not matter for textual
    macros, however, since the reparse of the text determines subsequent
    expectations.)
    Quasiquotes default to hygienic lexical scoping, just like closures. The
    visibility of lexical variables is limited to the quasi expression by
    default. A variable declaration can be made externally visible using the
    "COMPILING::" pseudo-package. Individual variables can be made visible,
    or all top-level variable declarations can be exposed using the "quasi
    :COMPILING" form.
    Both examples below will add $new_variable to the lexical scope of the
    macro call:
      quasi {  my $COMPILING::new_variable;   my $private_var; ... }
      quasi :COMPILING { my $new_variable; { my $private_var; ... } }
    (Note that ":COMPILING" has additional effects described in "Macros".)
Other matters
  Anonymous hashes vs blocks
    "{...}" is always a block. However, if it is completely empty or
    consists of a single list, the first element of which is either a hash
    or a pair, it is executed immediately to compose a "Hash" object.
    The standard "pair" list operator is equivalent to:
        sub pair (*@LIST) {
            my @pairs;
            for @LIST -> $key, $val {
                push @pairs, $key => $val;
            return @pairs;
    or more succinctly (and lazily):
            gather for @LIST -> $key, $val {
                take $key => $val;
    The standard "hash" list operator is equivalent to:
        sub hash (*@LIST) {
            return { pair @LIST };
    So you may use "sub" or "hash" or "pair" to disambiguate:
        $obj =  sub { 1, 2, 3, 4, 5, 6 };   # Anonymous sub returning list
        $obj =      { 1, 2, 3, 4, 5, 6 };   # Anonymous sub returning list
        $obj =      { 1=>2, 3=>4, 5=>6 };   # Anonymous hash
        $obj =      { 1=>2, 3, 4, 5, 6 };   # Anonymous hash
        $obj =  hash( 1, 2, 3, 4, 5, 6 );   # Anonymous hash
        $obj =  hash  1, 2, 3, 4, 5, 6  ;   # Anonymous hash
        $obj = { pair 1, 2, 3, 4, 5, 6 };   # Anonymous hash
  Pairs as lvalues
    Since they are immutable, Pair objects may not be directly assigned:
        (key => $var) = "value";    # ERROR
    However, when binding pairs, names can be used to "match up" lvalues and
    rvalues, provided you write the left side as a signature using ":(...)"
    notation:
        :(:who($name), :why($reason)) := (why => $because, who => "me");
    (Otherwise the parser doesn't know it should parse the insides as a
    signature and not as an ordinary expression until it gets to the ":=",
    and that would be bad. Alternately, the "my" declarator can also force
    treatment of its argument as a signature.)
  Out-of-scope names
    "GLOBAL::<$varname>" specifies the $varname declared in the "*"
    namespace. Or maybe it's the other way around...
    "CALLER::<$varname>" specifies the $varname visible in the dynamic scope
    from which the current block/closure/subroutine was called, provided
    that variable carries the ""dynamic"" trait. (All variables with a "*"
    twigil are automatically marked with the trait. Likewise certain
    implicit lexicals ($_, $/, and $!) are so marked.)
    "DYNAMIC::<$varname>" specifies the $varname visible in the innermost
    dynamic scope that declares the variable with the ""is dynamic"" trait
    or with a name that has the "*" twigil.
    "MY::<$varname>" specifies the lexical $varname declared in the current
    lexical scope.
    "OUR::<$varname>" specifies the $varname declared in the current
    package's namespace.
    "COMPILING::<$varname>" specifies the $varname declared (or about to be
    declared) in the lexical scope currently being compiled.
    "OUTER::<$varname>" specifies the $varname declared in the lexical scope
    surrounding the current lexical scope (i.e. the scope in which the
    current block was defined).
  Declaring a "MAIN" subroutine
    Ordinarily a top-level Perl "script" just evaluates its anonymous
    mainline code and exits. During the mainline code, the program's
    arguments are available in raw form from the @*ARGS array. At the end of
    the mainline code, however, a "MAIN" subroutine will be called with
    whatever command-line arguments remain in @*ARGS. This call is performed
    if and only if:
    a)  the compilation unit was directly invoked rather than by being
        required by another compilation unit, and
    b)  the compilation unit declares a "Routine" named ""MAIN"", and
    c)  the mainline code is not terminated prematurely, such as with an
        explicit call to "exit", or an uncaught exception.
    The command line arguments (or what's left of them after mainline
    processing) is magically converted into a "Capture" and passed to "MAIN"
    as its arguments, so switches may be bound as named args and other
    arguments to the program may be bound to positional parameters or the
    slurpy array:
        sub MAIN ($directory, :$verbose, *%other, *@filenames) {
            for @filenames { ... }
    Each incoming argument is automatically passed through the "val()"
    function, which will attempt to intuit the types of the textual
    arguments such that they may be used in multimethod dispatch. If "MAIN"
    is declared as a set of "multi" subs, multi dispatch is performed, and
    the type information intuited by "val()" may be used to distinguish the
    different signatures:
        multi MAIN (Int $i) {...}   # foo 1
        multi MAIN (Rat $i) {...}   # foo 1/2
        multi MAIN (Num $i) {...}   # foo 1e6
        multi MAIN ($i) {...}       # foo bar
    As with module and class declarations, a sub declared with the "unit"
    declarator (and ending in semicolon) is allowed at the outermost file
    scope if it is the first such declaration, in which case the rest of the
    file is the body:
        unit sub MAIN ($directory, :$verbose, *%other, *@filenames);
        for @filenames { ... }
    This form is allowed only for simple subs named "MAIN" that are intended
    to be run from the command line. A "proto" or "multi" definition may not
    be written in semicolon form, nor may "MAIN" subs within a module or
    class be written in semicolon form. (A "MAIN" routine is allowed in a
    module or class, but is not usually invoked unless the file is run
    directly (see a above). This corresponds to the "unless caller" idiom of
    Perl 5.) In general, you may have only one semicolon-style declaration
    that controls the whole file.
    If an attempted dispatch to "MAIN" fails, the "USAGE" routine is called.
    If there is no "USAGE" routine, a default message is printed to standard
    error. If "--help" is passed as a command line option to the program,
    the usage message is printed to standard output instead.
    This usage message is automatically generated from the signature (or
    signatures) of "MAIN". This message is generated at compile time, and
    hence is available at any later time as "$?USAGE".
    Common Unix command-line conventions are mapped onto the capture as
    follows:
        Assuming C<-n> is the short name for C<--name>,
        On command line...         $*ARGS capture gets...
        # Short names
        -n                         :name
        -n=value                   :name<value>
        -n="spacey value"          :name«'spacey value'»
        -n='spacey value'          :name«'spacey value'»
        -n=val1,'val 2',etc        :name«val1 'val 2' etc»
        # Long names
        --name                     :name
        --name=value               :name<value>
        --name="spacey value"      :name«'spacey value'»
        --name "spacey value"      :name«'spacey value'»
        --name='spacey value'      :name«'spacey value'»
        --name=val1,'val 2',etc    :name«val1 'val 2' etc»
        --                                          # end named argument processing
        # Negation
        --/name                    :!name
        --/name=value              :name<value> but False
        --/name="spacey value"     :name«'spacey value'» but False
        --/name='spacey value'     :name«'spacey value'» but False
        --/name=val1,'val 2',etc   :name«val1 'val 2' etc» but False
        # Native
        :name                      :name
        :/name                     :!name
        :name=value                :name<value>
        :name="spacey value"       :name«'spacey value'»
        :name='spacey value'       :name«'spacey value'»
        :name=val1,'val 2',etc     :name«val1 'val 2' etc»
    Exact Perl 6 forms are okay if quoted from shell processing:
        ':name<value>'             :name<value>
        ':name(42)'                :name(42)
    For security reasons, only constants are allowed as arguments, however.
    The default "Capture" mapper pays attention to declaration of "MAIN"'s
    parameters to resolve certain ambiguities. A "--foo" switch needs to
    know whether to treat the next word from the command line as an
    argument. (Allowing the spacey form gives the shell room to do various
    things to the argument.) The short "-foo" form never assumes a separate
    argument, and you must use "=". For the "--foo" form, if there is a
    named parameter corresponding to the switch name, and it is of type
    "Bool", then no argument is expected. Otherwise an argument is expected.
    If the parameter is of a non-slurpy array type, all subsequent words up
    to the next command-line switch (or the end of the list) are bound to
    that parameter.
    As usual, switches are assumed to be first, and everything after the
    first non-switch, or any switches after a "--", are treated as
    positionals or go into the slurpy array (even if they look like
    switches). Other policies may easily be introduced by calling "MAIN"
    explicitly. For instance, you can parse your arguments with a grammar
    and pass the resulting "Match" object as a "Capture" to "MAIN":
        @*ARGS ~~ /<MyGrammar::top>/;
        MAIN(|$/);
        exit;
        sub MAIN ($frompart, $topart, *@rest) {
            if $frompart<foo> { ... }
            if $topart<bar><baz> { ... }
    This will conveniently bind top-level named matches to named parameters,
    but still give you access to nested matches through those parameters,
    just as any "Match" object would. Of course, in this example, there's no
    particular reason the sub has to be named "MAIN".
    To give both a long and a short switch name, you may use the pair
    notation to install several names for the same parameter. If any of the
    names is a single character, it will be considered a short switch name,
    while all other parameters names are considered as long switch name. So
    if the previous declaration had been:
        sub MAIN (:f(:$frompart), :t(:$topart), *@rest)
    then you could invoke the program with either "-f" or "--frompart" to
    specify the first parameter. Likewise you could use either "-t" or
    "--topart" for the second parameter.
  Relationship of MAIN routine with lexical setting
    The preceding section describes the use of "MAIN" in the user's code.
    There may also be an implicit "MAIN" routine supplied by the setting of
    the current compilation unit. (The "-n" and "-p" command-line switches
    are implemented this way.) In this case the user's mainline code is not
    automatically executed; instead, execution is controlled by the
    setting's "MAIN" routine. That routine calls "{YOU_ARE_HERE}" at the
    point where the user's code is to be lexically inserted (in the
    abstract). A setting may also call "{YOU_ARE_HERE}" outside of a "MAIN"
    routine, in which case it functions as a normal setting, and the
    "{YOU_ARE_HERE}" merely indicates where the user's code goes logically.
    (Or from the compiler's point of view, which the lexical scope to dump a
    snapshot of for later use by the compiler as the setting for a different
    compilation unit.) In this case the execution of the user code proceeds
    as normal. In fact, the "CORE" setting ends with a "{YOU_ARE_HERE}" to
    dump the "CORE" lexical scope as the standard setting. In this sense,
    "CORE" functions as an ordinary prelude.
    If a "MAIN" routine is declared both in the setting and in the user's
    code, the setting's "MAIN" functions as the actual mainline entry point.
    The user's "MAIN" functions in an embedded fashion; the setting's
    invocation of "{YOU_ARE_HERE}" functions as the main invocation from the
    point of view of the user's code, and the user's "MAIN" routine will be
    invoked at the end of each call to "{YOU_ARE_HERE}".
  Implementation note on autothreading of only subs
    The natural way to implement autothreading for "multi" subs is to simply
    have the junctional signatures (the ones that can accept "Mu" or
    junction as well as "Any" parameters) match more loosely than the
    non-autothreading versions, and let multiple dispatch find the
    appropriate sub based on the signature. Those generic routines then end
    up redispatching to the more specific ones.
    On the other hand, the natural implementation of "only" subs is to call
    the sub in question directly for efficiency (and maybe even inline it in
    some cases). That efficiency is, after all, the main reason for not just
    making all subs "multi". However, this direct call conflicts with the
    desire to allow autothreading. It might be tempting to simply make
    everything multi dispatch underneath, and then say that the "only"
    declaration merely means that you get an error if you redeclare. And
    maybe that is a valid approach if the multiple dispatch mechanism is
    fast enough.
    However, a direct call still needs to bind its arguments to its
    parameters correctly, and it has to handle the case of failure to bind
    somehow. So it is also possible to implement autothreading of "only"
    subs based on failover from the binding failure. This could either be a
    one-shot failover followed by a conversion to a "multi" call, or it
    could failover every time you try to autothread. If we assume that
    junctional processing is likely to be fairly heavyweight most of the
    time compared to the cost of failing to bind, that tends to argue for
    failing over every time. This is also more conducive to inlining, since
    it's difficult to rewrite inlined calls. In any case, nowadays a "proto"
    declaration is considered to be a kind of "only" sub, and needs to
    handle autothreading similarly if the signature of the "proto" excludes
    junctions.
  Introspection
    This section describes the methods implemented by the routine objects
    that allow introspection of the inner works of that routine.
   Routine
    .candidates
        This method returns a (potentially lazy) list of the candidates
        associated with the current routine. An "only" routine should return
        a list with itself as the single item.
    .signature
        This method returns the signature of the current routine.
    .cando($capture)
        This method returns a (potentially lazy) list of the candidates that
        match the given capture, ordered by goodness of match, with the best
        match first.
    .push($candidate)
        Adds $candidate to the list of candidates for this "proto", calling
        this method in an "only" routine should result in a failure. It is
        also accepted for "multi"s declared in the source code to finalize
        the list of candidates and also return a failure here. But "Proto"s
        created by calling "Proto.new()" should be able add candidates at
        run-time.
   Signature
    See section "Signature Introspection".
    Synopsis 7: Lists and Iteration
        Created: 07 September 2015
        Last Modified: 07 September 2015
        Version: 1
Design Overview
    Perl 6 provides a wide array of list-related features, including eager,
    lazy, and parallel evaluation of sequences of values, and arrays
    offering compact and multi-dimensional storage. Laziness in particular
    needs careful handling, so as to provide the power advanced users desire
    while not creating surprises for typical language users who have the
    (reasonable) expectation that an assignment into an array will have
    immediate effect. Additionally, it is important to give the programmer
    control of when values will and won't be retained. Finally, all of this
    needs to be done in a way that provides the convenience that a Perl is
    expected to provide, while still having a model that can be understood
    through understanding a small number of rules.
  Sequences vs. Lists
    In Perl 6, we use the term "sequence" to refer to something that can,
    when requested, produce a sequence of values. Of note, it can only be
    asked to produce them once. We use the term "list" to refer to things
    that hold (and so remember) values. There are various concrete types
    that represent various kinds of list and sequence with different
        (1, 2, 3)       # a List, the simplest kind of list
        [1, 2, 3]       # an Array, a list of (assignable) Scalar containers
        |(1, 2)         # a Slip, a list which flattens into a surrounding List
        $*IN.lines      # a Seq, a sequence that can be processed serially
        (^1000).race    # a HyperSeq, a sequence that can be processed in parallel
  The single argument rule
    The "@" sigil in Perl indicates "these", while "$" indicates "the". This
    kind of plural/single distinction shows up in various places in the
    language, and much convenience in Perl comes from it. Flattening is the
    idea that an "@"-like thing will, in certain contexts, have its values
    automatically incorporated into the surrounding list. Traditionally this
    has been a source of both great power and great confusion in Perl. Perl
    6 has been through a number of models relating to flattening during its
    evolution, before settling on a straightforward one known as the "single
    argument rule".
    The single argument rule is best understood by considering the number of
    iterations that a "for" loop will do. The thing to iterate over is
    always treated as a single argument to the "for" loop, thus the name of
    the rule.
        for 1, 2, 3 { }         # List of 3 things; 3 iterations
        for (1, 2, 3) { }       # List of 3 things; 3 iterations
        for [1, 2, 3] { }       # Array of 3 things (put in Scalars); 3 iterations
        for @a, @b { }          # List of 2 things; 2 iterations
        for (@a,) { }           # List of 1 thing; 1 iteration
        for (@a) { }            # List of @a.elems things; @a.elems iterations
        for @a { }              # List of @a.elems things; @a.elems iterations
    The first two are equivalent because parentheses do not actually
    construct a list, but only group. It is the "infix:<,>" operator that
    forms a list. The third also performs three iterations, since in Perl 6
    "[...]" constructs an "Array" but does not wrap it into a "Scalar"
    container. The fourth will do two iterations, since the argument is a
    list of two things; that they both happen to have the "@"-sigil does
    not, alone, lead to any kind of flattening. The same goes for the fifth;
    "infix:<,>" will happily form a list of one thing.
    The single argument rule does respect "Scalar" containers. Therefore:
        for $(1, 2, 3) { }      # List in a Scalar; 1 iteration
        for $[1, 2, 3] { }      # Array in a Scalar; 1 iteration
        for $@a { }             # Array in a Scalar; 1 iteration
    The single argument rule is implemented consistently throughout the
    language. For example, consider the "append" method:
        @a.append: 1, 2, 3;       # appends 3 values to @a
        @a.append: [1, 2, 3];     # appends 3 values to @a
        @a.append: @b;            # appends @b.elems values to @a
        @a.append: @b,;           # same, trailing comma doesn't make > 1 argument
        @a.append: $(1, 2, 3);    # appends 1 value (a List) to @a
        @a.append: $[1, 2, 3];    # appends 1 value (an Array) to @a
    Additionally, the list constructor (the "infix:<,>" operator) and the
    array composer (the "[...]" circumfix) follow the rule:
        [1, 2, 3]               # Array of 3 elements
        [@a, @b]                # Array of 2 elements
        [@a, 1..10]             # Array of 2 elements
        [@a]                    # Array with the elements of @a copied into it
        [1..10]                 # Array with 10 elements
        [$@a]                   # Array with 1 element (@a)
        [@a,]                   # Array with 1 element (@a)
        [[1]]                   # Same as [1]
        [[1],]                  # Array with a single element that is [1]
        [$[1]]                  # Array with a single element that is [1]
    The only one of these that is likely to provide a surprise is "[[1]]",
    but it is deemed sufficiently rare that it does not warrant an exception
    to the very general single argument rule.
User-level Types
    A "List" is an immutable, potentially infinite, list of values. The
    simplest way to form a List is with the "infix:<,>" operator:
        1, 2, 3
    A "List" can be indexed and, provided it is finite, asked for its number
    of elements:
        say (1, 2, 3)[1];       # 2
        say (1, 2, 3).elems;    # 3
    As it is immutable, it is not possible to "push", "pop", "shift",
    "unshift", or "splice" a "List". The "reverse" and "rotate" operations
    return new "List"s.
    While a "List" itself is immutable, it may freely contain mutable
    things, including "Scalar" containers. Thus:
        my $a = 2;
        my $b = 4;
        ($a, $b)[0]++;
        ($a, $b)[1] *= 2;
        say $a;             # 3
        say $b;             # 8
    Trying to assign to an immutable value in a "List" is an error, however.
        (1, 2, 3)[0]++;     # Dies: Cannot assign to an immutable value
  Slip
    The "Slip" type is a subclass of "List". A "Slip" will have its values
    incorporated into a surrounding "List".
        (1, (2, 3), 4).elems        # 3
        (1, slip(2, 3), 4).elems    # 4
    It is possible to coerce a "List" to a "Slip", so the above can also be
    written as:
        (1, (2, 3).Slip, 4).elems   # 4
    This is a common way to get flattening in places it will not magically
    take place:
        my @a = 1, 2, 3;
        my @b = 4, 5;
        for @a.Slip, @b.Slip { }    # 5 iterations
    It's also a bit verbose, which is why the "prefix:<|>" operator will,
    anywhere other than a function call argument list, do a "Slip" coercion:
        for |@a, |@b { }            # 5 iterations
    It can also be useful in forms such as:
        my @prefixed-values = 0, |@values;
    Where the single argument rule would otherwise make "@prefixed-values"
    have two elements, the zero and @values.
    The "Slip" type is also respected by "map", "gather"/"take", and lazy
    loops. It is the way a "map" can place multiple values into its result
    stream:
        my @a = 1, 2;
        say @a.map({ $_ xx 2 }).elems;      # 2
        say @a.map({ |($_ xx 2) }).elems;   # 4
    An "Array" is a subclass of "List" that places values assigned to it
    into "Scalar" containers, meaning they can be mutated. It is the default
    type that an "@"-sigil variable gets.
        say @a.WHAT;        # (Array)
        @a[1]++;
        say @a;             # 1 3 3
    In the absence of a shape specification, it will grow automatically.
        my @a;
        @a[5] = 42;
        say @a.elems;       # 6
    An "Array" supports "push", "pop", "shift", "unshift", and "splice".
    Assignment to an array is eager by default, and creates a new set of
    Scalar containers:
        my @b = @a;
        say @b;             # 1, 2, 3
    Note that the "[...]" "Array" constructor is equivalent to creating and
    then assigning to an anonymous "Array", and so has the same semantics
    with regard to eagerness and fresh containers.
  Seq
    A "Seq" is a one-shot producer of values. Most list processing
    operations return a "Seq", as do most synchronous sources of multiple
    values.
        say (1, 2, 3).map(* + 1).^name;  # Seq
        say (1, 2 Z 'a', 'b').^name;     # Seq
        say (1, 1, * + * ... *).^name;   # Seq
        say $*IN.lines.^name;            # Seq
    Since a "Seq" will not by default remember its values, it can only be
    consumed once. For example, if a "Seq" is stored:
        my \seq = (1, 2, 3).map(* + 1);
    Then only one attempt to iterate it will work; subsequent attempts will
    die as the values have already been consumed:
        for seq { .say }    # 2\n3\n4\n
        for seq { .say }    # Dies: This Seq has already been iterated
    This means you can be confident that a loop going over a file's lines:
        for open('data').lines {
            .say if /beer/;
    Will not be retaining the lines of the file in memory. Additionally, it
    is easy to set up processing pipelines that also will not retain all of
    the lines in memory:
        my \lines = open('products').lines;
        my \beer = lines.grep(/beer/);
        my \excited = beer.map(&uc);
        .say for excited;
    However, any attempt to re-use "lines", "beer", or "excited" will result
    in an error. This program is equivalent in performance to:
        .say for open('products').lines.grep(/beer/).map(&uc);
    But provides a chance to name the stages. Note that it's possible to use
    "Scalar" variables instead, but the single argument rule means that the
    final loop would have to be:
        .say for |$excited;
    Assigning a "Seq" to an "Array" will - so long as the sequence is not
    marked lazy - eagerly perform the operation and store the results into
    the "Array". Therefore, there are no surprises to anyone writing:
        my @lines = open('products').lines;
        my @beer = @lines.grep(/beer/);
        my @excited = @beer.map(&uc);
        .say for @excited;
    Re-using any of these arrays will work out fine. Of course, the memory
    behavior of this program is radically different, and it will be slower
    due to all of the extra "Scalar" containers created (resulting in extra
    garbage collection) and poor locality of reference (we have to talk
    about the same string many times over the programs lifetime).
    Occasionally it can be useful to request that a "Seq" cache itself. This
    can be done by calling the "cache" method on a "Seq", which makes a lazy
    "List" from the "Seq" and returns it. Subsequent calls to "cache" will
    return the same lazy list. Note that the first call to "cache" counts as
    consuming the "Seq", and so it will not work out if any prior iteration
    has taken place, and any later attempt to iterate the "Seq" after
    calling "cache" will also fail. It is only ".cache" which may be called
    more than once.
    A "Seq" does not do the "Positional" role like a "List". Therefore, it
    can not be bound to an "@"-sigil variable:
        my @lines := $*IN.lines;    # Dies
    One consequence of this is that, naively, you could not pass a "Seq" as
    an argument to be bound to an "@"-sigil parameter:
        sub process(@data) {
        process($*IN.lines);
    This would be rather too inconvenient. Therefore, the signature binder
    (which actually uses "::=" assignment semantics rather than ":=") will
    spot failure to bind the <@>-sigil parameter, and then check if the
    argument does the "PositionalBindFailover" role. If it does, then it
    will call the "cache" method on the argument and bind the result of that
    Both "Seq" and "List", along with various other types in Perl 6, do the
    "Iterable" role. The primary purpose of this role is to promise that an
    "iterator" method is available. The average Perl 6 user will rarely need
    to care about the "iterator" method and what it returns.
    The secondary purpose of "Iterable" is to mark out things that will
    flatten on demand, when the "flat" method or function is used on them.
        for flat @a, @b { }         # 5 iterations
        say [flat @a, @b].elems;    # 5
    Another use of "flat" is to flatten nested "List" structure. For
    example, the "Z" (zip) operator produces a "List" of "List":
        say (1, 2 Z 'a', 'b').perl; # ((1, "a"), (2, "b")).Seq
    A "flat" can be used to flatten these, which is useful in conjunction
    with a "for" loop using a pointy block with multiple parameters:
        for flat 1, 2 Z 'a', 'b' -> $num, $letter { }
    Note that "flat" respects "Scalar" containers, and so:
        for flat $(1, 2) { }
    Will only do one iteration. Remember that an "Array" stores everything
    in a "Scalar" container, and so "flat" on an "Array" - short of weird
    tricks with binding - will always be the same as iterating over the
    "Array" itself. In fact, the "flat" method on an "Array" returns
    identity.
  HyperSeq
  array
The Iterator API and Implementation Types
  The Iterator role
  The IterationBuffer class
Parallelism
        Jonathan Worthington <jnthn@jnthn.net>
    Synopsis 8: Capture and Argument Lists
        Created: 20 Sep 2009
Introduction
    Unlike most programming languages, the data structure that is used to
    send the parameters into a routine invocation (be it a method or a sub)
    is exposed to the language as a built-in type like any other. This
    represents a very important aspect of the Perl 6 runtime requirements.
    Additionally to the fact that this data structure is visible in the
    language type system, it is not assumed that the capture is a native
    type, which means that the internal representation of the data is
    subject to change. The only thing the runtime can assume is the API
    described here.
    Of course the runtime can cheat whenever it knows the capture is
    implemented by its own internal data structure for optimization
    purposes, but it should allow the use of foreign types when invoking a
    routine, as long as the object says true to ".^does(Capture)".
    Captures and argument lists are also the basis for the
    multidimensionality of lists in Perl 6. Unlike Perl 5, no flattening
    happens unless it's explicitly required by the user, which is done by
    enforcing the list context. If you use the item context the
    dimensionality should be preserved.
    In addition to the list and item context, there's also a special
    context, which is, in a simplified way, called "Capture context", but it
    actually means "deferred context", in a way that the Capture or List is
    kept as-is while they are manipulated in the code. This is useful to
    avoid unwanted flattening as well as avoiding the DWIMmy features that
    might change the capture's behavior.
    This is the main point of why Captures replace Perl 5 references; they
    allow you to send data untouched from one place to another. The second
    reason is that as in Perl 6 everything is an object, there isn't really
    "pass-by-value" anymore, you're always sending a reference, Captures
    simply carry other objects without enforcing any context on them.
Capture or List
    While a "Capture" is the object that holds the parameters sent to a
    routine (positional and named), a "List" is a more fundamental data
    structure that doesn't really differentiate named arguments from
    positional arguments.
    A list doesn't enforce any context, so a way that no flattening or
    coercion is done. When you examine a list object, it will include all
    the listed items, whether they look like named arguments or positional
    arguments. For example:
      1, 2, :a<b>
    The list represented here has 3 positional items. A List might be
    statically converted to a Capture if it's clear to the parser that it's
    being used as the arguments to a routine call.
    A Capture, on the other hand, is not required to keep the positional
    information for the named arguments, for example:
      foo(1,:a<b>,2)
    In the call to the routine foo, there are only two positional arguments
    and one named argument, and you won't be able to find "b" from the
    "Positional" interface, but only from the Associative.
    The differentiation from List and Capture is important to keep the
    regular use of inline declarations consistent, let's say you do the
    following:
      my $a = (0, :a<b>, 2);
      say $a[2];
    If we had Capture and List as the same data structure, you wouldn't get
    2 as the result of the above code, because there are only two positional
    arguments, not three. Using the same example:
      sub foo($p1, $p2, :$a) {...}
      foo(|$a);
    In that case, the List is converted into a Capture, and therefore the
    pair ":a<b>" is no longer visible as a positional argument, only as
    named.
    Note that once you convert a List into a Capture, you won't be able to
    get the original List again, because a Capture doesn't hold the
    information about the position of named arguments.
Multidimensionality
    Probably the most important task of Lists and Captures is to implement
    the multidimensionality of lists in Perl 6, this means that the barrier
    used to detect the dimensionality of the data structures by the
    operators is whatever the item inside it implements List or Capture. For
    instance:
      my $a = (1, (2, (3, 4)));
      say $a[1];
    In that case, you'll get "2, (3, 4)" (or whatever is implemented in the
    .Str method of that specific List).
    But, you should be able to:
      say $a[1;0];
    Which is going to return 2, which is almost the same as:
      say $a[1][0];
    But the first provides a more convenient and optimizeable way of asking
    for it. If you want to get the value 4 from that data structure you need
    to:
      say $a[1;1;1];
    Note that if you assign that list to an array, it will be flattened, so:
      my @a = 1, (2, (3, 4));
      say @a[3];
    Would print 4, at the same time that trying to ask for
    multidimensionality information from that list would result in a
    failure:
      say @a[1;1;1];
    As the element 1 of the array @a is not a Capture or a List, it is not
    possible for the ".[]" operator to traverse it.
    [Conjecture: It is still not clear if the multidimensional access should
    be able to get into regular arrays, i.e.: "[1,[2,[3,[4]]]] ]"
    It is important to realize that it's not the parens that are creating
    the List, but the "infix:<,>". The parens are only required in order to
    define a sub-list.
    On the other hand, if you bind a list to a variable, it doesn't really
    matter which sigil it uses:
      my @a := (1, (2, (3, 4)));
      say @a[1;1;1]; # "4"
      say @a[3]; # failure
    Captures and argument lists are seen the same way regarding
    multidimensionality, for instance:
      my $a = ((map { $_ * 2 }, 1..5),(map { $_ / 2 }, 1..5));
      say $a[0;0]; # 2
      say $a[1;0]; # 0.5
    The same way, if each map closure returns more than one item inside its
    capture:
      my $a = ((map { $_ * 2, $_ / 2 }, 1..5),(map { $_ / 2, $_ * 2 }, 1..5));
      say $a[0;0;0]; # 2
      say $a[0;0;1]; # 0.5
      say $a[1;0;0]; # 0.5
      say $a[1;0;0]; # 2
    The flattening process will traverse into Lists and Captures, so:
      1, (2, (3, 4))
    will result in:
      1, 2, 3, 4
    after flattening, while:
      1, [2, [3, 4]]
    Would remain as-is.
Context deferral
    Also known as "Capture Context", defines how you can defer the context
    coercion for a given value. That is a fundamental feature because
    something as simple as assigning to a scalar might imply context
    coercion that would get you a modified value.
    Capture context is able to preserve the values as-is, in a way that you
    can later apply any context and have the same result as if the context
    was applied immediately.
    Context deferral is actually the reason why Perl 6 no longer supports
    the "wantarray" operator, nor does it provide any substitute. The way
    you should implement wantarray-like behavior is by properly overriding
    the coercion for each context. The Contextual::Return module is an
    implementation of that concept in Perl 5.
    [ The capture sigil does not exist, though left in this document for the
    time being pending a suitable replacement mechanism to handle context
    deferral.]
    In order to use the context deferral in your code, you need to use the
    "capture sigil", which can be presented in two forms:
      my ¢a = (1, (2, (3, 4)));
    Synopsis 9: Data Structures
        Created: 13 Sep 2004
        Version: 52
    This synopsis summarizes the non-existent Apocalypse 9, which discussed
    in detail the design of Perl 6 data structures. It was primarily a
    discussion of how the existing features of Perl 6 combine to make it
    easier for the PDL folks to write numeric Perl.
Lazy lists
    All list contexts are lazy by default. They might still flatten
    eventually, but only when forced to. You have to use the "eager" list
    operator to get a non-lazy list context, and you have to use the "flat"
    operator to guarantee flattening. However, such context is generally
    provided by the eventual destination anyway, so you don't usually need
    to be explicit.
Sized types
    Sized low-level types are named most generally by appending the number
    of bits to a generic low-level type name:
        int1
        int2
        int4
        int8
        int16
        int32       (aka int on 32-bit machines)
        int64       (aka int on 64-bit machines)
        int128      (aka int on 128-bit machines)
        uint1       (aka bit)
        uint2
        uint4
        uint8       (aka byte)
        uint16
        uint32
        uint64
        uint128
        num16
        num32
        num64       (aka num on most architectures)
        num128
        complex16
        complex32
        complex64   (aka complex on most architectures)
        complex128
        rat8
        rat16
        rat32
        rat64
        rat128
        buf8        aka buf, a "normal" byte buffer
        buf16       a uint16 buffer
        buf32       a uint32 buffer
        buf64       a uint64 buffer
    Complex sizes indicate the size of each "num" component rather than the
    total. This would extend to tensor typenames as well if they're built-in
    types. Of course, the typical tensor structure is just reflected in the
    dimensions of the array--but the principle still holds that the name is
    based on the number of bits of the simple base type.
    The unsized types "int" and "num" are based on the architecture's normal
    size for "int" and "double" in whatever version of C the run-time system
    is compiled in. So "int" typically means "int32" or "int64", while "num"
    usually means "num64", and "complex" means two of whatever "num" turns
    out to be. For symmetry around the decimal point, native "rat"s have a
    numerator that is twice the size of their denominator, such that a
    "rat32" actually has an "int64" for its numerator. Custom rational types
    may be created by instantiating the "Rational" role with two types; if
    both types used are native types, the resulting type is considered a
    native type.
    You are, of course, free to use macros or type declarations to associate
    additional names, such as "short" or "single". These are not provided by
    default. An implementation of Perl is not required to support 64-bit
    integer types or 128-bit floating-point types unless the underlying
    architecture supports them. 16-bit floating-point is also considered
    optional in this sense.
    And yes, an "int1" can store only -1 or 0. I'm sure someone'll think of
    a use for it...
    Note that these are primarily intended to represent storage types; the
    compiler is generally free to keep all intermediate results in wider
    types in the absence of declarations or explicit casts to the contrary.
    Attempts to store an intermediate result in a location that cannot hold
    it will generally produce a warning on overflow. Underflow may also warn
    depending on the pragmatic context and use of explicit rounding
    operators. The default rounding mode from "Num" to "Int" is to truncate
    the fractional part without warning. (Note that warnings are by
    definition resumable exceptions; however, an exception handler is free
    to either transform such a warning into a fatal exception or ignore it
    completely.)
    An explicit cast to a storage type has the same potential to throw an
    exception as the actual attempt to store to such a storage location
    would.
    With IEEE floating-point types, we have a bias towards the use of
    in-band "+Inf", "-Inf", and "NaN" values in preference to throwing an
    exception, since this is construed as friendlier to vector processing
    and pipelining. Object types such as "Num" and "Int" may store
    additional information about the nature of the failure, perhaps as an
    unthrown exception or warning.
Compact structs
    A class whose attributes are all low-level value types can behave as a
    struct. (Access from outside the class is still only through accessors,
    though, except when the address of a serialized version of the object is
    used or generated for interfacing to C-like languages.) Whether such a
    class is actually stored compactly is up to the implementation, but it
    ought to behave that way, at least to the extent that it's trivially
    easy (from the user's perspective) to read and write to the equivalent C
    structure. That is, when serialized or deserialized to the C view, it
    should look like the C struct, even if that's not how it's actually
    represented inside the class. (This is to be construed as a substitute
    for at least some of the current uses of "pack"/"unpack".) Of course, a
    lazy implementation will probably find it easiest just to keep the
    object in its serialized form all the time. In particular, an array of
    compact structs must be stored in their serialized form (see next
    section).
    For types that exist in the C programming language, the serialized
    mapping in memory should follow the same alignment and padding rules by
    default. Integers smaller than a byte are packed into a power-of-two
    number of bits, so a byte holds four 2-bit integers. Datum sizes that
    are not a power of two bits are not supported unless declared by the
    user with sufficient information to determine how to lay them out in
    memory, possibly with a pack/unpack format associated with the class, or
    with the strange elements of the class, or with the types under which
    the strange element is declared.
    Note that a compact struct that has no mutators is itself a value type,
    so except for performance considerations, it doesn't matter how many
    representations of it there are in memory as long as those are
    consistent. On the other hand, structs with mutators must behave more
    like normal mutable objects.
    The packing serialization is performed by coercion to an appropriate
    buffer type. The unpacking is performed by coercion of such a buffer
    type back to the type of the compact struct.
Standard array indexing
    Standard array indices are specified using square brackets. Standard
    indices always start at zero in each dimension of the array (see
    "Multidimensional arrays"), and are always contiguous:
        @dwarves[0] = "Happy";           # The 1st dwarf
        @dwarves[6] = "Doc";             # The 7th dwarf
        @seasons[0] = "Spring";          # The 1st season
        @seasons[2] = "Autumn"|"Fall";   # The 3rd season
Fixed-size arrays
    A basic array declaration like:
        my @array;
    declares a one-dimensional array of indeterminate length. Such arrays
    are autoextending. For many purposes, though, it's useful to define
    array types of a particular size and shape that, instead of
    autoextending, fail if you try to access outside their declared
    dimensionality. Such arrays tend to be faster to allocate and access as
    well. (The language must, however, continue to protect you against
    overflow--these days, that's not just a reliability issue, but also a
    security issue.)
    To declare an array of fixed size, specify its maximum number of
    elements in square brackets immediately after its name:
        my @dwarves[7];           # Valid indices are 0..6
        my @seasons[4];           # Valid indices are 0..3
    No intervening whitespace is permitted between the name and the size
    specification, but "unspace" is allowed:
        my @values[10];           # Okay
        my @keys  [10];           # Error
        my @keys\ [10];           # Okay
    Note that the square brackets are a compile-time declarator, not a
    run-time operator, so you can't use the "dotted" form either:
        my @values.[10];          # An indexing, not a fixed-size declaration
        my @keys\ .[10];          # Ditto
    Attempting to access an index outside an array's defined range will
    fail:
        @dwarves[7] = 'Sneaky';   # Fails with "invalid index" exception
    However, it is legal for a range or sequence iterator to extend beyond
    the end of an array as long as its min value is a valid subscript; when
    used as an rvalue, the range is truncated as necessary to map only valid
    locations. (When used as an lvalue, any non-existent subscripts generate
    WHENCE proxies that can receive new values and autovivify anything that
    needs it.)
    It's also possible to explicitly specify a normal autoextending array:
        my @vices[*];             # Length is: "whatever"
                                  # Valid indices are 0..*
    For subscripts containing range or sequence iterators extending beyond
    the end of autoextending arrays, the range is truncated to the actual
    current size of the array rather than the declared size of that
    dimension. It is allowed for such a range to start one after the end, so
    that
        @array[0..*]
    merely returns "()" if @array happens to be empty. However,
        @array[1..*]
    would fail because the range's min is too big.
    Note that these rules mean it doesn't matter whether you say
        @array[*]
        @array[0 .. *]
        @array[0 .. *-1]
    because they all end up meaning the same thing.
    There is no autotruncation on the left end. It's not that hard to write
    0, and standard indexes always start there.
    Subscript size declarations may add a named ":map" argument supplying a
    closure, indicating that all index values are to be mapped through that
    closure. For example, a subscript may be declared as cyclical:
        my @seasons[4, :map( * % 4 )];
        my @seasons[4, :map{ $_ % 4 }];  # same thing
    In this case, all numeric values are taken modulo 4, and no range
    truncation can ever happen. If you say
        @seasons[-4..7] = 'a' .. 'l';
    then each element is written three times and the array ends up with
    "['i','j','k','l']". The mapping function is allowed to return
    fractional values; the index will be the "floor" of that value. (It is
    still illegal to use a numeric index less that 0.) One could map indexes
    logarithmically, for instance, as long as the numbers aren't so small
    they produce negative indices.
    Another use might be to map positive numbers to even slots and negative
    numbers to odd slots, so you get indices that are symmetric around 0
    (though Perl is not going to track the max-used even and odd slots for
    you when the data isn't symmetric).
Typed arrays
    The type of value stored in each element of the array (normally "Any"
    for unspecified type) can be explicitly specified too, as an external
    "of" type:
        my num @nums;                     # Each element stores a native number
        my @nums of num;                  # Same
        my Book @library[1_000_000];      # Each element stores a Book object
        my @library[1_000_000] of Book;   # Same
    Alternatively, the element storage type may be specified as part of the
    dimension specifier (much like a subroutine definition):
        my @nums[-->num];
        my @library[1_000_000 --> Book];
Compact arrays
    In declarations of the form:
        my bit @bits;
        my int @ints;
        my num @nums;
        my int4 @nybbles;
        my buf @buffers;
        my complex128 @longdoublecomplex;
        my Array @ragged2d;
    the presence of a low-level type tells Perl that it is free to implement
    the array with "compact storage", that is, with a chunk of memory
    containing contiguous (or as contiguous as practical) elements of the
    specified type without any fancy object boxing that typically applies to
    undifferentiated scalars. (Perl tries really hard to make these elements
    look like objects when you treat them like objects--this is called
    autoboxing.)
    Unless explicitly declared to be of fixed size, such arrays are
    autoextending just like ordinary Perl arrays (at the price of
    occasionally copying the block of data to another memory location, or
    using a tree structure).
    A compact array is for most purposes interchangeable with the
    corresponding buffer type. For example, apart from the sigil, these are
    equivalent declarations:
        my uint8 @buffer;
        my buf8 $buffer;
    (Note: If you actually said both of those, you'd still get two different
    names, since the sigil is part of the name.)
    So given @buffer you can say
        $piece = substr(@buffer, $beg, $end - $beg);
    and given $buffer you can also say
        @pieces = $buffer[$n ..^ $end];
    Note that subscripting still pulls the elements out as numbers, but
    "substr()" returns a buffer of the same type.
    For types that exist in the C programming language, the mapping in
    memory should follow the same alignment rules, at least in the absence
    of any declaration to the contrary. For interfacing to C pointer types,
    any buffer type may be used for its memory pointer; note, however, that
    the buffer knows its length, while in C that length typically must be
    passed as a separate argument, so the C interfacing code needs to
    support this whenever possible, lest Perl inherit all the buffer overrun
    bugs bequeathed on us by C. Random C pointers should never be converted
    to buffers unless the length is also known. (Any call to strlen() should
    generally be considered a security hole.) The size of any buffer type in
    bytes may be found with the ".bytes" method, even if the type of the
    buffer elements is not "byte". (Strings may be asked for their size in
    bytes only if they support a buffer type as their minimum abstraction
    level, hopefully with a known encoding. Otherwise you must encode them
    explicitly from the higher-level abstraction into some buffer type.)
Multidimensional arrays
    Perl 6 arrays are not restricted to being one-dimensional (that's simply
    the default). To declare a multidimensional array, you specify it with a
    semicolon-separated list of dimension lengths:
        my int @ints[4;2];          # Valid indices are 0..3 ; 0..1
        my @calendar[12;31;24];     # Valid indices are 0..11 ; 0..30 ; 0..23
    Arrays may also be defined with a mixture of fixed and autoextending
    dimensions. For example, there are always 12 months in a year and 24
    hours in a day, but the number of days in the month can vary:
        my @calendar[12;*;24];     # day-of-month dimension unlimited/ragged
    You can pass a slice (of any dimensionality) for the shape as well:
        @shape = 4, 2;
        my int @ints[ ||@shape ];
    The "prefix:<||>" operator interpolates a list into a semicolon list at
    the semicolon level.
    The shape in the declaration merely specifies how the array will
    autovivify on first use, but ends up as an attribute of the actual
    container object thereby. On the other hand, the shape may be also
    supplied entirely by an explicit constructor at run-time:
        my num @nums = Array of num.new(:shape(3;3;3));
        my num @nums .=new():shape(3;3;3); # same thing
    A multidimensional array is indexed by a semicolon list (or "semilist"),
    which is really a list of lists in disguise. Each sublist is a slice of
    one particular dimension. So:
        @array[0..10; 42; @x]
    is really short for something like:
        @array.postcircumfix:<[ ]>( (0..10), (42), (@x) );
    The method's internal **@slices parameter turns the subscripts into
    three independent lists, which can be read lazily independently of one
    other. (Though a subscripter will typically use them left-to-right as it
    slices each dimension in turn.)
    Note that:
        @array[@x,@y]
    is always interpreted as a one-dimensional slice in the outermost
    dimension, which is the same as:
        @array[@x,@y;]
    or more verbosely:
        @array.postcircumfix:<[ ]>( ((@x,@y)) );
    To interpolate an array at the semicolon level rather than the comma
    level, use the "prefix:<||>" operator:
        @array[||@x]
    which is equivalent to
        @array.postcircumfix:<[ ]>( ((@x[0]), (@x[1]), (@x[2]), etc.) );
  Autoextending multidimensional arrays
    Any dimension of the array may be declared as ""*"", in which case that
    dimension will autoextend. Typically this would be used in the final
    dimension to make a ragged array functionally equivalent to an array of
    arrays:
        my int @ints[42; *];            # Second dimension unlimited/ragged
        push(@ints[41], getsomeints());
    but *any* dimension of an array may be declared as autoextending:
        my @calendar[12;*;24];          # day-of-month dimension unlimited/ragged
        @calendar[1;42;8] = 'meeting'   # See you on January 42nd
    It is also possible to specify that an array has an arbitrary number of
    dimensions, using a "hyperwhatever" ("**") at the end of the dimensional
    specification:
        my @grid[**];                      # Any number of dimensions
        my @spacetime[*;*;*;**];           # Three or more dimensions
        my @coordinates[100;100;100;**];   # Three or more dimensions
    Note that "**" is a shorthand for something that means "||(* xx *)", so
    the extra dimensions are all of arbitrary size. To specify an arbitrary
    number of fixed-size dimensions, write:
        my @coordinates[ ||(100 xx *) ];
    This syntax is also convenient if you need to define a large number of
    consistently sized dimensions:
        my @string_theory[ ||(100 xx 11) ];    # 11-dimensional
User-defined array indexing
    Any array may also be given a second set of user-defined indices, which
    need not be zero-based, monotonic, or even integers. Whereas standard
    array indices always start at zero, user-defined indices may start at
    any finite value of any enumerable type. Standard indices are always
    contiguous, but user-defined indices need only be distinct and in an
    enumerable sequence.
    To define a set of user-defined indices, specify an explicit or
    enumerable list of the indices of each dimension (or the name of an
    enumerable type) in a set of curly braces immediately after the array
    name:
        my @dwarves{ 1..7 };
        my @seasons{ <Spring Summer Autumn Winter> };
        my enum Months
            «:Jan(1) Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec»;
        my @calendar{ Months; 1..31; 9..12,14..17 };    # Business hours only
    Array look-ups via user-defined indices are likewise specified in curly
    braces instead of square brackets:
        @dwarves{7} = "Doc";             # The 7th dwarf
        say @calendar{Jan;13;10};        # Jan 13th, 10am
    User-defined indices merely provide a second, non-standard "view" of the
    array; the underlying container remains the same. Each user-defined
    index in each dimension is mapped one-to-one back to the standard (zero-
    based) indices of that dimension. So, given the preceding definitions:
                     maps to
        @dwarves{1}  ------>  @dwarves[0]
        @dwarves{2}  ------>  @dwarves[1]
                :                   :
        @dwarves{7}  ------>  @dwarves[6]
    and:
                            maps to
        @seasons{'Spring'}  ------>  @seasons[0]
        @seasons{'Summer'}  ------>  @seasons[1]
        @seasons{'Autumn'}  ------>  @seasons[2]
        @seasons{'Winter'}  ------>  @seasons[3]
        @seasons<Spring>    ------>  @seasons[0]
        @seasons<Summer>    ------>  @seasons[1]
        @seasons<Autumn>    ------>  @seasons[2]
        @seasons<Winter>    ------>  @seasons[3]
                              maps to
        @calendar{Jan;1;9}    ------>  @calendar[0;0;0]
        @calendar{Jan;1;10}   ------>  @calendar[0;0;1]
                :                              :
        @calendar{Jan;1;12}   ------>  @calendar[0;0;3]
        @calendar{Jan;1;14}   ------>  @calendar[0;0;4]
        @calendar{Feb;1;9}    ------>  @calendar[1;0;0]
        @calendar{Dec;31;17}  ------>  @calendar[11;30;7]
    User-defined indices can be open-ended, but only on the upper end (i.e.
    just like standard indices). That is, you can specify:
        my @sins{7..*};      # Indices are: 7, 8, 9, etc.
    but not:
        my @virtue{*..6};
        my @celebs{*};
    These last two are not allowed because there is no first index, and
    hence no way to map the infinity of negative user-defined indices back
    to the standard zero-based indexing scheme.
    Declaring a set of user-defined indices implicitly declares the array's
    standard indices as well (which are still zero-based in each dimension).
    Such arrays can be accessed using either notation. The standard indices
    provide an easy way of referring to "ordinal" positions, independent of
    user-specified indices:
        say "The first sin was @sins[0]";
        # First element, no matter what @sin's user-defined indexes are
    Note that if an array is defined with fixed indices (either standard or
    user-defined), any attempt to use an index that wasn't specified in the
    definition will fail. For example:
        my @values{2,3,5,7,11};   # Also has standard indices: 0..4
        say @values[-1];           # Fails (not a valid standard index)
        say @values{1};            # Fails (not a valid user-defined index)
        say @values{4};            # Fails (not a valid user-defined index)
        say @values[5];            # Fails (not a valid standard index)
        say @values{13};           # Fails (not a valid user-defined index)
    Furthermore, if an array wasn't specified with user-defined indices,
    *any* attempt to index it via ".{}" will fail:
        my @dwarves[7];    # No user-defined indices;
        say @dwarves{1};   # Fails: can't map .{1} to a standard .[] index
    When ":k", ":kv", or ":p" is applied to an array slice, it returns the
    kind of indices that were used to produce the slice:
        @arr[0..2]:p          # 0=>'one', 1=>'two', 2=>'three'
        @arr{1,3,5}:p         # 1=>'one', 3=>'two', 5=>'three'
    Adverbs may be applied only to operators, not to terms, so ":k", ":kv",
    and ":p" may not be applied to a full array. However, you may apply an
    adverb to a Zen slice, which can indicate which set of keys are desired:
        my @arr{1,3,5,7,9} = <one two three four five>;
        say @arr[]:k;           # 0, 1, 2, 3, 4
        say @arr{}:k;           # 1, 3, 5, 7, 9
    The ".keys" method also returns the keys of all existing elements. For a
    multidimensional array each key is a list containing one value for each
    dimension.
    The ".shape" method also works on such an array; it returns a slice of
    the valid keys for each dimension. The component list representing an
    infinite dimension is necessarily represented lazily. (Note that the
    ".shape" method returns the possible keys, but the cartesian product of
    the key slice dimensions is not guaranteed to index existing elements in
    every case. That is, this is not intended to reflect current
    combinations of keys in use (use ":k" for that). Note that you have to
    distinguish these two forms:
        @array[].shape      # the integer indices
        @array{}.shape      # the user-defined indices
Inclusive subscripts
    Within any array look-up (whether via ".[]" or ".{}"), the "whatever
    star" can be used to indicate "all the indices". The meaning of "all"
    here depends on the definition of the array. If there are no
    pre-specified indices, the star means "all the indices of currently
    allocated elements":
        my @data                      # No pre-specified indices
            = 21, 43, 9, 11;          # Four elements allocated
        say @data[*];                 # So same as:  say @data[0..3]
        @data[5] = 101;               # Now six elements allocated
        say @data[*];                 # So same as:  say @data[0..5]
    If the array is defined with predeclared fixed indices (either standard
    or user-defined), the star means "all the defined indices":
        my @results{1,3...99}         # Pre-specified indices
            = 42, 86, 99, 1;
        say @results[*];              # Same as:  say @results[0..49]
        say @results{*};              # Same as:  say @results{1,3...99}
    You can omit unallocated elements, either by using the ":v" adverb:
        say @results[*]:v;            # Same as:  say @results[0..3]
        say @results{*}:v;            # Same as:  say @results{1,3,5,7}
    or by using a "zen slice":
        say @results[];               # Same as:  say @results[0..3]
        say @results{};               # Same as:  say @results{1,3,5,7}
    A "whatever star" can also be used as the starting-point of a range
    within a slice, in which case it means "from the first index":
        say @calendar[*..5];          # Same as:  say @calendar[0..5]
        say @calendar{*..Jun};        # Same as:  say @calendar{Jan..Jun}
        say @data[*..3];              # Same as:  say @data[0..3]
    As the end-point of a range, a lone "whatever" means "to the maximum
    specified index" (if fixed indices were defined):
        say @calendar[5..*];          # Same as:  say @calendar[5..11]
        say @calendar{Jun..*};        # Same as:  say @calendar{Jun..Dec}
    or "to the largest allocated index" (if there are no fixed indices):
        say @data[1..*];              # Same as:  say @results[1..5]
Negative and differential subscripts
    The "whatever star" behaves differently than described above when it is
    treated as a number inside a standard index. In this case it evaluates
    to the length of the array. This provides a clean and consistent way to
    count back or forwards from the end of an array:
        @array[*-$N]      # $N-th element back from end of array
        @array[*+$N]      # $N-th element at or after end of array
    More specifically:
        @array[*-2]       # Second-last element of the array
        @array[*-1]       # Last element of the array
        @array[+*]        # First element after the end of the array
        @array[*+0]       # First element after the end of the array
        @array[*+1]       # Second element after the end of the array
        @array[*-3..*-1]  # Slice from third-last element to last element
        @array[*-3..*]    # (Same thing via range truncation)
    (Note that, if a particular array dimension has fixed indices, any
    attempt to index elements after the last defined index will fail, except
    in the case of range truncation described earlier.)
    Negative subscripts are never allowed for standard subscripts unless the
    subscript is declared modular.
    The Perl 6 semantics avoids indexing discontinuities (a source of subtle
    runtime errors), and provides ordinal access in both directions at both
    ends of the array.
Mixing subscripts
    Occasionally it's convenient to be able to mix standard and user-defined
    indices in a single look-up.
    Within a ".[]" indexing operation you can use "*{$idx}" to convert a
    user-defined index $idx to a standard index. That is:
        my @lengths{ Months } = (31,28,31,30,31,30,31,31,30,31,30,31);
        @lengths[ 2 .. *{Oct} ]      # Same as:  @lengths[ 2 .. 9 ]
    Similarly, within a ".{}" indexing operation you can use "*[$idx]" to
    convert from standard indices to user-defined:
        @lengths{ *[2] .. Oct }      # Same as:  @lengths{ Mar .. Oct }
    In other words, when treated as an array within an indexing operation,
    "*" allows you to convert between standard and user-defined indices, by
    acting like an array of the indices of the indexed array. This is
    especially useful for mixing standard and user-defined indices within
    multidimensional array look-ups:
        # First three business hours of every day in December...
        @calendar{Dec; *; *[0..2]}
        # Last three business hours of first three days in July...
        @calendar[*{July}; 0..2; *-3..*-1]
    Extending this feature, you can use "**" within an indexing operation as
    if it were a multidimensional array of *all* the indices of a fixed
    number of dimensions of the indexed array:
        @calendar{ July; **[0..2; *-3..*-1] }
        # Same...
        @calendar[ **{July; 1..3}; *-3..*-1]
    It is also possible to stack subscript declarations of various types,
    including a final normal signature to specify named args and return
        my @array[10]{'a'..'z'}(:$sparse --> MyType);
    [Note: the final signature syntax is merely reserved for now, and not
    expected to work until we figure out what it really means, if it means
    anything.]
PDL support
    An array @array can be tied to a PDL at declaration time:
        my num @array[||@mytensorshape] is PDL;
        my @array is PDL(:shape(2;2;2;2)) of int8;
    PDLs are allowed to assume a type of "num" by default rather than the
    usual simple scalar. (And in general, the type info is merely made
    available to the "tie" implementation to do with what it will. Some data
    structures may ignore the "of" type and just store everything as general
    scalars. Too bad...)
    Arrays by default are one dimensional, but may be declared to have any
    dimensionality supported by the implementation. You may use arrays just
    like scalars -- the main caveat is that you have to use binding rather
    than assignment to set one without copying:
        @b := @a[0,2,4 ... *]
    With PDLs in particular, this might alias each of the individual
    elements rather than the array as a whole. So modifications to @b are
    likely to be reflected back into @a. (But maybe the PDLers will prefer a
    different notation for that.)
    The dimensionality of an array may be declared on the variable, but the
    actual dimensionality of the array depends on how it was created.
    Reconciling these views is a job for the particular array
    implementation. It's not necessarily the case that the declared
    dimensionality must match the actual dimensionality. It's quite possible
    that the array variable is deliberately declared with a different
    dimensionality to provide a different "view" on the actual value:
        my int @array[2;2] is Puddle .= new(:shape(4) <== 0,1,2,3);
    Again, reconciling those ideas is up to the implementation, "Puddle" in
    this case. The traits system is flexible enough to pass any metadata
    required, including ideas about sparseness, raggedness, and various
    forms of non-rectangleness such as triangleness. The implementation
    should probably carp about any metadata it doesn't recognize though. The
    implementation is certainly free to reject any object that doesn't
    conform to the variable's shape requirements.
Subscript and slice notation
    A subscript indicates a "slice" of an array. Each dimension of an array
    is sliced separately, so a multidimensional slice subscript may be
    supplied as a semicolon-separated list of slice sublists. A
    three-dimensional slice might look like this:
        @x[0..10; 1,0; 1,*+2...*]
    It is up to the implementation of @x to decide how aggressively or
    lazily this subscript is evaluated, and whether the slice entails
    copying. (The PDL folks will generally want it to merely produce a
    virtual PDL where the new array aliases its values back into the old
    one.)
    Of course, a single element can be selected merely by providing a single
    index value to each slice list:
        @x[0;1;42]
Cascaded subscripting of multidimensional arrays
    For all multidimensional array types, it is expected that cascaded
    subscripts:
        @x[0][1][42]
        @x[0..10][1,0][1,*+2...*]
    will either fail or produce the same results as the equivalent semicolon
    Built-in array types are expected to succeed either way, even if the
    cascaded subscript form must be implemented inefficiently by
    constructing temporary slice objects for later subscripts to use.
    (User-defined types may choose not to support the cascaded form, but if
    so, they should fail rather than providing different semantics.) As a
    consequence, for built-in types of declared shape, the appropriate
    number of cascaded subscripts may always be optimized into the semicolon
    form.
The semicolon operator
    At the statement level, a semicolon terminates the current expression.
    Within any kind of bracketing construct, semicolon notionally separates
    the sublists of a multidimensional slice, the interpretation of which
    depends on the context. Such a semicolon list treats each of its
    sublists separately, deferring the context of the sublist until it is
    bound somewhere. The storage of these sublists is hidden in the inner
    workings of the list. It does not produce a list of lists unless the
    list as a whole is bound into a slice context.
    Single dimensional arrays expect simple slice subscripts, meaning they
    will treat a list subscript as a slice in the single dimension of the
    array. Multi-dimensional arrays, on the other hand, know how to handle a
    multidimensional slice, with one subslice for each dimension. You need
    not specify all the dimensions; if you don't, the unspecified dimensions
    are "wildcarded". Supposing you have:
        my num @nums[3;3;3];
    Then
        @nums[0..2]
        @nums[0..2;]
        @nums[0,1,2;*;*]
    But you should maybe write the last form anyway just for good
    documentation, unless you don't actually know how many more dimensions
    there are. For that case use "**":
        @nums[0,1,2;**]
    If you wanted that 0..2 range to mean
        @nums[0;1;2]
    it is not good enough to use the "|" prefix operator, because that
    interpolates at the comma level, so:
        @nums[ |(0,1,2) ]
    just means
        @nums[ 0,1,2 ];
    Instead, to interpolate at the semicolon level, you need to use the "||"
    prefix operator:
        @nums[ ||(0..2) ]
    The zero-dimensional slice:
        @x[]
    is assumed to want everything, not nothing. It's particularly handy
    because Perl 6 (unlike Perl 5) won't interpolate a bare array without
        @x = (1,2,3);
        say "@x = @x[]";    # prints @x = 1 2 3
    Lists are lazy in Perl 6, and the slice lists are no exception. In
    particular, list generators are not flattened until they need to be, if
    ever. So a PDL implementation is free to steal the values from these
    generators and "piddle" around with them:
        @nums[$min ..^ $max]
        @nums[$min, *+3 ... $max]
        @nums[$min, *+3 ... *]
        @nums[1,*+2...*]         # the odds
        @nums[0,*+2...*]         # the evens
        @nums[1,3...*]           # the odds
        @nums[0,2...*]           # the evens
PDL signatures
    To rewrite a Perl 5 PDL definition like this:
           pp_def(
                'inner',
                Pars => 'a(n); b(n); [o]c(); ', # the signature, see above
                Code => 'double tmp = 0;
                         loop(n) %{ tmp += $a() * $b(); %}
                         $c() = tmp;' );
    you might want to write a macro that parses something vaguely resembling
        role PDL_stuff[::TYPE] {
            PDLsub inner (@a[$n], @b[$n] --> @c[]) {
                my TYPE $tmp = 0;
                for ^$n {
                    $tmp += @a[$_] * @b[$_];
                @c[] = tmp;
    where that turns into something like this:
            multi inner (TYPE @a, TYPE @b --> TYPE) {
                my $n = @a.shape[0];        # or maybe $n is just a parameter
                assert($n == @b.shape[0]);  #  and this is already checked by PDL
                return $tmp;
    Then any class that "does PDL_stuff[num]" has an "inner()" function that
    can (hopefully) be compiled down to a form useful to the PDL threading
    engine. Presumably the macro also stores away the PDL signature
    somewhere safe, since the translated code hides that information down in
    procedural code. Possibly some of the "[n]" information can come back
    into the signature via "where" constraints on the types. This would
    presumably make multimethod dispatch possible on similarly typed arrays
    with differing constraints.
    (The special destruction problems of Perl 5's PDL should go away with
    Perl 6's GC approach, as long as PDL's objects are registered with the
    run-time system correctly.)
Autothreading types
  Junctions
    A junction is a superposition of data values pretending to be a single
    data value. Junctions come in four varieties:
        list op     infix op
        =======     ========
        any()       |
        all()       &
        one()       ^
        none()      (no "nor" op defined)
    Note that the infix ops are "list-associative", insofar as
        $a | $b | $c
        $a & $b & $c
        $a ^ $b ^ $c
    mean
        any($a,$b,$c)
        all($a,$b,$c)
        one($a,$b,$c)
        any(any($a,$b),$c)
        all(all($a,$b),$c)
        one(one($a,$b),$c)
    Some contexts, such as boolean contexts, have special rules for dealing
    with junctions. In any item context not expecting a junction of values,
    a junction produces automatic parallelization of the algorithm. In
    particular, if a junction is used as an argument to any routine
    (operator, closure, method, etc.), and the scalar parameter you are
    attempting to bind the argument to is inconsistent with the "Junction"
    type, that routine is "autothreaded", meaning the routine will be called
    automatically as many times as necessary to process the individual
    scalar elements of the junction in parallel. ("Each" types are also
    autothreaded, but are serial and lazy in nature.)
    The results of these separate calls are then recombined into a single
    junction of the same species as the junctive argument. If two or more
    arguments are junctive, then the argument that is chosen to be
    "autothreaded" is:
    *   the left-most *all* or *none* junction (if any), or else
    *   the left-most *one* or *any* junction
    with the tests applied in that order.
    Each of the resulting set of calls is then recursively autothreaded
    until no more junctive arguments remain. That is:
           substr("camel", 0|1, 2&3)
        -> all( substr("camel", 0|1, 2),      # autothread the conjunctive arg
                substr("camel", 0|1, 3)
              )
        -> all( any( substr("camel", 0, 2),   # autothread the disjunctive arg
                     substr("camel", 1, 2),
                   ),
                any( substr("camel", 0, 3),   # autothread the disjunctive arg
                     substr("camel", 1, 3),
                   )
        -> all( any( "ca",                    # evaluate
                     "am",
                any( "cam",
                     "ame",
        -> ("ca"|"am") & ("cam"|"ame")        # recombine results in junctions
    Junctions passed as part of a container do not cause autothreading
    unless individually pulled out and used as a scalar. It follows that
    junctions passed as members of a "slurpy" array or hash do not cause
    autothreading on that parameter. Only individually declared parameters
    may autothread. (Note that positional array and hash parameters are in
    fact scalar parameters, though, so you could pass a junction of array or
    hash objects.)
    The exact semantics of autothreading with respect to control structures
    are subject to change over time; it is therefore erroneous to pass
    junctions to any control construct that is not implemented via as a
    normal single dispatch or function call. In particular, threading
    junctions through conditionals correctly could involve continuations,
    which are almost but not quite mandated in Perl 6.0.0. Alternately, we
    may decide that boolean contexts always collapse the junction by
    default, and the exact value that allowed the collapse to "true" is not
    available. A variant of that is to say that if you want autothreading of
    a control construct, you must assign or bind to a non-"Mu" container
    before the control construct, and that assignment or binding to any such
    container results in autothreading the rest of the dynamic scope. (The
    performance ramifications of this are not clear without further
    experimentation, however.) So for now, please limit use of junctions to
    situations where the eventual binding to a scalar formal parameter is
    clear.
  Each
    [This section is considered conjectural.]
    An "Each" type autothreads like a junction, but does so serially and
    lazily, and is used only for its mapping capabilities. The prototypical
    use case is where a hyperoperator would parallelize in an unfortunate
    way:
        @array».say          # order not guaranteed
        @array.each.say      # order guaranteed
Parallelized parameters and autothreading
    Within the scope of a "use autoindex" pragma (or equivalent, such as
    "use PDL" (maybe)), any closure that uses parameters as subscripts is
    also a candidate for autothreading. For each such parameter, the
    compiler supplies a default value that is a range of all possible values
    that subscript can take on (where "possible" is taken to mean the
    declared shape of a shaped array, or the actual shape of an
    autoextending array). That is, if you have a closure of the form:
        -> $x, $y { @foo[$x;$y] }
    then the compiler adds defaults for you, something like:
        -> $x = @foo.shape[0].range,
           $y = @foo.shape[1].range { @foo[$x;$y] }
    where each such range is autoiterated for you.
    In the abstract (and often in the concrete), this puts an implicit loop
    around the block of the closure that visits all the possible subscript
    values for that dimension (unless the parameter is actually supplied to
    the closure, in which case the supplied value is used as the slice
    subscript instead).
    This implicit loop is assumed to be parallelizable.
    So to write a typical tensor multiplication:
        Cijkl = Aij * Bkl
    you can simply call a closure with no arguments, allowing the
    "autoindex" pragma to fill in the defaults:
        use autoindex;
        -> $i, $j, $k, $l { @c[$i; $j; $k; $l] = @a[$i; $j] * @b[$k; $l] }();
    or you can use the "do BLOCK" syntax (see "The do-once loop" in S04) to
    call that closure, which also implicitly iterates:
        do -> $i, $j, $k, $l {
            @c[$i; $j; $k; $l] = @a[$i; $j] * @b[$k; $l]
    or even use placeholder variables instead of a parameter list:
        do { @c[$^i; $^j; $^k; $^l] = @a[$^i; $^j] * @b[$^k; $^l] };
    That's almost pretty.
    It is erroneous for an unbound parameter to match multiple existing
    array subscripts differently. (Arrays being created don't count.)
    Note that you could pass any of $i, $j, $k or $l explicitly, or prebind
    them with a ".assuming" method, in which only the unbound parameters
    autothread.
    If you use an unbound array parameter as a semicolon-list interpolator
    (via the "prefix:<||>" operator), it functions as a wildcard list of
    subscripts that must match the same everywhere that parameter is used.
        do -> @wild { @b[ ||@wild.reverse ] = @a[ ||@wild ] };
    produces an array with the dimensions reversed regardless of the
    dimensionality of @a.
    The optimizer is, of course, free to optimize away any implicit loops
    that it can figure out how to do more efficiently without changing the
    semantics.
    See RFC 207 for more ideas on how to use autothreading (though the
    syntax proposed there is rather different).
Hashes
    Like arrays, you can specify hashes with multiple dimensions and fixed
    sets of keys:
        my num %hash{<a b c d e f>};        # Only valid keys are 'a'..'f'
        my num %hash{'a'..'f'};             # Same thing
        my %rainfall{ Months; 1..31 }       # Keys: Jan..Dec ; 1..31
    Unlike arrays, you can also specify a hash dimension via a non-
    enumerated type, which then allows all values of that type as keys in
    that dimension:
        my num %hash{<a b c d e f>; Str};   # 2nd dimension key may be any string
        my num %hash{'a'..'f'; Str};        # Same thing
        my %rainfall{ Months; Int };        # Keys: Jan..Dec ; any integer
    To declare a hash that can take any object as a key rather than just a
    string or integer, say something like:
        my %hash{Any};
        my %hash{*};
    A hash of indeterminate dimensionality is:
        my %hash{**};
    You can limit the keys to objects of particular types:
        my Fight %hash{Dog; Squirrel where {!.scared}};
    The standard Hash:
        my %hash;
    is really short for:
        my Mu %hash{Str(Any)};
    Note that any type used as a key must be intrinsically immutable, or it
    has to be able to make a copy that functions as an immutable key, or it
    has to have copy-on-write semantics. It is erroneous to change a key
    object's value within the hash except by deleting it and reinserting it.
    The order of hash keys is implementation dependent and arbitrary. Unless
    %hash is altered in any way, successive calls to ".keys", ".kv",
    ".pairs", ".values", or ".iterator" will iterate over the elements in
    the same order.
Autosorted hashes
    The default hash iterator is a property called ".iterator" that can be
    user replaced. When the hash itself needs an iterator for ".pairs",
    ".keys", ".values", or ".kv", it calls "%hash.iterator()" to start one.
    In item context, ".iterator" returns an iterator object. In list
    context, it returns a lazy list fed by the iterator. It must be possible
    for a hash to be in more than one iterator at a time, as long as the
    iterator state is stored in a lazy list.
    The downside to making a hash autosort via the iterator is that you'd
    have to store all the keys in sorted order, and resort it when the hash
    changes. Alternately, the entire hash could be tied to an ISAM
    implementation (not included (XXX or should it be?)).
    For multidimensional hashes, the key returned by any hash iterator is a
    list of keys, the size of which is the number of declared dimensions of
    the hash. [XXX but this seems to imply another lookup to find the value.
    Perhaps the associated value can also be bundled in somehow.]
Autovivification
    Autovivification will only happen if the vivifiable path is bound to a
    read-write container. Value extraction (that is, binding to a readonly
    or copy container) does not autovivify.
    Note that assignment is treated the same way as binding to a copy
    container, so it does not autovivify its right side either.
    Any mention of an expression within a Capture (that is, an argument
    list) delays the autovivification decision to binding time. (Binding to
    a raw parameter defers the decision even further.)
    This is as opposed to Perl 5, where autovivification could happen
    unintentionally, even when the code looks like a non-destructive test:
        # This is Perl 5 code
        exists $hash{foo}{bar}; # creates $hash{foo} as an empty hash reference
    In Perl 6 these read-only operations are indeed non-destructive:
        %hash<foo><bar> :exists; # %hash is still empty
    But these bindings *do* autovivify:
        my $val := %hash<foo><bar>;
        my $capture = \@array[0][0]; # $capture is a Capture object - see S02
        my :($obj) := $capture;   # @array[0][0] created here
        foo(@array[0][0]);
        sub foo ($obj is rw) {...}  # same thing, basically
        %hash<foo><bar> = "foo"; # duh
    This rule applies to "Array", "Hash", and any other container type that
    chooses to return an autovivifiable type object (see S12) rather than
    simply returning "Failure" when a lookup fails. Note in particular that,
    since autovivification is defined in terms of type objects rather than
    failure, it still works under "use fatal".
    This table solidifies the intuition that an operation pertaining to some
    data structure causes the type object to autovivify to such an object:
        operation                autovivifies to
        =========                ===============
        push, unshift, .[]       Array
        .{}                      Hash
    In addition to the above data structures autovivifying, "++" and "--"
    will cause an "Int" to appear, "~=" will create a "Str" etc; but these
    are natural consequences of the operators working on "Failure",
    qualitatively different from autovivifying containers.
    The type of the type object returned by a non-successful lookup should
    be identical to the type that would be returned for a successful lookup.
    The only difference is whether it's officially instantiated (defined)
    yet. That is, you cannot distinguish them via ".WHAT" or ".HOW", only
    via ".defined".
    Binding of an autovivifiable type object to a non-writeable container
    translates the type object into a similar type object without its
    autovivifying closure and puts that new type object into the container
    instead (with any pertinent historical diagnostic information carried
    over). There is therefore no magical method you can call on the readonly
    parameter that can magically autovivify the type object after the
    binding. The newly bound variable merely appears to be a simple
    uninitialized value. (The original type object retains its closure in
    case it is rebound elsewhere to a read-write container.)
    Some implementation notes: Nested autovivifications work by making
    nested type objects that depend on each other. In the general case the
    containers must produce type objects any time they do not know how the
    container will be bound. This includes when interpolated into any
    capture that has delayed binding:
        \( 1, 2, %hash<foo><bar> )          # must defer
        \%hash<foo><bar>                    # must defer
    In specific situations however, the compiler can know that a value can
    only be bound readonly. For instance, "infix:<+>" is prototyped such
    that this can never autovivify:
        %hash<foo><bar> + 42
    In such a case, the container object need not go through the agony of
    calculating an autovivifying closure that will never be called. On the
    other hand:
        %hash<foo><bar> += 42
    binds the left side to a mutable container, so it autovivifies.
    Assignment doesn't look like binding, but consider that it's really
    calling some kind of underlying set method on the container, which must
    be mutable in order to change its contents.
    Synopsis 10: Packages
        Created: 27 Oct 2004
        Last Modified: 9 Jul 2010
        Version: 13
    This synopsis summarizes Apocalypse 10, which discusses packages despite
    never having been written.
Packages
    As in Perl 5, packages are the basis of modules and classes. Unlike in
    Perl 5, modules and classes are declared with distinct keywords, but
    they're still just packages with extra behaviors. Likewise every
    typename has an associated package namespace, even if unused.
    An ordinary package is declared with the "package" keyword. Unlike in
    earlier versions of Perl 5, in Perl 6 it can only be used with a block:
        package Bar {...}   # block is in package Bar
    A named package declaration can occur as part of an expression, just
    like named subroutine declarations.
    As a special exception, if a braceless "package" declaration occurs as
    the first executable statement in a file, then it's taken to mean that
    the rest of the file is Perl 5 code.
        package Foo;        # the entire file is Perl 5
    This form is illegal in a Perl 6 file. If you wish to have a file-scoped
    package, either use the brace form or declare it with the "module"
    keyword instead.
    Since there are no barewords in Perl 6, package names must be
    predeclared. Alternatively, the sigil-like "::PackageName" syntax may be
    used to indicate that the type will be supplied some other way, however
    this syntax is not valid in declarative scenarios, especially parameter
    lists where it has entirely different semantics. The "::" prefix does
    not imply globalness as it does in Perl 5. (Use "GLOBAL::" for that.)
    A bare "package" declarator (without an explicit scope declarator such
    as "my") declares an "our" package within the current package (or
    module, or class, or role, or...). Use "GLOBAL::" to declare a global
    package name.
    To declare a lexically scoped package, use "my package".
    To declare an anonymous package you can use either of
        package {...}
        package :: {...}
    All files start out being parsed in the "GLOBAL" package, but may switch
    to some other package scope depending on the first package-ish
    declaration. If that first declaration is not a package variant, then
    the parsing switches to the ""main"" package for Perl 5 code. Perl 6
    code stays "GLOBAL" in that situation. The mainline code is thus in the
    "GLOBAL" namespace unless declared otherwise.
    Package traits are set using "is":
        package Foo is bar {...}
    All symbolic links are done with the "::($expr)" syntax, which is legal
    in any variable, package, module, or class name anywhere a "::Ident" is
    legal. The string returned by the expression will be parsed for "::"
    indicating subpackage names. Do not confuse this with the
        Foo::{$key}
    syntax that lets you do a lookup in a particular symbol table. In this
    case, the key is not parsed for "::". It's just a hash lookup.
    All package bodies (including module and class bodies) execute at the
    normal execution time of the code in which they are embedded. For normal
    mainline code, this is the normal flow of execution; if this is too late
    to initialize something in the package that you want to be initialized,
    consider use of a MAIN subroutine, which is invoked at the end of normal
    execution. See "Declaring a "MAIN" subroutine" in S06.
    For packages (modules, classes, roles, etc.) defined in separate files
    from the mainline code, there can be no mainline code by definition, but
    the top-level code in the used module needs to be executed at some point
    in case things need initialization. Invocation of this pseudo-mainline
    code in the module notionally happens no later than at the point of the
    "use" or "need" call in the process of compilation, but the module's
    code is assumed to be sufficiently uninteresting that it need be
    executed only once regardless of how many times the module is used
    subsequently in the compilation. (In fact, it might not need to run at
    all if the result of some previous compilation's run has been cached.)
    If it is desired to have code that varies in meaning from run to run,
    then you should put such code into an "INIT" block. (Likewise, you could
    put code into a "CHECK" block that has inconsistent semantics from
    compilation to compilation, but that's probably a bad idea.)
    In any case, it is erroneous for any external module to depend on any
    knowledge of its user with respect to compilation order or other dynamic
    information, since other users may also depend on this single
    "first-use" execution and expect consistent semantics. (Really, all such
    dynamic dependencies should be passed in at run time to the routines or
    methods of your module as normal parameters or as dynamic variables. For
    instance, you cannot know at module compile time whether your caller is
    going to be using 'fatal' semantics or not. That is dynamically scoped
    info.)
    If you wish to have a module that does something extra if invoked
    standalone, define a MAIN subroutine, which will be ignored if the
    module is merely used/needed elsewhere.
Package nesting
    A declaration of any object of the form "A::B::c" also creates (if
    needed) an empty package "A", and an empty package "B" inside of "A", in
    addition to creating "c" inside of "B". Such empty packages may
    subsequently be redeclared as any other package-like object (module,
    class, etc.), and no redeclaration warning will be issued for such a
    redeclaration. If a parent package already exists, no stub package needs
    to be created, and no declaration of the form "A::B::c" has anything to
    say about the type of package "A" or package "A::B", since any package
    variant can function as a package for the purposes of naming things.
    Apart of package declaration constructs, package names are always
    searched for from the innermost lexical scope to outermost. If not
    defined in any surrounding lexical scope, the package is searched for
    from the current package up through the containing packages to "GLOBAL".
    If it is not found, a compiler error results.
    As with an initial "::", the presence of a "::" within the name does not
    imply globalness (unlike in Perl 5). True globals are always in the
    "GLOBAL::" namespace.
    The "PROCESS::" namespace, shared by all interpreters within the
    process, is notionally outside of "GLOBAL::", but package searches do
    not look there for anything. (Contextual variable searches do; $*PID
    will eventually locate $PROCESS::PID if not hidden by an inner
    callframe's $*PID.)
Autoloading
    A package (or any other similar namespace) can control autoloading.
    However, Perl 5's "AUTOLOAD" is being superseded by MMD autoloaders that
    distinguish declaration from definition, but are not restricted to
    declaring subs. A run-time declarator multisub is declared as:
        multi CANDO ( MyPackage, $type, $name, *%args)
    which stands in for the declaration of a container object within another
    container object; it is called when anyone is searching for a name in
    the package (or module, or class), and the name doesn't already exist in
    the package. (In particular, ".can" calls "CANDO" when trying to
    determine if a class supports a particular method.) The arguments to
    "CANDO" include type information on what kind of object is expected in
    context, or this may be intuited from the name requested. In any case,
    there may be multiple "CANDO" routines that are dispatched via MMD:
        multi CANDO ( MyPackage, Item, $name, *%args)
        multi CANDO ( MyPackage, Array, $name, *%args)
        multi CANDO ( MyPackage, Hash, $name, *%args)
        multi CANDO ( MyPackage, Code, $name, *%args)
    The package itself is just passed as the first argument, since it's the
    container object. Subsequent arguments identify the desired type of the
    inner container and the "name" or "key" by which the object is to be
    looked up in the outer container. Such a name does not include its
    container name, unlike Perl 5's magical $AUTOLOAD variable. Nor does it
    include the type information of a Code object's "long name"; this
    information comes in via the type parameter, and may be matched against
    using ordinary subsignature matching:
        multi CANDO ( MyPackage, &:($), $name, *%args)     # 1 arg
        multi CANDO ( MyPackage, &:($,$), $name, *%args)   # 2 args
    The slurpy %args hash is likely to be empty in standard Perl 6 usage,
    but it's possible that some dialects of Perl will desire a mechanism to
    pass in additional contextual information, so this parameter is reserved
    for such purposes.
    The "CANDO" is expected to return an inner container object of the
    proper sort (i.e. a variable, subroutine, or method object), or a proxy
    object that can "autovivify" lazily, or "Nil" if that name is not to be
    considered declared in the namespace in question. (Only bare "Nil" is
    interpreted as "not there", since typed undefs may function as
    autovivifiable proxy objects. See S12.)
    The declaration merely defines the interface to the new object. That
    object need not be completely defined yet, though the "CANDO" routine is
    certainly *allowed* to define it eagerly, and even install the inner
    object into the outer container (the symbol table) if it wants to cache
    the declaration.
    At declaration time it might not yet be known whether the inner
    container object will be used in lvalue or rvalue context; the use of a
    proxy object can supply either readonly or rw semantics later.
    When the package in question is a class, it is also possible to declare
    real methods or submethods:
        multi method CANDO ($self: Code, $name, *%args)
        multi submethod CANDO ($self: Item, $name, *%args)
    The method form is inherited by subclasses. Submethods are never
    inherited but may still do MMD within the class. (Ordinary multisubs are
    "inherited" only to the extent allowed by nested lexical scopes.)
    When the package in question is not a class, there is a slight problem
    insofar as Perl 6 doesn't by default look into packages for functions
    anymore, only lexical scopes. However, we'd still like the ability to
    dynamic add functions to a package, so there are two ways to get around
    the lexical limitation.
    First, presuming you have a "CANDO" that adds to your current package,
    you can simply call a newly-minted subroutine explicitly via the current
    package:
        OUR::($somename)();
    This bypasses the lexical namespaces entirely. Alternately, we can set
    up a mechanism whereby, if you import or define a "CANDO" into a given
    lexical scope, all calls from within that scope register a failover that
    adds the current package to the list of places to look for subroutines
    (or, obviously, call the "CANDO" as a last resort after that). There is
    no performance impact on existing lexically scoped definitions,
    including those from "CORE". This approach does require that failure to
    find a function name cannot be reported at compile time, but must be
    delayed till run time instead. Another potential disadvantage is that
    the package's symbols are also shadowed by all symbols defined in your
    outer lexical scopes, including "CORE". If this is a problem, use the
    direct "OUR" call above.
    Another way to look at it is that a lexical "CANDO" adds itself to the
    end of the function dispatcher's search, but sets up the current package
    as a kind of cache for newly-defined functions just ahead of itself in
    the search path.
    Synopsis 11: Compilation Units
        Last Modified: 2 Apr 2015
        Version: 45
    This synopsis discusses those portions of Apocalypse 12 that ought to
    have been in Apocalypse 11.
Units
    Perl 6 code is compiled per compilation unit, or *compunit* for short.
    These are loaded with a "use", "need" or "require" statement (usually at
    compile time). Or they are created as a string in a variable and
    compiled with an "EVAL" statement (usually at runtime). This synopsis is
    mostly about compunits loaded at compile time.
    In the common vernacular of a Perl 5 developer, a *module* is the same
    as the file that contains the source code of a package. For Perl 6
    developers, this is generally not much different. However, such a
    *module* is really a compunit that may contain 0 or more package-like
    statements, some of which may be *module*. Confusing? Yes it is. On top
    of that, Perl 6 allows different versions of the same compunit to be
    installed in a single *repository*. And it allows compunits from other
    languages to be loaded.
    In Perl, the "use" statement is really just telling Perl to find a
    compunit for the given name and load its contents. Whether that name is
    the name of a "package", "module", "class", "grammar" or "role", a
    combination of these or something else entirely in a "slang", is not
    known at the moment the compunit is searched for (and hopefully found).
    Only when the contents of the compunit are compiled, does Perl find out
    what's inside.
    In Perl 5, the compunit's name to filename translation is generally
    mechanical. "Foo::Bar" will always refer to "Foo/Bar.pm" in a directory:
    it does not need any outside information to find out the name of the
    file to be loaded.
    Perl 6 however, only knows about *repositories* that contain compunits.
    Each repository is represented as an object with the CompUnitRepo
    interface in the "@?INC" array. Whenever a compunit needs to be loaded,
    each element in the "@?INC" is queried for the compunit, and any
    candidates are returned. An exception occurs if there is no candidate,
    or more than one candidate that matches the requirement. Otherwise, the
    contents of the compunit is then obtained and loaded.
    There are 2 standard implementations of the "CompUnitRepo" interface:
    CompUnitRepo::Local::File and CompUnitRepo::Local::Installation. The
    first is used whenever you're specifying the "-I" parameter when running
    Perl 6. The second is always used when searched for locally installed
    compunits as files in directories. Of course, one is free to devise any
    other way of storing and searching for compunits, as long as "API" is
    the same.
    See "Distributions, Recommendations, Delivery and Installation" in S22
    for more information about the "CompUnitRepo" interface.
Modules
    As in Perl 5, a "module" is just a kind of package. Unlike in Perl 5,
    modules and classes are declared with separate keywords, but they're
    still just packages with extra behaviors. In the case of modules, the
    extra behavior is the availability of the "export" trait and any
    associated support for Perl 6 standard export semantics.
    A module is declared with the "module" keyword. There are two basic
    declaration syntaxes:
        unit module Foo; # rest of scope is in module Foo
        module Bar {...}    # block is in module Bar
    A named module declaration can occur as part of an expression, just like
    named subroutine declarations.
    Since there are no barewords in Perl 6, module names must be
    predeclared, or use the sigil-like "::ModuleName" syntax. The "::"
    prefix does not imply globalness as it does in Perl 5. (Use "GLOBAL::"
    for that.)
    A bare (unscoped) "module" declarator declares a nested "our" module
    name within the current package. However, at the start of a compunit,
    the current package is "GLOBAL", so the first such declaration in the
    file is automatically global.
     You can use "our module" to explicitly declare a module in the current
    package. To declare a lexically scoped module, use "my module". Module
    names are always searched for from innermost scopes to outermost. As
    with an initial "::", the presence of a "::" within the name does not
    imply globalness (unlike in Perl 5).
    The default package for the main program is "GLOBAL". (Putting "module
    GLOBAL;" at the top of your program is redundant, except insofar as it
    tells Perl that the code is Perl 6 code and not Perl 5 code. But it's
    better to say "use v6" for that.)
    Module traits are set using "is":
        module Foo is bar {...}
    An anonymous module may be created with either of:
        module {...}
        module :: {...}
    The second form is useful if you need to apply a trait:
        module :: is bar {...}
Exportation
    Exportation is now done by trait declaration on the exportable item:
        unit module Foo;                                # Tagset...
        sub foo is export                   {...}  #  :DEFAULT, :ALL
        sub bar is export(:DEFAULT :others) {...}  #  :DEFAULT, :ALL, :others
        sub baz is export(:MANDATORY)       {...}  #  (always exported)
        sub bop is export(:ALL)             {...}  #  :ALL
        sub qux is export(:others)          {...}  #  :ALL, :others
    Methods also take the "is export" trait: the method will then be
    exported as a *multi sub* that takes the object as the first parameter:
        method close (IO::Handle:D) is export { ... }
    Constants (and enums) are also exportable items. As are variables
    declared in "our" scoping:
        our @foo is export = <foo bar>
        our %bar is export = <foo bar>
        our $baz is export = "foobar"
        constant $FOO is export = "foobar"
        enum FooBar is export (:baz(1))
    Every compunit has a "UNIT" package, which gets a lexically scoped
    "EXPORT" package automatically. Declarations marked as "is export" are
    bound into it, with their tagsets as inner packages. For example, the
    "sub bar" above will bind as "UNIT::EXPORT::DEFAULT::<&bar>",
    "UNIT::EXPORT::ALL::<&bar>", and "UNIT::EXPORT::others::<&bar>".
    Tagset names consisting entirely of capitals are reserved for Perl.
    Exports contained within a module will also be bound into an our-scoped
    "EXPORT" package nested in the module, again with the tagsets forming
    inner packages. This is so the "import" keyword can be used with a
    package to import from it; the lexical "IMPORT" package in "UNIT", on
    the other hand, is the only thing that is considered by "use" for
    importing.
    Inner packages automatically add their export list to packages in all
    their outer scopes (including UNIT):
        module Foo {
            sub foo is export {...}
            module Bar {
                sub bar is export {...}
                module Baz {
                    sub baz is export {...}
    This compunit will export &foo, &bar and &baz by default.
Dynamic exportation
    The default "EXPORTALL" handles symbol exports by removing recognized
    export items and tagsets from the argument list, then calls the "EXPORT"
    subroutine in that package (if there is one), passing in the remaining
    If the exporting module is actually a class, "EXPORTALL" will invoke its
    "EXPORT" method with the class itself as the invocant.
Compile-time Importation
    [Note: the :MY forms are being rethought currently.]
    Importing via "use" binds into the current lexical scope by default
    (rather than the current package, as in Perl 5).
        use Sense <&common @horse>;
    You can be explicit about the desired package:
        use Sense :MY<&common> :OUR<@horse>;
    That's pretty much equivalent to:
        use Sense;
        my &common ::= Sense::<&common>;
        our @horse ::= Sense::<@horse>;
    (if &common and @horse are "our"-scoped in package "Sense").
    It is also possible to re-export the imported symbols:
        use Sense :EXPORT;                   # import and re-export the defaults
        use Sense <&common> :EXPORT;         # import "&common" and re-export it
        use Sense <&common> :EXPORT<@horse>; # import "&common" but export "@horse"
    In the absence of a specific scoping specified by the caller, one may
    also specify a different scoping default by use of ":MY" or ":OUR" tags
    as arguments to "is export". (Of course, mixing incompatible scoping in
    different scopes is likely to lead to confusion.)
    The "use" declaration is actually a composite of two other declarations,
    "need" and "import". Saying
    breaks down into:
        need Sense;
        import Sense <&common @horse>;
    These further break down into:
          my $target ::= OUTER;
          for <Sense> {
            my $scope = load_compunit(find_compunit_defining($_));
            # install the name of the type
            $target.install_alias($_, $scope{$_}) if $scope{$_}:exists;
            # get the package declared by the name in that scope,
            my $package = $_ ~ '::';
            # if there isn't any, then there's just the type...
            my $loaded_compunit = $scope{$package} or next;
            # get a copy of the package, to avoid action-at-a-distance
            # install it in the target scope
            $target{$package} := $loaded_compunit.copy;
            # finally give the chance for the module to install
            # the selected symbols
            $loaded_compunit.EXPORTALL($target, <&common @horse>);
  Loading without importing
    The "need" declarator takes a list of modules and loads them (at compile
    time) without importing any symbols. It's good for loading class modules
    that have nothing to export (or nothing that you want to import):
        need ACME::Rocket;
        my $r = ACME::Rocket.new;
    This declaration is equivalent to Perl 5's:
        use ACME::Rocket ();
    Saying
        need A,B,C;
          for <A B C> {
  Importing without loading
    The importation into your lexical scope may also be a separate
    declaration from loading. This is primarily useful for modules declared
    inline, which do not automatically get imported into their surrounding
        my module Factorial {
            sub fact (Int $n) is export { [*] 1..$n }
        import Factorial 'fact';   # imports the multi
    The last declaration is syntactic sugar for:
        BEGIN Factorial.WHO.EXPORTALL(MY, 'fact');
    This form functions as a compile-time declarator, so that these
    notations can be combined by putting a declarator in parentheses:
        import (role Silly {
            enum Ness is export <Dilly String Putty>;
        }) <Ness>;
    This really means:
        BEGIN (role Silly {
        }).WHO.EXPORTALL(MY, <Ness>)
    Without an import list, "import" imports the ":DEFAULT" imports.
Runtime Importation
    Importing via "require" also installs names into the current lexical
    scope by default, but delays the actual binding till runtime:
        require Sense <common @horse>;
    This means something like:
        BEGIN MY.declare_stub_symbols('Sense', <common @horse>);
        # run time!
        MY.import_realias(:from(load_compunit(find_compunit_defining('Sense'))), 'Sense');
        MY.import_realias(:from(Sense), <common @horse>);
    (The ".import_realias" requires that the symbols to be imported already
    exist; this differs from ".import_alias", which requires that the
    imported symbols do *not* already exist in the target scope.)
    Additionally, the "require" expression evaluates to the value which is
    installed as the alias, so that "(require Foo::Bar).new" and similar
    expressions do the most useful thing.
    Alternately, a filename may be mentioned directly, which installs a
    package that is effectively anonymous to the current lexical scope, and
    may only be accessed by whatever global names the module installs:
        require "/home/non/Sense.pm" <common @horse>;
    which breaks down to:
        BEGIN MY.declare_stub_symbols(<common @horse>);
        MY.import_realias(:from(load_compunit("/home/non/Sense.pm")), <common @horse>);
    Only explicitly mentioned names may be so imported. In order to protect
    the run-time sanctity of the lexical pad, it may not be modified by
    "require". Tagsets are assumed to be unknown at compile time, hence
    tagsets are not allowed in the default import list to ":MY", but you can
    explicitly request to put names into the ":OUR" scope, since that is
    modifiable at run time:
        require Sense <:ALL>    # does not work
        require Sense :MY<ALL>  # this doesn't work either
        require Sense :OUR<ALL> # but this works
    If the import list is omitted, then nothing is imported. Since you may
    not modify the lexical pad, calling an importation routine at runtime
    cannot import into the lexical scope, and defaults to importation to the
    package scope instead:
        require Sense;
        Sense.EXPORTALL;   # goes to the OUR scope by default, not MY
    (Such a routine *may* rebind existing lexicals, however.)
    When you pass a string, "require" always assumes the string contains a
    filename. To specify both a module name and a filename, use a colonpair
    modifier:
        require Sense:file("/home/non/Sense.pm") <common @horse>;
    At minimum, this will create the "Sense" package at compile time, even
    if the "require" never puts anything into it at run time. (Sound
    practice would keep it consistent with whatever the "require" is going
    to do later, however.) By default the package is created as an "our"
    package unless it has already been declared "my" earlier.
    It is also possible to specify the compunit name indirectly by string:
        my $sense = "Sense";
        require ::($sense) <common @horse>;
    The parser will have no idea what your module is actually going to be
    called, so it installs no package name known at compile time. Other than
    that, the semantics are identical to the direct form.
Versioning
    Whenever an authority (such as a CPAN author or a company) posts a
    compilation unit as part of a distribution of Perl 6 code, or enters it
    into any Perl 6 library, the module is required to declare its full name
    so that installations can know its unique, immutable identity, such that
    multiple versions by different authors can coexist, all of them
    available to any installed version of Perl. (For the purposes of
    "standard Perl 6 library" we do not just mean publicly shared libraries
    such as CPAN, but also any internal or site-wide libraries that are
    shared outside the given module's dev group.)
    Such modules are also required to specify exactly which version (or
    versions) of Perl they are expecting to run under, so that future
    versions of Perl can emulate older versions of Perl (or give a cogent
    explanation of why they cannot). This will allow the language to evolve
    without breaking existing widely used modules. (Perl 5 library policy is
    notably lacking here; it would induce massive breakage even to change
    Perl 5 to make strictness the default.) If an installed module breaks
    because it declares that it supports future versions of Perl when it
    doesn't, then it must be construed to be the module's fault, not Perl's.
    If Perl evolves in a way that does not support emulation of an older
    version (at least, back to 6.0.0), then it's Perl's fault (unless the
    change is required for security, in which case it's the fault of the
    insensitive clod who broke security :).
    The internal API for package names is always case-sensitive, even if the
    library system is hosted on a system that is not case-sensitive.
    Likewise internal names are Unicode-aware, even if the filesystem isn't.
    This implies either some sort of name mangling capability or storage of
    intermediate products into a database of some sort for the
    CompUnitRepo::Local::Installation class and similar classes. In any
    event, the actual storage location must be encapsulated in the library
    system such that it is hidden from all language level naming constructs.
    (Provision must be made for interrogating the library system for the
    actual location of a module, of course, but this falls into the category
    of introspection.) Note also that distributions need to be distributed
    in a way that they can be installed on case-insensitive systems without
    loss of information. That's fine, but the language-level abstraction
    must not leak details of this mechanism without the user asking for the
    details to be leaked.
    As discussed in "Units", the required parts for library insertion are
    the (long) name of the compilation unit, a URI identifying the
    author/authority (called auth to be intentionally ambiguous), its
    version number (ver for short) and an optional API indicator. For
    example, if a compunit contains this configuration in its META6.json:
      "name"    : "Dog",
      "version" : "1.2.1"
      "api"     : "woof"
    and has been installed from an author identified by "cpan:JRANDOM", then
    when you then attempt to load a compilation unit, like:
        use Dog;
    you're really wildcarding the unspecified bits:
        use Dog:auth(Any):ver(Any):api(Any);
    And when you say:
        use Dog:<1.2.1>;
    you're really asking for:
        use Dog:auth(Any):ver<1.2.1>:api(Any);
    Saying 1.2.1 specifies an *exact* match on that part of the version
    number, not a minimum match. To match more than one version, put a range
    operator as a selector in parens:
        use Dog:ver(v1.2.1..v1.2.3);
        use Dog:ver(v1.2.1..^v1.3);
        use Dog:ver(v1.2.1..*);
    When specifying the version of your own module, 1.2 is equivalent to
    1.2.0, 1.2.0.0, and so on. However "use" searches for modules matching a
    version prefix, so the subversions are wildcarded, and in this context
    ":ver<1.2>" really means ":ver<1.2.*>". If you say:
        use v6;
        use Perl:ver<6.*>;
    you're asking for any version of Perl 6. You need to say something like
        use Perl:<6.0>;
        use Perl:<6.0.0>;
        use Perl:<6.2.7.1>;
    if you want to lock in a particular set of semantics at some greater
    degree of specificity. And if some large company ever forks Perl, you
    can say something like:
        use Perl:auth<cpan:TPF>
    to guarantee that you get the unembraced Perl. ":-)"
    When it happens that the same module is available from more than one
    auth, and the desired auth is not specified by the "use", the version
    lineage that was created first wins, unless overridden by local policy
    or by official abandonment by the original auth (as determined either by
    the author or by community consensus in case the author is no longer
    available or widely regarded as uncooperative). An abandoned lineage
    will be selected only if it is the only available lineage of locally
    installed modules.
    Once the auth is selected, then and only then is any version selection
    done. This implies that all installed compunits record permanently when
    they were first installed in the library, and this creation date is
    considered immutable. This date can be specified with the uppercase
    block typename CREATED. For example:
     =CREATED 20130626 - it was a good day
    As with the other credentials of the compunit, only the first \S+ are
    used and expected to be in the form YYYYMMDD.
    When loading a compilation unit with wildcards, any valid smartmatch
    selector works:
        use Dog:auth(/:i jrandom/):ver(v1.2.1 | v1.3.4);
        use Dog:auth({ .substr(0,5) eq 'cpan:'}):ver(Any);
    In any event, however you select the compunit, its full name is
    automatically aliased to the short name for the rest of your lexical
    scope. So you can just say
        my Dog $spot .= new("woof");
    and it knows (even if you don't) that you meant the one by
    *cpan:JRANDOM* and version *1.3.4*.
    If you need to have two different versions of the same compunit loaded
    at the same time, you can specify the name of the compunit separately
    with the *:name* adverb:
        use OldDog:name<Dog>:auth<cpan:JRANDOM>:ver<1.2.1>;
        use OldDog:<Dog cpan:JRANDOM 1.2.1>;  # same thing
    This would alias Dog of *cpan:JRANDOM*, version *1.2.1* to OldDog in the
    current lexical scope.
    The "use" statement also allows an external language to be specified in
    addition to (or instead of) an authority, so that you can use modules
    from other languages. The "from" adverb also parses any additional parts
    as short-form arguments. For instance:
        use Whiteness:from<perl5>:name<Acme::Bleach>:auth<cpan:DCONWAY>:ver<1.12>;
        use Whiteness:from<perl5 Acme::Bleach cpan:DCONWAY 1.12>;  # same thing
    The string form of a version recognizes the "*" wildcard in place of any
    position. It also recognizes a trailing "+", so
        :ver<6.2.3+>
    is short for
        :ver(v6.2.3 .. v6.2.*)
    And saying
        :ver<6.2.0+>
    specifically rules out any prereleases.
    If two different compunits in your program require two different
    versions of the same compunit, Perl will simply load both versions at
    the same time. For compunits that do not manage exclusive resources, the
    only penalty for this is memory, and the disk space in the library to
    hold both the old and new versions. For compunits that do manage an
    exclusive resource, such as a database handle, there are two approaches
    short of requiring the user to upgrade. The first is simply to refactor
    the compunit into a stable supplier of the exclusive resource that
    doesn't change version often, and then the outer wrappers of that
    resource can both be loaded and use the same supplier of the resource.
    The other approach is for the compunit to keep the management of its
    exclusive resource, but offer to emulate older versions of the API. Then
    if there is a conflict over which version to use, the new one is used by
    both users, but each gets a view that is consistent with the version it
    thinks it is using. Of course, this depends crucially on how well the
    new version actually emulates the old version.
  Tie-breaking
    When specifing an insufficiently strict -use- statement, it will be
    possible that more than one compunit will match the given specification.
    In that case the following rules apply:
    die if the selected compunits have a different :api value
        A different :api value indicates a difference in API, which means
        that probably at least one of the compunits is incompatible with the
        code wanting to use it.
    select the highest version (within the same api)
        All compunits with the same API can be considered compatible. It's
        most likely that the newest version will be the best to be used. So
        if you didn't care about the version, the newest will be used.
Forcing Perl 6
    To get Perl 6 parsing rather than the default Perl 5 parsing, we said
    you could force Perl 6 mode in your main program with:
    Actually, if you're running a parser that is aware of Perl 6, you can
    just start your main program with any of:
        unit module;
        unit class;
    Those all specify the latest Perl 6 semantics, and are equivalent to
        use Perl:auth(Any):ver(v6..*);
    To lock the semantics to 6.0.0, say one of:
        use Perl:ver<6.0.0>;
        use :<6.0.0>;
        use v6.0.0;
    In any of those cases, strictures and warnings are the default in your
    main program. To start it in *lax* mode, start it with
        no strict;
    (Invoking perl with "-e" has the same effect.)
    In the other direction, to inline Perl 5 code inside a Perl 6 program,
    put "use v5" at the beginning of a lexical block. Such blocks can nest
    arbitrarily deeply to switch between Perl versions:
        # ...some Perl 6 code...
            use v5;
            # ...some Perl 5 code...
                use v6;
                # ...more Perl 6 code...
    It's not necessary to force Perl 6 if the interpreter or command
    specified already implies it, such as use of a ""#!/usr/bin/perl6""
    shebang line. Nor is it necessary to force Perl 6 in any file that
    begins with the "unit", "class", "module", "grammar" or "role" keywords.
Tool use vs language changes
    In order that language processing tools know exactly what language they
    are parsing, it is necessary for the tool to know exactly which variant
    of Perl 6 is being parsed in any given scope. All Perl 6 compilation
    units that are complete files start out at the top of the file in the
    Standard Dialect (which itself has versions that correspond to the same
    version of the official Perl test suite). "EVAL" strings, on the other
    hand, start out in the language variant in use at the point of the
    "EVAL" call, so that you don't suddenly lose your macro definitions
    inside "EVAL".
    All language tweaks from the start of the compilation unit must be
    tracked. Tweaks can be specified either directly in your code as macros
    and such, or such definitions may be imported from a package. As the
    compiler progresses through the compilation unit, other grammars may be
    substituted in an inner lexical scope for an outer grammar, and parsing
    continues under the new grammar (which may or may not be a derivative of
    the standard Perl grammar).
    Language tweaks are considered part of the interface of any package you
    import. Version numbers are assumed to represent a combination of
    interface and patch level. We will use the term *interface version* to
    represent that part of the version number that represents the interface.
    For typical version number schemes, this is the first two numbers (where
    the third number usually represents patch level within a constant
    interface). Other schemes are possible though. (It is recommended that
    branches be reflected by differences in authority rather than
    differences in version, whenever that makes sense. To make it make sense
    more often, some hierarchical authority-naming scheme may be devised so
    that authorities can have temporary subauthorities to hold branches
    without relinquishing overall naming authority.)
    So anyway, the basic rule is this: you may import language tweaks from
    your own private (user-library as specified in @?INC) code as you like;
    however, all imports of language tweaks from the installed Perl 6
    library must specify the exact interface version of the package.
    Such installed interface versions must be considered immutable on the
    language level, so that once any language-tweaking compunit is in
    circulation, it may be presumed to represent a fixed language change. By
    examination of these interface versions a language processing tool can
    know whether it has sufficient information to know the current language.
    In the absence of that information, the tool can choose either to
    download and use the compunit directly, or the tool can proceed in
    ignorance. As an intermediate position, if the tool does not actually
    care about running the code, the tool need not actually have the
    complete compunit in question; many language tweaks could be stored in a
    database of interface versions, so if the tool merely knows the nature
    of the language tweak on the basis of the interface version it may well
    be able to proceed with perfect knowledge. A compunit that uses a
    well-behaved macro or two could be fairly easily emulated based on the
    version info alone.
    But more realistically, in the absence of such a hypothetical database,
    most systems already come with a kind of database for distributions that
    have already been installed. So perhaps the most common case is that you
    have downloaded an older version of the same distribution, in which case
    the tool can know from the interface version whether that older
    distribution represents the language tweak sufficiently well that your
    tool can use the interface definition from that distribution without
    bothering to download the latest patch.
    Note that most compilation units do no language tweaking, and in any
    case cannot perform language tweaks unless these are explicitly
    exported.
    Compilation units that export "multi"s are technically language tweaks
    on the semantic level, but as long as those new definitions modify
    semantics within the existing grammar (by avoiding the definition of new
    macros or operators), they do not fall into the language tweak category.
    Compilation units that export new operators or macros are always
    considered language tweaks. (Unexported macros or operators intended
    only for internal use of the module itself do not count as language
    tweaks.)
    The requirement for immutable interfaces extends transitively to any
    packages imported by a language tweak module. There can be no
    indeterminacy in the language definition either directly or indirectly.
    It must be possible for any compilation unit to be separately compiled
    without knowledge of the lexical or dynamic context in which it will be
    embedded, and this separate compilation must be able to produce a
    deterministic profile of the interface. It must be possible to extract
    out the language tweaking part of this profile for use in tools that
    wish to know how to parse the current language variant
    deterministically.
    Synopsis 12: Objects
        Last Modified: 26 Oct 2014
        Version: 134
    This synopsis summarizes Apocalypse 12, which discusses object-oriented
    programming.
    A class is a module declared with the "class" keyword. As with modules,
    the public storage, interface, and name of the class is represented by a
    package and its name, which is usually (but not necessarily) a global
    name. A class is a module and thus can export stuff, but a class adds
    even more behavior to support Perl 6's standard class-based OO.
    Taken as a type object, a class name represents all of the possible
    values of its type, and the type object can thus be used as a proxy for
    any "real" object of that type in calculating what a generic object of
    that type can do. The class object is an object, but it is not a Class,
    because there is no mandatory Class class in Perl 6, and because type
    objects in Perl 6 are considered undefined. We wish to support both
    class-based and prototype-based OO programming. So all metaprogramming
    is done through the current object's "HOW" object, which can delegate
    metaprogramming to any metamodel it likes. However, by default, objects
    derived from "Mu" support a fairly standard class-based model.
    There are two basic class declaration syntaxes:
        unit class Foo;          # rest of file is class definition
        has $.foo;
        class Bar { has $.bar }     # block is class definition
    The first form is allowed only as the first declaration in a compilation
    unit (that is, file or "EVAL" string).
    If the class body begins with a statement whose main operator is a
    single "prefix:<...>" (yada) listop, the class name is introduced
    without a definition, and a second declaration of that class in the same
    scope does not complain about redefinition. (Statement modifiers are
    allowed on such a "..." operator.) Thus you may forward-declare your
    classes:
        class A {...}     # introduce A as a class name without definition
        class B {...}     # introduce B as a class name without definition
        my A $root .= new(:a(B));
        class A {
            has B $.a;
        class B {
            has A $.b;
    As this example demonstrates, this allows for mutually recursive class
    definitions (though, of course, it can't allow recursive inheritance).
    It is also possible to extend classes via the "augment" declarator, but
    that is considered somewhat antisocial and should not be used for
    forward declarations.
    [Conjecture: we may also allow the "proto" and "multi" declarator
    modifiers on class definitions to explicitly declare classes with
    multiple bodies participating in a single definition intentionally.]
    A named class declaration can occur as part of an expression, just like
    Classes are primarily for instance management, not code reuse. Consider
    using roles when you simply want to factor out common code.
    Perl 6 supports multiple inheritance, anonymous classes, and autoboxing.
    All public method calls are "virtual" in the C++ sense.
    You may derive from any built-in type, but the derivation of a low-level
    type like "int" may only add behaviors, not change the representation.
    Use composition and/or delegation to change the representation.
    Since there are no barewords in Perl 6, bare class names must be
    predeclared. You can predeclare a stub class and fill it in later just
    as you would a subroutine.
    You can force interpretation of a name as a class or type name using the
    "::" prefix. In an rvalue context the "::" prefix is a no-op, but in a
    declarational context, it binds a new type name within the declaration's
    scope along with anything else being declared by the declaration.
    Without a "my" or other scoping declarator, a bare "class" declarator
    declares an "our" declarator, that is, a name within the current
    package. Since class files begin parsing in the "GLOBAL" package, the
    first class declaration in the file installs itself as a global name,
    and subsequent declarations then install themselves into the current
    class rather than the global package.
    Hence, to declare an inner class in the current package (or module, or
    class), use "our class" or just "class". To declare a lexically scoped
    class, use "my class". Class names are always searched for from
    innermost scopes to outermost. As with an initial "::", the presence of
    a "::" within the name does not imply globalness (unlike in Perl 5). So
    the outward search can look in children of the searched namespaces.
    An inner class or role in a generic context must be lexically scoped if
    it depends on any generic parameter or type; and such an inner class or
    role is also a generic type. [Conjecture: it is erroneous to assume that
    any generic type is uniquely associated with a package.]
  Class traits
    Class traits are set using "is":
        class MyStruct is rw {...}
   Single inheritance
    An "isa" is just a trait that happens to be another class:
        class Dog is Mammal {...}
   Multiple inheritance
    Multiple inheritance is specified with multiple "is" modifiers:
        class Dog is Mammal is Pet {...}
   Composition
    Roles use "does" instead of "is":
        class Dog is Mammal does Pet {...}
   The "also" declarator
    You may put these inside as well by use of the "also" declarator:
        class Dog {
            also is Mammal;
            also does Pet;
    (However, the "also" declarator is primarily intended for use in roles,
    to distinguish class traits that might not be properly understood as
    generic when placed in the role header, which tends to communicate the
    false impression that the trait in question is to be applied directly to
    the role rather than to the composed class.)
  Metaclasses
    Every object (including any class-based object) delegates to an instance
    of its metaclass. You can get at the metaclass of any object via the
    "HOW" method, which returns an instance of the metaclass. A "class"
    object is just considered an "empty" instance in Perl 6, more properly
    called a "prototype" or "generic" object, or just "type object". Perl 6
    doesn't really have any classes named "Class". Types of all kinds are
    instead named via these undefined type objects, which are considered to
    have exactly the same type as an instantiated version of themselves. But
    such type objects are inert, and do not manage the state of class
    instances.
    The actual object that manages instances is the metaclass object pointed
    to by the "HOW" syntax. So when you say ""Dog"", you're referring to
    both a package and a type object, the latter of which points to the
    object representing the class via "HOW". The type object differs from an
    instance object not by having a different type but rather in the extent
    to which it is defined. Some objects may tell you that they are defined,
    while others may tell you that they are undefined. That's up to the
    object, and depends on how the metaclass chooses to dispatch the
    ".defined" method.
  Closed classes
    Classes are open and non-final by default, but may easily be closed or
    finalized not by themselves but by the entire application, provided
    nobody issued an explicit compile-time request that the class stay open
    or non-final. (Or a site policy could close any applications that use
    the policy.) Platforms that do dynamic loading of sub-applications
    probably don't want to close or finalize classes wholesale, however.
    Roles take on some of the compile-time function of closed classes, so
    you should probably use those instead anyway.
  Private classes
    A private class can be declared using "my"; most privacy issues are
    handled with lexical scoping in Perl 6. The fact that importation is
    lexical by default also means that any names your class imports are also
    private by default.
    In grammars, one cannot use grammar attributes so one can call a grammar
    rule from an unrelated grammar. One can emulate that behavior with
    lexically scoped grammars created within a closure. The lexical
    variables captured by the closure can then be used where grammar
    attributes would be.
  Class composition
    Class declarations (in particular, role composition) are strictly
    compile time statements. In particular, if a class declaration appears
    inside a nested scope, the class declaration is constrained to compose
    in exactly the same way on any possible execution. All named roles and
    superclasses must be bound as non-rebindable readonly values; any
    parameters to traits will be evaluated only in a non-cloning context.
    Names bound by the class declaration are made non-rebindable and read
    only so they may be used as superclasses.
  Anonymous class declaration
    In an anonymous class declaration, "::" by itself may represent the
    anonymous class name if desired:
        class {...}                # ok
        class is Mammal {...}      # WRONG
        class :: is Mammal {...}   # ok
        class { also is Mammal; ...}    # also ok
Methods
    Methods are routines declared in a class with the "method" keyword:
        method doit ($a, $b, $c) { ... }
        method doit ($self: $a, $b, $c) { ... }
        method doit (MyName $self: $a, $b, $c) { ... }
        method doit (::?CLASS $self: $a, $b, $c) { ... }
  Invocants
    Declaration of the invocant is optional. You may always access the
    current invocant using the keyword "self". You need not declare the
    invocant's type, since the lexical class of the invocant is known in any
    event because methods must be declared in the class of the invocant,
    though of course the actual (virtual) type may be a derived type of the
    lexical type. You could declare a more restrictive type, but that would
    probably be a bad thing for proper polymorphism. You may explicitly type
    the invocant with the lexical type, but any check for that will be
    optimized away. (The current lexically-determined class may always be
    named as "::?CLASS" even in anonymous classes or roles.)
    To mark an explicit invocant, just put a colon after it:
        method doit ($x: $a, $b, $c) { ... }
    If you declare an explicit invocant for an Array type using an array
    variable, you may use that directly in list context to produce its
    elements
        method push3 (@x: $a, $b, $c) { ... any(@x) ... }
    Note that the "self" term refers directly to the object the method was
    invoked on, and therefore:
        class A is Array {
            method m() { .say for self }
        A.new(1, 2, 3).m;
    Will produce 3 lines of output.
  Private methods
    Private methods are declared using "!":
        method !think (Brain $self: $thought)
    (Such methods are completely invisible to ordinary method calls, and are
    in fact called with a different syntax that uses "!" in place of the "."
    character. See below.)
  Method scoping
    Unlike with most other declarations, "method" declarations do not
    default to "our" semantics, or even "my" semantics, but rather "has"
    semantics. So instead of installing a symbol into a lexical or package
    symbol table, they merely install a public or private method in the
    current class or role via calls to its metaobject. (Likewise for
    "submethod" declarations--see "Submethods" below.)
    Use of an explicit "has" declarator has no effect on the declaration.
    You may install additional aliases to the method in the lexical scope
    using "my" or in the current package using "our". These aliases are
    named with &foo notation and return a "Routine" object that may be
    called as a subroutine, in which case you must supply the expected
    invocant as the first argument.
  Method calls
    To call an ordinary method with ordinary method-dispatch semantics, use
    either the dot notation or indirect object notation:
        $obj.doit(1,2,3)
        doit $obj: 1,2,3
    Indirect object notation now requires a colon after the invocant, even
    if there are no arguments after the colon:
        $handle.close;
        close $handle:;
    To reject method call and only consider subs, simply omit the colon from
    the invocation line:
        close($handle);
        close $handle;
    However, here the built-in IO class defines "method close () is export",
    which puts a "multi sub close (IO)" in scope by default. Thus if the
    $handle evaluates to an "IO" object, then the two subroutine calls above
    are still translated into method calls.
    Dot notation can omit the invocant if it's in $_:
        .doit(1,2,3)
    Method calls use the C3 method resolution order.
   Fancy method calls
    Note that there is no corresponding notation for private methods.
        !doit(1,2,3)        # WRONG, would be parsed as not(doit(1,2,3))
        self!doit(1,2,3)    # okay
    There are several forms of indirection for the method name. You can
    replace the identifier with a quoted string, and it will be evaluated as
    a quote and then the result of that is used as the method name.
        $obj."$methodname"(1,2,3)   # use contents of $methodname as method name
        $obj.'$methodname'(1,2,3)   # no interpolation; call method with $ in name!
        $obj!"$methodname"()          # indirect call to private method name
    As an aid to catching Perl 5 brainos, this quoted form always requires a
    parenthesized argument list to distinguish it from code that looks like
    a Perl 5 concatenation.
    Within an interpolation, the double-quoted form may not contain
    whitespace. This does what the user expects in the common case of a
    quoted string ending with a period:
        say "Foo = $foo.";
    If you really want to call a method with whitespace, you may work around
    this restriction with a closure interpolation:
        say "Foo = {$foo."a method"()}";  # OK
    [Note: to help catch the mistaken use of "infix:<.>" as a string
    concatenation operator, Perl 6 will warn you about "useless use of
    quotes" at compile time if the string inside quotes is an identifier.
    (It does not warn about non-identifier strings, but such strings are
    likely to produce missing method errors at run time in any case.) Also,
    if there is whitespace around an intended "." concatenation, it cannot
    be parsed as a method call at all; instead it fails at compile time
    because standard Perl 6 has a pseudo "infix:<.>" operator that always
    fails at compile time.]
    For situations where you already have a method located, you can use a
    simple scalar variable in place of method name:
        $methodobj = $foo ?? &bar !! &baz;
        $obj.$methodobj(1,2,3)
    or more succinctly but less readably:
        $obj.$($foo ?? &bar !! &baz)(1,2,3)
    The variable must contain a "Callable" object (usually of type "Code"),
    that is, a closure of some sort. Regardless of whether the closure was
    defined as a method or a sub or a block, the closure is called directly
    without any class dispatch; from the closure's point of view, however,
    it is always called as a method, with the object as its first argument,
    and the rest of the arguments second, third, and so on. For instance,
    such a closure may be used to abstract a "navigational" path through a
    data structure without specifying the root of the path till later:
        $locator = -> $root, $x, $y { $root.<foo>[$x]<bar>{$y}[3] }
        $obj.$locator(42,"baz")  # $obj<foo>[42]<bar><baz>[3]
        $locator = { .<here> }
        $obj.$locator            # $obj<here>
    As a convenient form of documentation, such a closure may also be
    written in the form of an anonymous method:
        $locator = method ($root: $x, $y) { $root.<foo>[$x]<bar>{$y}[3] }
        $locator = method { self.<here> }
    Note however that, like any anonymous closure, an anonymous method can
    only be dispatched to directly, like a sub. You may, of course, bind an
    anonymous method to the name of a method in a class's public interface,
    in which case it is no longer anonymous, and may be dispatched to
    normally via the class. (And in fact, when the normal method dispatcher
    is calling individual candidates in its candidate list, it calls each
    candidate as a sub, not as a method, or you'd end up with recursive
    dispatchers.) But fundamentally, there's no such thing as a method
    closure. The "method" declarator on an anonymous method has the primary
    effect of making the declaration of the invocant optional. (It also
    makes it an official "Routine" that can be returned from, just as if
    you'd used "sub" to declare it.)
    Instead of a scalar variable, an array variable may also be used:
        $obj.@candidates(1,2,3)
    As with the scalar variant, string method names are not allowed, only
    "Callable" objects, The list is treated as a list of candidates to call.
    After the first successful call the rest of the candidates are
    discarded. Failure of the current candidate is indicated by calling
    "nextwith" or "nextsame" (see "Calling sets of methods" below).
    Note also that the
        $obj.$candidates(1,2,3)
    form may dispatch to a list of candidates if $candidates is either a
    list or a special "Code" object representing a partial dispatch to a
    list of candidates. If $candidates (or any element of @candidates) is an
    iterable object it is expanded out recursively until "Callable"
    candidates are found. The call fails if it hits a candidate that is not
    "Callable", "Iterable", or "List".
    Another form of indirection relies on the fact that operators are named
    using a variant on pair notation, which gives you these forms:
        $x.infix:[$op]($y)
        $x.prefix:[$op]
        $x.postfix:[$op]
    Generally you see these with the literal angle bracket form of
    subscript:
        $a.infix:<*>($b)      # equivalent to $a * $b
        $a.prefix:<++>        # equivalent to ++$a
        $a.postfix:<++>       # equivalent to $a++
    If you omit the syntactic category, the call will be dispatched
    according to the number of arguments either as "prefix" or as "infix":
        $a.:<+>($b)           # equivalent to $a + $b
        $a.:<++>              # equivalent to ++$a
        $a.:<!>               # equivalent to !$a
        @a.:<[*]>             # equivalent to [*] @a
    But it's probably better to spell out the syntactic category when the
    actual operator is not obvious:
    You must use a special syntax to call a private method:
        $mybrain!think($pinky)
        self!think($pinky)
    For a call on your own private method, you may also use the
    attribute-ish form:
        $!think($pinky)     # short for $(self!think($pinky))
    Parentheses (or a colon) are required on the dot/bang notations if there
    are any arguments (not counting adverbial arguments). There may be no
    space between the method name and the left parenthesis unless you make
    use of "unspace":
        .doit       # okay, no arguments
        .doit()     # okay, no arguments
        .doit ()    # ILLEGAL (two terms in a row)
        .doit\ ()   # okay, no arguments, same as .doit() (unspace form)
    Note that the named method call forms are special and do not use the dot
    form of postfix. If you attempt to use the postfix operator form, it
    will assume you want to call the method with no arguments and then call
    the result of *that*:
        .doit.()    # okay, no arguments *twice*, same as .doit().()
        .doit\ .()  # okay, no arguments *twice*, same as .doit.().() (unspace form)
    However, you can turn any of the named forms above into a list operator
    by appending a colon:
        .doit: 1,2,3        # okay, three arguments
        .doit(1): 2,3       # okay, one argument plus list
        .doit (): 1,2,3     # ILLEGAL (two terms in a row)
    In particular, this allows us to pass a final closure in addition to the
    "normal" arguments:
        .doit: { $^a <=> $^b }              # okay
        .doit(): { $^a <=> $^b }            # okay
        .doit(1,2,3): { $^a <=> $^b }       # okay
    Normally a space is required after the colon to disambiguate what
    follows from a pair that extends the previous name. However, names may
    not be extended with the ":{}" pair notation, and therefore it is
    allowed to drop the space after the colon if the first argument to the
    method is a closure. Hence, any of the above may be written without the
    space after the colon:
        .doit:{ $^a <=> $^b }              # okay
        .doit():{ $^a <=> $^b }            # okay
        .doit(1,2,3):{ $^a <=> $^b }       # okay
    These are parsed as if there were a space there, so the argument list
    may continue if the closure is followed by a comma.
    In case of ambiguity between indirect object notation and dot form, the
    nearest thing wins:
        dothis $obj.dothat: 1,2,3
        dothis ($obj.dothat(1,2,3))
    and you must say
        dothis ($obj.dothat): 1,2,3
        $obj.dothat.dothis: 1,2,3
    if you mean the other thing.
    Also note that if any term in a list is a bare closure or pointy block,
    it will be considered to be the final argument of its list if the
    closure's right curly is followed by a newline.
    If instead the closure's right curly is followed by a method call, the
    closure is the invocant:
        @list.map:{ "'$^x $^y'".say }.assuming: 'got:'
    To call the method of the result of the former method call, add parens:
        @list.map({ "got: $^x" }).say
    Even when the colon of a method call does not require whitespace when
    followed by a block, it will look odd, so it may be clearer to add the
    space to make the method calls on the right look more like they attach
    to the block itself instead of the term on the left:
        @list.map: { "'$^x $^y'".say }.assuming: 'got:'
    This will also visually distinguish between a method call introducing
    colon and an object pair constructor.
  Lvalue methods
    Methods (and subs) may be declared as lvalues with "is rw". You can use
    an argumentless "rw" method anywhere you can use a variable, including
    in "temp" and "let" statements. (In fact, you can use an "rw" method
    with arguments as a variable as long as the arguments are used only to
    identify the actual value to change, and don't otherwise have strange
    side effects that differ between rvalue and lvalue usage. Setter methods
    that expect the new value as an argument do not fall into the
    well-behaved category, however.)
  Scalar container indirection
    Method calls on mutable scalars always go to the object contained in the
    scalar (autoboxing value types as necessary):
        $result = $object.doit();
        $length = "mystring".codes;
    Method calls on non-scalar variables just calls the "Array", "Hash" or
    "Code" object bound to the variable:
        $elems = @array.elems;
        @keys  = %hash.keys;
        $sig   = &sub.signature;
    Use the prefix "VAR" macro on a scalar variable to get at its underlying
    "Scalar" object:
        if VAR($scalar).readonly {...}
    "VAR" is a no-op on a non-scalar variables and values:
        VAR(1);     # 1
        VAR(@x);    # @x
    There's also a corresponding "postfix:<.VAR>" macro that can be used as
    if it were a method:
        if $scalar.VAR.readonly {...}
    (But since it's a macro, "VAR" is not dispatched as a real method. To
    dispatch to a real ".VAR" method, use the indirect "$obj."VAR"" form.)
    You can also get at the container through the appropriate symbol table:
        if MY::<$scalar>.readonly {...}
  FALLBACK methods
    If your class defines a method with the special name "FALLBACK", that
    method will be called if all other attempts to locate a method fail,
    including normal method dispatch as well as delegation (see below). The
    first argument to the method will be the method name (as a string) that
    was unsuccessfully searched for. The original call's arguments are
    passed in as rest of the "FALLBACK"'s argument list.
    It is legal for the "FALLBACK" method to be a proto method that
    dispatches to multi methods.
Class methods
    Other OO languages give you the ability to declare "class" methods that
    either don't need or actively prohibit calls on instances. Perl 6 gives
    you a choice. If you declare an ordinary method, it can function as a
    "class" method when you pass it a type object such as ""Dog"" regardless
    of how defined the prototype object is, as long as the method body
    doesn't try to access any information that is undefined in the current
    instance. Alternatively, a method can use the ":U" type modifier on the
        method oh_so_static(::?CLASS:U:) {
    This will cause the method to actively refuse invocations on instances,
    and only permit invocation through the type object.
Submethods
    Submethods are for declaring infrastructural methods that shouldn't be
    inherited by subclasses, such as initializers:
        submethod BUILD (:$arg) {
            $!attr = $arg;
    Apart from the keyword, submethod declaration and call syntax is
    identical to method syntax. You may mix methods and submethods of the
    same name within the class hierarchy, but only the methods are visible
    to derived classes via inheritance. A submethod is called only when a
    method call is dispatched directly to the current class.
    Conjecture: in order to catch spelling errors it is a compile-time
    warning to define a submethod in any class that does not inherit the
    corresponding method name from some base class. More importantly, this
    would help safeguard Liskov substitutability. (But note that the
    standard "Mu" class already supplies a default "BUILD" and "new".)
Attributes
    Attributes are stored in an opaque datatype, not in a hash. Not even the
    class has to care how they're stored, since they're declared much like
    ordinary variables. Instead of "my", use "has":
        class Dog is Mammal {
            has $.name = "fido";
            has $.tail is rw;
            has @.legs;
            has $!brain;
    Public attributes have a secondary sigil of "dot", indicating the
    automatic generation of an accessor method of the same name (unless the
    class declares an explicit method of that name before the closing
    bracket). Private attributes use an exclamation to indicate that no
    public accessor is generated.
    The "true name" of the private variable always has the exclamation, but
    much like with "our" variables, you may declare a lexically scoped alias
    to the private variable by saying:
            has $brain;     # also declares $!brain;
    As with the "!" declaration, no accessor is generated.
    And any later references to the private variable within the same block
    may either use or omit the exclamation, as you wish to emphasize or
    ignore the privacy of the variable. Outside the block, you must use the
    "!" form. If you declare with the "!" form, you must use that form
    consistently everywhere. If you declare with the "." form, you also get
    the private "!" form as a non-virtual name for the actual storage
    location, and you may use either "!" or "." form anywhere within the
    class, even if the class is reopened. Outside the class you must use the
    public "." form, or rely on a method call (which can be a private method
    call, but only for trusted classes).
    For public attributes, some traits are copied to the accessor method.
    The "rw" trait causes the generated accessor to be declared "rw", making
    it an lvalue method. The default is a read-only accessor.
    If you declare the class as "rw", then all the class's attributes
    default to "rw", much like a C struct.
    You may write your own accessors to override any or all of the
    autogenerated ones.
    The attribute variables may be used within instance methods to refer
    directly to the attribute values. Outside the instance methods, the only
    access to attributes is through the accessors since an object has to be
    specified. The dot form of attribute variables may be used in derived
    classes because the dot form always implies a virtual accessor call.
    Every *dot* declaration also declares a corresponding private
    *exclamation* storage location, and the exclamation form may be used
    only in the actual class, not in derived classes. Reference to the
    internal storage location via "$!foo" should generally be restricted to
    submethods. Ordinary methods should stick to the "$.foo" form.
    In fact, within submethods, use of the "$.foo" form on attributes that
    are available as "$!foo" (that is, that are declared directly by this
    class) is illegal and produces a dire compile-time warning (which may be
    suppressed). Within a submethod the "$.foo" form may only be used on
    attributes from parent classes, because only the parent classes' part of
    the object is guaranteed to be in a consistent state (because "bless"
    calls the "BUILD" routines of the parent classes before the child
    classes). If you attempt to get around this by declaring "BUILD" as a
    method rather than a submethod, that will also be flagged as a dire (but
    suppressible) compile-time warning. (It is *possible* to define an
    inheritable "BUILD" routine if you have access to all the metadata for
    the current class, but it's not easy, and it certainly doesn't happen by
    accident just because you change "submethod" to "method".)
    Because "$.foo", "@.foo", "%.foo", "&.foo" are just shorthands of
    "self.foo" with different contexts, the class does not need to declare
    any of those as an attribute -- a "method foo" declaration can work just
    as well.
    As with the normal method call forms, only dotless parentheses may
    contain arguments. If you use the ".()" form it will perform an extra
    level of indirection after the method call:
        self.foo(1,2,3);    # a regular method call
        self.foo.(1,2,3);   # self.foo().(1,2,3), call .() on closure returned by .foo
        $.foo(1,2,3);       # calls self.foo under $ context
        $.foo.(1,2,3);      # $.foo().(1,2,3), call .() on closure returned by .foo
        &.foo(1,2,3);       # calls self.foo under & context
        &.foo.(1,2,3);      # &.foo().(1,2,3), call .() on closure returned by .foo
  Attribute default values
    Pseudo-assignment to an attribute declaration specifies the default
    value. The value on the right is treated as an implicit closure and
    evaluated at object build time, that is, when the object is being
    constructed, not when class is being composed. To refer to a value
    computed at compilation or composition time, you can either use a
    temporary or a temporal block of some sort:
        has $.r = rand;     # each object gets different random value
        constant $random = rand;
        has $.r = $random;  # every object gets same value
        has $.r = BEGIN { rand };
        has $.r = INIT { rand };
        has $.r = ENTER { rand };
        has $.r = FIRST { rand };
        has $.r = constant $myrand = rand;
    When it is called at "BUILD" time, the topic of the implicit closure
    will be the attribute being initialized, while "self" refers to the
    entire object being initialized. The closure will be called at the end
    of the "BUILD" only if the attribute is not otherwise initialized in
    either the signature or the body of the "BUILD". The closure actually
    defines the body of an anonymous method, so "self" is available with
    whatever attributes are constructed by that point in time (including all
    parent attributes). The initializers are run in order of declaration
    within the class, so a given initializer may refer back to an attribute
    defined in a preceding "has" declaration.
  Class attributes
    Class attributes are declared with either "my" or "our". The only
    difference from ordinary "my" or "our" variables is that an accessor is
    generated according to the secondary sigil:
        our $.count;        # generates a public read-only .count accessor
        our %!cache is rw;  # generates no public accessor
        our @items;         # generates no public accessor
        my  $.count;        # generates a public read-only .count accessor
        my  %!cache is rw;  # generates no public accessor
        my  @items;         # generates no public accessor
    Unlike attributes declared with "has", class attributes are shared
    between the undefined type, all instances of the class, and all
    subclasses.
Construction and Initialization
    All classes inherit a default "new" constructor from "Mu". It expects
    all arguments to be named parameters initializing attributes of the same
    name. You may write your own "new" to override the default, or write
    constructors with any other name you like. As in Perl 5, a constructor
    is any routine that calls "bless". Unlike in Perl 5, you call it as a
    method on the class object (though any object may be used as a class
    object), passing the arguments to be used in building the object.
    The representation of the class determines how to create the object, so
    it's not longer necessary for you to supply a candidate to "bless". For
    example, a P5Hash object would give you an object representation that
    uses hashes just like P5 does. The default "P6Opaque" representation
    doesn't tell you what it's going to use for its representation, since
    that's why it's called "opaque", after all.
    The "bless" method allows one or more positional arguments representing
    autovivifying type objects. Such an object looks like a type name
    followed by a hash subscript (see "Autovivifying objects" below). These
    are used to initialize superclasses.
    Other than a list of autovivifying type objects, all arguments to
    "bless" must be named arguments, not positional. Hence, the main purpose
    of custom constructors is to turn positional arguments into named
    arguments for "bless". The "bless" method allows an object to be used
    for its class invocant. (Your constructor need not allow this). In any
    case, the object is not used as a prototype. Use ".clone" instead of
    ".bless" if that's what you mean.
  Semantics of "bless"
    Any named arguments to "bless" are automatically passed to the "BUILD"
    routines.
    For normal user classes, "P6opaque" is the default representation. Other
    possibilities are "P6hash", "P5hash", "P5array", "PyDict", "Cstruct",
    etc. If you wish to pass special options to the representation layer for
    creating the object, that's between you and the representation. (A
    representation might look for additional class traits, for instance,
    telling it bit sizes and such.)
    The "bless" method automatically calls all appropriate "BUILD" routines
    for the current class, which initializes the object in least-derived to
    most-derived order. ("DESTROY" submethods work the same way, only in
    reverse.)
    The default "BUILD" semantics are inherited from "Mu", so you need to
    write initialization routines only if you wish to modify the default
    behavior. The "bless" method automatically passes the appropriate
    argument list to the "BUILD" of its various parent classes. If the type
    of the parent class corresponds to one of the type objects passed to
    bless, that type object's argument list is used. Otherwise all the
    arguments to bless are passed to the parent class's "BUILD". For the
    final "BUILD" of the current object, all the arguments to "bless" are
    passed to the "BUILD", so it can deal with any type objects that need
    special handling. (It is allowed to pass type objects that don't
    correspond to any parent class.)
        class Dog is Animal {...}
        my $pet = Dog.new( :name<Fido>, Animal{ :blood<warm>, :legs(4) } );
    Here we are using an autovivifying "Animal" type object to specify what
    the arguments to "Animal"'s "BUILD" routine should look like. (It does
    not actually autovivify an "Animal" apart from the one being created.)
    You can write your own "BUILD" submethod to control initialization. If
    you name an attribute as a parameter, that attribute is initialized
    directly, so
        submethod BUILD (:$!tail, :$!legs) {}
        submethod BUILD (:$tail is copy, :$legs is copy) {
            $!tail := $tail;
            $!legs := $legs;
    Whether you write your own "BUILD" or not, at the end of the "BUILD",
    any default attribute values are implicitly copied into any attributes
    that haven't otherwise been initialized. Note that the default "BUILD"
    will only initialize public attributes; you must write your own "BUILD"
    (as above) in order to present private attributes as part of your
    initialization API.
  Cloning
    You can clone an object, changing some of the attributes:
        $newdog = $olddog.clone(:trick<RollOver>);
Mutating methods
    You can call an in-place mutator method like this:
        @array .= sort;
    One handy place for an in-place mutator is to call a constructor on a
    variable of a known type:
        my Dog $spot .= new(:tail<LONG>, :legs<SHORT>);
Calling sets of methods
    For any method name, there may be some number of candidate methods that
    could handle the request: typically, inherited methods or multi
    variants. The ordinary "dot" operator dispatches to a method in the
    standard fashion. There are also "dot" variants that call some number of
    methods with the same name:
        $object.meth(@args)   # calls one method or dies
        $object.?meth(@args)  # calls method if there is one, otherwise Nil
        $object.*meth(@args)  # calls all methods (0 or more, () if none)
        $object.+meth(@args)  # calls all methods (1 or more, die if none)
    The method name may be quoted when disambiguation is needed:
        $object."+meth"(@args)
        $object.'VAR'(@args)
    As with ordinary calls, the identifier supplying the literal method name
    may be replaced with an interpolated quote to specify the method name
    indirectly. It may also be replaced with an array to specify the exact
    list of candidates to be considered:
        my @candidates := $object.WALK(:name<foo>, :breadth, :omit($?CLASS));
        $object.*@candidates(@args);
    The "WALK" method takes these arguments:
        :canonical      # canonical dispatch order
        :ascendant      # most-derived first, like destruction order
        :descendant     # least-derived first, like construction order
        :preorder       # like Perl 5 dispatch
        :breadth        # like multi dispatch
        :super              # only immediate parent classes
        :name<name>         # only classes containing named method declaration
        :omit(Selector)     # only classes that don't match selector
        :include(Selector)  # only classes that match selector
    Any method can defer to the next candidate method in the list by the
    special functions "callsame", "callwith", "nextsame", and "nextwith".
    The "same" variants reuse the original argument list passed to the
    current method, whereas the "with" variants allow a new argument list to
    be substituted for the rest of the candidates. The "call" variants
    dispatch to the rest of the candidates and return their values to the
    current method for subsequent processing, whereas while the "next"
    variants don't return, but merely defer to the rest of the candidate
    list:
        callsame;           # call with the original arguments (return here)
        callwith();         # call with no arguments (return here)
        callwith(1,2,3);    # call with a new set of arguments (return here)
        nextsame;           # redispatch with the original arguments (no return)
        nextwith();         # redispatch with no arguments (no return)
        nextwith(1,2,3);    # redispatch with a new set of arguments (no return)
        samewith(1,2,3);    # same dispatcher with new arguments (no return)
    For dispatches using "." and ".?", the return value is the "Capture"
    returned by the first method completed without deferring. (Such a return
    value may in fact be failure, but it still counts as a successful call
    from the standpoint of the dispatcher.) Likewise the return value of
    ".*" and ".+" is a list of "Captures" returned by those methods that ran
    to completion without deferring to next method.
    It is also possible to trim the candidate list so that the current call
    is considered the final candidate. (This is implicitly the case already
    for the dispatch variants that want a single successful call.) For the
    multiple call variants, "lastcall" will cause the dispatcher to throw
    away the rest of the candidate list, and the subsequent return from the
    current method will produce the final "Capture" in the returned list.
    (If you were already on the last call of the candidate list, no
    candidates are thrown away, only the list. So you can't accidentally
    throw away the wrong list by running off the end, since the candidate
    list is ordinarily not thrown away by the dispatcher until after the
    last call.)
    Since it's possible to be dispatching within more than one candidate
    list at a time, these control flow calls are defined to apply only to
    the dynamically innermost dispatcher. If, for instance, you have a
    single dispatch to a "proto" method that then calls into a multiple
    dispatch on the "multi" methods within a class, "nextsame" within one of
    those "multi"s would go to the next best "multi" method within the
    class, not the next method candidate in the original single dispatch.
    This is not a bad limitation, since dispatch loops are dynamically
    scoped; to get to the outermost lists you can "pop" unwanted candidate
    lists using "lastcall":
        lastcall; nextsame;  # call next in grandparent dispatcher loop
    [Conjecture: if necessary, "lastcall" could have an argument or invocant
    to specify which kind of a dispatch loop we think we're throwing away,
    in case we're not sure about our context. This confusion could arise
    since we use "nextsame" semantics at least three different ways: single
    dispatch, multiple dispatch, and routine wrapper dispatch.]
    The "samewith" redispatches the method call using the current
    dispatcher: this is mainly intended if you have one "worker" method, and
    several "frontend" methods in the same class to avoid code duplication.
    The frontend methods then mangle the parameters before sending them off
    to the worker method with "samewith".
Parallel dispatch
    Any of the method call forms may be turned into a hyperoperator by
    treating the method call as a postfix:
        @object».meth(@args)   # calls one method on each
        @object».?meth(@args)  # calls method if there is one on each
        @object».*meth(@args)  # calls all methods (0 or more) on each
        @object».+meth(@args)  # calls all methods (1 or more) on each
        @object».=meth(@args)  # calls mutator method on each
        @object»!meth(@args)   # calls private method on each
    The return value is a list with exactly the same number of elements as
    @object. Each such return value is a "List" or "List" of "List" as
    specified above for the non-hyper "dot" variants.
    Hyperoperators treat a junction as a scalar value, so saying:
        $junction».meth(@args);
    is just like:
        $junction.meth(@args);
    As with other forms of method call, the "meth" above may be replaced
    with a quoted string or variable to do various forms of indirection.
    Note that, as with any hyper operator, the methods may be evaluated in
    any order (although the method results are always returned in the same
    order as the list of invocants). Use an explicit loop if you want to do
    something with ordered side effects, such as I/O.
Multisubs and Multimethods
    The "long name" of a subroutine or method includes the type signature of
    its invocant arguments. The "short name" doesn't.
  "multi" Declarations
    If you put "multi" in front of any sub declaration, it allows multiple
    long names to share a short name, provided all of them are declared
    "multi", or there is a single prior or outer "proto" in the same file
    that causes all unmarked subs to default to multi in that lexical scope.
    If a sub is not marked with "multi" and it is not governed within that
    same file by a "proto" of the same short name, it is considered unique,
    an *only* sub. (An imported "proto" can function as such a governing
    declaration.)
    For method declarations, the "proto", "multi", and "only" declarations
    work similarly but not identically. The explicit declarations work the
    same, except that calculation of governance and candidate sets proceeds
    via the inheritance tree rather than via lexical scoping. The other
    difference is that a proto method of a given short name forcing all
    unmarked method declarations to assume multi in all subclasses
    regardless of which file they are declared in, unless explicitly
    overridden via "only method".
  "only" Declarations
    An "only" sub (or method) doesn't share with anything outside of it or
    declared prior to it. Only one such sub (or method) can inhabit a given
    namespace (lexical scope or class), and it hides any outer subs (or
    less-derived methods) of the same short name. It is illegal for a
    "multi" or "proto" declaration to share the same scope with an "only"
    declaration of the same short name.
    Since they come from a different file, the default "proto" declarations
    provided by Perl from the setting scope do *not* automatically set the
    defaults in the user's scope unless explicitly imported, so a "sub"
    declaration there that happens to be the same as a setting "proto" is
    considered "only" unless explicitly marked "multi". (This allows us to
    add new "proto" declarations in the setting without breaking the user's
    old code.) In the absence of such an explicit "sub" declaration,
    however, the "proto" from the innermost outer lexical scope is used by
    the compiler in the analysis of any calls to that short name. (Since
    only list operators may be post-declared, as soon as the compiler sees a
    non-listop operator it is free to apply the setting's "proto" since any
    user-defined "only" version of it must of necessity be declared or
    imported earlier in the user's file or not at all.)
  "proto" Declarations
    A "proto" always functions as a dispatcher around any "multi"s declared
    after it in the same scope, More specifically, it is the generic
    prototype of a dispatcher, which must be instantiated anew in each scope
    that has a different candidate list. (This works much like type punning
    from roles to classes. Or you can think of this dispatcher as a priming
    of the proto's code with the candidate list appropriate to the scope.)
    For the sake of discussion, let us say that there is a declarator
    equivalent to "only" that is instead spelled "dispatch". Generally a
    user never writes a "dispatch" sub (it might not even be allowed); a
    "dispatch" is always instantiated from the governing "proto". A new
    "dispatch" sub or method is autogenerated in any scope that needs one,
    that is, in any scope that can see a different set of multi declarations
    than its parent scope (or scopes, in the case of multiple inheritance).
    More precisely, for any given "proto" and a point of call, there is a
    candidate set of routines (functions or methods) that is the
    intersection of two sets: the set of routines governed downward by the
    "proto" and the set of routines visible upward from the point of a call.
    It is allowed to reuse the "dispatch" of a parent scope if and only if
    it would result in the same candidate list in the current scope (the
    scope at the point of call).
    Since "dispatch" is nearly identical to "only", saying &foo always
    refers to the innermost visible "dispatch" or "only" sub, never to a
    "proto" or "multi". Likewise, "$obj.can('foo')" will return the
    most-derived "dispatch" or "only" method.
  "proto" Signatures
    Within its scope, the signature of a "proto" also nails down the
    presumed order and naming of positional parameters, so that any call to
    that short name with named arguments in that scope can presume to
    rearrange those arguments into positional parameters based on that
    information. (Unrecognized names remain named arguments.) Any other type
    information or traits attached to the "proto" may also be passed along
    to the routines within its scope, so a "proto" definition can be used to
    factor out common traits. This is particularly useful for establishing
    grammatical categories in a grammar by declaring a "proto" "token" or
    "proto" "rule". (Perl 6's grammar does this, for instance.)
  "multi" Variables
    You can have multiple "multi" variables of the same name in the same
    scope, and they all share the same storage location and type. These are
    declared by one "proto" declaration at the top, in which case you may
    leave the "multi" implicit on the rest of the declarations in the same
    scope. You might do this when you suspect you'll have multiple
    declarations of the same variable name (such code might be produced by a
    macro or by a code generator, for instance) and you wish to suppress any
    possible warnings about redefinition.
  "multi" Routines
    In contrast, "multi" routines can have only one instance of the long
    name in any namespace, and that instance hides any outer (or
    less-derived) routines with the same long name. It does not hide any
    routines with the same short name but a different long name. In other
    words, "multi"s with the same short name can come from several different
    namespaces provided their long names differ and their short names aren't
    hidden by an "only" or "proto" declaration in some intermediate scope.
  Multisub Resolution
    When you call a routine with a particular short name, if there are
    multiple visible long names, they are all considered candidates. They
    are sorted into an order according to how close the run-time types of
    the arguments match up with the declared types of the parameters of each
    candidate. The best candidate is called, unless there's a tie, in which
    case the tied candidates are redispatched using any additional
    tiebreaker strategies (see below). For the purpose of this nominal
    typing, no constrained type is considered to be a type name; instead the
    constrained type is unwound into its base type plus constraint. Only the
    base type upon which the constrained type is based is considered for the
    nominal type match (along with the fact that it is constrained). That
    is, if you have a parameter:
        subset Odd of Int where { $_ % 2 }
        proto foo {*}
        multi foo (Odd $i) {...}
    it is treated as if you'd instead said:
        multi foo (Int $i where { $_ % 2 }) {...}
    Any constrained type is considered to have a base type that is "epsilon"
    narrower than the corresponding unconstrained type. The compile-time
    topological sort takes into account the presence of at least one
    constraint, but nothing about the number or nature of any additional
    constraints. If we think of Int' as any constrained version of Int, then
    Int' is always tighter nominally than Int. (Int' is a meta-notation, not
    Perl 6 syntax.)
    The order in which candidates are considered is defined by a topological
    sort based on the "type narrowness" of each candidate's long name, where
    that in turn depends on the narrowness of each parameter that is
    participating. Identical types are considered tied. Parameters whose
    types are not comparable are also considered tied. A candidate is
    considered narrower than another candidate if at least one of its
    parameters is narrower and all the rest of its parameters are either
    narrower or tied. Also, if the signature has any additional required
    parameters not participating in the long name, the signature as a whole
    is considered epsilon tighter than any signature without extra
    parameters. In essence, the remaining arguments are added to the
    longname as if the user had declared a capture parameter to bind the
    rest of the arguments, and that capture parameter has a constraint that
    it must bind successfully to the additional required parameters. All
    such signatures within a given rank are considered equivalent, and
    subject to tiebreaker B below.
    This defines the partial ordering of all the candidates. If the
    topological sort detects a circularity in the partial ordering, all
    candidates in the circle are considered tied. A warning will be issued
    at "CHECK" time if this is detected and there is no suitable tiebreaker
    that could break the tie.
   Candidate Tiebreaking
    There are three tiebreaking modes, in increasing order of desperation:
        A) inner or derived scope
        B) run-time constraint processing
        C) use of a candidate marked with "is default"
    Tiebreaker A simply prefers candidates in an inner or more derived scope
    over candidates in an outer or less derived scope. For candidates in the
    same scope, we proceed to tiebreaker B.
    In the absence of any constraints, ties in tiebreaker A immediately
    failover to tiebreaker C; if not resolved by C, they warn at compile
    time about an ambiguous dispatch.
    If there are any tied candidates with constraints, it follows from our
    definitions above that all of them are considered to be constrained. In
    the presence of longname parameters with constraints, or the implied
    constraint of extra required arguments, tiebreaker B is applied.
    Candidates which are tied nominally but have constraints are considered
    to be a completely different situation, insofar as it is assumed the
    user knows exactly why each candidate has the extra constraints it has.
    Thus, constrained signatures are considered to be much more like a
    switch defined by the user. So for tiebreaker B the candidates are
    simply called in the order they were declared, and the first one that
    successfully binds (and completes without calling nextsame or nextwith)
    is considered the winner, and all the other tied candidates are ignored.
    If all the constrained candidates fail, we throw out the rank of
    constrained variants and proceed to the next tighter rank, which may
    consist of the unconstrained variants without extra arguments.
    For ranks that are not decided by constraint (tiebreaker B), tiebreaker
    C is used: only candidates marked with the "default" trait are
    considered, and the best matching default routine is used. If there are
    no default routines, or if two or more of the defaults are tied for
    best, the dispatch fails.
   Parameter Constraint Exclusion
    Ordinarily all the parameters of a multi sub are considered for
    dispatch. Here's a declaration for an integer range operator with two
    parameters in its long name:
        multi sub infix:<..>(Int $min, Int $max) {...}
    Sometimes you want to have parameters that aren't counted as part of the
    long name. For instance, if you want to allow an optional "step"
    parameter to your range operator, but not consider it for multi
    dispatch, then put a double semicolon instead of a comma before it:
        multi sub infix:<..>(Int $min, Int $max;; Int $by = 1) {...}
    The double semicolon, if any, determines the complete long name of a
    "multi". (In the absence of that, a double semicolon is assumed after
    the last declared argument, but before any return signature.) Note that
    a call to the routine must still be compatible with subsequent
    Note that the $by is not a required parameter, so doesn't impose the
    kind of constraint that allows tiebreaker B. If the default were
    omitted, it would be a required parameter, and subject to tiebreaker B.
    Likewise an ordinary named parameter does not participate as a
    tiebreaker, but you can mark named parameters as required to effectively
    make a switch based on named binding:
        multi foo (Int $a;; :$x!) {...}     # constrained
        multi foo (Int $a;; :$y!) {...}     # constrained
        multi foo (Int $a;; :$z!) {...}     # constrained
        multi foo (Int $a;; *%_) {...}      # unconstrained
    The first three are dispatched under tiebreaker B as a constrained rank.
    If none of them can match, the final one is dispatched as an
    unconstrained rank, since *%_ is not considered a required parameter.
   Constrained Type Candidates
    Likewise, constrained types sort before unconstrained:
        multi bar (Even $a) {...}   # constrained
        multi bar (Odd $a) {...}    # constrained
        multi bar (Int $a) {...}    # unconstrained
    And values used as subset types also sort first, and are dispatched on a
    first-to-match basis:
        multi baz (0) {...}         # constrained
        multi baz (1) {...}         # constrained
        multi baz (Int $x) {...}    # unconstrained
    If some of the constrained candidates come by import from other modules,
    they are all considered to be declared at the point of importation for
    purposes of tiebreaking; subsequent tiebreaking is provided by the
    original order in the used module.
    [Conjecture: However, a given "multi" may advertise multiple long names,
    some of which are shorter than the complete long name. This is done by
    putting a semicolon after each advertised long name (replacing the
    comma, if present). A semicolon has the effect of inserting two
    candidates into the list. One of them is inserted with exactly the same
    types, as if the semicolon were a comma. The other is inserted as if all
    the types after the semicolon were of type "Any", which puts it later in
    the list than the narrower actual candidate. This merely determines its
    sort order; the candidate uses its real type signature if the dispatcher
    gets to it after rejecting all earlier entries on the candidate list. If
    that set of delayed candidates also contains ties, then additional
    semicolons have the same effect within that sublist of ties. Note,
    however, that semicolon is a no-op if the types after it are all "Any".
    (As a limiting case, putting a semicolon after every parameter produces
    dispatch semantics much like Common Lisp. And putting a semicolon after
    only the first argument is much like ordinary single-dispatch methods.)
    Note: This single-semicolon syntax is merely to be considered reserved
    until we understand the semantics of it, and more importantly, the
    pragmatics of it (that is, whether it has any valid use case). Until
    then only the double-semicolon form will be implemented in the standard
    language.]
    A "method" or "submethod" doesn't ordinarily participate in any
    subroutine-dispatch process. However, they can be made to do so if
    prefixed with a "my" or "our" declarator.
   Multi Submethods et Cetera
    Multi submethods work just like multi methods except they are
    constrained to an exact type match on the invocant, just as ordinary
    submethods are.
    Perl 6.0.0 is not required to support multiple dispatch on named
    parameters, only on positional parameters. Note however that any
    dispatcher derived from "proto" will map named arguments to known
    declared positional parameters and call the "multi" candidates with
    positionals for those arguments rather than named arguments.
    Within a multiple dispatch, "nextsame" means to try the next best match,
    or next best default in case of tie.
    The "sub" keyword is optional immediately after a "proto", "multi", or
    "only" keyword, but the "method" keyword is not.
    A "proto" declaration may not occur after a "multi" declaration in the
    same scope.
  Method call vs. Subroutine call
    The caller indicates whether to make a method call or subroutine call by
    the call syntax. The "dot" form and the indirect object form default to
    method calls. All other prefix calls default to subroutine calls. This
    applies to prefix unary operators as well:
        !$obj;  # same as $obj.prefix:<!>
    A method call considers only methods (including multi-methods and
    submethods) from the class hierarchy of its invocant, and fails if none
    is found. The object in question is in charge of interpreting the
    meaning of the method name, so if the object is a foreign object, the
    name will be interpreted by that foreign runtime.
    A subroutine call considers only visible subroutines (including
    submethods) of that name. The object itself has no say in the dispatch;
    the subroutine dispatcher considers only the types the arguments
    involved, along with the name. Hence foreign objects passed to
    subroutines are forced to follow Perl semantics (to the extent foreign
    types can be coerced into Perl types, otherwise they fail).
    There is no fail-over either from subroutine to method dispatch or vice
    versa. However, you may use "is export" on a method definition to make
    it available also as a "multi" sub. As with indirect object syntax, the
    first argument is still always the invocant, but the export allows you
    to use a comma after the invocant instead of a colon, or to omit the
    colon entirely in the case of a method with no arguments other than the
    invocant. Many standard methods (such as "IO::close" and "Array::push")
    are automatically exported to the "CORE" namespace by default. For other
    exported methods, you will not see the "multi" sub definition unless you
    "use" the class in your scope, which will import the "proto" (and
    associated "multi" subs) lexically, after which you can call it using
    normal subroutine call syntax.
    In the absence of an explicit type on the method's invocant, the
    exported "multi" sub's first argument is implicitly constrained to match
    the class in which it was defined or composed, so for instance the
    "multi" version of "close" requires its first argument to be of type
    "IO" or one of its subclasses. If the invocant is explicitly typed, that
    will govern the type coverage of the corresponding "multi"'s first
    argument, whether that is more specific or more general than the class's
    invocant would naturally be. (But be aware that if it's more specific
    than "::?CLASS", the binding may reject an otherwise valid single
    dispatch as well as a multi dispatch.) In any case, it does no good to
    overgeneralize the invocant if the routine itself cannot handle the
    broader type. In such a situation you must write a wrapper to coerce to
    the narrower type.
Trusts
    Attributes are tied to a particular class definition, so a method can
    only directly access the attributes of a class it's defined within when
    the invocant is the "self" of that attribute. However, it may call the
    private attribute accessors from a different class if that other class
    has indicated that it trusts the class the multi method is defined in:
        class MyClass {
            trusts YourClass;
    The trust really only applies to "MyClass", not to possible subclasses
    thereof.
    The syntax for calling back to "MyClass" is "$obj!MyClass::meth()". Note
    that private attribute accessors are always invoked directly, never via
    a dispatcher, since there is never any question about which object is
    being referred to. Hence, the private accessor notation may be
    aggressively inlined for simple attributes, and no simpler notation is
    needed for accessing another object's private attributes.
Delegation
    Delegation lets you pretend that some other object's methods are your
    own. Delegation is specified by a "handles" trait verb with an argument
    specifying one or more method names that the current object and the
    delegated object will have in common:
        has $tail handles 'wag';
    Since the method name (but nothing else) is known at class construction
    time, the following ".wag" method is autogenerated for you:
        method wag (|args) { $!tail.wag(|args) }
    You can specify multiple method names:
        has $.legs handles <walk run lope shake lift>;
    It's illegal to call the outer method unless the attribute has been
    initialized to an object of a type supporting the method, such as by:
        has Tail $.tail handles 'wag' .= new(|%_);
    Note that putting a "Tail" type on the attribute does not necessarily
    mean that the method is always delegated to the "Tail" class. The
    dispatch is still based on the *run-time* type of the object, not the
    declared type.
    Any other kind of argument to "handles" is considered to be a smartmatch
    selector for method names. All such selectors establish a failover to be
    used only if normal method dispatch fails, so it cannot be used to
    override any method in the normal ancestry of the object. So you can
    say:
        has $.fur is rw handles /^get_/;
        has $.fur is rw handles Groomable;
    then you get only those methods available via the "Groomable" role or
    class. To delegate everything, use the "Whatever" matcher:
        has $the_real_me handles *;
    Wildcard matches are evaluated only after it has been determined that
    there's no exact match to the method name anywhere in this object or in
    any of its parents. When you have multiple wildcard delegations to
    different objects, it's possible to have a conflict of method names.
    Wildcard method matches are evaluated in order, so the earliest one
    wins. (Non-wildcard method conflicts can be caught at class composition
    time.) If the wildcards for this class find nothing, then wildcards are
    checked for each of the ancestral classes in standard method resolution
    order.
    The form with "*" checks only for existing methods in the delegate's
    class (or its parents). It will not call any kind of a fallback via the
    delegate. (This allows you to call a "FALLBACK" routine of your own if
    the delegation would fail, since your own "FALLBACK" always runs after
    delegation, even wildcard delegation.) If instead you want to delegate
    completely and utterly, including a search of the delegate for its own
    fallback methods, with abject failure if the delegate can't handle it,
    then use the "HyperWhatever" instead:
        has $the_real_me handles **;
    If, where you would ordinarily specify a string, you put a pair, then
    the pair maps the method name in this class to the method name in the
    other class. If you put a hash, each key/value pair is treated as such a
    mapping. Such mappings are not considered wildcards.
        has $.fur handles { :shakefur<shake>, :scratch<get_fleas> };
    You *can* do a wildcard renaming, but not with pairs. Instead do
    smartmatch with a substitution:
        has $.fur handles (s/^furget_/get_/);
    Ordinarily delegation is based on an attribute holding an object, but it
    can also be based on the return value of a method:
        method select_tail handles <wag hang> {...}
Types and Subtypes
    The type system of Perl consists of roles, classes, and subtypes. You
    can declare a subtype like this:
        my subset Str_not2b of Str where /^[isnt|arent|amnot|aint]$/;
    or this:
        my Str subset Str_not2b where /^[isnt|arent|amnot|aint]$/;
    An anonymous subtype looks like this:
        Str where /^[isnt|arent|amnot|aint]$/;
    A "where" clause implies future smartmatching of some kind: the as-yet
    unspecified object of the type on the left must match the selector on
    the right. Our example is roughly equivalent to this closure:
        { $_.does(Str) and $_ ~~ /^[isnt|arent|amnot|aint]$/; }
    except that a subtype knows when to call itself.
    A subtype is not a subclass. Subclasses add capabilities, whereas a
    subtype adds constraints (takes away capabilities). A subtype is
    primarily a handy way of sneaking smartmatching into multiple dispatch.
    Just as a role allows you to specify something more general than a
    class, a subtype allows you to specify something more specific than a
    class. A subtype specifies a subset of the values that the original type
    specified, which is why we use the "subset" keyword for it.
    While subtypes are primarily intended for restricting parameter types
    for multiple dispatch, they also let you impose preconditions on
    assignment. If you declare any container with a subtype, Perl will check
    the constraint against any value you might try to bind or assign to the
    container.
        subset Str_not2b of Str where /^[isnt|arent|amnot|aint]$/;
        subset EvenNum   of Num where { $^n % 2 == 0 }
        my Str_not2b $hamlet;
        $hamlet = 'isnt';   # Okay because 'isnt' ~~ /^[isnt|arent|amnot|aint]$/
        $hamlet = 'amnt';   # Bzzzzzzzt!   'amnt' !~~ /^[isnt|arent|amnot|aint]$/
        my EvenNum $n;
        $n = 2;             # Okay
        $n = -2;            # Okay
        $n = 0;             # Okay
        $n = 3;             # Bzzzzzzzt
    It's legal to base one subtype on another; it just adds an additional
    constraint. That is, it's a subset of a subset.
    You can use an anonymous subtype in a signature:
        sub check_even (Num where { $^n % 2 == 0 } $even) {...}
    That's a bit unwieldy, but by the normal type declaration rules you can
    turn it around to get the variable out front:
        sub check_even ($even of Num where { $^n % 2 == 0 }) {...}
    and just for convenience we also let you write it:
        sub check_even (Num $even where { $^n % 2 == 0 }) {...}
    since all the type constraints in a signature parameter are just anded
    together anyway.
    You can leave out the block when matching against a literal value of
    some kind:
        proto sub fib (Int $) {*}
        multi sub fib (Int $n where 0|1) { return $n }
        multi sub fib (Int $n) { return fib($n-1) + fib($n-2) }
    In fact, you can leave out the "where" declaration altogether:
        multi sub fib (0) { return 0 }
        multi sub fib (1) { return 1 }
    Subtype constraints are used as tiebreakers in multiple dispatch:
        use Rules::Common :profanity;
        multi sub mesg ($mesg of Str where /<profanity>/ is copy) {
            $mesg ~~ s:g/<profanity>/[expletive deleted]/;
            print $MESG_LOG: $mesg;
        multi sub mesg ($mesg of Str) {
    For multi dispatch, a long name with a matching constraint is preferred
    over an equivalent one with no constraint. So the first "mesg" above is
    preferred if the constraint matches; otherwise the second is preferred.
    To export a subset type, put the export trait just before the "where":
        subset Positive of Int is export where * > 0;
    Note that the declaration of the "of" type for a subset doesn't really
    mean what an "of" type means elsewhere in the language. It is merely
    declaring the universe of input values for a boolean function. In fact,
    when used as a coercion, a subset type returns a "Bool" based on its
    condition, so it can be used directly as a predicate without the
    overhead of smartmatching:
        if Even($x) { ... }
        .say if .Even for 1..10;
  Abstract vs Concrete types
    For any named type, certain other subset types may automatically be
    derived from it by appending an appropriate adverbial to its name:
        Int:_       Allow either defined or undefined Int values
        Int:D       Allow only defined (concrete) Int values
        Int:U       Allow only undefined (abstract) Int values
    That is, these mean something like:
        Int:D       Int:_ where DEFINITE($_)
        Int:U       Int:_ where not(DEFINITE($_))
    where "DEFINITE" is a boolean macro that says whether the object in
    question has a valid concrete representation (see "Introspection"
    below).
    In standard Perl 6, "Int" is generally assumed to mean "Int:_", except
    for invocants, where the default is "Int:D". (The default "new" method
    has a prototype whose invocant is ":U" instead, so all new methods all
    default to allowing type objects.)
    These defaults may be changed within a lexical scope by various pragmas.
    In particular,
        use parameters :D;
    will cause non-invocant parameters to default to ":D". Conjecturally,
        use variables :D;
    would do the same for types used in variable declarations.
    In such lexical scopes you may use the ":_" form to get back to the
    standard behavior. In particular, since invocants default to defined,
        use invocant :_;
    will make invocants allow any sort of defined or undefined invocant.
  Multiple constraints
    [Conjecture: This entire section is considered a guess at our post-6.0.0
    direction. For 6.0.0 we will allow only a single constraint before the
    variable, and post constraints will all be considered "epsilon" narrower
    than the single type on the left. The single constraint on the left may,
    however, be a value like 0 or a named subset type. Such a named subset
    type may be predeclared with an arbitrarily complex "where" clause; for
    6.0.0 any structure type information inferable from the "where" clause
    will be ignored, and the declared subset type will simply be considered
    nominally derived from the "of" type mentioned in the same declaration.]
    More generally, a parameter can have a set of constraints, and the set
    of constraints defines the formal type of the parameter, as visible to
    the signature. (No one constraint is privileged as the storage type of
    the actual argument, unless it is a native type.) All constraints are
    considered in type narrowness. That is, these are equivalently narrow:
        Foo Bar @x
        Bar Foo @x
    The constraint implied by the sigil also counts as part of the official
    type. The sigil is actually a constraint on the container, so the actual
    type of the parameter above is something like:
        Positional[subset :: of Any where Foo & Bar]
    Static "where" clauses also count as part of the official type. A
    "where" clause is considered static if it can be applied to the types to
    the left of it at compile time to produce a known finite set of values.
    For instance, a subset of an enum type is a static set of values. Hence
        Day $d where 'Mon'..'Fri'
    is considered equivalent to
        subset Weekday of Day where 'Mon'..'Fri';
        Weekday $d
    Types mentioned in a dynamic "where" class are not considered part of
    the official type, except insofar as the type includes the notion: "is
    also constrained by a dynamic "where" clause", which narrows it by
    epsilon over the equivalent type without a "where" clause.
        Foo Bar @x              # type is Foo & Bar & Positional
        Foo Bar @x where Baz    # slightly tighter than Foo Bar Positional
    The set of constraints for a parameter creates a subset type that
    implies some set of allowed values for the parameter. The set of allowed
    values may or may not be determinable at compile time. When the set of
    allowed values is determinable at compile time, we call it a static
    subtype.
    Type constraints that resolve to a static subtype (that is, with a fixed
    set of elements knowable (if not known) at compile time) are considered
    to be narrower than type constraints that involve run-time calculation,
    or are otherwise intractable at compile time. Note that all values such
    as 0 or "foo" are considered singleton static subtypes. Singleton values
    are considered narrower than a subtype with multiple values, even if the
    subtype contains the value in question. This is because, for enumerable
    types, type narrowness is defined by doing set theory on the set of
    enumerated values.
    So assuming:
        my enum Day ['Sun','Mon','Tue','Wed','Thu','Fri','Sat'];
        subset Weekday of Day where 'Mon' .. 'Fri'; # considered static
        subset Today of Day where *.today;
    we have the following pecking order:
        Parameter                   # Set of possible values
        =========                   ========================
        Int $n                      # Int
        Int $n where Today          # Int plus dynamic where
        Int $n where 1 <= * <= 5    # Int plus dynamic where
        Day $n                      # 0..6
        Day $n where Today          # 0..6 plus dynamic where
        Day $n where 1 <= * <= 5    # 1..5
        Int $n where Weekday        # 1..5
        Day $n where Weekday        # 1..5
        Weekday $n                  # 1..5
        Tue                         # 2
    Note the difference between:
    The first "where" is considered dynamic not because of the nature of the
    comparisons but because "Int" is not finitely enumerable. Our "Weekday"
    subset type can calculate the set membership at compile time because it
    is based on the "Day" enum, and hence is considered static despite the
    use of a "where". Had we based "Weekday" on "Int" it would have been
    considered dynamic. Note, however, that with "anded" constraints, any
    enum type governs looser types, so
        Int Day $n where 1 <= * <= 5
    is considered static, since "Day" is an enum, and cuts down the search
    space.
    The basic principle we're trying to get at is this: in comparing two
    parameter types, the narrowness is determined by the subset
    relationships on the sets of possible values, not on the names of
    constraints, or the method by which those constraints are specified. For
    practical reasons, we limit our subset knowledge to what can be easily
    known at compile time, and consider the presence of one or more dynamic
    constraints to be epsilon narrower than the same set of possible values
    without a dynamic constraint.
    As a first approximation for 6.0.0, subsets of enums are static, and
    other subsets are dynamic. We may refine this in subsequent versions of
    Perl.
Enumerations
    An enumeration is a type that facilitates the use of a set of symbols to
    represent a set of constant values. Its most obvious use is the
    translation of those symbols to their corresponding values. Each
    enumeration association is a constant pair known as an *enum*, which is
    of type "Enum". Each enum associates an *enum key* with an *enum value*.
    Semantically therefore, an enumeration operates like a constant hash,
    but since it uses a package "Stash" to hold the entries, it presents
    itself to the user's namespace as a typename package containing a set of
    constant declarations. That is,
        enum E <a b c>;
    is largely syntactic sugar for:
        package E {
            constant a = 0;
            constant b = 1;
            constant c = 2;
    (However, the "enum" declaration supplies extra semantics.)
    Such constant declarations allow the use of the declared names to stand
    in for the values where a value is desired. In addition, since a
    constant declaration introduces a name that behaves as a subtype
    matching a single value, the enum key can function as a typename in
    certain capacities where a typename is required. The name of the
    enumeration as a whole is also considered a typename, and may be used to
    represent the set of values. (Note that when we wish to verbally
    distinguish the enumeration as a whole from each individual enum pair,
    we use the long term "enumeration" for the former, despite the fact that
    it is declared using the "enum" keyword.)
    In the "enum" declaration, the keys are specified as a parenthesized
    list, or an equivalent angle bracket list:
        my enum Day ('Sun','Mon','Tue','Wed','Thu','Fri','Sat');
        my enum Day <Sun Mon Tue Wed Thu Fri Sat>;
  Value Generation
    The values are generated implicitly by default, but may also be
    specified explicitly. If the first value is unspecified, it defaults to
    0. To specify the first value, use pair notation (see below).
    If the declared enumeration typename begins with an uppercase letter,
    the enum values will be derived from "Int" or "Str" as appropriate. If
    the enumeration typename is lowercase, the enumeration is assumed to be
    representing a set of native values, so the default value type is "int"
    or "buf".
    The base type can be specified if desired:
        my bit enum maybe <no yes>;
        my Int enum day ('Sun','Mon','Tue','Wed','Thu','Fri','Sat');
        our enum day of uint4 <Sun Mon Tue Wed Thu Fri Sat>;
    The declared base type automatically distributes itself to the
    individual constant values. For non-native types, the enum objects are
    guaranteed only to be derived from and convertible to the specified
    type. The actual type of the enum object returned by using the symbol is
    the enumeration type itself.
        Fri.WHAT    # Day, not Int.
        +Fri        # 5
        Fri.Numeric # 5
        Fri ~~ Int  # True, because derived from Int
        Fri.perl    # 'Day::Fri'
        ~Fri        # 'Fri' (only for numeric enums)
        Fri.Stringy # 'Fri' (only for numeric enums)
        Fri.Str     # 'Fri' (only for numeric enums)
        Fri.gist    # 'Fri' (used by say)
        Fri.key     # 'Fri'
        Fri.value   # 5
        Fri.pair    # :Fri(5)
        Fri.kv      # 'Fri', 5
        Fri.defined # True
    Other than that, number valued enums act just like numbers, while string
    valued enums act just like strings. "Fri.so" is true because its value
    is 5 rather than 0. "Sun.so" is false.
    Enums based on native types may be used only for their value, since a
    native value doesn't know its own type.
    Since methods on native types delegate to their container's type, a
    variable typed with a native type will know which method to call:
        my day $d = 3;
        $d.key     # returns "Wed"
    Such declarational forms are not always convenient; to translate native
    enum values back to their names operationally, you can pull out the enum
    type's "EnumMap" and invert it:
        constant %dayname := day.enums.invert;
        %dayname{3} # Wed
  The Enumeration Type
    The enumeration type itself is an undefined type object, but supplies
    convenient methods:
        Day.defined   # False
        3 ~~ Day($_)  # True, in range
        8 ~~ Day($_)  # False, *not* in range
        Day.enums     # map of key/value pairs
    The ".enums" method returns an "EnumMap" that may be used either as a
    constant hash value or as a list of pairs:
        my enum CoinFace <Heads Tails>;
        CoinFace.enums.keys       # ('Heads', 'Tails')
        CoinFace.enums.values     # (0, 1)
        CoinFace.enums.kv         # ('Heads', 0, 'Tails', 1)
        CoinFace.enums.invert     # (0 => 'Heads', 1 => 'Tails')
        CoinFace.enums.[1]        # Tails => 1
    The enumeration typename itself may be used as a coercion operator from
    either the key name or a value. First the argument is looked up as a
    key; if that is found, the enum object is returned. If the key name
    lookup fails, the value is looked up using an inverted mapping table
    (which might have duplicates if the mapping is not one-to-one):
        Day('Tue')           # Tue constant, found as key
        Day::('Tue')         # (same thing)
        Day(3)               # Wed constant, found as value
        Day.enums.invert{3}  # (same thing)
  Anonymous Enumerations
    An anonymous "enum" just makes sure each string turns into a pair with
    sequentially increasing values, so:
        %e = enum < ook! ook. ook? >;
        %e = ();
        %e<ook!> = 0;
        %e<ook.> = 1;
        %e<ook?> = 2;
    The return value of an anonymous enumeration is an "EnumMap". The "enum"
    keyword is still a declarator here, so the list is evaluated at compile
    time. Use a coercion to "EnumMap" to get a run-time map.
  Composition from Pairs
    The enumeration composer inspects list values for pairs, where the value
    of the pair sets the next value explicitly. Non-pairs "++" the previous
    value. (Str and buf types increment like Perl 5 strings.) Since the
    "«...»" quoter automatically recognizes pair syntax along with
    interpolations, we can simply say:
        my enum DayOfWeek «:Sun(1) Mon Tue Wed Thu Fri Sat»;
        our Str enum Phonetic «:Alpha<A> Bravo Charlie Delta
                                Echo Foxtrot Golf Hotel India Juliet
                                Kilo Lima Mike November Oscar Papa
                                Quebec Romeo Sierra Tango Uniform
                                Victor Whiskey X-ray Yankee Zulu»;
        enum roman (i => 1,   v => 5,
                    x => 10,  l => 50,
                    c => 100, d => 500,
                    m => 1000);
        my Item enum hex «:zero(0) one two three four five six seven eight nine
                          :ten<a> eleven twelve thirteen fourteen fifteen»;
    Note that enumeration declaration evaluates its list at compile time, so
    any interpolation into such a list may not depend on run-time values.
    Otherwise enums wouldn't be constants. (If this isn't what you want, try
    initializing an ordinary declaration using "::=" to make a scoped
    readonly value.)
    You may import enum types; only non-colliding symbols are imported.
    Colliding enum keys are hidden and must be disambiguated with the type
    name. Any attempt to use the ambiguous name will result in a fatal
    compilation error. (All colliding values are hidden, not just the new
    one, or the old one.) Any explicit sub or type definition hides all
    imported enum keys of the same name but will produce a warning unless
    "is redefined" is included.
  Anonymous Mixin Roles using "but" or "does"
    Since non-native "Enum" values know their enumeration type, they may be
    used to name a desired property on the right side of a "but" or "does".
    So these:
        $x = "Today" but Tue;
        $y does True;
    expand to:
        $x = "Today" but Day::Tue;
        $y does Bool::True;
    The "but" and "does" operators expect a role on their right side. An
    enum type is not in itself a role type; however, the "but" and "does"
    operators know that when a user supplies an enum type, it implies the
    generation of an anonymous mixin role that creates an appropriate
    accessor, read-write if an attribute is being created, and read-only
    otherwise. It depends on whether you mix in the whole or a specific enum
    or the whole enumeration:
        $x = "Today" but Tue;       # $x.Day is read-only
        $x = "Today" but Day;       # $x.Day is read-write
    Mixing in a specific enum object implies only the readonly accessor.
    really means something like:
        $x = "Today".clone;
        $x does anon role { method Day { Day::Tue } };
    The fully qualified form does the same thing, and is useful in case of
    enum collision:
    Note that the method name is still ".Day", however. If you wish to mix
    in colliding method names, you'll have to mixin your own anonymous role
    with different method names.
    Since an enumeration supplies the type name as a coercion, you can also
        $x = "Today" but Day(Tue);
        $x = "Today" but Day(2);
    After any of those
        $x.Day
    returns "Day::Tue" (that is, the constant object representing 2), and
    both the general and specific names function as typenames in normal
    constraint and coercion uses. Hence,
        $x ~~ Day
        $x ~~ Tue
        $x.Day == Tue
        Day($x) == Tue
        $x.Tue
    all return true, and
        $x.Wed
        $x.Day == Wed
        8 ~~ Day($_)
    all return false.
    Mixing in the full enumeration type produces a read-write attribute:
        $x = "Today" but Day;       # read-write .Day
        $x does anon role { has Day $.Day is rw }
    except that nothing happens if there is already a "rw" attribute of that
    Note that the attribute is not initialized. If that is desired you can
    supply a "WHENCE" closure:
        $x = "Today" but Day{ :Day(Tue) }
        $x = "Today" but Day{ Tue }  # conjecturally, for "simple" roles
  Adding Traits
    To add traits to an enumeration declaration, place them after the
    declared name but before the list:
        enum Size is silly <regular large jumbo>;
  Exporting
    To export an enumeration, place the export trait just before the list:
        enum Maybe is export <No Yes Dunno>;
  Implying a Role
    To declare that an enumeration implies a particular role, supply a
    "does" in the same location
        enum Maybe does TristateLogic <No Yes Dunno>;
  Built-in Enumerations
    Two built-in enumerations are:
        our enum Bool does Boolean <False True>;
        our enum Taint does Tainting <Untainted Tainted>;
    Note that "Bool" and "Taint" are not role names themselves but imply
    roles, and the enum values are really subset types of "Int", though the
    constant objects themselves know that they are of type "Bool" or
    "Taint", and can therefore be used correctly in multimethod dispatch.
    You can call the low-level ".Bool" coercion on any built-in type,
    because all built-in types do the "Boolean" role, which requires a
    ".Bool" method. Hence, there is a great difference between saying
            $x does Boolean;        # a no-op, since $x already does Boolean
            $x does Bool;           # create a $.Bool attribute, also does Boolean
    Conditionals evaluate the truth of a boolean expression by testing the
    return value of ".Bool"; how they do this is a mystery, except that they
    must do something mysterious and platform dependent to avoid calling
    ".Bool" recursively on the results of ".Bool".
    Never compare a value to ""True"". Just use it in a boolean context.
    Well, almost never...
    If you wish to be explicit about a boolean context, use the high-level
    "so" function or "?" prefix operator, which are underlying based on the
    ".Bool" method. Since ".Bool" always collapses junctions, so do these
    functions. (Hence if you really need to autothread a bunch of boolean
    values, you'll have to convert them to some other type such as "Bit"
    that can be used as a boolean value later. Generally it makes no sense
    to autothread booleans, so we have a policy of collapsing them sooner
    rather than later.)
  Miscellaneous Rules
    Like other type names and constant names, enum keynames are parsed as
    standalone tokens representing scalar values, and don't look for any
    arguments. Unlike type names but like constant names, enum keynames
    return defined values. Also unlike types and unlike the enum type as a
    whole, individual keynames do not respond to ".()" unless you mix in
    "Callable" somehow. (That is, it makes no sense to coerce Wednesday to
    Tuesday by saying "Tue($wed)".) Enumerations may not be post-declared.
        our enum Maybe <OK FAIL>;
        sub OK is redefined {...}
        $x = OK;   # certainly the enum value
        $x = OK()  # certainly the function
    Since there is an enum "OK", the function "OK" may only be called using
    parentheses, never in list operator form. (If there is a collision on
    two enum values that cancels them both, the function still may only be
    called with parentheses, since the enum key is "poisoned".)
  The ".pick" Method
    Enumeration types (and perhaps certain other finite, enumerable types
    such as finite ranges) define a ".pick" method on the type object of
    that type. Hence:
        CoinFace.pick
    returns "Heads" or "Tails" with equal probability, and
        Month.pick(*)
    will return the months in random order. Presumably
        StandardPlayingCards.pick(5)
    might return a Royal Flush, but a Full House is much more likely. It can
    never return Five Aces, since the pick is done without replacement. (If
    it *does* return Five Aces, it's time to walk away. Or maybe run.)
    To pick from the list of keynames or values, derive them via the
    ".enums" method described above.
Open vs Closed Classes
    By default, all classes in Perl are non-final, which means you can
    potentially derive from them. They are also open, which means you can
    add more methods to them, though you have to be explicit that that is
    what you're doing:
        augment class Mu {
            method wow () { say "Wow, I'm in the Cosmic All." }
    Otherwise you'll get a class redefinition error. (Also, to completely
    replace a definition, use ""supersede"" instead of ""augment""...but
    don't do that, since the compiler may have already committed to
    optimizations based on the old definition.)
    In order to discourage casual misuse of these declarators, they are not
    allowed on global classes unless you put a special declaration at the
    top:
        use MONKEY-TYPING;
    For optimization purposes, Perl 6 gives the top-level application the
    right to close and finalize classes by the use of "oo", a pragma for
    selecting global semantics of the underlying object-oriented engine:
        use oo :closed :final;
    This forces the optimizer to consider the current file to represent the
    top-level application; however, the optimizer is also allowed to assume
    these semantics when it can determine that it is linking an entire
    application, such as when the current file is being run from the command
    line or from a mouse click.
    These pragmatics (whether explicit or assumed) merely change the
    application's default to closed and final, which means that at the end
    of the main compilation ("LINK" time) the optimizer is allowed to look
    for candidate classes to close or finalize. But anyone (including the
    main application) can request that any class stay open or nonfinal, and
    the class closer/finalizer must honor that.
        use class :open<Mammal Insect> :nonfinal<Str>
    These properties may also be specified on the class definition:
        class Mammal is open {...}
        class Insect is open {...}
        class Str is nonfinal {...}
    or by lexically scoped pragma around the class definition:
            use class :open;
            class Mammal {...}
            class Insect {...}
            use class :nonfinal;
            class Str {...}
    There is *no* syntax for declaring individual classes closed or final.
    The application may only request that the optimizer close and finalize
    unmarked classes.
Representations
    By default Perl 6 assumes that all objects have a representation of
    "P6opaque". This may be overridden with a trait:
        class Mammal is repr(P6Hash) {...}
    Whether implicit or explicit, the representation is considered to be
    fixed for the class after declaration, and the optimizer is free to
    optimize based on this guarantee. It is illegal to create an object of
    the same type with any other representation. If you wish to allow
    objects to be created with run-time specified representations, you must
    specifically pessimize the class:
        class Mammal is repr(*) {...}
    An "augment" is allowed to do this as long as it is before the main
    "LINK" time, at which point the compiler commits to its optimization
    strategies. Compilers are not required to support run-time
    pessimizations (though they may). Compilers may also generate both
    optimal and pessimal code paths and choose which to run based on
    run-time information, as long as correct semantics are maintained.
    All non-native representations are required to support undefined type
    objects that may contain unthrown exceptions ("Failure" objects); while
    this can be implemented using an alternate representation, Perl 6
    doesn't think of it that way. All normal objects in Perl 6 may be used
    as a specific object (proper noun) if they are defined, or as a generic
    object (common noun) whether or not they are defined. You get this
    representation polymorphism for free independently of the restriction
    above.
Interface Consistency
    By default, all methods and submethods that do not declare an explicit
    "*%" parameter will get an implicit *%_ parameter declared for them
    whether they like it or not. In other words, all methods allow
    unexpected named arguments, so that "nextsame" semantics work
    consistently.
    If you mark a class ""is hidden"", it hides the current class from
    ""nextsame"" semantics, and incidentally suppresses the autogeneration
    of *%_ parameters. Methods on hidden classes may still be called as
    "$obj.NameOfHiddenClass::yourmethod".
    A similar effect can be achieved from the derived class by saying "hides
    Base" instead of "is Base".
Introspection
    Metamethods for objects are named with interrogative pronouns in
    uppercase:
        WHAT        the type object of the type, .gist returns MyClass()
        WHICH       the object's identity value
        WHO         the package supporting the object, stringifies to long name
        WHERE       the memory address of the object
        HOW         the metaclass object: "Higher Order Workings"
        WHEN        (reserved for events?)
        WHY         the attached Pod value
        WHENCE      autovivification closure
    These may be used either as methods or as unary operators:
        $obj.WHAT   # method form of P5's ref
        WHAT $obj   # unary form of P5's ref
    These should all be considered built-in language primitives, not true
    operators or methods, even if a given implementation happens to
    implement one or more of them that way. The optimizer reserves the right
    to assume it knows what these names mean without user meddling. Do not
    attempt to override or overload them, or bend them into twisty little
    brain pretzels, except to fulfill those parts of the standard interface
    that require you to do so. (Value types, for instance, currently require
    a definition of WHICH. This too may change as our notions of identity
    are refined.)
    If you get a foreign object from another language and need to call its
    ".WHERE" method, you can say:
        $obj."WHERE"()
    And if you don't know the method name in advance, you'd be using the
    variable form anyway:
        $obj."$methodname"()
    or:
        $obj.$methodobject
    which also bypasses the macros.
    There is one more macro:
        DEFINITE    the object has a valid concrete representation
    The "DEFINITE" macro serves as the default for the "Mu.defined" method.
    For now Perl 6 reserves the right to change how all these macros and the
    corresponding "^" forms are defined in terms of each other. In
    particular, the ".^" forms will automatically supply the invocant as the
    first argument to methods of the metaclass, while the other forms
    require you to pass this explicitly.
    Note that "WHAT.gist" surrounds the name with parens to indicate
    undefinedness. Use ".perl" to get the bare name from a type object. Use
    one of ".Str", ".Stringy", "prefix:<~>", or "infix:<~>" to get the
    Perl5ish semantics of returning the empty string (with a warning) on any
    type object. (There is no "undef", in Perl 6; type objects provide typed
    undefs instead.)
    In general, use of these uppercased accessors in ordinary code should be
    a red flag that Something Very Strange is going on. (Hence the allcaps.)
    Most code should use Perl 6's operators that make use of this
    information implicitly. For instance, instead of
        $obj.WHAT === Dog
        $x.WHICH === $y.WHICH
        $obj.WHAT.bless(%args)
    you usually just want:
        $obj ~~ Dog
        $x === $y
        $obj.bless(%args)
    Every class has a "HOW" function/method that lets you get at the class's
    metaobject, which lets you get at all the metadata properties for the
    class (or other metaobject protocol) implementing the objects of the
    class:
        MyClass.methods()           # call MyClass's .methods method (error?)
        MyClass.HOW.methods($obj)       # get the method list of MyClass
    The "^" metasyntax is equivalent to ".HOW":
        MyClass.HOW.methods($obj)   # get the method list of MyClass
        MyClass.^methods()          # get the method list of MyClass
    Each object of the class also has a ".HOW" or ".^" method:
        $obj.HOW.methods($obj);
        $obj.^methods();
    (If you are using prototype-based OO rather than class-based, you must
    use the object form, since every such object functions as its own
    class.)
    Class traits may include:
        identifier  { :name<Dog> :auth<http://www.some.com/~jrandom> :ver<1.2.1> }
            name      Dog
            authority http://www.some.com/~jrandom
            version   v1.2.1
        author        Joe Random
        description   This class implements camera obscura.
        subject       optics, boxes
        language      ja_JP
        licensed      Artistic|GPL
        parents       list of parent classes
        roles         list of roles
        disambig      how to deal with ambiguous method names from roles
        repr          P6opaque, P6hash, P5hash, P5array, PyDict, Cstruct, etc.
    These are for the standard Perl 6 Meta-Object Protocol, but other MOPs
    may define other traits. The identifier should probably be accessed
    through the ".WHO" object in any case, which may have its own object
    methods depending on how type namespaces evolve over time. Which of
    these items are actually part of the ".HOW" object and which are
    delegated back to the package and prototype objects is up to the MOP.
    (Note also that anonymous classes may have anonymous packages and
    prototype objects, in which case stringification is not likely to
    produce something of interest to non-gurus.)
    The ".^parents" method by default returns a flattened list of all
    parents out to (but not including) "Cool" or "Any", sorted in MRO
    (dispatch) order. Other options are:
        :local              just returns the immediate parents
        :local($n)          return $n levels
        :excl               exclude Cool and Any (the default)
        :all                include Cool and Any
        :tree               the inheritance hierarchy as nested arrays
    The ".^methods" method returns method-descriptors containing:
        name                the name of the method
        signature           the parameters of the method
        as                  the coercion type of the method
        proto               whether this method governs a set of multi methods
        do                  the method body
    The ".^methods" method has a selector parameter that lets you specify
    whether you want to see a flattened or hierarchical view, whether you're
    interested in private methods, and so forth.
        :local              only methods defined in the current class
        :local($n)          out $n levels
        :tree               methods by class structure (inheritance hierarchy)
        :private            include private methods
    Note that, since introspection is primarily for use by the outside world
    (the class already knows its own structure, after all), a set of "multi"
    methods are presented to be a single "proto" method. You need to use
    ".candidates" on that to break it down further.
    The ".^attributes" method returns a list of "Attribute" objects that
    have methods like these:
        name
        type
        scope
        rw
        private
        has-accessor
        build
        readonly
        get_value($obj)
        set_value($obj, $new_value)
    Note that an "Attribute" is not tied to a particular object of a type,
    but rather to the type itself. Which is why "get_value" and "set_value"
    need to receive the actual object as first positional parameter.
    [Conjecture: if it's not feasible for a meta class or a representation
    to implement "set_value" and "get_value", it may die with an helpful
    error message when these methods are called.]
    "set_value" and "get_value" violate the privacy of attributes, and thus
    should be used with care, and at the user's own risk.
    ".^attributes" also takes the parameters:
        :tree               attributes by class structure (inheritance hierarchy)
    Strictly speaking, metamethods like ".isa()", ".does()", and ".can()"
    should be called through the meta object:
        $obj.HOW.can($obj, "bark")
        $obj.HOW.does($obj, Dog)
        $obj.HOW.isa($obj, Mammal)
        $obj.^can("bark")
        $obj.^does(Dog)
        $obj.^isa(Mammal)
    But "Any" gives you shortcuts to those:
        $obj.can("bark")
        $obj.does(Dog)
        $obj.isa(Mammal)
    These, may, of course, be overridden in a subclass, so don't use the
    short form unless you wish to allow for overrides. In general, "Any"
    will delegate only those metamethods that read well when reasoning about
    an individual object. Infrastructural methods like ".^methods" and
    ".^attributes" are not delegated, so "$obj.methods" fails.
    The smartmatch:
    actually calls:
    which is true if $obj either "does" or "isa" "Dog" (or "isa" something
    that "does" "Dog"). If "Dog" is a subset, any additional "where"
    constraints must also evaluate true.
    Unlike in Perl 5 where ".can" returns a single "Code" object, Perl 6's
    version of ".^can" returns a "WALK" iterator for a set of routines that
    match the name, including all autoloaded and wildcarded possibilities.
    In particular, ".^can" interrogates any class package's "CANDO" method
    for names that are to be considered autoloadable methods in the class,
    even if they haven't been declared yet. Role composition sometimes
    relies on this ability to determine whether a superclass supplies a
    method of a particular name if it's required and hasn't been supplied by
    the class or one of its roles.
    The motivation for stopping at "Cool" and "Any" by default is that the
    first derivation from one of those is really what the user thinks of as
    the root class of the type hierarchy most of the time. Methods outside
    of that are really part of Perl 6's lexicon, recognizable across all
    types. Hence if you say, for example, "$object.sort" or
    "$object.arctan", you're invoking well-known cultural concepts that tend
    to transcend the user's type hierarchy. When the user asks for
    $object.^methods, listing such methods by default is rather irritating.
    Note that when we say ""Cool" and "Any"" above, we really mean those
    types as well as any types outside of them, such as "Mu" or "Junction".
    But users should not generally be deriving from those types anyway.
Custom Meta-objects
    [Note: This section is still subject to some changes, but does at least
    reflect current implementation reality fairly well.]
    When the parser encounters a package declarator, it uses the name of the
    declarator (such as "class" or "grammar") to look up the type of
    meta-object to use. The default meta-objects support the standard Perl 6
    OO semantics. However, it is possible for a module to export different
    meta-objects with different semantics. This is done by declaring an
    "EXPORTHOW" package, which should be located in "UNIT" of the module
    (and thus can be lexically scoped).
    Just as the "EXPORT" package never contains symbols directly, but
    instead contains packages that denote tags and directives (such as
    "DEFAULT"), the "EXPORTHOW" package expects meta-objects to be installed
    under one of the following packages:
        SUPERSEDE   Uses the exported meta-object for the named declarator in
                    the scope that the module is imported in to
        COMPOSE     Takes the meta-object currently in effect for the named
                    declarator and composes the exported role into it
        DECLARE     Like SUPERSEDE, but also adds a new package declarator to
                    the grammar if required
    For example, a module can replace the meta-object used for the "grammar"
    keyword in any scope it is imported into by doing:
        my module EXPORTHOW::SUPERSEDE { }
        EXPORTHOW::SUPERSEDE<grammar> = TracedGrammarHOW;
    An MVC framework could declare a new "controller" package declarator and
    associate it with a meta-class of its choosing by doing:
        my module EXPORTHOW::DECLARE { }
        EXPORTHOW::DECLARE<controller> = ControllerHOW;
    The "COMPOSE" directive is perhaps the most sophisticated, and its usage
    is encouraged where possible. Instead of exporting an entirely new
    meta-object, "COMPOSE" enables exporting a role. At the point the
    declarator is first used, all roles exported for it through "COMPOSE"
    will be taken together and added to a class derived from the current
    meta-object for the declarator (which may have been provided by a
    SUPERSEDE or DECLARE export from another module used in the scope). This
    class will then be composed, with any conflicts indicated.
        my module EXPORTHOW::COMPOSE {
            # Provide a role that adds logging to class method calls.
            role class {
                method find_method($obj, $name) {
                    say "Calling $name";
                    nextsame;
                method publish_method_cache($obj) {
                    # Make sure all dispatches go through find_method
    The benefit of "COMPOSE" is that it enables two modules that extend a
    meta-object in a non-conflicting way to be used together in the same
    scope, with explicit detection of conflicts if they occur. For example,
    if one module wishes to override "compose" and another wishes to
    override "find_method", the two can be used together safely. By
    contrast, "SUPERSEDE" and "DECLARE" can only be used by one module per
    declarator in a given scope, thwarting composition. The compiler should
    produce an error if this rule is broken.
    The easiest way to define a new meta-object is to inherit from an
    existing meta-object.
        my class TracedGrammarHOW is Metamodel::GrammarHOW {
    Here is a list of the various meta-objects that you may safely subclass
    and the name they are installed under by default.
        Metamodel::ClassHOW                 class
        Metamodel::EnumHOW                  enum
        Metamodel::GrammarHOW               grammar
        Metamodel::ModuleHOW                module
        Metamodel::PackageHOW               package
        Metamodel::ParametricRoleHOW        role
        Metamodel::ParametricRoleGroupHOW   role-group
        Metamodel::SubsetHOW                subset
    All of these meta-objects inherit from "Any". However, they will in turn
    be implemented by other meta-objects that may or may not do so. This is
    considered implementation specific, and implementations may re-arrange
    these details freely between versions. Thus, relying on them is
    erroneous.
        SomeP6Class.HOW         # Promises to (ultimately) inherit from Any
        SomeP6Class.HOW.HOW     # Implementation specific
    Roles are a little interesting, since they involve multiple
    meta-objects. When you write:
        role Foo {
    Then a "ParametricRoleHOW" is created to represent the role declaration.
    It is in turn wrapped up inside a "ParametricRoleGroupHOW", which is
    then installed under the name "Foo". This is because one short name may
    have many long names due to signatured roles.
        role Foo[::T] {
    Sometimes, it may be interesting to customize meta-object behaviour on a
    per-type basis. While this could be done by writing a custom meta-class
    and arranging for it to be used, Perl 6 permits overriding specific
    meta-methods on a per-type basis. For example, if the "trusts" adverb
    was not flexible enough and the class instead wanted to implement a more
    custom policy on what other types it trusts, it could do something like:
        method ^is_trusted($obj, $do_we_trust_it) {
            return $do_we_trust_it ~~ TheRoleOfTheTrustworthy;
    It's not necessary to override existing meta-methods either; this can be
    used to attach whatever properties are desired to the meta-object for
    the type:
        method ^license($obj) { 'Artistic License' }
    Note that meta-methods generally need to take an argument that
    corresponds to the object they are invoked on. This is because:
        $obj.^license
    Desugars to:
        $obj.HOW.license($obj)
    Meaning that implementing meta-methods providing prototype-like
    semantics are possible.
    Methods declared with the "^" modifier are handed to the meta-object by
    the "add_meta_method" method, rather than the usual "add_method". At
    compose time of the class (usually, the closing "}"), if there are any
    such per-type meta-methods, a role will be generated containing the
    meta-methods, and this will be mixed in to the meta-object. This means
    that this mechanism is only useful for overriding meta-methods called
    after class composition. Therefore, short of trying to restrict
    "augment" operations in the future, it does not make sense to write a
    "method ^add_method(...) { ... }". Such declarational behaviour changes
    should be handled through the "EXPORTHOW" approach. Any meta-methods in
    a role will not have immediate effect, but will rather be passed along
    to any class the role is composed into, and so take effect at
    composition time of each class composing the role.
Autovivifying objects
    The "WHENCE" property of an object is its autovivifying closure. Any
    undefined prototype object may carry such a closure that can lazily
    create an object of the appropriate type. When the closure is eventually
    evaluated it is expected to return an argument list corresponding to the
    arguments to a ".bless" call. For instance, a "CANDO" routine, instead
    of creating a "Dog" object directly, could instead return something
    like:
        Dog but WHENCE({ :name<Fido> })
    which runs the closure if the object ever needs to be autovivified. The
    closure can capture whatever initializers were available in the original
    The short form of the above is simply:
        Dog{ :name<Fido> }
    This form is also lazily evaluated:
        my $dog = Dog{ :name<Fido> };
        defined $dog or say "doesn't exist";  # Fido doesn't exist
        $dog.wag()                            # Fido wags his tail
    When the typename happens to be a role, autovivifying it involves
    attempting to create a punned class of the same name as the role.
    Whether this succeeds or not depends on whether the role is sufficiently
    complete to serve as a class on its own. Regardless of whether such an
    attempt would succeed, it is always perfectly fine to define a lazy type
    object for a role just as long as it's only ever used as an argument to
    "bless", since "bless" will only be using its closure to construct the
    role's "BUILD" arguments in the context of the complete new class. (Of
    course, an inconsistent or incomplete class composition may subsequently
    fail, and in fact the incomplete role autovivification mentioned above
    is likely to be implemented by failing at the point of class
    composition.)
    Note that when used as an argument to a method like "bless", the type
    object is sufficiently lazy that autovivifying is done only by the
    appropriate "BUILD" routine. It does not waste energy creating a "Dog"
    object when that object's attributes would later have to be copied into
    the actual object. (On top of which, such an implementation would make
    it impossible to use type objects to initialize incomplete roles.)
    The object autovivification syntax works only for literal named types,
    so any indirection must be written more explicitly:
        ::($dogproto){ :name<Fido> }
        $dogproto but WHENCE({ :name<Fido> })
        $dogproto.WHAT{ :name<Fido> }
    Note that in contrast to this syntax, a lookup of a symbol in the "Dog"
    package requires a final "::" before the subscript:
        Dog::{$varname}
    Synopsis 13: Overloading
        Created: 2 Nov 2004
        Last Modified: 17 Jan 2012
        Version: 17
    have been in Apocalypse 13.
Multiple dispatch
    The overloading mechanism of Perl 5 has been superseded by Perl 6's
    multiple dispatch mechanism. Nearly all internal functions are defined
    as "multi" subs or "multi" methods on generic types. Built-in operators
    are merely oddly named functions with an alternate call syntax. All you
    have to do to overload them is to define your own "multi" subs and
    methods that operate on arguments with more specific types.
    For unary operators, this makes little effective difference, but for
    binary operators, multiple dispatch fixes the Perl 5 problem of paying
    attention only to the type of the left argument. Since both argument
    types are used in deciding which routine to call, there is no longer any
    trickery involving swapping the arguments to use the right argument's
    type instead of the left one. And there's no longer any need to examine
    a special flag to see if the arguments were reversed.
    For much more about multiple dispatch, see S12.
Syntax
    There is no longer any special "use overload" syntax separate from the
    declarations of the "multi" routines themselves. To overload an existing
    built-in sub, say something like:
        multi sub uc (TurkishStr $s) {...}
    A "multi" is automatically exported if governed by a proto that is
    exported. It may also be explicitly exported:
        multi sub uc (TurkishStr $s) is export {...}
    Now if you call "uc()" on any Turkish string, it will call your function
    rather than the built-in one.
    If you import a multi into a UNIT scope, it is automatically
    re-exported.
    The types of the parameters are included in the *longname* of any
    "multi" sub or method. So if you want to overload string concatenation
    for Arabic strings so you can handle various ligatures, you can say:
        multi sub infix:<~>(ArabicStr $s1, ArabicStr $s2) {...}
        multi sub infix:<~>(Str $s1, ArabicStr $s2) {...}
        multi sub infix:<~>(ArabicStr $s1, Str $s2) {...}
    The "use overload" syntax had one benefit over Perl 6's syntax in that
    it was easy to alias several different operators to the same service
    routine. This can easily be handled with Perl 6's aliasing:
        multi sub unimpl (MyFoo $x, MyFoo $y) { upchuck(); }
        &infix:<+> ::= &unimpl;
        &infix:<-> ::= &unimpl;
        &infix:<*> ::= &unimpl;
        &infix:</> ::= &unimpl;
    A "multi" is in effect only within the scope in which it is defined or
    imported. Generally you want to put your "multi" subs into a package
    that will be imported wherever they are needed.
    Conjectural: If the first parameter to a "multi" signature is followed
    by an invocant colon, that signature represents two signatures, one for
    an ordinary method definition, and one for the corresponding "multi"
    definition that has a comma instead of the colon. This form is legal
    only where the standard method definition would be legal, and only if
    any declared type of the first parameter is consistent with "$?CLASS".
Fallbacks
    Dispatch is based on a routine's signature declaration without regard to
    whether the routine is defined yet. If an attempt is made to dispatch to
    a declared but undefined routine, Perl will redispatch to an "AUTODEF"
    submethod [conjectural] as appropriate to define the routine. This
    provides a run-time mechanism for fallbacks. By default, these
    declarations are taken at face value and do not specify any underlying
    semantics. As such, they're a "shallow" interpretation.
    [Note: the following section on "is deep" may no longer be necessary
    given the way metaoperators are now constructed.]
    However, sometimes you want to specify a "deep" interpretation of your
    operators. That is, you're specifying the abstract operation, which may
    be used by various shallow operators. Any deep multi declarations will
    be "amplified" into all the shallow operators that can be logically
    based on it. If you say:
        multi sub infix:<%> (Us $us, Them $them) is deep { mymod($us,$them) }
    then
        multi sub infix:<%=> (Us $us, Them $them) { $us = $us % $them }
    is also generated for you (unless you define it yourself). The mappings
    of magical names to sub definitions is controlled by the "%?DEEPMAGIC"
    compiler hash. Pragmas can influence the contents of this hash over a
    lexical scope, so you could have different policies on magical
    autogeneration. The default mappings correspond to the standard fallback
    mappings of Perl 5 overloading.
    These deep mappings are mainly intended for infix operators that would
    have difficulty naming all their variants. Prefix operators tend to be
    simpler; note in particular that
        multi prefix:<~> is deep {...}
    is better written:
        method Stringy {...}
    (see below).
Type Casting
    A class may define methods that allow it to respond as if it were a
    routine, array, or hash. The long forms are as follows:
        method postcircumfix:<( )> (|capture) {...}
        method postcircumfix:<[ ]> (**@slice) {...}
        method postcircumfix:<{ }> (**@slice) {...}
    Those are a bit unwieldy, so you may also use these short forms:
        method &.( |capture ) {...}
        method @.[ **@slice ] {...}
        method %.{ **@slice } {...}
    The sigil-dot sequence in these short forms autogenerates the
    corresponding public operators, in exactly the same way that the
    sigil-dot in:
        has $.action;
        has @.sequence;
        has %.mapping;
    autogenerates public accessor methods.
    And because it uses the same method-autogeneration mechanism, the
    specific sigil used to specify a short-form postcircumfix operator
    doesn't actually matter...as long as it's followed by a dot and the
    bracket pair containing the signature. (Though it's probably kinder to
    future readers of your code to stick with the "natural" sigil for each
    type of bracket.)
    Note that the angle bracket subscripting form ".<a b c>" automatically
    translates itself into a call to " .{'a','b','c'} ", so defining methods
    for angles is basically useless.
    The expected semantics of "&.()" is that of a type on which may or may
    not create a new object. So if you say:
        $fido = Dog.new($spot)
    it certainly creates a new "Dog" object. But if you say:
        $fido = Dog($spot)
    it might call "Dog.new", or it might pull a "Dog" with Spot's identity
    from the dog cache, or it might do absolutely nothing if $spot already
    knows how to be a "Dog". As a fallback, if no method responds to a
    coercion request, the class will be asked to attempt to do
    "Dog.new($spot)" instead.
    It is also possible (and often preferable) to specify coercions from the
    other end, that is, for a class to specify how to coerce one of its
    values to some other class. So, if you define a method whose name
    happens to be type name, you can view it as a coercion to that type. But
    that method is a regular method even its name happens to be a type name.
    That means the compiler does not enforce the type of the returned value.
        method Str { self.makestringval() }
    As with all methods, you can also export the corresponding "multi":
        multi method Str is export { self.makestringval() }
    in which case you can use both calling forms:
        $x.Str
        Str($x)
    If the source class and the destination class both specify a coercion
    routine, the ambiguity is settled by the ordinary rules of dispatch.
    That is, "$x.Str" will always prefer the method form and "Str($x)" will
    always prefer the functional form.
    Note that, because the name of an anonymous class is unknown, coercion
    to an anonymous class can only be specified by the destination class:
        $someclass = generate_class();
        $someclass($x);
    Synopsis 14: Roles and Parametric Types [DRAFT]
        Created: 24 Feb 2009 (extracted from S12-objects.pod)
        Last Modified: 24 Nov 2012
        Version: 11
    This synopsis discusses roles and parametric types, which were
    originally discussed in A12.
    Classes are primarily in charge of object management, and only
    secondarily in charge of software reuse. In Perl 6, roles take over the
    job of managing software reuse. Depending on how you care to look at it,
    a role is like a partial class, or an interface with default
    implementation, or a set of generic methods and their associated data,
    or a class closed at compile time.
    Roles may be composed into a class at compile time, in which case you
    get automatic detection of conflicting methods. A role may also be mixed
    into a class or object at run time to produce an anonymous derived class
    with extra capabilities, but in this case conflicting methods are
    overridden by the new role silently. In either case, a class is
    necessary for instantiation--a role may not be directly instantiated.
    A role is declared like a class, but with a "role" keyword:
        role Pet {
            method feed ($food) {
                $food.open_can;
                $food.put_in_bowl;
                self.eat($food);
    A role may not inherit from a class, but may be composed of other roles.
    However, this "crony" composition is not evaluated until class
    composition time. This means that if two roles bring in the same crony,
    there's no conflict--it's just as if the class pulled in the crony role
    itself and the respective roles didn't. A role may never conflict with
    itself regardless of its method of incorporation. A role that brings in
    two conflicting crony roles *may* resolve them as if it were a class.
    This solution is accepted by the class unless the class supplies its own
    solution. If two different roles resolve the same crony conflict two
    different ways, those roles are themselves in conflict and must be
    resolved by a "more derived" role or the class.
    A role doesn't know its own type until it is composed into a class. Any
    mention of its main type (such as "::?CLASS") is generic, as is any
    reference to "self" or the type of the invocant. You can use a role name
    as a type, but only for constraints, not for declaring actual objects.
    (However, if you use a role as if it were a class, an anonymous class is
    generated that composes the role, which provides a way to force a role
    to test its crony composition for infelicities.)
    If a role merely declares methods without defining them, it degenerates
    to an interface:
            method feed ($food) {...}
            method groom () {...}
            method scratch (:$where) {...}
    Note that, while these methods must become available at class
    composition time, they might be supplied by any of: another role, the
    class itself, or some superclass. We know the methods that are coming
    from the other roles or the class, but we don't necessarily know the
    complete set of methods supplied by our super classes if they are open
    or rely on wildcard delegation. However, the class composer is allowed
    to assume that only currently declared superclass methods or
    non-wildcard methods are going to be available. A stub can always be
    installed somewhere to "supply" a missing method's declaration.
    Roles may have attributes:
            has $.collar = Collar.new(tag => Tag.new);
            method id () { return $.collar.tag }
            method lose_collar () { undefine $.collar }
    Within a role the "has" declarator always indicates the declaration from
    the viewpoint of the class. Therefore a private attribute declared using
    "has" is private to the class, not to the role. You may wish to declare
    an attribute that is hidden even from the class; a completely private
    role attribute (that will exist per instance of the class) may be
    declared like this:
        my $!spleen;
    The name of such a private attribute is always considered lexically
    scoped. If a role declares private lexical items, those items are
    private to the role due to the nature of lexical scoping. Accessors to
    such items may be exported to the class, but this is not the default. In
    particular, a role may say
        trusts ::?Class;
    to allow "self!attr()" access to the role's "$!attr" variables with the
    class or from other roles composed into the class. Conflicts between
    private accessors are also caught at composition time, but of course
    need not consider super classes, since no-one outside the current class
    (or a trusted class) can call a private accessor at all. (Private
    accessors are never virtual, and must be package qualified if called
    from a trusted scope other than our own. That is, it's either
    "self!attr()" or "$obj!TrustsMe::attr().")
    A role may also distinguish a shared method
        has method foo ...
        method foo ...      # same
    from a nonshared private method:
        my method !foo ...
        my method foo ...   # same, but &foo is aliased to &!foo
    Generally you'd just use a lexically scoped sub, though.
        my sub foo ...
    A role can abstract the decision to delegate:
            has $groomer handles <bathe groom trim> = hire_groomer();
    Note that this puts the three methods into the class as well as
    $groomer. In contrast, ""my $!groomer"" would only put the three
    methods; the attribute itself is private to the role.
    A role is allowed to declare an additional inheritance for its class
    when that is considered an implementation detail:
            also is Friend;
  Compile-time Composition
    A class incorporates a role with the verb "does", like this:
        class Dog is Mammal does Pet does Sentry {...}
    or equivalently, within the body of the class closure:
            also does Sentry;
            also is Mammal does Pet does Sentry;
    There is no ordering dependency among the roles.
    A class's explicit method definition hides any role definition of the
    same name. A role method in turn hides any methods inherited from other
    classes.
    If there are no method name conflicts between roles (or with the class),
    then each role's methods can be installed in the class. If, however, two
    roles try to introduce a method of the same name the composition of the
    class fails. (Two "has" attributes of the same name, whether public or
    private, are always a composition fail. Role-private attributes are
    exempt from this, and from the viewpoint of the composition, don't even
    exist, except to allocate a slot for each such attribute.)
    There are several ways to solve method conflicts. The first is simply to
    write a class method that overrides the conflicting role methods,
    perhaps figuring out which role method to call.
    Alternately, if the role's methods are declared "multi", they can be
    disambiguated based on their long name. If the roles forget to declare
    them as multi, you can force a multi on the roles' methods by installing
    a proto stub in the class being constructed:
        proto method shake {...}
    (This declaration need not precede the "does" clause textually, since
    roles are not actually composed until the end of the class definition,
    at which point we know which roles are to be composed together in a
    single logical operation, as well as how the class intends to override
    the roles.)
    The proto method will be called if the multi fails:
        proto method shake { warn "They couldn't decide" }
  Run-time Mixins
    Run-time mixins are done with "does" and "but". The "does" binary
    operator is a mutator that derives a new anonymous class (if necessary)
    and binds the object to it:
        $fido does Sentry
    The "does" infix operator is non-associative, so this is a syntax error:
        $fido does Sentry does Tricks does TailChasing does Scratch;
    You can, however, say
        $fido does Sentry;
        $fido does Tricks;
        $fido does TailChasing;
        $fido does Scratch;
    And since it returns the left side, you can also say:
        ((($fido does Sentry) does Tricks) does TailChasing) does Scratch;
    Unlike the compile-time role composition, each of these layers on a new
    mixin with a new level of inheritance, creating a new anonymous class
    for dear old Fido, so that a ".chase" method from "TailChasing" hides a
    ".chase" method from "Sentry".
    You can also mixin a precomposed set of roles:
        $fido does (Sentry, Tricks, TailChasing, Scratch);
    This will level the playing field for collisions among the new set of
    roles, and guarantees the creation of no more than one more anonymous
    class. Such a role still can't conflict with itself, but it can hide its
    previous methods in the parent class, and the calculation of what
    conflicts is done again for the set of roles being mixed in. If you
    can't do compile-time composition, we strongly recommend this approach
    for run-time mixins since it approximates a compile-time composition at
    least for the new roles involved.
    A role applied with "does" may be parameterized with an initializer in
    parentheses, but only if the role supplies exactly one attribute to the
    mixin class:
        $fido does Wag($tail);
        $line does taint($istainted);
    Note that the parenthesized form is *not* a subroutine or method call.
    It's just special initializing syntax for roles that contain a single
    property.
    The supplied initializer will be coerced to the type of the attribute.
    Note that this initializer is in addition to any parametric type
    supplied in square brackets, which is considered part of the actual type
        $myobj does Array[Int](@initial)
    A property is defined by a role like this:
        role answer {
            has Int $.answer is rw = 1;
    The property can then be mixed in or, alternatively, applied using the
    "but" operator. "but" is like "does", but creates a copy and mixes into
    that instead, leaving the original unmodified. Thus:
        $a = 0 but answer(42)
    Really means something like:
        $a = ($anonymous = 0) does answer(42);
    Which really means:
        (($anonymous = 0) does answer).answer = 42;
        $a = $anonymous;
    Which is why there's a "but" operator.
    If you put something that is not a role on the right hand side of the
    "does" or "but" operators then an anonymous role will be auto-generated
    containing a single method that returns that value. The name of the
    method is determined by doing .WHAT.perl on the value supplied on the
    RHS. The generated role is then mixed in to the object. For example:
        $x does 42
    Is equivalent to:
        $x does role { method Int() { return 42 } }
    Note that the role has no attributes and thus no storage; if you want
    that, then you should instead use:
        $x does Int(42)
    Which mixes in the Int role and initializes the single storage location
    Int that it declares with 42, and provides an lvalue accessor.
    Note that .WHAT on an enumeration value stringifies to the name of the
    enumeration, and as a result:
        0 but True
        0 but role { method Bool() { return True } }
    And thus the resulting value will be considered true in boolean context.
    The list syntax for composing multiple roles in a single "does" or "but"
    by putting them in a list also applies here. Thus:
        42 but ("the answer", False)
        42 but (role { method Str() { return "the answer" } },
                role { method Bool() { return False } })
    Which gives you a compact way to build context-sensitive return values.
    Note that multiple roles rather than a single one are generated, so that
    anything like:
        42 but (True, False)
    Will fail as a result of standard role composition semantics (because
    two roles are both trying to provide a method Bool).
Traits
    Traits are just properties (roles) applied to something that is being
    declared (the *declarand*), such as containers or classes. It's the
    declaration of the item itself that makes traits seem more permanent
    than ordinary properties. In addition to adding the property, a trait
    can also have side effects.
    Traits are generally applied with the "is" keyword, though not always.
    To define a trait handler for an "is xxx" trait, define one or more
    multisubs into a property role like this:
        role xxx {
            has Int $.xxx;
            multi trait_mod:<is>(::?CLASS:U $declarand, :$xxx!) {...}
            multi trait_mod:<is>(Any $declarand, :$xxx!) {...}
    Then it can function as a trait. A well-behaved trait handler will say
        $declarand does xxx($arg);
    somewhere inside to set the metadata on the declarand correctly. Since a
    class can function as a role when it comes to parameter type matching,
    you can also say:
        class MyBase {
            multi trait_mod:<is>(MyBase:U $declarand, MyBase $base) {...}
            multi trait_mod:<is>(Any $declarand, MyBase $tied) {...}
    These capture control if "MyBase" wants to capture control of how it
    gets used by any class or container. But usually you can just let it
    call the generic defaults:
        multi trait_mod:<is>(Any:U $declarand, $base) {...}
    which adds $base to the "isa" list of class $declarand, or
        multi trait_mod:<is>(Any $declarand, $tied) {...}
    which sets the "tie" type of the container declarand to the
    implementation type in $tied.
    Most traits are really just adverbial pairs which, instead of being
    introduced by a colon, are introduced by a (hopefully) more readable
    "helping verb", which could be something like ""is"", or ""will"", or
    ""can"", or ""might"", or ""should"", or ""does"". Any trait verb that
    is parsed the same as trait_mod:<is> may be defined the same way. Here's
    ""will"", which (being syntactic sugar) merely delegates to back to
    "is":
        multi sub trait_mod:<will>($declarand, :$trait) {
            trait_mod:<is>($declarand, :$trait);
    Other traits are applied with a single word, and require special
    parsing. For instance, the ""of"" trait is defined something like this:
        role of {
            has ReturnType $.of;
            multi sub trait_mod:<of>($declarand, ReturnType $arg) is parsed /<typename>/ {
                $declarand does of($arg);
    Unlike compile-time roles, which all flatten out in the same class,
    compile-time traits are applied one at a time, like mixin roles. You
    can, in fact, apply a trait to an object at run time, but if you do,
    it's just an ordinary mixin role. You have to call the appropriate
    "trait_mod:<is"()> routine yourself if you want it to do any extra
    shenanigans. The compiler won't call it for you at run time like it
    would at compile time.
    Note that the declarations above are insufficient to install new trait
    auxiliaries or verbs into the user's grammar, since macro definitions
    are lexically scoped, and in the declarations above extend only to the
    end of the role definition. The user's lexical scope must somehow have
    processed (or imported) a proto declaration introducing the new syntax
    before it can be parsed correctly. (This doesn't apply to pre-existing
    syntax such as "is", of course.)
    Calls to "trait_mod" routines are evaluated in sink context.
Parametric Roles
    A role's main type is generic by default, but you can also parameterize
    other types explicitly using type parameters:
        role Pet[::Petfood = TableScraps] {
            method feed (Petfood $food) {...}
    (Note that in this case you must not use ::Petfood in the inner
    declaration, or it would rebind the type to type of the actual food
    parameter.)
    If you want to parameterize the initial value of a role attribute, be
    sure to put a double semicolon if you don't want the parameter to be
    considered part of the long name:
        role Pet[::ID;; $tag] {
            has ID $.collar .= new($tag);
    You don't just have to parameterize on types; any value is fine. Imagine
    we wanted to factor out a "greet" method into a role, which takes
    somebody's name and greets them. We can parameterize it on the greeting.
        role Greet[Str $greeting] {
            method greet() { say "$greeting!"; }
        class EnglishMan does Greet["Hello"] { }
        class Slovak does Greet["Ahoj"] { }
        class Lolcat does Greet["OH HAI"] { }
        EnglishMan.new.greet(); # Hello
        Slovak.new.greet(); # Ahoj
        Lolcat.new.greet(); # OH HAI
    Similarly, we could do a role for requests.
        role Request[Str $statement] {
            method request($object) { say "$statement $object?"; }
        class EnglishMan does Request["Please can I have a"] { }
        class Slovak does Request["Prosim si"] { }
        class Lolcat does Request["I CAN HAZ"] { }
        EnglishMan.new.request("yorkshire pudding");
        Slovak.new.request("borovicka");
        Lolcat.new.request("CHEEZEBURGER");
    Sadly, the Slovak output sucks here. Borovicka is the nominative form of
    the word, and we need to decline it into the accusative case. But some
    languages don't care about that, and we don't want to have to make them
    all supply a transform. Thankfully, you can write many roles with the
    same short name, and a different signature, and multi-dispatch will pick
    the right one for you (it is the exact same dispatch algorithm used by
    multi-subs). So we can write:
        role Request[Str $statement, &transform] {
            method request($object) {
                say "$statement " ~ transform($object) ~ "?";
        module Language::Slovak {
            sub accusative($nom) {
                # ...and before some smartass points it out, I know
                # I'm missing some of the masculine animate declension...
                return $nom.subst(/a$/, 'u');
        class Slovak does Request["Prosim si", &Language::Slovak::accusative] { }
    Which means we can now properly order our borovicka in Slovakia, which
    is awesome. Until you do it in a loop and find the Headache['very bad']
    role got mixed into yourself overnight, anyway...
  Relationship Between of And Types
    The of keyword is just syntactic sugar for providing a single parameter
    to a parametric type. Thus:
        my Array of Recipe %book;
    Actually means:
        my Array[Recipe] %book;
    This can be nested, so:
        my Hash of Array of Recipe @library;
    Is just:
        my Hash[Array[Recipe]] @library;
    Therefore:
        my Array @array;
    Means an Array of Array (actually, a Positional of Array).
  Parametric Subtyping
    If you have two types in a subtyping relationship such that T1 is
    narrower than T2, then also the roles:
        role R[::T] { }
        role R[::T1, ::T2] { }
    Will act such that R[T1] is narrower than R[T2]. This extends to
    multiple parameters, however they must all be narrower or the same (this
    is unlike in multiple dispatch where you can have one narrower and the
    rest narrower or tied). That is, assuming we have some unrelated type
    T3, then R[T2, T1] is narrower than R[T1,T1] but R[T2,T1] is not
    narrower than R[T1,T3].
    Nesting follows naturally from this definition, so a role R[R[T2]] is
    narrower than a role R[R[T1]].
    This all means that, for example, if you have a sub:
        sub f(Num @arr) { ... }
    Then you can also call it with an array of Int.
        my Int @a = 1,2,3;
        f(@a);
  The structure of role types and packages
    When a role is declared:
        role Foo { }
    Then the symbol `Foo` that gets installed in the enclosing package
    represents a potential group of roles that will be disambiguated by
    arguments. A later declaration:
        role Foo[::T] { }
    Adds to the existing group. The "::?PACKAGE" inside of each of these is
    therefore something different from Foo itself. The group's meta-object
    type is "ParametricRoleGroupHOW", while "ParametricRoleHOW" is the
    meta-object type for individual parametric roles.
    Writing "Foo[Int]" is not sufficient to concretize a role, because that
    needs the target class; therefore this returns a type with the
    meta-object "CurriedRoleHOW" that will pass along the extra type
    parameters at the point of composition, to aid selection of the correct
    parametric variant. Therefore, it does not address a particular
    "ParametricRoleHOW".
    Normal users of Perl 6 will have to care little for these details.
    However, given that any "our" scoped symbol declared inside of a role
    body will end up in a package that is simply unaddressable without
    digging into the meta-objects, "our" declarations in a role are
    forbidden. This does not prevent installation directly into
    "::?PACKAGE.WHO", for expert users who want the escape hatch. It simply
    means syntactic "our" declarations will be forbidden to avoid the
    inevitable confusion that will result from trying to access them.
  Interaction of typed and untyped data structures
    Certainly so far as Perl 6.0.0 goes, only types that have been declared
    on a container count in the type check. That is, if we have a sub:
        sub f(Int @arr) { ... }
    And call it with any of:
        f([1,2,3]);
        my @a = 1,2,3;
    Then neither of these calls will work. The type check is based on the
    declared type of the array, and the content is unknown to the type
    checker.
    DRAFT: Synopsis 16: IO / Name Services
        Created: 12 Sep 2006
        Last Modified: 19 Nov 2009
    This is a draft document. Many of these functions will work as in Perl
    5, except we're trying to rationalize everything into roles. For now you
    can assume most of the important functions will automatically be in the
    * namespace. However, with IO operations in particular, many of them are
    really methods on an IO handle, and if there is a corresponding global
    function, it's merely an exported version of the method.
IO
  Overridable IO handles
    In Perl 6, there are the *standard* IO handles, and any number of
    overriding inner filehandles for the same symbol.
    The *standard* handles are our old familiar friends (with new names).
    Standard input changed from STDIN to $*IN, standard output changed from
    STDOUT to $*OUT, and standard error changed from STDERR to $*ERR. In
    Perl 6 these symbols represent more of a concept than a given
    filehandle, since the meaning is contextually determined. The process's
    version of these handles live in the "PROCESS::" namespace, which is
    more global than the per-interpreter "GLOBAL::" namespace.
    When no explicit filehandle is used, the standard IO operators are
    defined in terms of the dynamic variables. So the "print" function
    prints to $*OUT, while "warn" warns to $*ERR. The "lines()" term inputs
    from $*ARGFILES which defaults to $*IN in the absence of any filenames.
    So any given dynamic scope (interpreter, thread, function or method
    call) may redefine the current meaning of any of those filehandles
    within the dynamic scope of itself and of its called routines.
    So to put it another way, when you write something like
        say "Howdy, world!"
    the "say" function looks for the current meaning of $*OUT, and takes the
    closest definition it can find in its callers. If none of the callers
    have overridden the definition, it looks in the interpreter's "GLOBAL"
    namespace. If the interpreter hasn't overridden the meaning, it takes
    the meaning from "PROCESS". In essence, any dynamic scope in Perl 6 is
    allowed to do IO redirection much like a Unix shell does with its
    subprocesses, albeit with a different syntax:
            temp $*OUT = open $newfile, :w;
            foo() # all stdout goes to $newfile
        # stdout reverts to outer scope's definition
  Roles and Classes
    The roles and classes that define most of the functionality for IO are
    defined in S32-setting-library/IO.pod. The main functions used are
    listed in S29 with references to S32-setting-library/IO.pod.
  Special Quoting Syntax
    The use of filenames requires a special quoting syntax. It works as
        qp{/path/to/file}
        q:p{/path/to/file}
    Both of the above result in the same "IO::Path" object.
    The quote characters can be any of the usual ones, although / is
    probably a bad choice for filenames.
    The code shown above returns a Path object (or a descendant thereof).
    Naturally you can also ask for interpolation in filenames:
        qp:qq{$directory/$file}
        qq:p{$directory/$file}
    There are a number of special adverbs that can be applied to the file
    quoting operator. Most of these are filesystem-specific. They confine
    what can be included in a filename.
    Any path that starts with a "/" is considered an absolute path,
    otherwise the path is considered relative.
    When creating a path with qp{}, the Path.Encoding attribute is set to
    $?ENC, unless the :bin modifier (see below) is used.
   Default constraints
    The default constraints can be set with the "use path" pragma, for
        use path :posix;
        use path :modern;
        use path :local;
    The default when in strict mode is "use path :posix", whereas the
    default in lax mode is "use path :local".
   :posix constraints
    The :modern set of constraints paths are portable POSIX paths (see
    POSIX.1-2008 sections 4.7 and 3.276). If platform/filesystem specific
    behavior is needed, specific constraints should be applied as needed
    The default constraints are to only allow "/" as separator and only
    allows portable POSIX filenames. That means A-Z, a-z, 0-9, <period>,
    <underscore>, and <hyphen>. Additionally, hyphen may not be the first
    character in the path.
   :portable
    In addition to the POSIX constraints above, the path should fit into 8
    characters, followed by a full stop, and then three more characters.
    Only the one full stop should appear in the filename. Additionally, no
    path may be longer than 64 characters.
   :local
    This is :win on a Windows platform, :unix on a Unix platform, etc. Note
    that this is specifically not portable between platforms with different
    constraint sets.
   :modern constraints
    The :modern set of constraints are the same as :posix, except that they
    may contain any UTF-8 character, rather than just those listed.
   :win constraints
    We allow Windows style paths so converting and maintaining code on this
    platform is not a pain.
    my Path $path = p:win{C:\Program Files\MS Access\file.file};
    Note that this specifically excludes the backslash quoting usually used
    with q{}.
   :unix constraints
    For Unix specific behavior we have a p:unix{} literal. Here the only
    limits are what is defined by the locale and the filesystem type. So we
    won't be able to write full Unicode if locale is set to Latin1.
    my Path $path = p:unix{/usr/src/bla/myfile?:%.file};
   :bin constraints (no constraints at all)
    If the above are causing problems, p:bin{} can be used as no checking is
    done here. However, this leaves the Path.Encoding attribute undefined,
    which means that certain features of Path will remain unavailable unless
    this attribute is set.
   Other constraints
    It is expected that other sets of constraints, such as VMS, DOS, and
    old-style Mac will be provided by modules.
  $*CWD
    The global variable $*CWD is a "IO::Path" object with certain special
    properties, mainly:
     * It must check whether the path exists before changing its value
     * It can only be assigned an absolute path; if you want to make relative
       changes, use the Array interface with .push and .pop
    $*CWD is specific to the current thread, unlike "%*ENV<PATH>" or the
    native getcwd/chdir path, which are both usually process-wide.
    The variable is used in at least these cases:
     * When a IO::Path object is created, if the string it is given is not an
       absolute path, then $*CWD is prepended to it.
     * When a subprocess is executed, it is executed with the current
       thread's $*CWD as its working directory.
  $*TMPDIR
    The global variable $*TMPDIR is an IO::Path object which points to the
    system's temporary directory. It will check the usual places such a
    "%*ENV<TMPDIR>", "/tmp", "C:\Windows\temp", etc (depending on the OS)
    for a writable directory. If a writable directory isn't found, it is set
    to $*CWD.
Name Services
  User role
        role User {
            has $username; # Username (some descendants(?) may want to implement a real $name)
            has $id;  # User ID
            has $dir; # Home directory for files
            method User new($Username?, $UID?) {...}
        Creates a new User object, fetching the information either by
        username or user ID.
            method write() {...}
        Tries to write the current User object to the user database. This
        may well fail.
    Str When converted to a Str, returns $username.
    Num When converted to a Num, returns $uid.
  OS::Unix::User role
        role OS::Unix::User does User {
            has $password;
            has $gid;
            has $gecos;
            has $shell;
    All the information is naturally fetched from the system via getpwuid,
    getpwnam, or the like.
  Group role
        role Group {
            has $name;
            has $id;
            has @members;
            method Group new(:$Name, :$ID);
            method write();
        Tries to write the group entry into the system group database.
  OS::Unix::NameServices role
    The NameServices role has a bunch of functions that between them will
    return the whole Name Services database between them, as lists of
    objects. The lists are specifically intended to be lazy.
        role NameServices {
            method List of User     users()     {...} # getpwent, setpwent, endpwent
            method List of Group    groups()    {...} # getgrent, setgrent, endgrent
            method List of Service  services()  {...} # getservent, setservent, endservent
            method List of Protocol protocols() {...} # getprotoent, setprotoent, endprotoent
            method List of Network  networks()  {...} # getnetent, setnetent, endnetent
            method List of Host     hosts()     {...} # gethostent, sethostent, endhostent
        Largely, the authors of the related Perl 5 docs.
    Synopsis 16: I/O
        Last Modified: 5 Nov 2014
        Version: 28
    Many of these functions will work as in Perl 5, except we're trying to
    rationalize everything into roles. For now you can assume most of the
    important functions will automatically be in the * namespace. However,
    with IO operations in particular, many of them are really methods on an
    IO handle, and if there is a corresponding global function, it's merely
    an exported version of the method.
    defined in terms of the dynamic variables. So the "say" function prints
    to $*OUT, while "note" prints to $*ERR. The "lines()" term inputs from
    $*ARGFILES which defaults to $*IN in the absence of any filenames. So
    any given dynamic scope (interpreter, thread, function or method call)
    may redefine the current meaning of any of those filehandles within the
    dynamic scope of itself and of its called routines.
      say "Howdy, world!"
          my $*OUT will leave *.close = open $newfile, :w;
          say "Written to $newfile";
      # stdout reverts to outer scope's definition, and closed the file
    In short:
        words     $*ARGFILES      read all words (Str)
  Path Names and the .IO coercer
    Path names are just strings ("Str"). Methods that return path names,
    will just return strings. As soon as you need to do manipulation on the
    path name (e.g. to find out its "basename" or "extension"), you can
    create an "IO::Path" object out of the string by applying the ".IO"
    coercer:
      my $path = $filename.IO;
    Then you can use any of the "IO::Path" methods, such as "open":
      my $handle = $newfile.IO.open(:w);
    Note that the "open()" sub, is just really syntactic sugar for the
      my $handle = open $newfile, :w;
  $*SPEC
    The current system's path semantics are encapsulated in $*SPEC dynamic
    variable. It adheres to the "IO::Spec" interface, and is automatically
    initialized for the current environment. But like any dynamic variable,
    can be overridden in a scope:
      { # Win32 path semantics in here
          my $*SPEC = IO::Spec::Win32;
          ...  # your code
      # original path semantics here again
    Please note that it does not need to be an instantiated object: the
    standard "IO::Spec" subclasses only provide class methods, and therefore
    do not need an instantiated object. But that could be different for a
    very specific third-party implementation of an "IO::Spec" class.
  $*CWD and chdir()
    The dynamic variable $*CWD is an "IO::Dir" object representing the
    current working directory. It is normally set with the "chdir()"
    function, which will check whether the specified path exists as a
    directory and is accessible ("-x").
      chdir($dir);  # sets $*CWD of scope, usually PROCESS::<$CWD>
    The "chdir()" function returns a "X::IO::Chdir" Failure if the path does
    not exist, or is not a directory, or is not accessible. Otherwise
    returns a newly created "IO::Dir" object (which will be "True").
    Please note that the path in $*CWD does not have any bearing on what the
    underlying operating system's concept of a "current directory". It is
    simply the path that will prepended before any implicit or explicit
    relative paths, and the default path that will be used when executing a
    sub-process.
    To be changing $*CWD just for a given scope, you can use "indir()":
      indir $dir, {
          ... your code in $dir ...
      };
      ... your code in $*CWD again ...
    or you can use "chdir()" with a temporary $*CWD:
          temp $*CWD = chddir($dir);
  $*TMPDIR and tmpdir()
    The dynamic variable $*TMPDIR is an "IO::Dir" object which points to the
    system's directory for temporary files. It can be set with the
    "tmpdir()" function which will check whether the specified path exists
    as a directory and has complete access ("+rwx").
      tmpdir($dir);  # sets $*TMPDIR of scope, usually PROCESS::<$TMPDIR>
    To set a locally scoped version of $*TMPDIR, you can use "tmpdir()" with
    a temporary $*TMPDIR:
          temp $*TMPDIR = $tmpdir($dir);
          ... your code with $*TMPDIR being $dir ...
      ... your code in original $*TMPDIR again ...
    It will return a newly created "IO::Dir" object (which is "True") or an
    appropriate "Failure".
    The initialization of $*TMPDIR at startup is set depending on the OS
    you're on.
  $*HOME and homedir()
    The dynamic variable $*HOME is an "IO::Dir" object which points to the
    user's home directory. It can be set with the "homedir()" function which
    will check whether the specified path exists as a directory and is
    completely accessible ("+rwx").
      homedir($dir);  # sets $*HOME of scope, usually PROCESS::<$HOME>
    To set a locally scoped version of $*HOME, you can use "homedir()" with
    a temporary $*HOME:
          temp $*HOME = homedir($dir);
          ... your code with $*HOME being $dir ...
      ... your code in original $*HOME again ...
    The initialization of $*HOME at startup is set depending on the OS
  System dependent path semantics and IO::Spec
    Each time an "IO::Path" object is created, the current $*SPEC will be
    encapsulated in the object, to be used for all path related operations.
    Of course, it is also possible to specify a specify a specific system's
    path semantics module when creating an "IO::Path" object with the
    ":SPEC" named parameter:
      my $SPEC = IO::Spec::Win32;
      my $path = $fileonNTFS.IO(:$SPEC);
      my $path = $fileonNTFS.IO(:SPEC<Win32>); # auto-expand to IO::Spec::Win32
  Functions and Classes
    The functions and classes that define most of the functionality for IO
    are more thoroughly defined in S32-setting-library/IO.pod. The main
    functions used are listed in S29 with references to
    S32-setting-library/IO.pod. An overview:
   Functions
      print(@text)                  # print text on $*OUT
      say(@text)                    # print text + newline on $*OUT
      note(@text)                   # print text + newline on $*ERR
      dd($a,$b,$c)                  # tiny data dumper on $*ERR
      $line = prompt($message)      # print message on $*OUT, obtain next line
      $handle = open($path)         # open a file, return IO::Handle
      @paths = dir                  # paths (as IO::Path) in $*CWD
      @paths = dir($dir)            # paths (as IO::Path) in $dir
      $contents = slurp($handle)    # read all that's left of an opened filehandle
      $contents = slurp($filename)  # read all from given filename
      spurt($handle,$contents)      # write $contents to $handle
      spurt($filename,$contents)    # write $contents to $filename
      mkdir($dir)                   # create a directory
      rmdir($dir)                   # remove a directory
      mkpath($path)                 # create directory and parents as appropriate
      chdir($dir)                   # set $*CWD
      temp $*CWD = chdir($dir)      # set $*CWD for the current scope
      indir($dir, { ... })          # execute code with temporary $*CWD
          ...
      tmpdir($dir)                  # set $*TMPDIR
      temp $*TMPDIR = tmpdir($dir)  # set $*TMPDIR for the current scope
      homedir($dir)                 # set $*HOME
      temp $*HOME = homedir($dir)   # set $*HOME for the current scope
      copy($from,$to)               # copy a file
      rename($from,$to)             # rename (move) a file on same physical storage
      move($from,$to)               # move (rename) a file to other storage
      unlink(*@files)               # remove one or more files
      chmod($permission,*@files)    # change permissions of one or more files
      link($target,$source)         # create a hard-link to a file
      symlink($target,$source)      # create a symbolic link to a file
   IO::Spec Class
    The "IO::Spec" itself only has one method: "select". It takes an OS
    descriptive name (usually something like what "$*DISTRO.name" gives) and
    returns the type object of the appropriate "IO::Spec" subclass.
      my $*SPEC = IO::Spec.select("MSWin32");  # gives IO::Spec::Win32
    Such a subclass should provide at least the following methods (in
    alphabetical order):
      abs2rel        convert an absolute path into a relative one
      canonpath      return a canonical version of the given path
      catdir         concatenate directories
      catpath        create a path from volume/directories/filename
      curdir         the path to the current directory (usually '.')
      curupdir       test for matching curdir|updir
      devnull        the path to the bit bucket (on Unixy systems '/dev/null')
      extension      the extension of the path
      is-absolute    whether the path is absolute
      join           create a path from hash with volume/directories/filename
      PATH           %ENV<PATH> interpreted as paths
      rel2abs        convert a relative path into an absolute one
      rootdir        the path to the root directory (on Unixy systems '/')
      split          split a path into volume/directories/filename in hash
      splitdir       split directories
      splitpath      split a path into volume/directories/filename as list
      tmpdir         path of the first writeable directory for temporary files
      updir          the path to the path directory (usually '..')
   IO::Path Class
      class IO::Path is Cool { }
    The official way to create an "IO::Path" object is with the "new"
    method. Apart from the "path" positional, it also takes optional ":SPEC"
    and "CWD" named parameters. The ".IO" coercer (which takes the same
    parameters as ".new") is the syntactic sugar that will most likely be
    used most often.
      my $io = $filename.IO;                  # current $*SPEC/$*CWD
      my $io = $filename.IO(:SPEC(*$SPEC));   # specific IO::SPEC
      my $io = $filename.IO(:SPEC(*$SPEC), :CWD($*CWD));
    which would be the same as:
      my $io = IO::Path.new($filename);
      my $io = IO::Path.new($filename, :SPEC(*$SPEC));
      my $io = IO::Path.new($filename, :SPEC(*$SPEC), :CWD($*CWD));
    If you only have filename components to start with, you can also create
    an "IO::Path" object with the ":volume", ":directory" and ":basename"
      my $io = IO::Path.new( :$volume, :$directory, :$basename );
    The following file test methods are provided:
      r          is readable by effective uid/gid
      w          is writable by effective uid/gid
      x          is executable by effective uid/gid
      o          is owned by effective uid
      R          is readable by real uid/gid
      W          is writable by real uid/gid
      X          is executable by real uid/gid
      O          is owned by real uid
      e          exists
      s          Size of the $!path of $io in bytes
      z          has zero size (an empty file)
      f          is a plain file
      d          is a directory
      l          is a symbolic link
      L          path of symbolic link (readlink)
      p          is a named pipe (FIFO)
      S          is a socket
      b          is a block special file
      c          is a character special file
      u          has setuid bit set
      g          has setgid bit set
      k          has sticky bit set
    can be fed the tests to be tried as a list of strings. The value
    This is mostly handy when passing file tests as parameters between
    routines and methods. From a performance point of view, direct use of
    the methods, like:
      if $io.f && $io.r && $io.w && $io.x && $io.s -> $size {
    or the smart match method:
      given $io {
          when :f :r :w :x {
              say "plain file with rwx of $_.s() bytes";
    is probably faster.
    These other methods are also provided (in alphabetical order):
      chdir          change $*CWD if directory
      child          append basename to path, return new object for that
      dir            files in path (if dir)
      directory      the directory part of the absolute path
      open           attempt to open file, return IO::Handle
      parent         remove last portion of path, return new object for that
      pipe           attempt to open a pipe, return IO::Pipe
      pred           previous logical path, return new object for that
      resolve        follow symlinks to the real path, return new object for that
      spurt          set the contents of the file
      succ           next logical path, return new object for that
   IO::Handle Class
      class IO::Handle does IO { }
    "open()" or "IO::Path.open". Nonetheless, you can create an "IO::Handle"
    object with just a path:
      my $handle = IO::Handle.new($filename);
      my $handle = IO::Handle.new($filename, :SPEC(*$SPEC));
      my $handle = IO::Handle.new($filename, :SPEC(*$SPEC), :CWD($*CWD));
    file has been ".close"d. The ".open" method does interact with the file
    system:
    It either returns True, or a "Failure" with additional information.
    The other methods of the "IO::Handle" class are only valid after the
    ".open" has been called successfully:
      close          close file handle, flush buffers
      encoding       set/return encoding of file handle
      eof            file pointer reached end of file
      fileno         file descriptor (usually a native integer)
      flush          flush buffers
      get            get next line from file
      getc           get next character from file
      ins            number of lines read
      IO             return new IO::Path of path of file
      lines          return rest of contents of file as lines
      opened         is the file open?
      p              the handle is a pipe
      path           the IO::Path of path of file, handles file tests
      print          write characters to file
      read           read bytes from file
      say            write characters + newline to file
      seek           move file pointer to given position
      slurp          return rest of contents of file
      t              is the file a TTY (as a person looking?)
      tell           return position of file pointer
      words          return rest of contents of file as words
      write          write bytes to file
   Interplay between Roles and Classes
    These classes and roles may cache and share pertinent information for
    better performance.
    Synopsis 17: Concurrency
        Created: 3 Nov 2013
        Last Modified: 27 December 2014
        Version: 25
    This synopsis is based around the concurrency primitives and tools
    currently being implemented in Rakudo on MoarVM and the JVM. It covers
    both things that are already implemented today, in addition to things
    expected to be implemented in the near future (where "near" means
    O(months)).
Design Philosophy
  Focus on composability
    Perl 6 generally prefers constructs that compose well, enabling large
    problems to be solved by putting together solutions for lots of smaller
    problems. This also helps make it easier to extend and refactor code.
    Many common language features related to parallel and asynchronous
    programming lack composability. For example:
    *   Locks do not compose, since two independently correct operations
        using locks may deadlock when performed together.
    *   Callback-centric approaches tend to compose badly, with chains of
        asynchronous operations typically leading to deeply nested
        callbacks. This essentially is just leaving the programmer to do a
        CPS transform of their own logical view of the program by hand.
    *   Directly spawning threads on a per-component basis tends to compose
        badly, as when a dozen such components are used together the result
        is a high number of threads with no ability to centrally schedule or
        handle errors.
    In Perl 6, concurrency features aimed at typical language users should
    have good composability properties, both with themselves and also with
    other language features.
  Boundaries between synchronous and asynchronous should be explicit
    Asynchrony happens when we initiate an operation, then continue running
    our own idea of "next thing" without waiting for the operation to
    complete. This differs from synchronous programming, where calling a sub
    or method causes the caller to wait for a result before continuing.
    The vast majority of programmers are much more comfortable with
    synchrony, as in many senses it's the "normal thing". As soon as we have
    things taking place asynchronously, there is a need to coordinate the
    work, and doing so tends to be domain specific. Therefore, placing the
    programmer in an asynchronous situation when they didn't ask for it is
    likely to lead to confusion and bugs. We should try to make places where
    asynchrony happens clear.
    It's also worthwhile trying to make it easy to keep asynchronous things
    flowing asynchronously. While synchronous code is pull-y (for example,
    eating its way through iterable things, blocking for results),
    asynchronous code is push-y (results get pushed to things that know what
    to do next).
    Places where we go from synchronous to asynchronous, or from
    asynchronous to synchronous, are higher risk areas for bugs and
    potential bottlenecks. Thus, Perl 6 should try to provide features that
    help minimize the need to make such transitions.
  Implicit parallelism is OK
    Parallelism is primarily about taking something we could do serially and
    using multiple CPU cores in order to get to a result more quickly. This
    leads to a very nice property: a parallel solution to a problem should
    give the same answer as a serial solution.
    While under the hood there is asynchrony and the inherent coordination
    it requires, on the outside a problem solved using parallel programming
    is still, when taken as a whole, a single, synchronous operation.
    Elsewhere in the specification, Perl 6 provides several features that
    allow the programmer to indicate that parallelizing an operation will
    produce the same result as evaluating it serially:
    *   Hyper operators ("Hyper operators" in S03) express that parallel
        operator application is safe.
    *   Junctions ("Junctions" in S09) may auto-thread in parallel.
    *   Feeds ("Feed operators" in S06) form pipelines and express that the
        stages may be executed in parallel in a producer-consumer style
        relationship (though each stage is in itself not parallelized).
    *   "hyper" and "race" list operators ("The hyper operator" in S02)
        express that iteration may be done in parallel; this is a
        generalization of hyper operators.
  Make the hard things possible
    The easy things should be easy, and able to be built out of primitives
    that compose nicely. However, such things have to be built out of what
    VMs and operating systems provide: threads, atomic instructions (such as
    CAS), and concurrency control constructs such as mutexes and semaphores.
    Perl 6 is meant to last for decades, and the coming decades will
    doubtless bring new ways do do parallel and asynchronous programming
    that we do not have today. They will still, however, almost certainly
    need to be built out of what is available.
    Thus, the primitive things should be provided for those who need to work
    on such hard things. Perl 6 should not hide the existence of OS-level
    threads, or fail to provide access to lower level concurrency control
    constructs. However, they should be clearly documented as *not* the way
    to solve the majority of problems.
Schedulers
    Schedulers lie at the heart of all concurrency in Perl 6. While most
    users are unlikely to immediately encounter schedulers when starting to
    use Perl 6's concurrency features, many of them are implemented in terms
    of it. Thus, they will be described first here to avoid lots of forward
    references.
    A scheduler is something that does the "Scheduler" role. Its
    responsibility is taking code objects representing tasks that need to be
    performed and making sure they get run, as well as handling any
    time-related operations (such as, "run this code every second").
    The current default scheduler is available as $*SCHEDULER. If no such
    dynamic variable has been declared, then $PROCESS::SCHEDULER is used.
    This defaults to an instance of "ThreadPoolScheduler", which maintains a
    pool of threads and distributes scheduled work amongst them. Since the
    scheduler is dynamically scoped, this means that test scheduler modules
    can be developed that poke a $*SCHEDULER into "EXPORT", and then provide
    the test writer with control over time.
    The "cue" method takes a "Callable" object and schedules it.
        $*SCHEDULER.cue: { say "Golly, I got scheduled!" }
    Various options may be supplied as named arguments. (All references to
    time are taken to be in seconds, which may be fractional.) You may
    schedule an event to fire off after some number of seconds:
        $*SCHEDULER.cue: in=>10, { say "10s later" }
    or at a given absolute time, specified as an "Instant":
        $*SCHEDULER.cue: at=>$instant, { say "at $instant" }
    If a scheduled item dies, the scheduler will catch this exception and
    pass it to a "handle_uncaught" method, a default implementation of which
    is provided by the "Scheduler" role. This by default will report the
    exception and cause the entire application to terminate. However, it is
    possible to replace this:
        $*SCHEDULER.uncaught_handler = sub ($exception) {
            $logger.log_error($exception);
    For more fine-grained handling, it is possible to schedule code along
    with a code object to be invoked with the thrown exception if it dies:
        $*SCHEDULER.cue:
            { upload_progress($stuff) },
            catch => -> $ex { warn "Could not upload latest progress" }
    Use ":every" to schedule a task to run at a fixed interval, possibly
    with a delay before the first scheduling.
        # Every second, from now
        $*SCHEDULER.cue: :every(1), { say "Oh wow, a kangaroo!" };
        # Every 0.5s, but don't start for 2s.
        $*SCHEDULER.cue: { say "Kenya believe it?" }, :every(0.5), :in(2);
    Since this will cause the given task to be executed at the given
    interval ad infinitum, there are two ways to make sure the scheduling of
    the task is halted at a future time. The first is provided by specifying
    the ":times" parameter in the .cue:
        # Every second, from now, but only 42 times
        $*SCHEDULER.cue: :every(1), :times(42), { say "Oh wow, a kangaroo!" };
    The second is by specifying code that will be checked at the end of each
    interval. The task will be stopped as soon as it returns a True value.
    You can do this with the ":stop" parameter.
        # Every second, from now, until stopped
        my $stop;
        $*SCHEDULER.cue: :every(1), :stop({$stop}), { say "Oh wow, a kangaroo!" };
        sleep 10;
        $stop = True;  # task stopped after 10 seconds
    The ".cue" method returns a "Cancellation" object, which can also be
    used to stop a repeating cue:
        my $c = $*SCHEDULER.cue: :every(1), { say "Oh wow, a kangaroo!" };
        $c.cancel;  # task stopped after 10 seconds
    Schedulers also provide counts of the number of operations in various
    states:
        say $*SCHEDULER.loads;
    This returns, in order, the number of cues that are not yet runnable due
    to delays, the number of cues that are runnable but not yet assigned to
    a thread, and the number of cues that are now assigned to a thread (and
    presumably running). [Conjecture: perhaps these should be separate
    methods.]
    Schedulers may optionally provide further introspection in order to
    support tools such as debuggers.
    There is also a "CurrentThreadScheduler", which always schedules things
    on the current thread. It provides the same methods, just no
    concurrency, and any exceptions are thrown immediately. This is mostly
    useful for forcing synchrony in places that default to asynchrony. (Note
    that ".loads" can never return anything but 0 for the currently running
    cues, since they're waiting on the current thread to stop scheduling
    first!)
Promises
    A "Promise" is a synchronization primitive for an asynchronous piece of
    work that will produce a single result (thus keeping the promise) or
    fail in some way (thus breaking the promise).
    The simplest way to use a "Promise" is to create one:
        my $promise = Promise.new;
    And then later "keep" it:
        $promise.keep;      # True
        $promise.keep(42);  # a specific return value for kept Promise
    Or "break" it:
        $promise.break;                             # False
        $promise.break(X::Some::Problem.new);       # With exception
        $promise.break("I just couldn't do it");    # With message
    The current status of a "Promise" is available through the "status"
    method, which returns an element from the "PromiseStatus" enumeration.
        enum PromiseStatus (:Planned(0), :Kept(1), :Broken(2));
    The result itself can be obtained by calling "result". If the "Promise"
    was already kept, the result is immediately returned. If the "Promise"
    was broken then the exception that it was broken with is thrown. If the
    "Promise" is not yet kept or broken, then the caller will block until
    this happens.
    A "Promise" will boolify to whether the "Promise" is already kept or
    broken. There is also an "cause" method for extracting the exception
    from a "Broken" "Promise" rather than having it thrown.
        if $promise {
            if $promise.status == Kept {
                say "Kept, result = " ~ $promise.result;
                say "Broken because " ~ $promise.cause;
            say "Still working!";
    You can also simply use a switch:
        given $promise.status {
            when Planned { say "Still working!" }
            when Kept    { say "Kept, result = ", $promise.result }
            when Broken  { say "Broken because ", $promise.cause }
    There are various convenient "factory" methods on "Promise". The most
    common is "start".
        my $p = Promise.start(&do_hard_calculation);
    This creates a "Promise" that runs the supplied code, and calls "keep"
    with its result. If the code throws an exception, then "break" is called
    with the "Exception". Most of the time, however, the above is simply
        my $p = start {
            # code here
    Which is implemented by calling "Promise.start".
    There is also a method to create a "Promise" that is kept after a number
    of seconds, or at a specific time:
        my $kept_in_10s      = Promise.in(10);
        my $kept_in_duration = Promise.in($duration);
        my $kept_at_instant  = Promise.at($instant);
    The "result" is always "True" and such a "Promise" can never be broken.
    It is mostly useful for combining with other promises.
    There are also a couple of "Promise" combinators. The "anyof" combinator
    creates a "Promise" that is kept whenever any of the specified
    "Promise"s are kept. If the first promise to produce a result is instead
    broken, then the resulting "Promise" is also broken. The cause is passed
    along. When the "Promise" is kept, it has a "True" result.
        my $calc     = start { ... }
        my $timeout  = Promise.in(10);
        my $timecalc = Promise.anyof($calc, $timeout);
    There is also an "allof" combinator, which creates a "Promise" that will
    be kept when all of the specified "Promise"s are kept, or broken if any
    of them are broken.
    [Conjecture: there should be infix operators for these resembling the
    junctionals.]
    The "then" method on a "Promise" is used to request that a certain piece
    of code should be run, receiving the "Promise" as an argument, when the
    "Promise" is kept or broken. If the "Promise" is already kept or broken,
    the code is scheduled immediately. It is possible to call "then" more
    than once, and each time it returns a "Promise" representing the
    completion of both the original "Promise" as well as the code specified
    in "then".
        my $feedback_promise = $download_promise.then(-> $res {
            given $res.status {
                when Kept   { say "File $res.result().name() download" }
                when Broken { say "FAIL: $res.cause()"                 }
    [Conjecture: this needs better syntax to separate the "then" policies
    from the "else" policies (and from "catch" policies?), and to avoid a
    bunch of switch boilerplate. We already know the givens here...]
    One risk when working with "Promise"s is that another piece of code will
    sneak in and keep or break a "Promise" it should not. The notion of a
    promise is user-facing. To instead represent the promise from the
    viewpoint of the promiser, the various built-in "Promise" factory
    methods and combinators use "Promise::Vow" objects to represent that
    internal resolve to fulfill the promise. ("I have vowed to keep my
    promise to you.") The "vow" method on a "Promise" returns an object with
    "keep" and "break" methods. It can only be called once during a
    "Promise" object's lifetime. Since "keep" and "break" on the "Promise"
    itself just delegate to "self.vow.keep(...)" or "self.vow.break(...)",
    obtaining the vow before letting the "Promise" escape to the outside
    world is a way to take ownership of the right to keep or break it. For
    example, here is how the "Promise.in" factory is implemented:
        method in(Promise:U: $seconds, :$scheduler = $*SCHEDULER) {
            my $p = Promise.new(:$scheduler);
            my $v = $p.vow;
            $scheduler.cue: { $v.keep(True) }, :in($seconds);
            $p;
    The "await" function is used to wait for one or more "Promise"s to
    produce a result.
        my ($a, $b) = await $p1, $p2;
    This simply calls "result" on each of the "Promise"s, so any exception
    will be thrown.
Channels
    A "Channel" is essentially a concurrent queue. One or more threads can
    put values into the "Channel" using "send":
        my $c = Channel.new;
        $c.send($msg);
    The call to ".send" does not block.
    Meanwhile, other threads can ".receive" the values:
        my $msg = $c.receive;
    The ".receive" call does block. Alternatively, the ".poll" method takes
    a message from the channel if one is there or immediately returns "Nil"
    if nothing is there. Only one call to ".receive" or ".poll" returns per
    call of ".send", and which listening thread receives each value is left
    up to the implementation's scheduler.
    Channels are ideal for producer/consumer scenarios, and since there can
    be many senders and many receivers, they adapt well to scaling certain
    pipeline stages out over multiple workers also. [Conjectural: The two
    feed operators "==>" and "<==" are implemented using Channel to connect
    each of the stages.]
    A "Channel" may be "forever", but it is possible to close it to further
    sends by telling it to "close":
        $c.close();
    Trying to "send" any further messages on a closed channel will throw the
    "X::Channel::SendOnDone" exception. Closing a channel has no effect on
    the receiving end until all sent values have been received. At that
    point, any further calls to receive will throw
    "X::Channel::ReceiveOnDone". The "closed" method returns a "Promise"
    that is kept when a sender has called "close" and all sent messages have
    been received. Note that multiple calls to the same channel's "closed"
    method return the same promise, not a new one.
    Like ".close", calling ".fail" will close the channel. However this
    represents an abnormal termination, and so, the method must be provided
    an exception which should be thrown instead of
    "X::Channel::ReceiveOnDone".
    A "Promise" may be obtained from a "Channel" via the ".closed" method.
    This "Promise" will be kept when the "Channel" is closed or broken if it
    is failed.
    A "whenever" clause (described below) on a "Channel" will fire for each
    received value, and may also mark the whenever as "done" using the same
    criteria as ".closed", so it can also be used in order to write a
    reactor to receive from a channel until it is closed:
        react {
            whenever $channel {
                "Got a $_".say;
        "Done".say;
    A "whenever" clause on a "Channel" competes for values inside the
    scheduler alongside any ".receive" and ".poll" calls on that "Channel"
    from other threads. This also is true when the clause is part of a
    "supply" block (described below).
    A "Channel" in list context will iterate all received values lazily, and
    stop iterating when the channel is closed:
        for @$channel -> $val { ... }
        for $channel.list -> $val { ... }
    Note that this is not a combinator, but a means for transfering data
    from the reactive realm to the lazy realm. Some reasonable amount of
    buffering is assumed between the two. Just like all the above
    constructs, it competes for values in the scheduler against any other
    readers.
Supplies
    Channels are good for producer/consumer scenarios, but because each
    worker blocks on receive, it is not such an ideal construct for doing
    fine-grained processing of asynchronously produced streams of values.
    Additionally, there can only be one receiver for each value. Supplies
    exist to address both of these issues.
    A "Supply" pushes or pumps values to one or more receivers who have
    registered their interest, by (often indirecty) calling the ".tap"
    method on the "Supply". This returns a "Tap" object unique to the
    receiver, which one may then ".close" to tell the "Supply" that the
    receiver is no longer interested. Note that this does not happen
    automatically if the "Tap" is thrown away, as the "Supply" also keeps a
    reference to the "Tap". The ".tap" method takes up to three callables as
    arguments, one block and two optional named arguments:
        $supply.tap: -> $value { say "Got a $value" },
            done => { say "Reached the end" },
            quit => {
                when X::FooBar { die "Major oopsie" };
                default        { warn "Supply shut down early: $_" }
    The first unnamed closure is known as the "emit" closure. It is invoked
    whenever a value is emitted into the thing that has been tapped. The
    optional named parameter "done" specifies the code to be invoked when
    all expected values have been produced and no more values will be
    emitted. The optional named parameter "quit" specifies the code to be
    invoked if there is an error. This also means there will be no further
    For the same reasons that we have "Vow"s for "Promise"s, supplies are
    split into a "Supply" role and a "Supplier" role. The "Supplier" role
    has a ".Supply" method used to create a live "Supply", and "emit",
    "done", and "quit" methods which send the corresponding events to any
    "Supply" objects so created. A "Supplier" is not tapped directly. The
    "Supply" role does not have "emit", "done", or "quit" methods, and may
    be tapped. This allows the provider of a "Supply", if they so desire, to
    be sure that one user cannot inject data to other users of a "Supply".
    Multiple supplies may be created from a "Supplier", and all taps of all
    such supplies receive events sent using said "Supplier".
        my $e = Supplier.new;
        my $y = $e.Supply;
        my $t1 = $y.tap({ say $_ });
        $e.emit(1);                              # 1\n
        $e.emit(2);                              # 2\n
        my $t2 = $y.tap({ say 2 * $_ },
                  :done({ say "End"  }));
        $e.emit(3);                              # 3\n6\n
        $t1.close;
        $e.emit(4);                              # 8\n
        $e.done;                                 # End\n
    The above example demonstrates a simple "live" supply -- note that $t2
    missed events 1 and 2 because it was not listening at the time they
    happened. From an outside perspective, a live supply will behave as if
    it were alive and happily producing values even when it never had taps
    or all its taps have been closed:
        my $r = Supplier.new;
        my $z = $r.Supply;
        $r.emit("A tree fell in the woods");     #
    A more common type of supply is an *on-demand* supply, which creates
    multiple independent streams of events, starting a new stream each time
    it is tapped. Each "Tap" receives only the events emitted on its private
    stream. For example, the factory method "Supply.interval" produces a
    fresh timer with the appropriate interval each time it is tapped, each
    of which will stop emitting values when its corresponding "Tap" is
    closed:
        my $i = Supply.interval(2);
        my $tick = $i.tap({ say " tick $_" });
        sleep 3;                                 # tick 0\n tick 1\n
        my $tock = $i.tap({ say " tock $_" });
        sleep 3.5;                               # tock 0\n tick 2\n tock 1\n tick 3\n
        $tock.close;
        sleep 3;                                 # tick 4\n
        $tick.close;
    By default most "Supply" objects are serial, meaning they will not emit
    simultaneous events (be they "emit", "done", or "quit" events.) Other
    supplies are entirely asyncronous: it is possible for values to be
    pumped from an any number of asynchronous workers running on different
    threads. To tell the difference between the two, the ".serial" method
    may be used. Note that calls to a "Supplier"'s ".emit", ".done", or
    ".quit" methods always block (and may deadlock in the presence of
    feedback) until all taps have been run -- the difference between a
    serial and a non-serial "Supply" is when multiple threads call ".emit"
    simultaneously: on a non-serial "Supply", multiple taps may run in
    parallel, one on each thread, each processing values emitted by that
    thread. On a serial "Supply", only one tap may run at the same time, and
    the threads calling ".emit" may block on the taps processing each
    other's values, not just their own. Because of the semantic of "not emit
    simultaneous events" it is also guaranteed, on a serial "Supply", that
    all taps corresponding to one thread emission will complete before any
    of the taps from another thread's emission are run.
    The "Supply" class has various methods that produce more interesting
    kinds of "Supply". These mostly produce serial supplies. Even the
    "Supplier.Supply" method produces a serial supply -- to get a fully
    asyncronous live supply one must use the "Supplier.unsanitized-supply"
    method. Most factory methods handle creation/retention/destruction of a
    "Supplier" internally, or combine prexisting "Supply" objects, so their
    users need only to concern themselves with "Supply" objects.
    The following methods are class methods which create a new "Supply"
    without requiring an existing "Supply". The methods "merge", "zip" and
    "zip-latest" also have class method forms, documented further below with
    their instance method counterparts.
    from-list
          my $fl = Supply.from-list(^10);
        Takes a (potentially lazy) list of values, and returns an on-demand
        "Supply" that, when tapped, will iterate over the values and invoke
        the "Tap"'s "emit" callable for each of them, and any "done"
        callable at the end. If the iteration at some point produces an
        exception, then the "Tap"'s "quit" callable will be invoked to pass
        along the exception.
    interval
          my $e1    = Supply.interval(1);     # Once a second, starting now
          my $e5i10 = Supply.interval(5, 10); # Each 5 seconds, starting in 10 seconds
        Produces an on-demand "Supply" that, when tapped, will produce
        successive integer values at a regular time interval, with the
        integer values counting up from 0.
        Take the returned tap object and close it to stop the ticks:
            my $e1 = Supply.interval(1).tap(&say);
            # ...later...
            $e1.close();
    Supplies are mathematically dual to iterators, and so it is possible to
    define the same set of operations on them as are available on lazy
    lists. The key difference is that, while "grep" on a lazy list *pulls* a
    value to process, working synchronously, "grep" on a Supply has values
    *pushed* through it, and pushes those that match the filter onwards to
    anything that taps it.
    The following methods are available on an instantiated "Supply" ($s in
    these examples). Note that calling most of these methods on an on-demand
    "Supply" does not constitute demanding a fresh set of values from the
    "Supply" -- a tap is not immediately performed. Instead, tapping the
    resulting "Supply" will do so, per "Tap". In other words, connected
    networks of Supplies do not sit around in the background pointlessly
    feeding each other values internally, they wait until something is
    listening. (This behavior is generally accomplished via "whenever"
    clauses, described below.)
          my @l := $s.list;
        Produces a lazy "List" with the values of the "Supply".
    wait
          $s.wait;
        Waits until the specified "Supply" is "done" or "quit". In the
        latter case, throws the exception with which the "Supply" was quit.
    Channel
          my $c = $s.Channel;
        Produces a "Channel" of the values of the given "Supply".
    Promise
          my $p = $s.Promise;
        Produces a "Promise" that will be kept when the "Supply" is done or
        broken if it is quit.
    last
          my $l = $s.last(42);  # default: 1
        Produces a "Supply" that will only emit the last N values of the
        given "Supply" (after that "Supply" is "done"). Default is the final
          my $g = $s.grab( { .sort } ); # sort the values of a Supply
        Produces a "Supply" which will cache all values emitted by the given
        "Supply" until it is done. It will then call the given closure and
        then ".emit" each of the return values of the closure, and then call
        ".done" on itself.
    flat
          my $f = $s.flat;
        Produces a "Supply" in which all values of the original supply are
        flattened then individually emitted.
    do
          my $seen;
          my $d = $s.do( {$seen++} );
        Produces a "Supply" that is identical to the original supply, but
        will execute the given code for its side-effects, once for each
        emitted value, before running any taps. Only one thread will ever be
        executing the side-effect code at a time; others will block behind
        it. In addition to serializing the side-effect, the resulting supply
        is also serial, even if the one it was created from is not. The
        side-effect code is only run for emitted values, not when the
        original is quit or done.
    act
          $s.act( {$seen++} );
        This is a special case of "Supply".do, that will also create a tap
        on the given "Supply", so that you only need to worry about writing
        the side-effect code. Returns the "Tap".
          my $g = $s.grep( * > 5 );
          my $g = $s.grep(Int);
        Produces a "Supply" that only provides values that you want. Takes
        either a "Callable" (which is supposed to return a "True" value to
        pass on emitted values) or a value to be smartmatched against.
    map Analogous to "List"'s ".map" method, but produces a "Supply".
          my $m = $s.map( * * 5 );
        Produces a "Supply" that provides its original's Supply values
        multiplied by 5.
          my $m2 = $s.map( { $_ xx 2 } );
        twice.
          my $u = $s.unique( :as( {$_} ), :with( &[===] ), :expires(1) );
        Produces a "Supply" that only provides unique values, as defined by
        the optional "as" and "with" named parameters (same as List.unique).
        The optional "expires" parameter specifies how long to wait (in
        seconds) before "resetting" and not considering a value to have been
        seen, even if it's the same as an old value.
          my $q = $s.squish( :as( {$_} ), :with( &[===] ), :expires(1) );
        Produces a "Supply" that only provides sequentially different
        values, as defined by the optional "as" and "with" named parameters
        (same as List.squish). The optional "expires" parameter specifies
        how long to wait (in seconds) before "resetting" and not squishing a
        new value with an old one, even if they are the same.
          my $a = $s.max(&by); # default &infix:<cmp>
        Produces a "Supply" that produces the maximum values of the
        specified "Supply". In other words, from a continuously ascending
        "Supply" it will produce all the values. From a continuously
        descending "Supply" it will only produce the first value. The
        optional parameter specifies the comparator, just as with "Any.max".
          my $i = $s.min(&by); # default &infix:<cmp>
        Produces a "Supply" that produces the minimum values of the
        specified "Supply". In other words, from a continuously descending
        ascending "Supply" it will only produce the first value. The
        optional parameter specifies the comparator, just as with "Any.min".
          my $m = $s.minmax(&by); # default &infix:<cmp>
        Produces a "Supply" that, for each value emitted, produces "Range"s
        with the minimum and maximum values seen thus far on the specified
        "Supply". The optional parameter specifies the comparator, just as
        with "Any.minmax".
    batch
          my $b = $s.batch( :elems(100), :seconds(1) );
        Produces a "Supply" that batches the values of the given Supply by
        either the number of elements (using the "elems" named parameter) or
        the maximum number of seconds (using the "seconds" named parameter)
        or both. Values are grouped in a single array element when flushed.
    throttle
          my $t = $s.throttle( $elems, $seconds );
        Produces a "Supply" that throttles emitting the values of the given
        Supply on the created "Supply" by the number of elements (specified
        by the first parameter) per number of seconds (specified by the
        second parameter).
          my $e = $s.elems($seconds?); # default: see all
        Produces a "Supply" that, for each value emitted, produces the
        number of elements seen thus far in the given "Supply". You can also
        specify an interval to only see the number of elements seen once per
        that interval.
          my $b = $s.rotor(@cycle);
        Produces a "rotoring" "Supply" with the same semantics as
        List.rotor.
    delayed
          my $d = $s.delayed( 3.5 );  # delay supply 3.5 seconds
        Produces a "Supply" that passes on the values of the given Supply
        with the given delay (in seconds).
    stable
          my $u = $s.stable( $seconds, :$scheduler );
        Produces a "Supply" that only passes on a value if it wasn't
        superseded by another value in the given time (in seconds).
        Optionally uses another scheduler than the default scheduler, using
        the "scheduler" named parameter.
    start
          my $t = $s.start( {...} );
        Takes a closure and, for each supplied value, schedules the closure
        to run on another thread. It then emits a Supply (resulting in us
        having a supply of supplies) that will either have a single value
        emitted and then be done if the async work completes successfully,
        or quit if the work fails. Useful for kicking off work on the thread
        pool if you do not want to block up the thread pushing values at you
        (maybe 'cus you are reacting to UI events, but have some
        long-running work to kick off). Usually used in combination with
        "migrate".
    migrate
          my $m = $t.migrate;
        Produces a continuous "Supply" from a "Supply", in which each value
        is a "Supply" which emits a value from the original "Supply"
        unchanged. As soon as a new "Supply" appears, it will close the
        previously emitted "Supply" and send the next value from the
        original "Supply" to the most recently emitted "Supply" instead. Can
        be used in combination with "schedule-on".
    schedule-on
          my $o = $m.schedule-on( $scheduler );
        This allows a "Supply"'s emit/done/quit to be scheduled on another
        scheduler. Useful in GUI situations, for example, where the final
        stage of some work needs to be done on some UI scheduler in order to
        have UI updates run on the UI thread.
          my $r = $s.reduce( {...} );
        Produces a "Supply" that will emit each reduction from the given
        "Supply", much like the triangular reduction metaoperator ("[\...]")
        on "List"s.
          my $l = $s.lines;              # chomp lines
          my $l = $s.lines( :!chomp );   # do *not* chomp lines
        Produces a "Supply" that will emit the characters coming in line by
        line from a "Supply" that's usually created by some asynchronous I/O
        operation. The optional ":chomp" named parameter indicates whether
        to remove line separators: the default is "True".
    words
          my $w = $s.words;
        Produces a "Supply" that will emit the characters coming in word by
        word from a "Supply" that's usually created by some asynchronous I/O
        operation.
          my $c = $s.classify( {.WHAT} );  # one Supply per type of value
          my $h = $s.classify( %mapper );
          my $a = $s.classify( @mapper );
        Produces a "Supply" which emits "Pair"s consisting of a
        classification value as ".key", and a "Supply" as the ".value". That
        supply will then emit any values from the original "Supply" which
        match the classifier. Parameters behave similar to "List.classify",
        but does not support multi-level classification.
          my $c = $s.categorize( {@categories} );
          my $h = $s.categorize( %mapper );
          my $a = $s.categorize( @mapper );
        Produces a "Supply" in which emits "Pair"s consisting of a
        match the classification value. Unlike ".classify", more than one
        "Pair" may be emitted per value emitted from the original "Supply".
        See "List.categorize" for a description of the behavior of the
        parameters.
          my $r = $s.reverse;
        Produces a "Supply" that emits the values of the given Supply in
        reverse order. Please note that this "Supply" will only start
        delivering values when the given "Supply" is ".done", much like
        ".grab".
          my $o = $s.sort(&by);  # default &infix:<cmp>
        sorted order. Please note that this "Supply" will only start
        delivering values when the given "Supply" is ".done". Optionally
        accepts a comparator "Block".
    There are some combinators that deal with bringing multiple supplies
    together:
    "merge"
          my $m = $s1.merge($s2);
          my $m = Supply.merge(@s);  # also as class method
        Produces a "Supply" containing the values produced by given and the
        specified supply or supplies, and triggering "done" once all of the
        supplies have done so. The resulting supply is serial, even if any
        or all of the merged supplies are not.
    "zip"
          my $z = $s1.zip($s2);                   # defaults to :with( &[,] )
          my $z = Supply.zip(@s, :with( &[,] ));  # also as class method
        Produces a "Supply" that pairs together items from the given and the
        specified supply or supplies, using "infix:<,>" by default or any
        other user-supplied function with the "with" named parameter. The
        resulting supply is serial, even if any or all of the zipped
        supplies are not.
    "zip-latest"
          my $z = $s1.zip-latest($s2);                  # like zip, defaults to :with( &[,] )
          my $z = Supply.zip-latest(@s, :with( &[,] )); # also a method on Supply.
          my $z = Supply.zip-latest( @s, :initial(42,63) ); # initial state
        Produces a "Supply" that will emit tuples of values as soon as any
        combined Supply produces a value. Before any tuples are emitted, all
        supplies have to have produced at least one value. By default, it
        uses "infix:<,>" to produce the tuples, but the named parameter
        "with" can override that. The resulting supply is serial, even if
        any or all of the merged supplies are not.
        The named parameter "initial" can optionally be used to indicate the
        initial state of the values to be emitted.
    [TODO: plenty more of these: while, until...]
    The above combinators which involve multiple source supplies need care
    in their implementation, since values may arrive at any point from each
    source, and possibly at the same time. To help write such combinators,
    the "supply" block and "whenever" clause are used. These, along with the
    "react" block, are available for general use as well.
    A "supply" block is a convenient way to create an on-demand "Supply". It
    is just a declaration and does not run until the "Supply" is tapped
    (which may happen multiple times resulting in multiple runs/clones of
    the block.) Within a "supply" block, emit can be used to emit values to
    the tapper, and done can be used to convey that there will be no more
      my $s = supply {
          emit 'a value!';
          emit 'another!';
          done;
    The emit and done can be in nested scopes, and follow the same rules as
    "gather" and "take", except they look for an enclosing "supply" or
    "react" rather than a "gather". There is no corresponding "quit"
    statement: instead, any unhandled exception thrown inside of a supply
    block will be passed onwards using ".quit".
    Likewise, a "whenever" clause also looks around itself lexotically for
    an enclosing "supply" or "react". A "whenever" clause takes a predicate
    which may be a "Supply", "Channel", "Promise" or "Iterable", followed by
    a consequent block. These clauses guarantee that only one thread will
    enter their consequent or that of any other "whenever" clause inside the
    same enclosing "supply" or "react" block at the same time -- blocking
    any ".emit" call on a "Supply" or leaving any additional values in a
    Channel's ".send" queue in the scheduler.
      my $s = Supply.interval(1);
      my $c = Channel.new;
      my $l := (while $++ < 4 { NEXT { sleep 1 }; Int(now - BEGIN now) });
      my $p = Promise.in(3);
      my %contended_hash;
      start {
          for 0..4 { sleep 1; $c.send($_); LAST { $c.close } }
      react {
          # This is safe, because the whenevers protect %contended_hash
          whenever $s { %contended_hash{$_}++; done if $_ > 4 };
          whenever $c { %contended_hash{$_}++ };
          whenever $l { %contended_hash{$_}++ };
          whenever $p { %contended_hash{$_}++ };
      %contended_hash.say; # 0 => 3, 1 => 3, 2 => 3, 3 => 3, 4 => 2, 5 => 1, True => 1
    A whenever with a "Supply" as a predicate will tap that predicate when
    the enclosing block is run (assuming control reaches the whenever
    clause.) It will then offer its consequent block as the emit closure for
    the resulting "Tap". However, it is sometimes best just to think of a
    "whenever" as a loop which runs once for each value produced by the
    predicate "Supply", using the produced values as the topic. Following
    this model, a "QUIT" or "LAST" phaser inside the consequent block may be
    used to provide a quit or done closure (respectively) to the "Tap". The
    resulting "Tap" itself is ensconced internally, but may also be accessed
    as the return value of the entire whenever clause. This is not necessary
    just in order for a whenever to close its own tap: "last" may be called
    from within the consequent to do so. Labels may be used as normal to
    close the taps of outer clauses. Closing the last active tap closes the
    generated "Supply".
    A whenever block with a "Channel" as a predicate behaves analogously,
    running the closure once for every value sent to it by the scheduler, as
    if it were constantly calling ".receive" on the "Channel". A "Promise"
    predicate runs the block when the "Promise" is kept or broken as if it
    were calling "await". An "Iterable" predicate will start a new iterator
    when the whenever clause is run, entering the consequent closure for
    each value pulled from the "Iterator". In all such cases, a "QUIT" block
    inside the "whenever" will catch exceptions generated from within the
    predicate. Handling these exceptions will prevent ".quit" from being
    called on the "Supply" created by the block.
    Note that it is possible for control never to reach a "whenever" clause
    when a "supply" or "react" block is run. In this case, the whenever
    clause has no effect. If control reaches a "whenever" clause more than
    once (for example, if it is inside a loop) multiple taps on the
    predicate (which may be different each time) are created. A "whenever"
    clause may also be executed later, after a "supply" block has produced a
    "Supply" which has then been tapped, or while waiting for a "react"
    block to fall off the bottom. This could happen from inside another
    "whenever" clause in response to an event, or from an externally added
    "Tap". This is legal, and dynamically adds a new tap (of the predicate)
    to the "Supply" which caused this to happen. That is to say, once
    active, a "Supply" may indeed use "whenever" clauses to self-modify, as
    long as it was originally syntactically anchored to a "supply" or
    "react" block:
       my $s1 = Supply.interval(1).share;
       my $s2 = supply {
           whenever $s1 {
               emit($_);
               done if $_ > 4;
           }
       };
       $s2.tap({
           if 2 < $_ < 5 {
               "MORE $_".say;
                whenever $s1 {
                    "OHAI $_".say;
       });
       sleep 10;
       # MORE 3
       # MORE 4
       # OHAI 4
       # OHAI 5
    Destructuring subsignatures may be used with "whenever" clause topics
    via pointy block syntax.
    A "supply" block containing "whenever" clauses will call "done" on
    itself when all "whenever" clause predicates (which have executed) have
    had ".done"/"quit", ".close"/".fail" or ".keep"/".break" called on them,
    appropriately, or in the case of an "Iterable" predicate, when the end
    has been reached. These conditions are equivalent to manually closing
    the clause with "last".
    A "react" block will not wait to be tapped -- it will immediately run
    and then wait for a done or quit condition, after which point, control
    will resume below the "react" block.
System events exposed as Supplies
    System events, such as signals, or mouse events, can be exposed as
    Supplies. Because of lack of portability, these will most likely be
    implemented as third-party modules.
    Basic signal support is offered by the "signal" function, which takes
    one or more "Signal" enums, and an optional "scheduler" named parameter.
    It produces a "Supply" which, when tapped, will "emit" any signal coming
    in. For example:
      signal(SIGINT).tap( { say "Thank you for your attention"; exit 0 } );
    would catch Control-C, thank you, and then exit. Of course, you don't
    need to exit immediately. Here's an example of how you would make sure
    that an iteration in a loop is completed before exiting:
      for @todo {
          state $quitting;
          state $tap = signal(SIGINT).tap( { $quitting = True } );
          LAST  $tap.close;
          LEAVE exit(0) if $quitting;
          ... # code to protect
    This probably could use some syntactic sugar.
    The list of supported "Signals" can be found by checking
    "Signal::.keys", as you would any enum.
I/O features exposed as Supplies
    Various I/O-related things are also exposed as supplies. For example, it
    is possible to get notifications on changes to files or files (directly)
    in a directory, using:
        IO::Notification.watch-path(".").tap(-> $file {
            say "$file changed";
    This is quite a mouthful, so there is a shortcut available with the "IO"
    coercer and the "watch" method:
        ".".IO.watch.tap: -> $file { say "$file changed" };
    Note that since I/O callbacks are, by default, scheduled on the thread
    pool, then it's possible that your callback will be executing twice on
    the same thread. One way to cope is with "act":
        ".".IO.watch.act(-> $file {
            state %changes;
            say "$file changed (change {++%changes{$file}})";
    It can also take "done" and "quit" named parameters; these go to the
    tap, while the "emit" closure is put in a "do". A "Tap" is returned,
    which may be closed in the usual way. (Note that the name "act" is also
    a subtle reference to actor semantics.)
Inter-Process Communication exposed as Promises and Supplies
    Starting external processes is rather easy: "shell()", "run()" and
    "qx//". Having external processes run asynchronously, is slightly more
    involved. But not much. The workhorse of asynchronous IPC in Perl 6 is
    "Proc::Async":
        my $proc = Proc::Async.new( $path, @args );
    If you like to send data to the process, you need to open it with the
    ":w" named parameter.
        my $proc = Proc::Async.new( $path, @args, :w );
    By default, the current environment (as available in %*ENV) will be set
    for the external process. You can override this with the :ENV named
        my $proc = Proc::Async.new( $path, @args, :ENV(%hash) );
    The returned object can then be called whenever needed to start the
    external process. However, before you do that, one needs to be clear
    what to do about the output of the external process. Getting information
    back from the external process's "STDOUT" or "STDERR", is done by a
    "Supply" that either gets characters or bytes.
        $proc.stdout.act(&say);   # simply pass it on to our $*OUT as chars
        $proc.stderr.act(&note);  # and $*ERR as chars, but could be any code
        $proc.stdout(:bin).act: { # process STDOUT bytes };
        $proc.stderr(:bin).act: { # process STDERR bytes };
    So, to make sure no information will be lost, you need to create and tap
    the supplies before the process is started.
    To start the external process, you need to call the ".start" method. It
    returns a "Promise" that becomes "Kept" (and True) if the process
    concludes successfully, or "Broken" (and False) if the process failed
    for some reason.
        my $done = $proc.start( :$scheduler = $*SCHEDULER );
    To send data to the running process, you can use the ".print", ".say"
    and ".write" methods on the "Proc::Async" object:
        my $printed = $proc.print( "Hello world\n", :$scheduler = $*SCHEDULER );
        my $said    = $proc.say(   "Hello world",   :$scheduler = $*SCHEDULER );
        my $written = $proc.write( $buffer,         :$scheduler = $*SCHEDULER );
    They all also return a "Promise" that is "Kept" when communication with
    the process was successful.
    Some programs expect their "STDIN" to be closed to signify the end of
    their processing. This can be achieved with the ".close-stdin" method:
        $proc.close-stdin;
    Finally, if your process as going awry, you can stop it with the ".kill"
        $proc.kill;            # sends HUP signal to process
        $proc.kill("SIGINT");  # send INT signal
        $proc.kill(1);         # if you just know the signal number on your system
    The parameter should be something that is acceptable to the
    Kernel.signal method.
The Event Loop
    There is no event loop. Previous versions of this synopsis mentioned an
    event loop that would be underlying all concurrency. In this version,
    this is not the case.
  Threads
    VM-level threads, which typically correspond to OS-level threads, are
    exposed through the "Thread" class. Whatever underlies it, a "Thread"
    should always be backed by something that is capable of being scheduled
    on a CPU core (that is, it may *not* be a "green thread" or similar).
    Most users will not need to work with "Thread"s directly. However, those
    building their own schedulers may well need to do so, and there may be
    other exceptional circumstances that demand such low-level control.
    The easiest way to start a thread is with the "start" method, which
    takes a "Callable" and runs it on a new thread:
        my $thread = Thread.start({
            say "Gosh, I'm in a thread!";
    It is also possible to create a thread object, and set it running later:
        my $thread = Thread.new(code => {
            say "A thread, you say?";
        # later...
        $thread.run();
    Both approaches result in $thread containing a "Thread" object. At some
    point, "finish" should be called on the thread, from the thread that
    started it. This blocks until the thread has completed.
        say "Certainly before the thread is started";
        my $thread = Thread.start({ say "In the thread" });
        say "This could come before or after the thread's output";
        $thread.finish();
        say "Certainly after all the above output";
    As an alternative to "finish", it is possible to create a thread whose
    lifetime is bounded by that of the overall application. Such threads are
    automatically terminated when the application exits. In a scenario where
    the initial thread creates an application lifetime thread and no others,
    then the exit of the initial thread will cause termination of the
    overall program. Such a thread is created by either:
        my $thread = Thread.new(:code({ ... }), :app_lifetime);
    Or just, by using the "start" method:
        my $thread = Thread.start({ ... }, :app_lifetime);
    The property can be introspected:
        say $thread.app_lifetime; # True/False
    Each thread also has a unique ID, which can be obtained by the "id"
        say $thread.id;
    This should be treated as an opaque number. It can not be assumed to map
    to any particular operating system's idea of thread ID, for example. For
    that, use something that lets you get at OS-level identifiers (such as
    calling an OS API using NativeCall).
    A thread may also be given a name.
        my $thread = Thread.start({ ... }, :name<Background CPU Eater>);
    This can be useful for understanding its usage. Uniqueness is not
    enforced; indeed, the default is "<anon>".
    A thread stringifies to something of the form:
        Thread<id>(name)
        Thread<1234>(<anon>)
    The currently executing thread is available through $*THREAD. This is
    even available in the initial thread of the program, in this case by
    falling back to $PROCESS::THREAD, which is the initial thread of the
    process.
    Finally, the "yield" method can be called on "Thread" (not on any
    particular thread) to hint to the OS that the thread has nothing useful
    to do for the moment, and so another thread should run instead.
  Atomic Compare and Swap
    The Atomic Compare and Swap (CAS) primitive is directly supported by
    most modern hardware. It has been shown that it can be used to build a
    whole range of concurrency control mechanisms (such as mutexes and
    semaphores). It can also be used to implement lock-free data structures.
    It is decidedly a primitive, and not truly composable due to risk of
    livelock. However, since so much can be built out of it, Perl 6 provides
    it directly.
    A Perl 6 implementation of CAS would look something like this:
        sub cas($ref is rw, $expected, $new) {
            my $seen = $ref;
            if $ref === $expected {
                $ref = $new;
            return $seen;
    Except that it happens atomically. For example, a crappy non-reentrant
    mutex could be implemented as:
        class CrappyMutex {
            has $!locked = 0;
            method lock() {
                loop {
                    return if cas($!locked, 0, 1) == 0;
            method unlock() {
                $!locked = 0;
    Another common use of CAS is in providing lock-free data structures. Any
    data structure can be made lock-free as long as you're willing to never
    mutate it, but build a fresh one each time. To support this, there is
    another &cas candidate that takes a scalar and a block. It calls the
    block with the seen initial value. The block returns the new, updated
    value. If nothing else updated the value in the meantime, the reference
    will be updated. If the CAS fails because another update got in first,
    the block will be run again, passing in the latest value.
    So, atomically incrementing a variable is done thusly:
        cas $a, { $_.succ };    # $a++
    or more generally for all assignment meta-operators:
        cas $a, { $_ * 5 };     # $a *= 5
    Another example, implementing a top-5 news headlines list to be accessed
    and updated without ever locking, as:
        class TopHeadlines {
            has $!headlines = [];   # Scalar holding array, as CAS needs
            method headlines() {
                $!headlines
            method add_headline($headline) {
                cas($!headlines, -> @current {
                    my @new = $headline, @current;
                    @new.pop while @new.elems > 5;
                    @new
                });
    It's the programmer's duty to ensure that the original data structure is
    never mutated and that the block has no side-effects (since it may be
    run any number of times).
Low-level primitives
    Perl 6 offers high-level concurrency methods, but in extreme cases, like
    if you need to implement a fundamentally different mechanism, these
    primitives are available.
  Locks
    Locks are unpleasant to work with, and users are pushed towards higher
    level synchronization primitives. However, those need to be implemented
    via lower level constructs for efficiency. As such, a simple lock
    mechanism - as close to what the execution environment offers as
    possible - is provided by the "Lock" class. Note that it is erroneous to
    rely on the exact representation of an instance of this type (for
    example, don't assume it can be mixed into). Put another way, treat
    "Lock" like a native type.
    A "Lock" is instantiated with "new":
        $!lock = Lock.new;
    The best way to use it is:
        $!lock.protect: {
            # code to run with the lock held
    This acquires the lock, runs the code passed, and then releases the
    lock. It ensures the lock will be released even if an exception is
    thrown. It is also possible to do:
            $!lock.lock();
            # do stuff
            LEAVE $!lock.unlock()
    When using the "lock" and "unlock" methods, the programmer must ensure
    that the lock is unlocked. "Lock" is reentrant. Naturally, it's easy to
    introduce deadlocks. Again, this is a last resort, intended for those
    who are building first resorts.
  Semaphore
    The "Semaphore" class implements traditional semaphores that can be
    initiated with a fixed number of permits and offers the operations
    "acquire" to block on a positive number of permits to become available
    and then reduce that number by one, "tryacquire" to try to acquire a
    permit, but return "False" instead of blocking if there are no permits
    available yet. The last operation is "release", which will increase the
    number of permits by one.
    The initial number of permits may be negative, positive or 0.
    Some implementations allow for race-free acquisition and release of
    multiple permits at once, but this primitive does not offer that
    capability.
    DRAFT: Synopsis 19: Command Line Interface
        Created: 12 Dec 2008
        Last Modified: 06 Oct 2014
    This is a draft document. This document describes the command line
    interface. It has changed extensively from previous versions of Perl in
    order to increase clarity, consistency, and extensibility. Many of the
    syntax revisions are extensions, so you'll find that much of the Perl 5
    syntax embedded in your muscle memory will still work.
    Notable features described in the sections below include:
    *   A smart default command-line processor in the core
    *   All options have a long, descriptive name for increased clarity
    *   Common options have a short, single-character name, and allow
        clustering
    *   Extended option syntax provides the ability to set boolean
        true/false
    *   New "++" metasyntax allows options to be passed through to
        subsystems
    This interface to Perl 6 is special in that it occurs at the
    intersection of the program and the operating system's command line
    shell, and thus is not accessed via a consistent syntax everywhere. A
    few assumptions are made here, which will hopefully stand the test of
    time: All command-line arguments are assumed to be in Unicode unless
    proven otherwise; and Perl is born of Unix, and as such the syntax
    presented in this document is expected to work in a Unix-style shell. To
    explore the particularities of other operating systems, see Synopsis 25
    (TBD).
Command Line Elements
    The command line is broken down into two basic elements: a *program*,
    and *arguments*. Each command line element is whitespace separated, so
    elements containing whitespace must be quoted. The *program* processes
    the arguments and performs the requested actions. For rakudo compiled
    with both MoarVM and JVM backends, respectively "perl6-m" and "perl6-j".
    With one compiled backend, the command can be shortened to "perl6" It is
    followed by zero or more *arguments*. The *program* portion of the
    command line is made available at run-time via the "PROCESS::<$PROGRAM>"
    variable (normally accessed as $*PROGRAM) as an "IO::Path".
    Command line *arguments* are broken down into *options* and *values*.
    Each option may take zero or more values. After all options have been
    processed, the remaining values (if any) generally consist of the name
    of a script for Perl to execute, followed by arguments for that script.
    If no values remain, Perl 6 implicitly opens STDIN to read the script.
    If you wish to pass arguments to a script read from STDIN, you must
    specify STDIN by name ("-" on most operating systems).
Backward (In)compatibility
    You may find yourself typing your favorite Perl 5 options, even after
    Christmas has arrived. As you'll see below, common options are provided
    which behave similarly. Less common options, however, may not be
    available or may have changed syntax. If you provide Perl with
    unrecognized command-line syntax, Perl gives you a friendly error
    message. If the unrecognized syntax is a valid Perl 5 option, Perl
    provides helpful suggestions to allow you to perform the same action
    using the current syntax.
  Unchanged Syntactic Features
    Several features have not changed from Perl 5, including:
    *   The most common options have a single-character short name
    *   Single-character options may be clustered with the same syntax and
        semantics
    *   Many command-line options behave similarly, for example:
          Option...                            Still means...
          -a                                   Autosplit
          -c                                   Check syntax
          -e *line*                            Execute
          -F *expression*                      Specify autosplit field separator
          -h                                   Display help and exit
          -I *directory*[,*directory*[,...]]   Unshift CompUnitRepo::Local('s) to @?INC
          -n                                   Act like awk
          -p                                   Act like sed
          -S                                   Search PATH for script
          -T                                   Enable taint mode
          -v                                   Display version info
          -V                                   Display verbose config info
        All of these options have extended syntax, and some may have
        slightly different semantics, so see "Option Reference" below for
        the details.
  Removed Syntactic Features
    Some Perl 5 command-line features are no longer available, either
    because there's a new and different way to do it in Perl 6, or because
    they're no longer relevant. Here's a breakdown of what's been removed:
    -0 *octal/hex*
        Sets input record separator. Missing due to lack of specification in
        Synopsis 16. There is a comment about this in the "Notes" section at
        the end of this document.
    -C *number/list*
        Control Unicode features. Perl 6 has Unicode semantics and assumes a
        UTF-8 command-line interface (until proven otherwise, at which point
        this functionality may be readdressed).
    -d, -dt, -d:foo, -D, etc.
        Debugging commands. Replaced with the "++BUG" metasyntactic option.
    -E *line*
        Execute a line of code, with all features enabled. This is specific
        to Perl 5.10, and not relevant to Perl 6, where "-e" performs this
        function.
    -i *extension*
        Modify files in-place. Haven't thought about it enough to add yet,
        but I'm certain it has a strong following. {{TODO review decision
        here}}
    -l  Enable automatic line-ending processing. This is the default
        behavior.
    -M *module*, -m *module*, etc.
        use/no module. Replaced by "--use".
    -P  Run option through C preprocessor. This caused problems for Perl 5,
        and is completely obsolete now.
    -s  Enable rudimentary switch parsing. By default, Perl 6 parses the
        arguments passed to a script using the signature supplied by the
        user in the MAIN routine (see "Declaring a MAIN subroutine" in S06).
    -t  Enable taint warnings mode. Taint mode needs more thought, but it's
        much more likely that the "-T" switch will take options rather than
        use a second command-line flag to implement related behavior.
    -u  Dump the core after parsing the program. This has been deemed
        obsolete.
    -U  Allow unsafe operations. This is extremely dangerous and
        infrequently used, and doesn't deserve its own command-line option.
    -w  Enable warnings. This is the default behavior.
    -W  Enable all warnings. This is infrequently used, and doesn't deserve
        its own command-line option.
    -X  Disable all warnings. This is infrequently used, and doesn't deserve
Options and Values
    Command line options are parsed using the following rules:
    *   Options must begin with one of the following symbols: "--", "-", or
        ":".
    *   Options are case sensitive. "-o" and "-O" are not the same option.
    *   All options have a multi-character, descriptive name for increased
        clarity. Multi-character option names always begin with "--" or ":".
    *   Common options have a short, one-character name for speed.
        Single-character names always begin with "-".
    *   Single-character options may be clustered. "-ab" means "-a -b". When
        a single-character option which requires a value is clustered, the
        option may appear only in the final position of the cluster.
    *   Options may be negated with "/", for example "--/name", ":/name",
        "-/n". Negated single-character options cannot appear in a cluster.
        In practice, negated options are rare anyway, as most boolean
        options default to False.
    *   Option names follow Perl 6 identifier naming convention, except "'"
        is not allowed, and single-character options may be any character or
        number.
    *   The special option "--" and "-e <program>" signal the parser to stop
        option processing. Arguments following a bare "--" (with no
        identifier) or a "-e" are always parsed as a list of values, even if
        they look like valid options.
    Delimited options allow you to transparently pass one or more options
    through to a subsystem, as specified by the special options that delimit
    those options. They are parsed according to the following rules:
    *   The opening and closing delimiters begin with two or more plus
        characters, for example "++". You'll usually use two plus
        characters, but more are allowed to avoid ambiguity when nesting
        delimited options.
    *   Opening and closing delimited option names follow option identifier
        naming convention, defined above.
    *   If the closing delimiter is omitted, the rest of the command line is
        consumed.
    *   Inside a delimited option, the "--" option does not suppress
        searching for the closing delimiter. That is, only the rest of the
        arguments within the delimiters are treated as values.
    *   Eager matching semantics are used, so the first closing delimiter
        found completes the match.
    *   Delimited options cannot be negated. However, the final delimiter
        takes a slash indicating the termination of the delimited
        processing, much like a closing HTML tag.
    These options are made available in dynamic variables matching their
    name, and are invisible to "MAIN()" except as "%*OPTS<name>". For
      ++PARSER --setting=Perl6-autoloop-no-print ++/PARSER
    is available inside your script as "%*OPTS<PARSER>", and contains
    "--setting=Perl6-autoloop-no-print". Since eager matching is used, if
    you need to pass something like:
      ++foo -bar ++foo baz ++/foo ++/foo
    you'll end up with
      %*OPTS<foo> = '-bar ++foo baz';
    which is probably not what you wanted. Instead, add extra "+" characters
      +++foo -bar ++foo baz ++/foo +++/foo
    which will give you
      %*OPTS<foo> = '-bar ++foo baz ++/foo';
    allowing you to properly nest delimited options.
    The actual storage location of %*OPTS may be either in
    "PROCESS::<%OPTS>" or "GLOBAL::<%OPTS>", depending on how the process
    sets up its interpreters.
    Values are parsed with the following rules:
    *   Values are passed to options with the following syntax
        "--option=value" or "--option value".
    *   Values containing whitespace must be enclosed in quotes, for example
        "-O="spacey value""
    *   Multiple values are passed by specifying multiple instances of the
        option, as in "--option=val1 --option='val 2'".
  Remaining arguments
    Any remaining arguments to the Perl 6 program are placed in the @*ARGS
    array.
Option Reference
    Perl 6 options, descriptions, and services.
  Synopsis
      multi sub perl6(
        Bool :a($autoloop-comb),
        Bool :c($check-syntax),
        Bool :$doc,
             :e($execute),
             :F($autoloop-delim),
        Bool :h($help),
             :I(@include),
             :L($language),
        Bool :n($autoloop-no-print),
             :O($output-format),
        Bool :p($autoloop-print),
        Bool :S($search-path),
        Bool :T($taint),
             :u($use),
        Bool :v($version),
        Bool :V($verbose-config),
        Bool :x($extract-from-text),
      );
  Reference
    --autoloop-comb, -a
        When used with "-n" or "-p", implicitly combs input and assigns the
        result to @_ within the loop produced by the "-n" or "-p".
        The default pattern is "/\S+/", an alternate pattern for comb may be
        specified with "--autoloop-pattern", a.k.a. "-F".
    ++CMD --command-line-parser *parser* ++/CMD
        Add a command-line processor. When this option is parsed, it
        immediately triggers an action that affects or replaces the
        command-line parser. Therefore, it is a good idea to put this option
        as early as possible in the argument list.
    --check-syntax, -c
        Check syntax, then exit. Desugars to "-e 'CHECK { compiles_ok();
        exit; }'".
    --doc
        Lookup Perl documentation in Pod format. Desugars to "-e 'CHECK {
        compiles_ok(); dump_perldoc(); }'". @*ARGS contains the arguments
        passed to "perl6", and is available at "CHECK" time, so
        "dump_perldoc()" can respond to command-line options.
        {{TODO may create a ++DOC subsystem here. also, may use -d for short
        name, even though it clashes with perl 5}}
    ++BUG [*switches*, *flags*] ++/BUG
        Set switches and flags for the debugger.
        Note: The debugger needs further specification.
    --execute, -e *line*
        Execute a single-line program in lax mode.
        If you don't wish to run in lax mode, but with strictures and
        warnings enabled, pass 'use strict;' at the -e on the command line,
        like "-e 'use strict; my $x = 42'".
    --autoloop-delim, -F *expression*
        Pattern to split on (used with -a). Substitutes an expression for
        the default split function, which is "{split ' '}". Accepts Unicode
        strings (as long as your shell lets you pass them). Allows passing a
        closure (e.g. -F "{use Text::CSV}"). Awk's not better any more :)
    --help, -h
        Print summary of options. Desugars to "++CMD --print-help --exit
        ++/CMD".
    --include, -I location[,Class=location[,...]]
        Prepend "CompUnitRepo"'s to @?INC, for ad hoc module searching. The
        CompUnitRepo::Local::File class will be assumed if no class has been
        specified. Any class specified should adhere to the CompUnitRepo
        interface. In any Searching the standard library follows the
        policies laid out in Synopsis 11.
    --language, -L *dsl*
        Set the domain specific language for parsing the script file. (That
        is, specify the *setting* (often known as the prelude) for the
        program.) "++PARSER --setting=*dsl* ++/PARSER".
    --autoloop-no-print, -n
        Act like awk. Desugars to "++PARSER
        --setting=Perl6-autoloop-no-print ++/PARSER".
    --output-format, -O *format*
        Emit compiler output to STDOUT in the specified format, rather than
        invoking the compiled code immediately. This option is
        implementation-specific, so consult the documentation for your Perl
        6 implementation for further details.
    --autoloop-print, -p
        Act like sed. Desugars to "++PARSER --setting=Perl6-autoloop-print
        ++/PARSER".
    --search-path, -S
        Use PATH environment variable to search for script specified on
        command-line.
    --taint, -T
        Turns on "taint" checking. See Synopsis 23 for details. Commits very
        early. Put this option as early on the command-line as possible.
    --use, -u *module*
        "--use *module*" and "-u *module*" desugars to "-e 'use *module*'".
        Specify version info and import symbols by appending info to the
        module name:
          -u'Sense:auth<cpan:JRANDOM>:ver<1.2.1> <common @horse>'
        You'll need the quotes so your shell doesn't complain about
        redirection. There is no special command-line syntax for "'no
        *module*", use "-e".
    --version, -v
        Display program name, version, patchlevel, etc. Desugars to "++CMD
        -v ++/CMD ++PARSER -v ++/PARSER ++BUG -v ++/BUG".
    --verbose-config, -V
        Display configuration details. Desugars to "++CMD -V ++/CMD ++PARSER
        -V ++/PARSER ++BUG -V ++/BUG".
    --extract-from-text, -x
        Run program embedded in Unicode text. Scan for the first line
        starting with "#!" and containing the word "perl", and start there
        instead. This is useful for running a program embedded in a larger
        message. (In this case you would indicate the end of the program
        using the "=END" block, as defined in Synopsis 26.)
        Desugars to "--PARSER --Perl6-extract-from-text --/PARSER".
Metasyntactic Options
    Metasyntactic options are a subset of delimited options used to pass
    arguments to an underlying component of Perl. Perl itself does not parse
    these options, but makes them available to run-time components via the
    "%*META-ARGS" dynamic variable.
    Standard in Perl 6 are three underlying components, "CMD", "PARSER", and
    "BUG". Implementations may expose other components via this interface,
    so consult the documentation for your Perl 6 implementation.
      On command line...                   Subsystem gets...
       ++X a -b  ++/X                      a -b
      # Nested options
      +++X a -b   ++X -c ++/X -d e +++/X   a -b ++X -c ++/X -d e
      # More than once (both are valid, but the second form is preferred)
       ++X a -b  ++/X -c  ++X -d e  ++/X   a -b -d e
      +++X a -b +++/X -c  ++X -d e  ++/X   a -b -d e
Environment Variables
    Environment variables may be used to the same effect as command-line
    PATH
        Used in executing subprocesses, and for finding the program if the
        -S switch is used.
    PERL6LIB
        A list of directories in which to look for ad hoc Perl library
        files.
        Note: this is speculative, as library loading is not yet specified,
        except insofar as S11 mandates various behaviors incompatible with
        mere directory probing.
    PERL6OPT
        Default command-line arguments. Arguments found here are prepended
        to the list of arguments provided on the command-line.
References
    <http://perldoc.perl.org/perlrun.html>
    <http://search.cpan.org/dist/Getopt-Long/lib/Getopt/Long.pm>
    <http://search.cpan.org/dist/Getopt-Euclid/lib/Getopt/Euclid.pm>
    <http://design.perl6.org/S06.html#Declaring_a_MAIN_subroutine>
    <http://search.cpan.org/dist/Perl6-Pugs/docs/Pugs/Doc/Run.pod>
    <http://haskell.org/ghc/docs/latest/html/users_guide/using-ghc.html>
    <http://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html>
Notes
    I'd like to be able to adjust the input record separator from command
    line, for instance to specify the equivalent of perl 5's "$/ = \32768;".
    So far, I don't have a solution, but perhaps pass a closure that
    evaluates to an Int? This should try to use whatever option does the
    same thing to a new filehandle when S16 is further developed.
        Jerry Gay <jerry.gay@rakudoconsulting.com>
        Moritz Lenz <moritz@cpan.org>
    DRAFT: Synopsis 21: Calling Foreign Code
        Last Modified: 23 Nov 2012
SYNOPSIS
        use NativeCall;
        sub native_function(int arg) is native('libsomething') { * }
        sub short_name() is native('libsomething') is symbol('long_and_complicated_name') { * }
        native_function(42);
DESCRIPTION
    Perl 6 has a standard foreign function interface, NativeCall. The only
    libraries NativeCall is able to interface with are those written in C.
    Languages like Fortran and C++ require name mangling, which is
    compiler-specific and thus falls well beyond the scope of this
    specification.
    Hypotheticals:
     This is likely not an exhaustive list of showstoppers for C++/Fortran
    compat; also, some platforms may be tricky simply in terms of C interop
    as well
  Calling foreign code
    A sub is marked as a native routine with the "is native" trait. A native
    sub must have an attached signature, which is used to specify the
    native-level argument structure of the function. If the return type of
    the function is "Mu" the native function returns no value, any other
    return type must be compatible with the types specified in the next
    section.
   The "is native" trait
        sub trait_mod:<is>(Routine $r, :$native!) is export(:DEFAULT, :traits) { ... }
    The "is native" trait is the main gateway used to access C libraries. A
    routine with this trait applied will not be a normal Perl 6 callable,
    but will call into the function with the same name in the specified
    library.
    The library name passed to "is native" is passed unmodified to
    <man:dlopen(3)> or the platform's equivalent and the symbol is the
    looked for in the handle returned from the call to "dlopen". If the
    library name is an undefined value or the empty string, the symbol will
    be searched for in the currently loaded libraries of the process; that
    is, behaviour consistent with "dlsym(RTLD_DEFAULT, symbol)" in C.
   The "is symbol" trait
        sub trait_mod:<is>(Routine $r, :$symbol!) is export(:DEFAULT, :traits) { ... }
    Since all symbols in a C library share a single namespace with all other
    libraries, it is common practice to prefix externally visible symbols
    with a library prefix so as not to interfere with other libraries. In
    Perl 6 this may be a nuisance, and the "is symbol" trait lets a user
    specify a different symbol name to search for than the name of the sub.
    A native sub also adorned with "is symbol" will search for the symbol
    specified in the symbol trait, rather than the name of the subroutine
    itself.
   The "is nativeconv" trait
        sub trait_mod:<is>(Routine $r, :nativeconv!) is export(:DEFAULT, :traits) { ... }
    Native code typically supports several different calling conventions. If
    a convention different than the default one is needed, it is specified
    with "is nativeconv($convention)". The conventions supported are
    platform-specific.
   The "is encoded" trait
        sub trait_mod:<is>(Routine $r,   :encoded!) is export(:DEFAULT, :traits) { ... }
        sub trait_mod:<is>(Parameter $p, :encoded!) is export(:DEFAULT, :traits) { ... }
    Input arguments and return values that are strings may be returned in
    any of a multitude of encodings. If the value is encoded differently
    from UTF-8, it must be stated explicitly.
   Global variables
    Caveat emptor: This whole section is conjectural.
    Just like functions exported by a library, global variables are accessed
    with the "is native" trait; after all, all exported symbols are the same
    from the point of view of the linker: a pointer to something. The "is
    symbol" and "is encoding" (for strings) traits also apply to variables.
  Marshalling and demarshalling of Perl 6 data
    The raw internal representation of most Perl 6 objects can't be expected
    to work sensibly with native code. To specify how to marshal and
    demarshal complex Perl 6 objects, representation polymorphism is most
    frequently used, but some classes are provided for frequent use cases.
    For pointer types, the type object associated with the Perl 6 class
    represents the null pointer.
   Numeric types
    Numeric types, both native types and not, have obvious marshalling
    semantics (as long as they are not arbitrary-precision types). A
    NativeCall implementation should support the following types:
    "int8", "uint8" signed and unsigned byte
    "int16", "uint16" signed and unsigned two-byte integer
    "int32", "uint32" signed and unsigned four-byte integer
    "int64", "uint64" signed and unsigned eight-byte integer
    "int", "uint" signed and unsigned machine word
    "Int" largest available integer type
    "num32" four-byte floating point number
    "num", "num64" eight-byte floating point number
     This is a wider range of native types than what S02 mandates. We'll
    either want to expand that list of natives, or find some other way of
    specifying sizes.
     There is no obvious mirror of "Int" for largest available *unsigned*
    type.
     Should "Num" be a synonym for "num"/"num64"?
     If the Int or Num type object is passed, should it be silently
    converted to a zero value, or cause an exception?
     How should overflows be handled?
   Strings
        multi explicitly-manage(Str $x is rw, :$encoding = 'utf8') is export(:DEFAULT, :utils) { ... }
    By default, a string passed to a native sub wil be marshalled to a "char
    *" appropriately encoded as specified with the "is encoded" trait. The
    memory allocated to the C string is freed when the function returns. If
    a "Str" object should have a persistent "char *" associated with it,
    this can be signalled by calling "explicitly-manage($str, $encoding)".
    The buffer allocated will never be freed.
    A string-valued native sub's return value will be unmarshalled according
    to the "is encoded" trait, and the C pointer is not freed as deciding
    whether the caller or callee owns the data can't be decided
    automatically, and freeing by default risks causing later code to access
    freed memory.
     We need better facilities for signaling when it's appropriate to free
    data. The current facilities have the benefit that it won't cause
    memory-related errors later on, but on the flip side, it will leak
    memory over time.
   The "OpaquePointer" class
        class OpaquePointer is repr('CPointer') { }
    The "OpaquePointer" type is the simplest possible way to interface with
    C pointers, and can be seen as similar to the "void *" type in C. An
    "OpaquePointer" offers no way to inspect the pointer or manipulate it;
    it can only be passed around in the program and back to C.
   The "CPointer" REPR
        typedef struct _magic magic;
        magic *magic_new(void);
        void   magic_perform(magic *m);
        class Magic is repr('CPointer') {
            my Magic sub magic_new()       is native('libmagic') { * }
            my sub magic_perform(Magic $m) is native('libmagic') { * }
            method new() { magic_new(); }
            method perform() { magic_perform(self); }
    The "CPointer" REPR enables types that are similar to "OpaquePointer" in
    that they cannot be introspected or mutated, but different in that they
    can have methods. This makes it easy to interface with "object-oriented"
    C code that returns an opaque pointer handle that encapsulate the
    resources used by the library and lets us implement this naturally using
    Perl 6 OO.
    A "CPointer" object can not have attributes.
   The "CArray" class
        class CArray[::Type] does Positional[Type] is export(:DEFAULT, :types) { ... }
    General Perl 6 arrays support features such as laziness, which means
    that they can not easily be marshalled into a C representation. Thus,
    NativeCall provides the CArray type which supports a set of array
    features compatible with marshalling to and from C. The "Type" parameter
    is, of course, mandatory as the exact layout of the array in memory
    depends on the type of the elements.
    A "Carray" that has been marshalled from a value returned from C cannot,
    given how arrays work in C, know the bounds of the array. Thus, it is
    the *user's* responsibility to ensure that all accesses are within the
    bounds of the array. NativeCall will make no attempt to figure this out,
    and requests for array elements outside of the array is likely to result
    in death by segmentation fault.
    If the "CArray" has been created in Perl 6, the bounds of the array are
    known, and operations can be bounds-checked and the array grown
    appropriately. Note, however, that growing an array may result in its C
    representation being moved to a different memory location. Thus, if a
    piece of C code has stored the location of an array and it is later on
    moved due to operations on the Perl side, strange bugs and segfaults are
    likely to ensue.
   The "CStruct" REPR
        class StructObject is repr('CStruct') { ... }
    Structs are an important part of most non-trivial C APIs; using the
    "CStruct" REPR, arbitrary structs can be accessed just like ordinary
    Perl 6 classes.
   Callable objects
    Callback arguments are, in essence, no different from normal data. They
    are declared as callables (typically with the "&" sigil) and also have
    an attached signature. The signature is important as the callback
    handling code needs this information to get the function's arguments off
    the stack.
    Callbacks returned from C are specified identically, but as return
    values rather than parameters (note: callbacks returned from C NYI).
   Complex data value types
    Caveat emptor: This section, like the one on global variables, is all
    conjecture. Nothing is implemented.
    In Perl 6 the distinction between value type and reference is intrinsic
    to the type. In C, on the other hand, any type can be used both as a
    value and reference type, depending on how it's used. Thus, NativeCall
    needs some mechanism to duplicate this. One possible source of
    inspiration for this is C#. C# distinguishes between value and reference
    types similarly to Perl 6 and also has a well-supported foreign function
    interface.
   Varargs
To be determined. This section is hypothetical.
    One option is an API similar to the C99 "stdarg.h" macros and explicitly
    get arguments off an opaque object. For example "my $arg = va_arg($args,
    Type)".
  Miscellaneous helper functions
   Refreshing outdated objects
        multi refresh($obj) is export(:DEFAULT, :utils) { { ... }
    To avoid unmarshalling data from the C representation whenever data is
    accessed, an efficient implementation is going to want to cache
    unmarshalled data. Whenever a complex object is passed to a native
    subroutine, the implementation should make sure the cache data isn't out
    of date. However, if the C code saves a pointer passed to it and a later
    invocation mutates the data pointed to, NativeCall can't magically
    detect this. In cases like this, the user will have to use "refresh" to
    invalidate any outdated objects in the cache.
     Sometimes it will be necessary to reinterpret a pointer-valued object
    as a different kind of pointer. One way to provide this would be a
    function a la: "my $val = reinterpret($ptr, Type)".
        Arne Skjærholt <arnsholt@gmail.com>
    Synopsis 22: Package Format [DRAFT]
        Created: 3 Nov 2005
        Last Modified: 19 Dec 2008
OVERVIEW
  Terminology and Scope
    I'll start by listing a few terms, and whether this document is supposed
    to cover them or not.
    *   .jib files; this is the source package format, and is specified in
        this document
    *   CPAN6; this is a piece of software for managing an archive network
        (such as CPAN). This is not specified in this document; see
        <http://cpan6.org/>
    *   PAUSE6; this is an actual network based on the cpan6 software (see
        above). It also is not documented here.
    *   CPAN6.pm; this is a piece of software that starts with what it can
        get on PAUSE6, and attempts to give you an installed perl module
        (this is a replacement for CPANPLUS/cpan2dist)
  Inspirations
    The following can be useful inspirations:
    *   Debian Policy: <http://www.us.debian.org/doc/debian-policy>
    *   Software::Packager::Metadata:
        <http://perlsoftpackmet.svn.sourceforge.net/viewvc/perlsoftpackmet/m
        ain/doc/> (click on the link in the Rev. column next to Overview)
PACKAGE LAYOUT
  Project directory
    Step 1 of the general flow should ideally be done by an automated tool,
    like p5's current Module::Starter or somesuch. Suffice to say, it should
    produce a layout something along these lines (note, this is just an
    example):
        p5-Foo-Bar/
            lib/
                Foo/
                    Bar.pm
            t/
                00_load.t
            _jib/
                META.info
    The files in the _jib dir are part of the package metadata. The most
    important file is the META.info file that holds all the collected
    metadata about the package, which ideally gets filled (mostly) by what
    is described in step 2 of the "General Flow". Any pre/posthook files
    should also go in this directory. This directory should be extensible,
    so new files can be added to extend functionality. See the section on "
    Metadata Spec " for details.
  .jib files
    These files are created in step 3 of the "General Flow"
    "JIB" is a simple 3 letter combination that's not yet 'taken' as a known
    extension. It's purposely not perl specific, as there's nothing about
    the "JIB" specification that's limiting it to perl only.
    # XXX - Also "package" is carrying double meaning in P6 as both
    namespace and source distribution. Can we remove the former meaning and
    refer to them as "module" and "namespace" from now on?
    ".jib" files are archives designed to distribute source packages, not
    installable packages. As we will need to compile things on the client
    side (things that have C bits or equivalent), and because we can not
    know the install path before hand, a source package is an obvious
    choice. A binary, installable package like ".deb" is therefor no option.
    These ".jib" contain metadata and installable code quite analogous to
    the ".deb" packages we know, except that the metadata is also used to
    "compile" (for the lack of a better term so far) the code on the user
    side.
    The name of a ".jib" file is determined as follows:
        <prefix>-<package-name>-<version>-<authority>.<extension>
    In praxis, this will produce a name along these lines:
        p5-Foo-Bar-1.1-cpan+kane.jib
    The Internal layout is as follows:
        - control.tgz
            * contains the data in the _jib directory
        - data.tgz
            * contains the following directories the other directories.
                This may be limited in the future, by say, a manifest.skip
                like functionality, or by dictating a list of directories/
                files that will be included
    There is room to ship more files alongside the 2 above mentioned
    archives. This allows us to ship an extra md5sum, version, signature,
    anything.
METADATA SPEC
        - Define no more than needed to get started for now
            - Allow for future extensions
            - Use YAML as metadata format as it's portable and available standard
                in perl6
  Supported fields
        - Prefix        Package prefix category     (p5)
        - Name          Perl module name            (Foo-Bar)
        - Version       Perl module version         (1.2.3)
        - Authority     From S11                    (cpan+KANE)
        - Package       Full package name           (p5-Foo-Bar-1.2.3-cpan+kane)
        - Description   Description of function     (This is what it does)
        - Author        CPAN author id              (KANE)
        - Depends       Packages it depends on[1][2](p5-Foo)
        - Provides      Packages this one provides  (p5-Foo-Bar,
                                                        p5-Foo-Bar-cpan+kane)
    As the <Prefix>-<Name>-<Version>-<Authority> combination make up the
    <Package> name, arguably, we can leave the former out. The upside is to
    make sure all fields contain unique information. The downside is that
    3rd party parsers will need to understand the "Package" syntax.
    Again, arguably, the "Author" and "Authority" fields overlap, and
    "Authority" can be made to hold both cases.
        [1] This is packages, *not* modules. If we need a module -> package
            mapping, this needs to be done when extracting the data from the
            compiler, and queried against the available packages cache.
        [2] See the section on L<Dependencies>
  Suggested fields[3]
        - Build-Depends Packages needed to build this package
        - Suggests      Packages suggested by this package
        - Recommends    Packages recommended by this package
        - Enhances      Packages that are enhanced by this package
        - Conflicts     Packages this one conflicts with
        - Replaces      Packages this one replaces
        - Tags          Arbitrary metadata about the package,
                        like flickr and debtags
        - Contains      List of modules (and scripts?) contained
                        in the package
        [3] Steal more tags from debian policy
DEPENDENCIES
  Dependency Notation
    Dependency notation allows you to express the following concepts:
    OR  Specifies alternatives
    AND Specifies cumulative requirements
    associate VERSION requirement
        Specifies a criteria for the version requirement
    grouping
        This allows nesting of the above expressions
   Basic notation:
        a, b                        # a AND b
        [a, b]                      # a OR b
        { a => "> 2" }              # a greater than 2
        { a => 1 }                  # shorthand for a greater or equal to 1
        \[ ... ]                    # grouping
   More complex examples:
        a, [b,c]                    # a AND (b OR c)
        { a => 1 }, { a => '< 2' }  # a greater or equal to 1 AND smaller than 2
        [a, \[ b, c ] ]             # a OR (b AND c) [1]
        [1] This is possibly not portable to other languages. Options seem
            thin as we don't have some /other/ grouping mechanism than [ ], { }
            and \[ ]; ( ) gets flattened and \( ) == [ ].
            We could abuse { } to create { OR => [ ] } and { AND => [ ] }
            groups, but it would not read very intuitively. It would also mean
            that the version requirements would have to be in the package naming,
            ie. 'a > 2' rather than a => '> 2'
   Serialization Examples
        # a, b -- AND
        - a
        - b
        # [a, b] -- OR
        -
          - a
          - b
        # { a => "> 2" } -- VERSIONED
        a: > 2
        # { a => 1 } -- VERSIONED
        a: 1
        # \[ ... ]  -- GROUPING
        - !perl/ref:
          =:
            - ...
        Jos Boumans <kane@cpan.org>
        Audrey Tang <audreyt@audreyt.org>
        Florian Ragwitz <rafl@debian.org>
    Synopsis 22: Distributions, Recommendations, Delivery and Installation
        Created: 15 March 2014
        Last Modified: 27 September 2015
        Version: 6
TERMINOLOGY
    Because many of the concepts used in this document may be overloaded by
    other concepts in the mind of the reader, it seems like a good idea to
    define some terminology first. Please note that these definitions only
    apply within the context of Perl 6.
  compilation unit
    A piece of code that can be compiled as a unit. It can either exist in a
    file (and be compiled using "use" or "require"), or be presented as a
    stream of characters for compilation with "EVAL". An example of a
    compilation unit in a file:
      lib/JSON/Fast.pm6
  distribution
    A distribution is an archive of some form that can be used to install
    zero or more compilation units (each stored in a separate file), with
    any possibly associated files needed for execution. For example:
      lib/JSON/PurePerl.pm6
    It has a name for identification, which may or may not coincide with the
    compilation units in the distribution. An example of a distribution
      JSON-Fast
    It also has a version, to distinguish it from other distributions with
    the same name. For instance:
      1.23
    Which, together, are used to create the filename of the distribution,
    for instance:
      JSON-Fast.1.23.tar.gz
    Please note that by changing the "::" from the module specification to a
    "-" for the filename of the archive, we are effectively disallowing an
    owner to upload a distribution for "JSON-Fast" and "JSON::Fast" at the
    same time. This seems unlikely to become a problem.
    A Perl 6 distribution must contain a configuration file named
    "META6.json", containing JSON-encoded information about the contents of
    the distribution.
  owner
    The owner of a distribution is responsible for the development of a
    distribution. This can either be a single person, or a (semi-)official
    organisation. The owner of a distribution has a (mnemonic) name, e.g.:
      JRANDOM
    Please note that the owner is not necessarily the developer of a
    distribution, although if the owner is a single individual, this is
    pretty likely.
  content storage
    A service to which an owner can upload a distribution to and other
    people can download specific distributions from. This is most likely
    some online web-service, but it does not need to be. It has a logical
    name that is essentially a URL. An example would be:
      cpan
    The (mnemonic) name of the owner usually coincides with the userid or
    login name used to upload distributions, but does not need to be.
  auth
    The "auth" of a distribution, is the combination of the content storage
    name with the name of the owner, separated by a colon. For example:
      cpan:JRANDOM
    Please note that this is not an authority, merely an indication of the
    location where the distribution for that owner was obtained. Typically
    the auth of a distribution is used to try to load compilation units of
    already installed distributions, such as in:
      use JSON::Fast:auth<cpan:JRANDOM>;
  identity
    The identity of a distribution, is the combination of name of the
    content storage, the name of the owner, name and version of a
    distribution, separated by colons. For example:
      cpan:JRANDOM:JSON-Fast:1.23
    There should really be only one unique distribution for a given identity
    in the world.
    The content storage should accept an identity and either directly return
    the archive for that distribution, or return a URL from which that
    distribution can be downloaded.
  recommendation manager
    A service that will translate a request for a compilation unit (with
    optional owner and/or version and/or content storage specification, like
    a "use" statement) into a list of zero or more identities of
    distributions that match the request.
    The recommendation manager is only used during the installation process
    of the distribution for a wanted compilation unit.
    A recommendation manager can be run by a community (like the current
    Perl 6 ecosystem or the packages list for Perl 5 on CPAN), or by company
    (for use inside the company itself), or by any reviewing / grading
    service (for use by anybody wanting to use that service), or by any
    other person willing to put in the effort.
    A request for:
      JSON::PurePerl
    would yield the identity:
    because the compilation unit "JSON::PurePerl" is part of the
    "JSON::Fast" distribution.
    However, a request for:
      JSON::Fast:auth<github:JRANDOM>
    would not find anything, because it has the wrong content storage
    specification ("github" instead of "cpan").
    Please note that a recommendation manager does not need to be bound to a
    single content storage. In fact, a recommendation manager would be best
    if being able to supply identities from the best of all worlds. And
    potentially be able to recommend identities responding to more natural
    language queries, but that is probably outside the scope of this
    A bundle of distributions is basically just a collection of identities
    that listen to a name (such as "Rakudo *"). A recommendation manager may
    provide bundles as part of its service. And packagers may use this
    information as the source for bundling distributions in their specific
    packaging system.
DISTRIBUTION
    A Perl 6 distribution consists of an archive of some form (presumably a
    .tar.gz, .tar.bz2 or .zip file) which is expected to at least contain a
    file called "META6.json". The existence of this file indicates that this
    distribution is a Perl 6 distribution. This is important for those
    archive networks that also serve as a content-distribution system for
    other types of distributions (such as PAUSE / CPAN), so that they can
    adapt the processing of the contents, or decide to ignore any processing
    at all (such as CPAN-testers not being able to test Perl 6 distributions
    (yet)).
  META6.json
    The META6.json file is a JSON-file that must at least contain a "perl",
    "name", "version" and "description" section.
   meta6
    Optional. The version of the META6.json schema in use, as a quoted
    Version literal (without the "v" prefix). If omitted a default value of
    "0" is assumed, which means the file conforms to S22 version 6 (i.e.
    pre-v6.c format).
   perl
    Mandatory. The minimal perl version for which this distribution can be
    installed. Specified as a version string. So:
      "perl" : "6.d"
    would not allow installation on Perl version 6.c
   name
    Mandatory. The name identifying this distribution. This is usually the
    name of the main module that this distribution provides. An example of
    this would be:
      "name" : "JSON::Fast"
   version
    Mandatory. The version literal for this distribution. An example of this
    would be:
      "version" : "1.23"
   description
    Mandatory. A one line description of this distribution. So, for
      "description" : "Providing fast JSON encoding/decoding"
   authors
    Optional. A list of (mnemonic) names of people who work / have worked on
    this distribution. For informational purposes only. An example:
      "authors" : [
        "Janet Random",
        "Sam Helpedwithit"
      ]
    Please note that for identification purposes, only the owner (who
    uploaded the distribution to the content storage) should be used.
   provides
    Mandatory. A list of module - local filename pairs that this
    distribution makes available to be "use"d. For example:
      "provides" : {
        "JSON::Fast"     : "lib/JSON/Fast.pm6",
        "JSON::PurePerl" : "lib/JSON/PurePerl.pm6"
    Please note that the filenames specified only indicate the names of the
    files in the distribution. The installer may need to mangle filenames to
    be able support file systems that do not support the file names given
    (e.g. when they contain Unicode characters where the file system does
    not support them). This also implies that any installer needs to keep a
    local database that is able to convert from the module names given, to
    the actual associated file).
   depends
    Optional. A list of run-time dependencies, specified as "use" strings.
    To indicate alternatives, it is possible to specify a list of "use"
    strings, instead of just a single use string. So:
      "depends" : [
        "Sereal:auth<cpan:*>:ver(1..*)",
        [ "Archive::Compress", "Archive::Zlib" ]
    would indicate a dependency on Sereal, and either Archive::Compress or
    Archive::Zlib.
    An installer has the option to automatically install any dependencies,
    if the user has so indicated. Dependencies and alternatives should be
    tried in the order they are specified. In the case of alternatives, the
    first one for which the recommendation manager returns an identity
    should be installed. Failure of installation of an alternative may allow
    automatic attempts on other alternatives.
    Please note that the "use" strings of compilation units are specified.
    It is the responsibility of the recommendation manager to turn these
    into identities of distributions that can be downloaded.
   emulates
    Optional. A hash in which the key is the compunit (provided by the
    distribution) to be aliased, and the value is the use string that should
    match to get that compilation unit. An example of this would be:
      "emulates" : {
        "JSON::Fast" : "JSON::XS:auth<cpan:MLEHMANN>"
    If then later, a program would say:
      use JSON::XS;
    it would in fact load the "JSON::Fast" compunit, but make it appear as a
    "JSON::XS" compunit, but only if there was no "real" "JSON::XS" compunit
    installed that would match the "use" specification. In other words: if
    the real thing is available, then it will be used. If it is not, it will
    fall back to the indicated compilation unit. And it will look like you
    are using the thing you asked for.
    Conversely, if one would do a:
      use JSON::Fast;
    then later doing a:
      use JSON::XS:auth<cpan:MLEHMANN>;
    in the same scope would become a no-op, just as if the compunit had
    already been loaded.
    Please note that it is responsibility of the emulating compunit to
    actually provide a compatible interface with emulated compunit.
   supersedes
    Optional. Has the same meaning as "emulates" for the "CompUnitRepo". But
    has additional meaning for external packagers: it indicates a potential
    superseding of the indicated compilation unit from the packagers point
    of view. See "superseded-by".
   superseded-by
    Optional. Has the reverse meaning of "emulates" for the "CompUnitRepo".
    It is a hash in which the key is compunit provided by the distribution,
    and the value is the "use" string of the compunit it should be aliased
    to if that compunit is available. So in this case:
      "superseded-by" : {
        "JSON::Fast" : "SuperJSON:ver(v1.0 .. *)"
    it would mean that if a program attempts to load the "JSON::Fast"
    compunit of this distribution, it should instead use any "SuperJSON"
    compunit that is installed that has a version of 1.0 or higher. In other
    words: please don't use my compunit, unless you really have to.
    This tag has additional meaning for packagers: if a packager detects a
    valid "supersedes" and "superseded-by" pair in its collection of
    distributions to be packaged, the packager may decide to only supply the
    distribution providing the "superseded-by" compilation unit.
    Please note that "superseded-by" has no meaning as a "depends", so an
    installer should probably not automatically install any "superseded-by"
    compunits.
   excludes
    Optional. A hash in which the key is a compilation unit provided by this
    distribution, and the value is a "use" string of all compilation units
    that will be disallowed when attempted to be loaded in the same lexical
    scope. An example of this would be:
      "excludes" : {
        "JSON::PurePerl" : "JSON::Slow:auth<cpan:*>:ver(1..*)"
    So, if a lexical scope loads "JSON::PurePerl" from this distribution,
    then attempting to load "JSON::Slow" will cause a Failure. Please note
    that this has no meaning for packagers: it is simply a way to provide a
    better error message if a collision of some sort will occur when both
    modules are loaded in the same lexical scope.
   build-depends
    Optional. A list of build-time dependencies, specified as "use" strings.
    An example of this would be:
      "build-depends" : [
        "Archive::Zip"
   test-depends
    Optional. A list of test-time dependencies, specified as "use" strings.
      "test-depends" : [
        "Test:auth<cpan:OVID>"
   resources
    Optional. A list of file names, each of them corresponding to a file in
    the "resources" directory in the distribution. At build time any not-yet
    existing files should be created. The installer will install all files
    into a location at its discretion (taking care of file-system
    case-insensitivity and Unicode-support issues), and make the files
    available through the "%?RESOURCES" hash.
   support
    Optional. A hash of key-value pairs regarding support for this
    distribution. Possible names are: "email", "mailinglist", "bugtracker",
    "source", "irc", "phone".
    email
        The email address of the owner of this distribution, if any.
    mailinglist
        The mailinglist of users of this distribution, if any.
    bugtracker
        The bugtracker of this distribution, if any.
    source
        The URL of the source of this distribution, if any.
    irc The URL of the IRC channel where this distribution can be discussed,
        if any.
    phone
        A fully qualified phone number (with potential cost indication) that
        can be used with queries about this distribution.
   production
    Optional. A Boolean to indicate whether or not this is a distribution
    intended to be used in production. For instance:
      "production" : true
    By default, a distribution is not ready for production. If a
    distribution is not ready for production, then it will never be
    recommended.
    Please note that this section is only to be used by installers, giving
    them the opportunity to decide whether or not to install that
    distribution. Once a distribution is installed, it can be loaded just
    like any other distribution.
   license
    Optional. The URL with the text of the license under which this
    distribution is available for installation. Or some other way to
    indicate the license, e.g. inspired by the Perl 5 module
    Software::License.
      "license" : "http://www.gnu.org/licenses/gpl-1.0.html"
   tags
    Optional. A list of general purpose tags. For instance:
      "tags" : [
        "json",
        "perl6"
    It has no meaning other than the meaning you assign to it.
  Special directories
    A distribution may contain several directories that will be handled
    specially.
   bin
    Any file inside this directory, will be installed as a callable shell
    application.
   t
    All ".t" files in this directory, will be tested in alphabetical order,
    possibly in parallel.
   hooks
    All files in this directory should contain executable Perl 6 code, to be
    executed at various stages of the install process of this distribution.
  Installation
    Distributions can be installed with an installer. This may be a
    command-line script, or be some kind of GUI. The installer needs the
    user to (implicitly) select the "CompUnitRepo" in which the distribution
    should be installed, and the recommendation manager that should be used
    to convert requests for a compilation unit into an identity of a
    distribution to be downloaded.
CLASSES
  CompUnitRepo
    Base class (interface, really) for the object living in the "@?INC"
    array. Used both for installing compunits, as well as finding a certain
    compunit by way of its from, longname, auth and ver information.
   Specifying a CompUnitRepo
    The specification of a CompUnitRepo can happen at various places: in a
    configuration file, on the command-line when starting (with "-I"), and
    in code when trying to create a CompUnitRepo object programmatically.
    Each specification consists of a CompUnitRepo class specification
    (either explicitly, implicitly, or the short-hand form using the
    "short-id" identifier), optional named parameters and a location
    indicator (usually a path or a URL).
    Some examples (where CURL is short for CompUnitRepo::Local):
      /foo/bar                    simple CURL::File in /foo/bar
      file#/foo/bar               (same)
      inst#/installed             simple CURL::Installation in /installed
      inst#name<work>#/installed  (same) but also set %?CUSTOM_LIB<work>
      inst#name[work]#/installed  (same) but more CLI-friendly
      inst#name{work}#/installed  (same) alternate CLI-friendly way
      CompUnitRepo::Local::Installation#/installed  (same) but with full class name
      CompUnitRepo::GitHub#masak/html-template      get it from GitHub
    Multiple specifications may be concatenated with ",". If no class is
    specified on subsequent specifications, then the previous class
    specification will be assumed. So:
      /foo/bar,/foo/baz           both use CURL::File
      inst#/installed,/also       both use CURL::Installation
      /foo/bar,inst#/installed    first CURL::File, second CURL::Installation
   new
      my $repo = CompUnitRepo.new( $specification );
    Create a new CompUnitRepo-like object with the given specification,
    either for inclusion in "@?INC", or to install a distribution. Returns
    the instantiated object.
    Please note that for a given "specification", there should always only
    be one "CompUnitRepo" object in a process.
   short-id
      say CompUnitRepo::Local::File.short-id;   # "file"
    Returns a short "\w+" identifier string (a "tag" if you will) to
    identify the use of this repo, e.g. in strings provided with the "-I"
    command line parameter. It should be unique for all of the CompUnitRepo
    subclasses loaded. The following "short-id"'s are pre-defined:
      file   CompUnitRepo::Local::File
      inst   CompUnitRepo::Local::Installation
   install
      my $installed = $repo.install( $dist );
    Install the compilation units of a "Distribution" in the appropriate way
    for this CompUnitRepo-like object. May cause a fatal exception if this
    repository does not support installing. The parameter contains the
    "Distribution" object to be installed. Returns True if the distribution
    was installed, or a "Failure" if it didn't.
    Of course, any implementation of CompUnitRepo's "install" interface, may
    decide to accept additional meta-information and store this and make
    available for later introspection.
   uninstall
      my $removed = $repo.uninstall( $dist );
    The opposite of "install".
   candidates
      my @candidates = $repo.candidates( $longname, $auth?, $ver?, $from? );
    Return CompUnit candidates given the matching credentials.
  CompUnitRepo::Local::File
    The simplest, default case for locating compilation units on a file
    system. The module name specified should directly map to a file, similar
    to how Perl 5 this does. Mainly intended to be used in development
    situations to allow developers to have modules to be available without
    them having to be installed.
    Will fail unconditionally: installing compilation units is done by
    putting files in the right location.
  CompUnitRepo::Local::Installation
    The default case for installed compilation units. Similar to the way
    Perl 5 installs modules, but with meta-information per object, rather
    than globally in a "packlist". This should be used by installers such as
    "panda".
    Install the given "Distribution" object in this repo.
  Distribution
    The class for installing distributions using
    "CompUnitRepo::Local::Installation". Basically provides the API to
    access the "META6.json" file of a distribution. It should at least
    contain the following methods:
   meta
      my $meta = $dist.meta;
    Return a Hash with the representation of the meta-data, constructed the
    same way as in the "META6.json" specification. Please note that an
    actual META6.json file does not need to exist, just a representation in
    that format.
   content
      my $content = $dist.content( <provides JSON::Fast lib/JSON/Fast.pm6> );
      my $content = $dist.content( <resource images fido.png> );
    Return the octet-stream as specified by the given keys, navigating
    through the "META6.json" hash.
  Distribution::Local::Tar
    An implementation of the "Distribution" API for locally stored ".tar"
    files.
  CompUnit
    The object that describes a compilation unit. Contains as much meta-data
    as possible, e.g. from the "Distribution" object it came from.
      my $compunit = CompUnit.new( $path );
    Create a new CompUnit object with the given specification. Returns the
    instantiated object, or "Failure" if it could not find the "path".
    Please note that for a given "path", there should always only be one
    "CompUnit" object in a process. This to prevent reloading the same
    compilation unit more than once.
   load
      my $loaded = @candidates[0].load(...);
    Returns True if loading of the "CompUnit" was successful, or a "Failure"
    if something went wrong.
   loaded
      my $loaded = $compunit.loaded;
    Return whether the compunit has been loaded.
   precomp
      my $precompiled = $compunit.precomp;
    Create a pre-compiled version of the CompUnit. Optionally takes an
    output file argument (default: the same path as the source, with an
    extension identifying it is a precompiled version), an optional named
    argument ":INC" (with default "@?INC") and an optional named argument
    ":force" to force creation even if the output file already exists.
SYSTEM VARIABLES
    Several dynamic variables are available.
  %?RESOURCE
    This hash provides compile and runtime access to files associated with
    the "Distribution" of the current compilation unit.
    So, if the "META6.json" file contains this "resource" section:
      "resource" : {
        "images" : [
          "fido.png", "zowie.png"
        ],
        "libraries" : {
          "inline_helper" : "build-time",
    then the "Distribution" is supposed to contain the files
    "resource/images/fido.png" and "resource/images/zowie.png". After
    installation, IO objects of such a file would be available through
      %?RESOURCE<images><fido.png>
    The absolute path could be obtained with:
      %?RESOURCE<images><fido.png>.abspath
    and a handle could be obtained with:
      %?RESOURCE<images><fido.png>.open
    without there being any guarantee that this path has anything to do with
    the path as specified in the distribution. Please also note that the
    installer will probably mangle filenames of actually installed files.
    This means you can have files with Unicode characters in upper/lower
    case, and still be able to access them when installed on a file system
    that does not support Unicode.
    If a leaf of the "resource" hash is a hash, it indicates files with
    special properties (such as being provided by the builder, so not part
    of the distribution). This will allow a good MANIFEST to be created from
    the META6.json information.
  %?CUSTOM_LIB
    This hash provides key/value pairs of "CompUnitRepo" specifications, to
    be used by packagers and/or installers.
  @?INC
    This array contains the "CompUnitRepo" objects that will be queried in
    turn whenever an attempt should be made to load a compilation unit (be
    that at compile time with "use", or at runtime with "require".
    The first "CompUnitRepo" object to return one candidate, will then be
    loaded and no further "CompUnitRepo" objects in "@?INC" will be queried.
    If the first "CompUnitRepo" object to return "any" candidates, returns
    more than one candidate, then all other "CompUnitRepo" objects in
    "@?INC" will also be queried, to allow any error message to present a
    full list of "CompUnit" candidate objects.
    Synopsis 24: Testing
        Created: 30 Dec 2010
        Last Modified: 14 August 2014
        Version: 8
        use Test;
        plan 6; # not needed when using "done"
        ok True, 'True is a true value';
        nok False, 'False is a false value';
        is 'ab'.uc, 'AB', 'successful string comparison';
        diag "we may have some mathematical issues"
          if !is-approx 2.sqrt, 1.4142135623, 'Approximate numeric comparison';
        dies-ok { die "yes"}, 'exceptions';
        dies-ok '1 1', 'two terms in a row are a parse error';
        done;  # not needed when doing "plan"
    Perl 6 comes with a standard testing module, "Test". It is the testing
    module used by the official spectest suite.
    The testing functions emit output conforming to the Test Anything
    Protocol. See <http://testanything.org>.
    For the purposes of this document, a *test file* is a file that does
    "use Test".
    All of the following functions are exported by default:
        # planning number of tests
        plan($number-of-tests)
        done()
        # unconditional passing/failing/notification
        pass($desc?)
        flunk($desc?)
        diag($desc)
        # skipping
        todo($reason, $count = 1)
        skip($reason, $count = 1)
        skip-rest($reason?)
        # evaluates $cond in boolean context
        ok(Mu $cond, $desc?)
        nok(Mu $cond, $desc?)
        # comparisons
        is(Mu $got, Mu $expected, $desc?)
        isnt(Mu $got, Mu $expected, $desc?)
        cmp-ok(Mu $got, $op, Mu $expected, $desc?)
        # structural comparison with infix:<eqv>
        is-deeply(Mu $got, Mu $expected, $desc?)
        # numeric comparison with 1e-5
        is-approx(Mu $got, Mu $expected, $desc?)
        # class membership testing
        isa-ok(Mu $var, Mu $type, $desc?)
        # grouping of tests, ok only if all ok
        subtest(&subtests, $desc?)
        # exception testing
        dies-ok($code, $desc?)
        lives-ok($code, $desc?)
        throws-like($code, $exception-type, $desc?, *%matcher)
Test plans
        sub plan($number-of-tests) is export { ... };
        sub done() is export { ... };
    In order to determine whether a test file ran all its tests, a "plan()"
    function call can be made somewhere in the test file, providing a count
    of the total number of tests. A TAP harness can then flag an error
    condition when the number of tests actually run doesn't match.
    If "plan()" isn't called, "done()" can be called at the end of the test
    file to output an automatically computed tally.
    A TAP harness will consider it an error if neither "plan()" nor "done()"
    was called, or if there was more than one call in the test file, or if
    the call occurred between calling two test functions (rather than at the
    beginning or at the end).
Test functions
    All test functions take an optional description argument, which will be
    printed along with the "ok" or "not ok" result and the test number. Note
    that what is displayed as optional parameters in the list below might as
    well be implemented by some other mechanism, such as several "multi
    sub"s. Such details are left as implementation-dependent.
    The names of positional parameters are non-normative, so supplying the
    positional arguments to these test files by name is discouraged.
  pass(), flunk()
        sub pass($desc?) is export { ... }
        sub flunk($desc?) is export { ... }
    The "pass()" function marks a test as passed. The "flunk()" function
    marks a test as not passed.
  diag()
        sub diag($message) is export { ... }
    The "diag()" function allows specific diagnostic information to be
    printed in a TAP-compatible manner on $*ERR. It is usually used when a
    particular test has failed to provide information that the test itself
    did not provide. Or it can be used to provide visual markers on how the
    testing of a test-file is progressing (which can be important when doing
    stress testing).
  todo(), skip(), skip-rest()
        sub todo($reason, $count = 1) is export { ... }
        sub skip($reason, $count = 1) is export { ... }
        sub skip-rest($reason?) is export { ... }
    The "todo()" function can be called before running other test functions,
    and marks the next $count tests as TODO.
    The "skip()" function is called *instead* of the some tests (usually
    because they would die), and emits $count SKIP markers in the TAP
    output.
    The "skip-rest()" function can be called conditionally to
    "skip($remaining)" all of the remaining tests.
    The "todo()" and "skip()" functions are generally automatically
    generated by some sort of source code fudging program.
  ok(), nok()
        sub ok(Mu $cond, $desc?) is export { ... }
        sub nok(Mu $cond, $desc?) is export { ... }
    The "ok()" function marks a test as passed if the given condition
    evaluates to "True". The "nok()" function marks a test as passed if the
    given condition evaluates to "False".
  is(), isnt(), cmp-ok()
        sub is(Mu $got, Mu $expected, $desc?) is export { ... }
        sub isnt(Mu $got, Mu $expected, $desc?) is export { ... }
        sub cmp-ok(Mu $got, $op, Mu $expected, $desc?) is export { ... }
    The "is()" function marks a test as passed if the obtained and expected
    values are the same. If $expected is a type object, then $got is
    compared using "===". If $expected is a defined value, then $got is
    compared using "eq". The "isnt()" function marks a test as passed if the
    obtained and expected values are not the same (using the same logic as
    with "is()").
    The "cmp-ok()" function compares two values with the given operator and
    passes the test if the comparison yields a "True" value. For ease of
    use, operators may be passed as strings, such as '==' or '~~'. Note that
    you can also pass a custom operator, for special types of comparisons.
    These functions are typically used to check scalar values.
  is-deeply()
        sub is-deeply(Mu $got, Mu $expected, $desc?) is export { ... }
    The "is-deeply()" function marks a test as passed if the obtained and
    expected values are "eqv". This is the best way to check for equality of
    (deep) data structures.
  is-approx()
        sub is-approx(Mu $got, Mu $expected, $desc?) is export { ... }
    The "is-approx()" function marks a test as passed if the obtained and
    expected numerical values are within 1e-5 of each other.
  isa-ok()
        sub isa-ok(Mu $object, Mu $type, $desc?) is export { ... }
    The "isa-ok()" function marks a test as passed if the given object is,
    or inherits from the given type. For convenience, types may also be
    specified as a string.
  subtest()
        sub subtest(&subtests, $desc?) is export { ... }
    The "subtest()" function executes the given block, consisting of usually
    more than one test, possibly including a "plan()" or "done()". It will
    pass the test only if all tests in the block, pass.
  dies-ok(), lives-ok(), throws-like()
        sub dies-ok(Callable $code, $desc?) is export { ... }
        sub lives-ok(Callable $code, $desc?) is export { ... }
        sub throws-like($code, $exception-type, $desc?, *%matcher) is export { ... }
    The "dies-ok()" passes the test if the given code throws an exception.
    The "lives-ok()" passes the test if the given code does not throw an
    The "throws-like()" function checks whether the given code (specified as
    either something "Callable", or as a something to be "EVAL"led) throws a
    specific exception (either specified as a Type object, or as a string).
    If an exception was thrown, it will also try to match the matcher hash,
    in which the key is the name of the method to be called on the
    exception, and the value is the value it should have to pass.
    Please note that you can only use the "EVAL" form if you are not
    referencing any symbols in the surrounding scope. If you are, you should
    encapsulate your string with a block and an EVAL. For instance:
        throws-like { EVAL q[ fac("foo") ] }, X::TypeCheck::Argument;
    [DRAFT] Synopsis 28 - Special Names [DRAFT]
        Created: 23 Feb 2009, created by Tim Nelson from miscellaneous documents lying around
        Last Modified: 8 September 2014
Special Variables
  Introduction
    This document serves as a collection point for what is known about
    special variables in Perl 6 and correlates them with the changes from
    Perl 5.
    If you are trying to find the Perl 6 equivalent of a Perl 5 special
    variable you know, try searching this file for the Perl 5 version. Each
    main entry is followed by a note containing the corresponding Perl 5
    variable(s). The list of main entries is also followed by a table
    showing the 5 and 6 variables side-by-side.
  Overview
   Secondary Sigils (also known as "twigils")
    A quick reminder of the relevant twigils from S02:
        $?foo   # Compiler constants (fixed at compile time)
        $*foo   # Context variable, default global (run time)
        $=foo   # File-scoped Pod data
    The various "$?foo" variables are determined at compile time, and are
    not modifiable at run time. This does not mean that the variable has the
    same value everywhere; for instance, "$?LINE" is different on every line
    of the program.
    The $*foo variables function both as dynamically scoped variables and as
    globals. Globalness is relative, in other words. Any dynamic scope may
    modify the set of globals visible via the $*foo notation. Most of the
    standard globals listed below actually live either in the "PROCESS" or
    the "GLOBAL" package, where "PROCESS" contains globals belonging to the
    entire process, while "GLOBAL" contains the globals belonging to the
    current interpreter, since a process may be running more than one
    interpreter. Unless otherwise indicated below, the outermost definition
    of these variables are kept in the "PROCESS" package.
    Please note that an implementation may decide to populate these
    variables lazily on the first access to <$*foo>. So checking for
    existence of these variables in the "PROCESS" or "GLOBAL" package may
    give a false negative.
    The "$=foo" variables are related to the "$?foo" variables insofar as
    the text of the program is known at compile time, so the values are
    static. However, the different twigil indicates that the variable
    contains Pod data, which is primarily under user control rather than
    compiler control. The structure of these variables will be fleshed out
    in S26.
   Named variables
     Variable          Spec  Type         Description
     --------          ----  ----         -----------
     @_                                   # ??? (FIX)
     $!                S04                # Current Exception object
     $/                S05   Match        # Last match
     $0, $1, $2        S05   Str          # First captured value from match: $/[0]
     @*ARGS            S06   Array of Str # command-line arguments
     $*ARGFILES        S02   IO::Handle   # The magic command-line input handle
     &?BLOCK           S06   Block        # current block (itself)
     ::?CLASS          S12   Class        # current class
     $?CLASS           S02   Class        # current class
     @=COMMENT        (S26)               # All the comment blocks in the file
     %?CONFIG                Hash of XXX  # configuration hash XXX What does this do?
     $*CWD             S16   IO::Path     # current working directory
     $=data           (S26)  IO           # data block handle (=begin data ... =end)
     %?DEEPMAGIC       S13   Hash of XXX  # Controls the mappings of magical names to sub definitions
     $?DISTRO          S02   Systemic     # Which OS distribution am I compiling under
     $*DISTRO          S02   Systemic     # Which OS distribution am I running under
     $*EGROUP                +Int,~Str    # effective $*GROUP
     %*ENV             S02   Hash of Str  # system environment variables
     $*ERR             S16   IO::Handle   # Standard error handle
     $*EUSER                 +Int,~Str    # effective $*USER
     $?COMPILER              IO::Path     # location of the compiler executable
     $*SHEBANG               IO::Path     # location of the interpreter executable (usually eqv $?COMPILER)
     $?FILE            S02   Str          # current filename of source file
     $?GRAMMAR         S02   Grammar      # current grammar
     $*GROUP                 +Int,~Str    # group id (numeric) or name (string)
     $*IN              S16   IO::Handle   # Standard input handle; is an IO object
     @?INC             S11                # where to search for user modules (but not std lib!)
     %?LANG            S02   Hash of Grammar # What is the current set of interwoven languages?
     $*LANG            S02   Str          # LANG variable from %*ENV that defines what human language is used
     $?LINE            S02   Int          # current line number in source file
     %*META-ARGS       S19   Hash of XXX  # Meta-arguments
     $?MODULE          S02   Module       # current module
     %*OPTS            S19   Hash of XXX  # Options from command line
     %*OPT...          S19   Hash of XXX  # Options from command line to be passed down
     $?KERNEL                Systemic     # operating system compiled for
     $*KERNEL                Systemic     # operating system running under
     $*OUT             S16   IO::Handle   # Standard output handle
     $?PACKAGE         S02   Package      # current package
     $?PERL            S02   Systemic     # Which Perl am I compiled for?
     $*PERL            S02   Systemic     # perl version running under
     $*PID                   Int          # system process id
     $=pod             S02                # POD6 data
     $*PROGRAM         S19   IO::Path     # location of the Perl program being executed
     %*PROTOCOLS       S16   Hash of Method # Stores the methods needed for the uri() function
     ::?ROLE                 Str          # current role (as package or type name)
     $?ROLE            S02   Role         # current role
     &?ROUTINE         S06   Routine      # current sub or method (itself)
     $?SCOPE           S02                # Current "my" scope (XXX unnecessary?)
     $*TMPDIR          S16   IO::Path     # system temporary directory
     $*TZ              S32                # Local time zone
     $?USAGE           S06   Str          # Default usage message generated at compile time
     $*USER                  +Int,~Str    # user id (numeric) or name (string)
     $?VM              S02   Systemic     # Which virtual machine am I compiling under
     $?XVM             S02   Systemic     # Which virtual machine am I cross-compiling for
    Note that dynamic variables such as $*OUT may have more than one current
    definition in the outer dynamic context, in which case the innermost
    dynamic scope in which it is defined determines the meaning. For
    instance, $PROCESS::OUT is the stdout for the entire process, but each
    interpreter can set its own $GLOBAL::OUT to make $*OUT mean whatever it
    wants independently of other interpreters. Any dynamic scope may also
    declare a local meaning of $*OUT that applies only to called code.
    Likewise each thread could log its own errors to its own $*ERR, since a
    thread is a dynamic scope.
    The "Systemic" role collects a few common features of some of the
    special variables such as $*PERL, "$?VM", $*KERNEL, etc. It in turn
    relies on the "Universal" role that all cosmically unique entities must
    support in order to have a unique name.
        role Universal {
            has Str $.name;
            has Str $.auth;
            has Version $.version;
            has Blob $.signature;  # optional?
        role Systemic does Universal {
            has $.desc;   # uname-ish version-like information goes here
   Perl 5 to Perl 6 special variable translation
    If a column has a "-" in it, it means that item is unavailable in that
    version of Perl.
     Perl 5              Perl 6         Comment
     -----------         -----------    -----------------------
     STDIN               $*IN           See S16; actual variable is $PROCESS::IN
     STDOUT              $*OUT          See S16; actual variable is $PROCESS::OUT
     STDERR              $*ERR          See S16; actual variable is $PROCESS::ERR
     $_ $ARG             $_             More lexically aware
     $_[1],$_[2]..       $^a,$^b..
     $a,$b               -              No special meaning whatsoever
     -                   $/             Object with results of last regex match
     $1,$2,$3...         $0,$1,$2...    Match capture variables start at 0
     $& $MATCH           ~$/
     $` $PREMATCH        substr based on $/.from
     $' $POSTMATCH       substr based on $/.to
     $+                  -              But info can now be retrieved from $/
     $^N                 $*MOST_RECENT_CAPTURED_MATCH  ...or some such.
                           or $/[*-$n]                       ...or omit
     @-                  $1.from, etc
     @+                  $1.to, etc.
     %!                  -
     $[                  -              This feature has been removed
     $*                  -              Deprecated long ago
     $#                  -              Deprecated long ago
     $^H                 -              These were only ever internal anyway
     %^H                 -
     -                   $!             Current exception (see L<S04>)
     $! $ERRNO $OS_ERROR -              Use shiny new $!
     $?  $CHILD_ERROR    -              Use shiny new $!
     $@  $EVAL_ERROR     -              Use shiny new $!
     $^E                 -              Use shiny new $!
     $^S                 -
     $. $NR              $*IN.ins()
     $/ $RS              $*IN.input-line-separator()
     $|                  $*OUT.autoflush()
     $, $OFS             $*OUT.output-field-separator()
     $\                  $*OUT.output-record-separator()
     $" $LIST_SEPARATOR  -
     $; $SUBSEP          -
     $$ $PID             $*PID
     $< $UID             $*UID          Real UID (User ID)
     $( $GID             $*GID          Real GID (Group ID)
     $> $EUID            $*EUID         Effective UID
     $) $EGID            $*EGID         Effective GID
     $0 $PROGRAM_NAME    $*PROGRAM-NAME
     $^C $COMPILING      $*COMPILING
     $^D $DEBUGGING      $*DEBUGGING
     $^F $SYS_FD_MAX     $*SYS_FD_MAX   ...or some such
     $^I $INPLACE_EDIT   $*INPLACE_EDIT ...or some such
     $^M                 $*EMERGENCY_MEMORY ...or some such (or omit)
     $^O $OSNAME         $*KERNEL.name (or $*DISTRO.name or $*VM.name)
     $^P $PERLDB         $*PERLDB       ...or some such
     $^R                 $*LAST_REGEXP_CODE_RESULT   ...or some such. Or omit.
     $^T $BASETIME       $*INITTIME     A Temporal::Instant object
     $^V $]              $?PERL.version
     $^W                 $*WARNINGS (if any dynamic control needed)
     ${^WARNING_BITS}    $?WARNINGS
     $^X                 $?COMPILER or $*SHEBANG (plus stringification)
     ARGV                $*ARGFILES     Note the P6 idiom for this handle:
                                        for lines() {
                                          # each time through loop
                                          # proc a line from files named in ARGS
                                        }
     @ARGV               @*ARGS
     ARGVOUT             TBD
     $ARGV               TBD
     @F                  @_
     %ENV                %*ENV
     @INC                @?INC (but not for std library modules)
     %INC                no equivalent, encapsulated in CompUnitRepo object
     %SIG                event filters plus exception translation
     $SIG{__WARN__}      $*ON_WARN
     $SIG{__DIE__}       $*ON_DIE
     ${^OPEN}            -              This was internal; forget it
  SPECIAL VARIABLES MORE IN DEPTH
   $?KERNEL / $*KERNEL
    Contains a "Kernel" class instance that does "Systemic". It further
    provides the following methods:
    release
        The release information of this kernel.
    arch
        Processor architecture.
    bits
        Number of bits used by architecture (typically 32 or 64 bits).
    hardware
        The processor hardware, if known.
    signals
        An "Array" of "Signal"s that are supported by this "Kernel", in
        which the ordinal number matches the lower level signal value.
    signal
          my $int = $*KERNEL.signal(SIGHUP);
          my $int = $*KERNEL.signal("HUP"); # or "SIGHUP"
          my $int = $*KERNEL.signal(1);     # just pass through for bare Ints
        Convert the given "Signal" Enum value, or a string representing that
        signal, to the internal value that this "Kernel" uses to send to a
        process.
   $?DISTRO / $*DISTRO
    Contains a "Distro" class instance that does "Systemic". It further
        The release information of this distribution.
    is-win
        True if this is a Windows-like distribution.
    path-sep
        The character that is used to separating paths in specifications,
        usually in environment variables such as "PATH".
   $?VM / $*VM
    Contains a "VM" class instance that does "Systemic". It further provides
    the following methods:
    config
        The configuration hash that was used to build the virtual machine.
    precomp-ext
        The extension used by pre-compiled module files.
    precomp-target
        The name of the compilation stage to produce pre-compiled module
        files (typically used as "--target=xxx").
   $?PERL / $*PERL
    Contains a "Perl" class instance that does "Systemic". It further
    VMnames
        A list of "$?VM.name" / "$*VM.name" values known.
    DISTROnames
        A list of "$?DISTRO.name" / "$*DISTRO.name" values known to have
        been seen with the current "$?VM.name" / "$*VM.name".
    compiler
        Contains a "Compiler" class instance that does "Systemic". It
        further provides the following methods:
        release
            The release information of this version of Perl.
        build-date
            The "DateTime" this version of Perl was built.
        codename
            The codename of this version of Perl.
  NOT YET DEFINED
    The following items are not yet defined, but will need to be defined.
    XXX Don't remove this line until this section is completely blank.
    The $?LANG and $*LANG variables are also confusing (both in S02).
   Form.pm
    These go in the Perl 5 to Perl 6 conversion table:
     Perl 6  Perl 5
     ------  -----------------------------------------
     -       $%  $FORMAT_PAGE_NUMBER
     -           HANDLE->format_page_number(EXPR)
     -       $=  $FORMAT_LINES_PER_PAGE
     -           HANDLE->format_lines_per_page(EXPR)
     -       $-  $FORMAT_LINES_LEFT
     -           HANDLE->format_lines_left(EXPR)
     -       $~  $FORMAT_NAME
     -           HANDLE->format_name(EXPR)
     -       $^  $FORMAT_TOP_NAME
     -           HANDLE->format_top_name(EXPR)
     -       $:  $FORMAT_LINE_BREAK_CHARACTERS
     -           IO::Handle->format_line_break_characters
     -       $^L $FORMAT_FORMFEED
     -           IO::Handle->format_formfeed
     -       $^A $ACCUMULATOR
   S15-unicode.pod
    ${^ENCODING} variable -- S32/Str.pod implies this is $?ENC $?NF --
    Unicode normalization form ${^UNICODE} variable
   Infectious trait spec
    ${^TAINT} variable, which is pending, among other things, infectious
    trait spec
    Synopsis 29: Builtin Functions
        Created: 12 Mar 2005
        Last Modified: 24 April 2015
        Version: 63
    In Perl 6, all builtin functions belong to a named package (generally a
    class or role). Not all functions are guaranteed to be imported into the
    CORE scope. In addition, the list of functions imported into "CORE" will
    be subject to change with each release of Perl. Authors wishing to
    "Future Proof" their code should either specifically import the
    functions they will be using, or always refer to the functions by their
    full name.
    After 6.0.0 comes out, global aliases will not be removed lightly, and
    will never be removed at all without having gone through a deprecation
    cycle of at least a year. In any event, you can specify that you want
    the interface for a particular version of Perl, and that can be emulated
    by later versions of Perl to the extent that security updates allow.
    Where code is given here, it is intended to define semantics, not to
    dictate implementation.
  Operators vs. Functions
    There is no particular difference between an operator and a function,
    but for the sake of documentation, only functions declared without
    specifying a grammatical category or with a category of "term:" (see
    "Bits and Pieces" in S02) will be described as "functions", and
    everything else as "operators" which are outside of the scope of this
    document. (See S03 for operators.)
  Multis vs. Functions
    In actual fact, most of the "functions" defined here are multi subs, or
    are multi methods that are also exported as multi subs. The Setting is
    responsible for importing all the standard multi subs from their various
    packages into the CORE lexical scope. See S02.
Type Declarations
    The following type declarations are assumed:
    Matcher
         subset Matcher of Mu where * !=== any(Bool,Match,Nil)
        Used to supply a test to match against. Assume "~~" will be used
        against it. Booleans are forbidden because they almost always
        indicate a programming error where the argument has been evaluated
        too soon against the wrong $_. For instance:
            grep $_ == 1, 1,2,3;        # evaluating wrong $_, so forbidden
            grep { $_ == 1 }, 1,2,3;    # okay
            grep * == 1, 1,2,3;         # okay
    Ordering
         subset KeyExtractor of Code where { .signature === :(Any --> Any) };
         subset Comparator   of Code where { .signature === :(Any, Any --> Int ) };
         subset OrderingPair of Pair where { .left ~~ KeyExtractor && .right ~~ Comparator };
         subset Ordering where Signature | KeyExtractor | Comparator | OrderingPair | Whatever;
        Used to handle comparisons between things. Generally this ends up in
        functions like "sort()", "min()", "max()", etc., as a $by parameter
        which provides the information on how two things compare relative to
        each other.
        Comparator
            A closure with arity of 2, which for ordering returns
            negative/zero/positive, signaling the first argument should be
            before/tied with/after the second. aka "The Perl 5 way".
            For equivalence the closure returns either not 0 or 0 indicating
            if the first argument is equivalent or not to the second.
        KeyExtractor
            A closure with arity of 1, which returns the "key" by which to
            compare. Values are compared using "cmp" for orderings and "eqv"
            for equivalences, which in Perl 6 do different comparisons
            depending on the types. (To get a Perl 5 string ordering you
            must compare with "leg" instead.)
            Internally the result of the KeyExtractor on a value should be
            cached.
            Note that it is very easy to generate a simple "KeyExtractor"
            using "~*" for strings and "+*" for numbers, since with most
            simple operators "*" returns a closure of one argument.
                @sorted = sort +*, @unsorted;  #ascending numeric
                @sorted = sort -*, @unsorted;  #descending numeric
        OrderingPair
            A combination of the two methods above, for when one wishes to
            take advantage of the internal caching of keys that is expected
            to happen, but wishes to compare them with something other than
            "eqv" or "cmp", such as "<=>" or "leg".
            If a signature is specified as a criterion, the signature is
            bound to each value and then each parameter does comparisons in
            positional order according to its type, as modified by its
            traits. Basically, the system will write the body of the key
            extraction and comparison subroutine for you based on the
            signature.
            For ordering the list of positional parameter comparisons is
            reduced as if using [||] but all comparisons do not need to be
            performed if an early one determines an increasing or decreasing
            order. For equivalence the list is reduced as if using [&&].
        Whatever
            An ordering of "*" does the default comparison for the operator:
                @sorted = sort *, @unsorted;
  Context
    caller
        See "The "callframe" and "caller" functions" in S06.
    callframe
    EVAL
         macro EVAL ( Str|Buf $code, Grammar :$lang = CALLER::<$?PARSER>)
        Execute $code as if it were code written in $lang. If $code is of
        type "Buf", the same decoding techniques are applied as a compiler
        for $lang would usually do to input files.
        The default for $lang is the language in effect at the exact
        location of the "EVAL" call.
        Returns whatever $code returns, or fails when the compilation fails.
        Note that unlike in Perl 5's "eval", "EVAL" does not catch any
        exceptions or control exceptions.
    EVALFILE
         multi EVALFILE (Str $filename ; Grammar :$lang = Perl6)
        Behaves like, and replaces Perl 5 "do EXPR", with optional $lang
        support.
    exit
         multi exit (Int $status = 0)
        Stops all program execution, and returns $status to the calling
        environment.
        An exit runs all appropriate scope-leaving blocks such as "LEAVE",
        "KEEP", and "UNDO", followed by all "END" blocks, followed by all
        "DESTROY"s that do more than just reclaim memory, and so cannot be
        skipped because they may have side effects visible outside the
        process. If run from an embedded interpreter, all memory must also
        be reclaimed.
        Exit can also be called from an "END" block: in that case only the
        $status to be returned to the calling environment, is changed. This
        does end the execution of the END block in question, but will still
        execute any remaining "END" blocks.
        Any threads started with the ":app_lifetime" parameter (which is
        basically any asynchronous action started with primitives other than
        "Thread.new"), will be terminated on exit.
    sleep
         multi sleep ( Real $for --> Nil )
         multi sleep ( Whatever --> Nil )
        Attempt to sleep for up to $for seconds, or forever when the
        argument is "*". Implementations are obligated to support sub-second
        resolutions if that is at all possible. You may pass any of "Int",
        "Num", "Rat", or "Duration" types as an argument, since those all do
        "Real", but regardless of which type you use, they are always scaled
        to seconds. (An implementation is allowed to provide access to a
        platform-specific function based on, say, nanoseconds, but Perl 6
        does not presume to know how much resolution clocks will have in the
        future, so requires everything to be specified in fractional
        seconds.)
        This function returns nothing; use "sleep-timer" if you wish it to
        return how much time is remaining on the specified sleep. However,
        if you really just want to keep rolling over in bed until your alarm
        goes off at a particular time, use "sleep-till" instead, since it is
        not subject to relative clock drift.
        All of these sleep functions work only on the current thread.
    sleep-timer
         multi sleep-timer ( Real $for --> Duration )
        Just like "sleep", but returns the amount of time remaining to sleep
        as a "Duration" (which will be 0 if the call was not interrupted).
        Depending on the platform and the system call involved, this may or
        may not require emulation by interrogating the clock before and
        after. For those systems whose system call returns the remaining
        time, this can be more efficient than interrogating the clock twice
        yourself, However, the optimizer is encouraged to change this to a
        bare "sleep" in sink context. (But then, you might as well just
        write that in the first place.)
    sleep-till
         multi sleep-till ( Instant $till --> Bool )
        Just like "sleep", but checks the current time and goes back to
        sleep if accidentally woken up early, to guarantee waiting until the
        specified time. Returns True if the function actually waited, or if
        the specified time happens to be the present moment. Returns False
        if you asked to sleep until a time in the past.
    die
         multi die (@LIST)
        Throws a fatal Exception. The default exception handler prints each
        element of the list to $*ERR (STDERR).
    fail
         multi fail (Str $message)
        Can only be called inside a routine and causes the routine to
        "return" an unthrown exception; a "Failure" object which stringifies
        to $message. If "use fatal" is in effect where the routine was
        called from, it throws the exception.
  Conversions
    bless
         method bless(*@protos, *%init_args )
        Calling "bless" on any invocant (but typically a type object) to
        create a new object with the same class as the invocant.
        The ".bless" method takes the first positional argument indicating a
        candidate to bless. If absent, the object builder implicitly asks
        the representation what its preferred, er, representation is.
        "bless" automatically creates an object appropriate to the
        representation of the class, then calls all appropriate "BUILD"
        routines for the current class, which initializes the object in
        least-derived to most-derived order. See "Objects" in S12 for more
        detailed information on object creation.
    chrs
    ords
    chr
    ord
         multi sub chrs( Int *@grid  --> Str )
         multi method ords( Str $string: --> List of Int ) is export
         multi method chr( Int $grid: --> Str ) is export
         multi method ord( Str $string: --> Int ) is export
        "chrs" takes zero or more integer grapheme ids and returns the
        corresponding characters as a string. If any grapheme id is used
        that represents a higher abstraction level than the current lexical
        scope supports, that grapheme is converted to the corresponding
        lower-level string of codepoints/bytes that would be appropriate to
        the current pragmatic context, just as any other Str would be
        downgraded in context.
        "ords" goes the other direction; it takes a string value and returns
        character values as integers. The definition of character is pragma
        dependent. Normally it's a grapheme id, but under codepoints or
        bytes scopes, the string is coerced to the appropriate low-level
        view and interpreted as codepoints or bytes. Hence, under "use
        bytes" you will never see a value larger than 256, and under "use
        codepoints" you will probably never see a value larger than
        0x10ffff. The only guarantee under "use graphemes" (the default) is
        that the number returned will correspond to the codepoint of the
        precomposed codepoint representing the grapheme, if there is such a
        codepoint. Otherwise, the implementation is free to return any
        negative unique 32-bit id. (The "chr" function will know how to
        backtranslate such ids properly to codepoints or bytes in any
        context. Note that we are assuming that every codepoint's context
        knows its normalization preferences, and every byte's context also
        knows its encoding preferences. (These are knowable in the lexical
        scope via the $?NF and $?ENC compile-time constants).)
        The "chr" and "ord" variants are restricted to processing a single
        character. As is customary, you may pass a longer string to "ord",
        but only the first character will be translated.
    item
         multi item ( $item --> Item )
        Forces generic Item context on its argument, and returns it.
         multi list ( Iterable $item --> List ) { $item.iterator.list }
         multi list ( List \iter --> List ) { iter }
        Almost a no-op; just makes sure that $item can be iterated.
         multi flat ( *@list --> List )
        Forces flat context on its arguments, and returns them. The heavy
        work is done by the "*@" binding.
    lol
         multi lol ( **@list --> List )
        Forces the argument list to be evaluated in lol ("list of lists")
        context. (Subscripts treat such a list of lists as a
        multidimensional slice.) Any sublist within the top level of the
        outer list will be transformed into an item (Scalar). The work is
        actually done by the binding to the "**@" parameter. See also the
        more general ".tree" method, which defaults to itemizing every
        level.
    hash
        The "hash" contextualizer
         multi hash ( *@list --> Hash )
        Forces the argument list to be evaluated in hash context. The
        expression is evaluated in list context (flattening any "Capture"s),
        then a hash will be created from the list, taken as a list of
        "Pair"s. (Any element in the list that is not a "Pair" will pretend
        to be a key and grab the next value in the list as its value.)
        Equivalent to "%()" (except that empty "%()" means "%($/)", while
        empty "hash()" means an empty hash).
         multi gist( |item --> Str )
         multi method gist( Mu $item: --> Str )
        Produces an informal string coercion, something a human might want
        to see if debugging, for instance. Each type may decide its own gist
        representation. "Mu.gist" just calls ".perl", but any type's "gist"
        method may override this to remove metainfo that a human would find
        to be cluttery or redundant, or to format a composite value with
        suitable whitespace to tell the bits apart, or to trim down an
        infinite list to something slightly shorter.
        "gist" is used as a last-ditch string coercion on each individual
        argument of various human-facing output routines, specifically
        "say", "note", "warn", and any non-exceptional arguments to "die".
        The "print" function is specifically excluded, since it's outputting
        to a printer. ":-)"
    :16, :8, :2, :10
         multi prefix:<:16> ( Str $hexstr --> Num )
         multi prefix:<:8> ( Str $octstr --> Num )
         multi prefix:<:2> ( Str $binstr --> Num )
         multi prefix:<:10> ( Str $decstr --> Num )
         etc.
        Interprets string as a number, with a default
        hexadecimal/octal/binary/decimal radix. Any radix prefix (0b, 0d,
        0x, 0o) mentioned inside the string will override this operator
        (this statement is true: 10 == :8("0d10")), except 0b and 0d will be
        interpreted as hex digits by :16 ("hex("0d10") == :16 "0d10"").
        "fail"s on failure.
        These aren't really functions, syntactically, but adverbial forms
        that just happen to allow a parenthesize argument. But more
        typically you'll see
            :4<222>
            :16<deadbeef>
        and such.
        Replaces Perl 5 "hex" and "oct".
  OS
    gethost
         multi gethost( --> OS::Name )
         multi gethost( Str $name, OS::Addfamily :$type --> OS::Name )
         multi method gethost( OS::Addr $addr: --> OS::Name ) is export
         multi method gethost( URI $uri: --> OS::Name ) is export
        The "gethost" function operates on host naming or address
        information and returns an "OS::Name". An "OS::Name" is, minimally:
         class OS::Name {
           has Str $.name;
           has OS::Addr $.addr;
           has Array of Str @.aliases;
           has Array of OS::Addr @.addrs;
        Such names can apply to anything which has a name that maps to an
        address, however, in this case the name is a hostname and the
        address is some sort of network identifier (e.g. an IPV4 address
        when resolving hosts that have IPV4 addresses).
        When stringified, an "OS::Name" yields its name. When stringified,
        an "OS::Addr" yields its address in an appropriate text format (e.g.
        "10.1.2.3" for an IPV4 address).
        The optional "type" adverb can be passed when resolving a hostname,
        and will filter the result to only those addresses that are of the
        appropriate address family. This feature may be supported by the
        underlying operating system, or Perl may emulate it.
          say "Connection from {$socket.peer.gethost}";
          my $address = gethost("foo.example.com").addr;
          my $hostname = gethost(:addr<"10.1.2.3">);
    chroot
         multi chroot ( Str $path = CALLER::<$_> --> Bool )
        On POSIX systems, changes the process context of the current process
        such that the "root" directory becomes $path and all rooted paths
        (those that begin with a leading path separator) are relative to
        that path. For security reasons, many operating systems limit this
        functionality to the superuser. The return value will be true on
        success.
    getlogin
         multi getlogin ( --> Str )
        Returns the username of the account running the program. This may
        not be as secure as using "getpwuid" on some platforms.
    kill
         multi kill ( OS::Signal $signal, Bool :$group, *@pids --> Bool )
         multi method kill ( Proc::PID $pid: OS::Signal $signal?, Bool :$group --> Bool )
        Sends the given $signal to the process(es) given and returns a
        boolean value indicating success (true) if all of the processes
        existed and were sent the signal and failure (false) if any of the
        processes did not exist or the signal could not be delivered to
        them.
        The $signal can be initialized from an integer signal number or a
        string. Common signals are:
         KILL - stop the process, do not allow it to exit gracefully
         TERM - stop the process, allow it to exit gracefully
         HUP  - Hangup, often used as a request to re-run from scratch
         STOP - Pause execution
         CONT - Continue after a STOP
        Consult your operating system documentation for the full list of
        signal names and numbers. For compatibility, a signal name may be
        prefixed with "SIG".
        The method form may omit the signal. In this case, the default
        signal is 'TERM'.
        If the ":group" named parameter is passed, "kill" will attempt to
        send the signal to a process *group* rather than a single process.
        This functionality is platform-specific.
        The special signal 0 can be sent which does not actually deliver a
        signal at all, and is used to determine if processes are still
        running:
          say "Still running" if $proc.kill(0);
    run
    shell
         multi shell ( $expression,   :$cwd = $CWD, :%env = %*ENV --> Proc )
         multi run   ( *$cmd, *@args, :$cwd = $CWD, :%env = %*ENV --> Proc )
        "shell" and "run" execute an external program, and return control to
        the caller once the program has exited.
        "shell" goes through the system shell ("cmd" on windows, "/bin/sh"
        on Unixish systems), thus interpreting all the usual shell meta
        characters.
        "run" treats the first argument as an executable name, and the rest
        of the positional arguments as command line arguments that are
        passed to the executable without any processing (except that it
        encodes Strings to buffers first, as does "shell").
        Both return a "Proc" object, which boolifies to "True" if the
        program had a successful exit and "False" otherwise. The "status"
        method on a "Proc" provides the exit code. If a "False" "Proc" is
        sunk, an exception will be thrown of type "X::Proc::Unsuccessful".
        If you want to execute an external program asynchronously (as in,
        not waiting for it to be finished), you will need "Proc::Async", as
        specced in S17-concurrency.
    runinstead
         multi runinstead ( ; Str $path, *@args )
         multi runinstead ( ; Str $command )
        Identical to "run" except that it never returns. The executed
        program replaces the currently running program in memory.
    syscall
  Concurrency
    There are higher-level models of concurrency management in Perl (see
    "Concurrency" in S17). These functions are simply the lowest level tools
    fork
         sub Processes::fork( --> Proc )
        Creates a copy of the current process. Both processes return from
        "fork". The original process returns the *child* process as a "Proc"
        object. The newly created process returns the *parent* process as a
        "Proc" object. As with any Proc object, the child process object
        numifies to the process ID (OS dependent integer). However, the
        parent process object numifies to 0 so that the child and parent can
        distinguish each other.
        Typical usage would be:
         if !defined(my $pid = fork) {
           die "Error calling fork: $!";
         } elsif $pid == 0 {
           say "I am the new child!";
           exit 0;
         } else {
           say "I am the parent of {+$pid}";
           wait();
         multi method wait( Proc $process: *%options --> Proc::Status )
         multi wait ( Proc $process = -1, *%options --> Proc::Status )
        Waits for a child process to terminate and returns the status object
        for the child. This status object will numify to the process ID of
        the child that exited.
        Important Proc::Status methods:
         .exit - Numeric exit value
         .pid - Process ID
         .signal - Signal number if any, otherwise 0
        For historical reasons there is a ".status" method which is equal
        to:
         ($status.exit +< 8) +| $status.signal
        If $process is supplied, then wait will only return when the given
        process has exited. Either a full "Proc" object can be passed, or
        just a numeric process ID. A -1 explicitly indicates that wait
        should return immediately if any child process exits.
        When called in this way, the returned "Proc::Status" object will
        have a ".pid" of -1 (which is also what it numifies to) if there was
        no such process to wait for.
        The named options include:
        blocking
            Defaults to true. If set to false, this forces wait to return
            immediately.
        WNOHANG
            Exists for historical compatibility. "WNOHANG =" 1> is identical
            to "blocking =" False>.
  Pending Apocalypse
    The following functions are classified by Apocalypse/Synopsis numbers.
    A/S??: OS Interaction
        chroot crypt getlogin /[get|set][pw|gr].*/ kill setpgrp setpriority
        times
        ... These are probably going to be part of POSIX, automatically
        imported to GLOBAL if the platform is the right one
  Default Functions
    These functions are exported into the default namespace
    all -- see S32-setting-library/Containers.pod
    any -- see S32-setting-library/Containers.pod
    cat -- see S32-setting-library/Containers.pod
    categorize -- see S32-setting-library/Containers.pod
    classify -- see S32-setting-library/Containers.pod
    defined -- see S32-setting-library/Basics.pod
    grep -- see S32-setting-library/Containers.pod
    first -- see S32-setting-library/Containers.pod
    join -- see S32-setting-library/Containers.pod
    keys -- see S32-setting-library/Containers.pod
    kv -- see S32-setting-library/Containers.pod
    map -- see S32-setting-library/Containers.pod
    max -- see S32-setting-library/Containers.pod
    min -- see S32-setting-library/Containers.pod
    none -- see S32-setting-library/Containers.pod
    one -- see S32-setting-library/Containers.pod
    pairs -- see S32-setting-library/Containers.pod
    pick -- see S32-setting-library/Containers.pod
    print -- see S32-setting-library/IO.pod
    printf -- see S32-setting-library/IO.pod
    reduce -- see S32-setting-library/Containers.pod
    reverse -- see S32-setting-library/Containers.pod
    roundrobin -- see S32-setting-library/Containers.pod
    say -- see S32-setting-library/IO.pod
    shape -- see S32-setting-library/Containers.pod
    sort -- see S32-setting-library/Containers.pod
    srand -- see S32-setting-library/Numeric.pod
    undefine -- see S32-setting-library/Basics.pod
    uri -- see S32-setting-library/IO.pod
    values -- see S32-setting-library/Containers.pod
    warn -- see S32-setting-library/Any.pod
    zip -- see S32-setting-library/Containers.pod
  Non-default Functions
    These functions which existed in Perl 5 still exist but are not part of
    the default namespace any more.
   Container
    The following functions can now be found in or replaced by something in
    the Container modules.
    delete, exists, pop, push, shift, splice, unshift
   Numeric
    See "Numeric" in S32.
   IO
    the IO modules.
    accept, bind, binmode, chdir, chmod, chown, close, closedir, connect
    eof, fcntl, fileno, flock, getc, getsockname, getsockopt, glob, ioctl,
    link, listen lstat, mkdir, open, opendir, pipe, print, printf, read,
    readdir, readline, readlink readpipe, recv, rename, rewinddir, rmdir,
    say, seek, seekdir, select, send, setsockopt shutdown, socket,
    socketpair, stat, symlink, sysopen, sysread, sysseek syswrite, tell,
    telldir, truncate, umask, unlink
   Temporal
    the Temporal modules.
    gmtime, localtime, time
   String
    the String module.
    chop, chomp, index, lc, pack, rindex, split, sprintf, substr, uc,
    ucfirst, unpack
  Obsolete Functions
    Some of these are obsoleted only as general functions, and are still
    available by using the right packages. Others are obsoleted in that
    they're keywords, rather than functions (these are in their own section,
    %
         $num1 % $num2
        Does a floating point modulo operation, i.e. 5.5 % 1 == 0.5 and 5 %
        2.5 == 0.
    dbmopen, dbmclose
         use DB_File;
    dump
        Dumped. Restoring from core dumps is in any event not very useful on
        modern virtual-memory operating systems. Startup acceleration should
        be accomplished using a precompiler of some kind (details will be
        very implementation specific), or a pre-forking daemon such as Perl
        5's App::Persistent (which will be an external module when it is
        ported).
    each
        See .pairs() method, above.
    endpwent, endgrent, endservent, endprotoent, endnetent, endhostent
        The NameServices role in S16 covers most of these.
    format, formline
        See Exegesis 7.
    getgrgid, getgrnam, getpwnam, getpwuid
        The User and Group roles in S16 cover most of these.
    getpwent, getgrent, getservent, getnetent, gethostent
    length()
        This word is banned in Perl 6. You must specify units. In practice,
        this probably means you want Str.chars(), although it could be
        Str.bytes(), or even something else. See S32-setting-library/String
        for details.
    lcfirst
        Retired due to lack of use case
    msgctl, msgget, msgrcv, msgsnd
        See IPC::SysV
    local
        Replaced by "temp" which, unlike "local", defaults to not changing
        the value.
    lock
        See "Concurrency" in S17. "lock" has been replaced by "Lock.new" and
        methods on the "Lock" object.
    quotemeta
        Because regex escaping metacharacters can easily be solved by quotes
        ("Simplified lexical parsing of patterns" in S05), and variables are
        not automatically interpolated ("Variable (non-)interpolation" in
        S05), "quotemeta" is no longer needed.
        Shell escaping should be handled by passing arguments to run, or
        with code that speaks the language of a specific shell.
    pos There is no "pos" function in Perl 6 because that would not allow a
        string to be shared among threads. Generally you want to use "$/.to"
        for that now, or keep your own position variable as a lexical.
    prototype
         &func.meta.signature;
         &func.^signature;
    ref There is no ref() any more, since it was almost always used to get
        the type name in Perl 5. If you really want the type name, you can
        use "$var.WHAT.perl". If you really want P5 ref semantics, use
        "Perl5::p5ref".
        But if you're just wanting to test against a type, you're likely
        better off performing an "isa" or "does" or "can", or just "$var ~~
        TYPE".
    reset
        Was there a *good* use for this?
    semctl, semget, semop
        See IPC::SysV;
    setpwent, setgrent, setservent, setprotoent, setnetent, sethostent
    shmctl, shmget, shmread, shmwrite
    study
        Algorithm was too Anglo-centric. Could be brought back if
        generalized somehow.
    tie, tied
        These are replaced by container types. The compiler is free to
        assume that any lexical variable is never going to change its
        container type unless some representation is made to that effect in
        the declaration. Note: P5's tied() is roughly replaced by P6's
        variable().
        XXX Examples?
        my $foo is ....? is tie the meta operation on the container type for
        'rebless' - macro tie ( $var, $class, *@args ) { CODE {
        variable($var).meta.rebless( $class, *@args ) } } )
        endXXX
    untie
        See notes on "tie", above, but basically these are replaced with
        container classes.
    vec Should replace "vec" with declared buffer/array of "bit", "uint2",
        "uint4", etc.
    waitpid
        "wait" can now be called with or without an optional process/pid.
   Keywords
    The following were listed in Perl 5's perlfunc, but should now be
    considered keywords rather than functions.
    last, my, next, no, our, package, return, sub, use
Default Export Questions
    Not sure whether these are exported by default or not. Also, many may no
    longer exist; if so, they should be entered in the "Obsolete" section.
    Signal-related
        alarm kill
    OS or library related
         chroot
         crypt
         getlogin
         getpeername -- should this go on Pipe?
        OS objects:
         --Process
         getpgrp
         getppid
         getpriority
         setpgrp
         setpriority
         --Service
         getservbyname
         getservbyport
         --Protocol
         getprotobyname
         getprotobynumber
         --Network
         getnetbyaddr
         getnetbyname
         --Host
         gethostbyaddr
         gethostbyname
    Flow control
        succeed proceed redo
    Other
        caller chr die do EVAL exec exit fork goto hex import int oct ord
        require scalar sleep state syscall system times utime wait
        Carlin Bingham <carlin@theintersect.org>
    [DRAFT] Synopsis 31: Pragmatic Modules
        Created: 24 Feb 2009
        Last Modified: 24 Feb 2009
    It is a general policy in Perl 6 that any pragma designed to influence
    though of course some similarity is good.
    All floating point IEEE modes must be lexically available via pragma
    except in cases where that would entail heroic efforts to bypass a
    braindead platform.
    XXX FIX: I (Tim Nelson) have no clue as to what the above entails, so
    the spec does not reflect this XXX
Pragmata
    use autoindex -- see S09-data.pod
    use bytes -- see S05-regex.pod
    use chars -- see S05-regex.pod
    use codes -- see S05-regex.pod
    use graphs -- see S05-regex.pod
    use m :foo -- see S05-regex.pod
    use MONKEY-TYPING -- see S12-objects.pod
    use PDL -- see S09-data.pod
    use regex :foo -- see S05-regex.pod
    use rule :foo -- see S05-regex.pod
    use rx :foo -- see S05-regex.pod
    use s :foo -- see S05-regex.pod
    use token :foo -- see S05-regex.pod
    use oo :closed :final -- see S12-objects.pod
    Synopsis 99: Glossary
        Created: 26 June 2013
        Last Modified: 26 Feb 2015
    This document tries to define many of the terms used within the Perl 6
    community. It does not have an "apocalypse" or "exegesis predecessor".
    It is intended as both a quick introduction to terms used on the
    "#perl6" "channel" on "freenode", as well as a more permanent, and
    deeper source of explanations in the context of Perl 6.
    If you, as a reader, miss a term in a glossary, just add the term with
    the explanation. Or if you are not sure what the missing term means,
    just add a header for the term. Without doubt, someone else more
    knowledgeable will add the explanation later for you and everybody else.
A
  Abstract class
    An abstract "class" defines the "interface" of a class. Its "method"s
    are left undefined. In Perl 6, abstract classes is one of the related
    abstractions implemented as "role"s.
  ack
    An improved version of "grep", written in Perl
    (<http://beyondgrep.com>).
    Also used by old folks to indicate acknowledgement.
  actions
    A class used to generate an "AST" from the results of parsing text with
    a "grammar". The method to attach a generated AST is called "make", to
    retrieve an AST you can call "made" or "ast". See "Action objects" in
    S05-regex.
  advent calendar
    Articles about Perl 6 for every days of December before Christmas. At
    <https://perl6advent.wordpress.com/>.
  adverb
    See "adverbial pair".
  adverbial pair
    A generalized form of "pair notation". They all start with the colon,
      adverbial pair  | pair notation
      ================|==============
      :foo<bar>       | foo => 'bar'
      :foo(bar)       | foo => bar
      :$foo           | foo => $foo
      :foo            | foo => True
      :!foo           | foo => False
  AFAICS
    As Far As I Can See.
  AFAICT
    As Far As I Can Tell.
  AFAIK
    As Far As I Know.
  afk
    Away From Keyboard. Logged in, but there's no one looking at the screen.
  ALAP
    As Late As Possible
    The class from which most things derive, except for "Junction"s. Any is
    derived from "Mu".
  any()
    A Junction with "or" semantics.
  API
    Application Programming Interface. Ideally, someone using your system or
    library should be able to do so with knowledge only of the API, but not
    necessarily knowing anything about the internals or implementation.
  Apocalypse
    A document originally written by "TimToady", in which he processed the
    initial barrage of RFC's that came out of the Perl community. Now only
    kept as an historical document for reference. See also "Exegesis" and
    "Synopsis".
  arity
    Number of "operand"s expected by an "operator".
  argument
  AST
    Acronym for Abstract Syntax Tree
    <http://en.wikipedia.org/wiki/Abstract_syntax_tree>. Used in many
    places, including "actions", "PAST", and "QAST".
  atomic
    See "CAS".
  attribute
    Per-object storage slot. Other languages call it "Field", "Member",
    "Slot" or "Property".
    Way of deliberately ambiguously expressing "author" or "authority".
  author
  authority
  autopun
    "Are you ignorant or apathetic?" - "I don't know, and I don't care."
B
  backlog
    That part of a discussion on an "IRC" channel that you've missed. If it
    is not or no longer available in your IRC client, you can go to sites
    such as <http://irc.perl6.org> to see what has been logged for you.
  backtrack
    Feature of a combinatorial algorithm which goes back one step toward the
    trunk after failing exploring a branch of the potential solution space.
    A string match is such an algorithm. Here, backtracking usually means
    moving back the "cursor". In a non-greedy match, it means moving the
    cursor forward.
  backend
    Denote a VM targeted by "Rakudo". Can be "MoarVM", "JVM" or "Parrot".
  Bailador
    Spanish for "dancer", The Bailador module
    (<https://github.com/tadzik/Bailador/>) is a port of Perl 5's Dancer web
    framework (<http://perldancer.org/>).
  bare string
    A non-quoted alphanumeric string. In Perl 6, only allowed at the left of
    a "fat comma".
  biab
    Back In A Bit. Only "afk" for a little while.
  binary
    An operator is binary or of "arity" two if its "category" is "infix" or
    "postcircumfix".
  blast
    "Block, Alternatively Statement". Several constructs in Perl 6 expect
    either a single "statement", or a "block". Thus, a blast:
        try { dangerous(); functions() };
        #   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  Block
        try dangerous-function();
        #   ^^^^^^^^^^^^^^^^^^^^          Statement
    Particularly cute, because "phaser"s expect blasts.
  block
    A source code section delimited by braces and may have an explicit
    "signature". Used for "control flow" and as "scope". A "return" in a
    block returns from the enclosing subroutine. A block is a "first class
    entity" which makes it useful for "functional programming".
  blorst
    "Block, OR Statement". Different way to say "blast".
    Boolean type.
  boolean
    Value of type "Bool". Apart the class itself, can be either "True" or
    "False".
  boolean context
    A "context" that forces an expression to give a "boolean" value. The
    "prefix" "operator"s "so", "not" and their respective higher
    "precedence" "?" and "!" forms force a boolean context with "!" and
    "not" doing a negation. The "predicate" part of a "control flow"
    "statement" forces a boolean context. A class can define a "Bool" method
    to handle the boolean context. For natives, within "MoarVM", it is
    handled by "/MVMBoolificationSpec" member of the "STable" structure.
  bootstrap
    Starting up a system that uses itself to define, build or compile
    itself, is a practical exercise on solving the chicken and egg problem.
    This phase is called bootstrap. Documentation
    <https://github.com/MoarVM/MoarVM/blob/master/docs/bootstrap.markdown>
    about bootstrapping the "6model" of MoarVM
  bot
    A program that does automatic tasks on one or more "IRC" channel by
    acting like a regular user (as far as the server is concerned) and
    performing some tasks that may involve answering to users requests.
    "camelia", "dalek" and "yoleaux" are bots on the "#perl6" channel.
  boxing
    Operation transforming a native value into an object. The reverse
    operation is unboxing. The relation between boxed/native should not be
    confused with "container"/containee.
  branch
  brb
    Be Right Back. Only "afk" for a little while.
  BS
    Bounded Serialization.
  BSON
    BSON is the binary counterpart to the textual "JSON" data format. Used
    by Mongodb and supported by the MARTIMM/BSON
    <https://github.com/MARTIMM/BSON/> "project".
  Bug report
    The way to report problems to the implementors. For the interpreters
    themselves, use "RT". It is good practice to include the interpreter
    "version" in a bug report. A short piece of example code that
    demonstrates the bug without requiring any further set-up is usually
    very well received, too - see also "golfing" For the user packages
    hosted on "github", you can report issues.
  bundle
    A bundle is a special "module" that directs "Panda" to install a list of
    modules. See also: "Task::Star".
  bytecode
    Bytecode is to a "Virtual Machine" what "machine code" is to a CPU but,
    unlike machine code, is portable. From "source code" "Rakudo" can
    generate bytecode for the "JVM" and "MoarVM" virtual machines. When
    executing a script, rakudo does not need to compile the used "module"s
    because they should already be available as bytecode installed by Panda.
C
  callable
  caller
    The piece of code (or its lexical environment) that called a given piece
    of code. Generally only known at run time.
  CALLER::
    A "pseudo-scope" to access "symbol"s in the "caller"'s "scope".
  camel case
    A naming convention where a word boundaries in a multiple word
    identifier is indicated with medial capitalization. For example,
    "isDeeply". Popular in Java, C++, C#, and Visual Basic.
    See "kebab case", "snake case".
  Camelia
    The butterfly-like logo of Perl 6 as can be observed at
    <http://perl6.org>.
  camelia
    The "bot" on #perl6 channel that will evaluate code for you in various
    versions of Perl 5, Perl 6 and "NQP".
  capture
    A regex can record substrings of the "match"ed string that are matched
    capturing parts of the regex. That part (and the matched text) is a
    capture.
    For example
        if '..42' ~~ / \.+ (\d+) / {
            #              ^^^^^ capture
            say $0;
            #   ^^ capture variable
    "(*...*)" is the capture syntax while its non-capturing counterpart is
    the grouping syntax : "[*...*]".
  CAS
    An atomic Compare And Swap. Primitive for lock-free multi-threaded
    read/write access.
  category
    In "grammar"s, regex of a "multi" form a category that are distinguished
    by their "longname". That includes the signature but also the value of
    the ":sym" adverb. An expression consists of tokens that belong either
    in the category "term" or one of the "operator"'s categories.
    A regex definition for one of the term kinds :
        token term:sym<name> { ... }
  CFG
    1) Context Free Grammar. 2) see "Control Flow Graph".
  character
    A "string" is a sequence of characters. Like in Perl 5, there is no
    character type in Perl 6 so when someone says a *character* about a
    "value", he means a string with one character. In "Unicode" a character
    is called a "grapheme" and may be composed of many "codepoints". But a
    string represented in the "NFG" normalization form proper to Perl 6 has
    a codepoint per character. That leads to O(1) performance for many
    string operations. Depending on the level of abstraction, the length of
    a given string differs. The abstractions are bytes, codepoints and
    graphemes and the relevant methods are respectively .bytes, .codes,
    .chars.
  channel
    Short for "IRC" channel.
    Or a concurrent queue.
  christmas
    Release date for a Perl 6 implementation. It was a recurring joke
    because the year was not specified. But at FOSDEM 2015, TimToady
    announced that the target date will be Christmas 2015.
  circularity saw
    A pun on "circular saw". When bootstrapping a language in terms of
    itself, we must rely on circular definitions in various places.
    Obviously if we were really to use those circular definitions to
    implement our language, we'll just get stuck in an infinite regress. So
    instead we grab our trusty "circularity saw" to cut those circular
    definitions in a spot deep down, hopefully in a way that the resulting
    splice will be very difficult for the end-user to notice in day-to-day
    use.
  circumfix
    If a syntactic construct, for example a pair of parentheses, surrounds
    another piece of syntax, the surrounding first part is called a
    circumfix.
        say (2 + 3);
          # ^^^^^^^ circumfix
        say <a b c>;
  class
    A basic software structure in "OOP". See the Wikipedia entry
    <http://en.wikipedia.org/wiki/Class_%28computer_programming%29>.
  CLI
    Command Line Interface, what you see in a Terminal (window).
  clog
    To "backlog".
    Etymology: There is a website "irclog.perlgeek.de" providing either IRC
    logs or IR clogs, depending on how you interpret the domain name.
  Closure Parameter
    A routine parameter that is a callable with particular constraints on
    its own parameters. For example, you may only want to accept callables
    that take a "Str" as their argument:
        sub call-me(&callback:(Str)) { ... }
    Not to be mistaken for Subsignatures.
    See also "Closure parameters" in S06-routines.
  CLR
    Common Language Runtime, as used by Niecza/mono/.NET.
  codepoint
  combining mark
  comment
    Parts of a program intended for user consumption that are not used to
    generate code. Beside the "#" that starts a comment ending with the
    current line, Perl 6 supports many syntactic forms for different kinds
    of comments. Like inline comments that can be used as "whitespace", or
    comments that appear after a name declaration that are included in the
    "pod" documentation.
    A "compilation unit" is a set of files or a string that is compiled at
    once. It involves the "serialization" of code and data.
  compile time
  compiler
    In a "dynamic language" like Perl 6, the compiler is also referred to as
    "interpreter". In simpler dynamic languages like Perl 5, the interpreter
    does not go through conceptual phases similar to the one for a compiler
    of non-dynamic language, the term compiler is rarely used.
    When transforming "concrete syntax" to "bytecode", the first conceptual
    phase is called parsing and generates a "parse tree". Next the parse
    tree is transformed into an abstract syntax tree which is a form that
    can be optimised. Next the abstract tree is transformed to "bytecode" in
    a "compilation unit". Then, this bytecode is executed. Depending on the
    type of the data manipulated by the "program", bytecode can be
    transformed into optimised bytecode or into "machine code". These last
    two operations are forms of "JIT".
  compiler constant
    A "variable" with a "?" "twigil". See
    <http://design.perl6.org/S02.html#Twigils> and S24
    <http://design.perl6.org/S24.html>.
  COMPILING::
    A "pseudo-scope" to access lexical "symbol"s in the "scope" being
    compiled.
  composer
    A composer is a syntax for defining "value"s. When values are "object"s,
    their composer is a "Huffmanization" of a "constructor" expression. For
    an example, see the "fat comma".
  compunit
    See "compilation unit".
  concurrency
    Property of simultaneous computations sharing resources. It necessitates
    some form of collaboration to guaranty the consistency of the said
    resources. Computations are materialized by "process"es or "thread"s.
    Collaboration involves synchronization primitives likes mutexes, locks,
    semaphores. Perl 6 provides high level abstractions like "feed"s,
    "junction"s, "hyperoperator"s, "promise"s, "channels" so that the
    programmer is usually spared the explicit use of threads and the endless
    problems they involve.
    Compare with "parallelism". See S17-concurrency.
  concrete
    An "object" "value" is concrete when it is not the "class" itself.
  concrete syntax
  container
  context
    A context specifies the kind of value expected from an expression. A
    context may be "boolean context", "numeric context", "item context",
    "list context" or "hash context". Some "prefix" "operator"s are used to
    force the context.
    Context is also information that can affect parsing
  context variable
    A "variable" with a "*" "twigil". Used to set up contextual information
    that can be shadowed by calls deeper in the "call stack". Heavily used
    in the Perl 6 compiler because Perl 6 is a very contextual language, so
    gathered information affects the parsing. See "keyword" for an example.
    See also "lexotic", <http://design.perl6.org/S02.html#Twigils> and S24
    <http://design.perl6.org/S24.html>. Also called dynamic variable.
  control flow
    Without control flow statements, a program's execution would be purely
    sequential. A control flow statement generally uses a predicate and
    branches to one of its substatements according to the predicate value.
  Control Flow Graph
    In "spesh", a "dominance" graph generated from "bytecode" analysis so
    that "Single Static Assignment" can be done.
  constant
    A "variable" that has an unchangeable "value".
  constructor
    The OO way to *construct* an object. Composers are constructor
    "Huffmanization"s that are available for the most common types like
    "pair"s.
  CORE::
    A "pseudo-scope" to access "symbol"s of the outermost lexical "scope",
    definition of standard Perl.
  CPAN
    Comprehensive Perl Archive Network. A content delivery system for Perl
    distributions.
  credentials
  CUR
    Short for "CompUnitRepo", the type of objects that inhabit "@?INC".
  CURL
    Short for "CompUnitRepo::Local", the type of "CompUnitRepo" objects that
    refer to the local file system.
  CURLI
    Short for "CompUnitRepo::Local::Installation".
  cursor
D
  dalek
    An "IRC" "bot" that reports when various projects have been updated. It
    used to give "karma" to those who pushed the changes to the project.
  DarkPAN
    Perl code in production use at companies that has never been uploaded to
    CPAN. As in "how will this change affect the DarkPAN", which can't be
    answered because you generally don't have access to that code.
  dead code
    Code that is never called. For example
        sub f() {
            say 42;
            return;
            # everything below this is dead code,
            # because the return; above prevents it from running
            say 23;
  debugger
    A piece of software that helps you to track down errors in your
    software. It typically allows things like stepping through code, setting
    breakpoints and inspecting variables.
  declarator
    a "keyword" that introduces a "symbol" and defines its "scope" and
    "extent". Perl 6 declarators are "has", "my", "state", "our",
    respectively for object variable , lexical variable, <stateful
    variable|/stateful> and package variable. Also the "twigil" "/*" in the
    name of a package or lexical variable sets its extent to "dynamic".
  destructuring
  dev
    Either a developer (person), or a development version of a program, or a
    branch for development in a repository.
  DFS
    Depth First Search. See also <http://xkcd.com/761/>.
  dies_ok
    A "Test" function that succeeds when its argument, a Code object, dies
    at run time. See S24 <http://design.perl6.org/S24.html>.
  diffy
    An "operator" that produces a resulting "value" of a "type" different
    from its "argument"s. For example, all the comparison operators like
    "==" and "lt" are diffy (because they produce "Bool"s), the range
    operators are diffy (because they produce ranges), but "+" and "~" and
    "x" are not diffy because they (sorta, kinda) emit what they accept.
    The reason we care about operators being diffy or not is that you can
    basically only reduce on non-diffy stuff. So "[+]" makes sense, but
    "[..]" doesn't. ("[==]" actually does makes sense even though it's
    diffy, but that's because it's also chaining.) You also can't make
    assignment metaoperators from diffy operators. So "+=" makes sense, but
    "..=" doesn't.
  DIHWIDT
    "Doctor, It Hurts When I Do This." Well, stop doing it then.
  dispatcher
    The piece of code in the runtime that determines which (multi) method or
    subroutine to invoke.
    A collection of 1 or more "compunit"s for installing locally, or for
    loading from a remote location.
  DRY
    Don't Repeat Yourself
  DSL
    "Domain specific language". See "slang".
  Domain specific language
    A special-purpose language used for a particular problem domain. For
    instance, some web frameworks (such as Dancer <http://perldancer.org/>)
    use a DSL so that programmers can write code in terms of routes and
    actions rather than lower level details of parsing HTTP requests and
    generating HTTP responses. See also
    <https://en.wikipedia.org/wiki/Domain-specific_language>
  dominance
    See "Control Flow Graph"
  DYNAMIC::
    A "pseudo-scope" to access contextual "symbol"s in my or any "caller"'s
    lexical "scope".
  dynamic
  dynamic language
  dynamic typing
  dynamic variable
    the dynamic here is unrelated to the one in "dynamic typing". See
    "context variable".
  DWIM
    Acronym for "Do What I Mean". A programming language designer motto.
E
  eager
    One of the opposites of "lazy".
  ecosystem
    The ecosystem <https://github.com/perl6/ecosystem> is a repository of
    Perl 6 modules installable by "Panda". "Rakudo *" releases include a
    tested subset of the ecosystem.
  edsel
    Something that intends to please everyone by catering for everybody's
    taste, yet in the end pleasing nobody, because nobody is catered for
    enough.
  empty list
    A list which contains no value. Denoted "()".
  EPIC FAIL
    An internet expression describing the very dramatic, spectacular or just
    funny failure of an endeavor. See the relevant Wikipedia entry
    <https://en.wikipedia.org/wiki/Failure#Internet_memes>.
  EVAL
    A Perl 6 command that takes a string as an argument and executes its
    content as Perl 6 code.
  exception
  Exegesis
    A document originally written by "TheDamian", in which he tried to
    explain the "Apocalypse"s to the common (wo)man. Now only kept as an
    historical document for reference. See also "Synopsis".
  export
    See "import".
  EXPORT
  Expression
    An expression is a part of a statement that is constituted of operators
    and their operands and gives a value. The semantic of an expression may
    depend on its "context". An expression is all or part of a "statement".
  extent
    The extent is the interval of time a "first class" entity lives. The
    extent is different from the "scope" of a name. A "lexical variable" can
    be still alive when its name is out of scope if some reference still
    exists.
  Extop
    An extension to the default "bytecode" "instruction set" in "Parrot" or
    "MoarVM". Used to support "opcode"s specific to a language.
F
  FAIL
  FAILBACK
    when available in a class, called when all other attempts by the
    "dispatcher" have failed.
  fat comma
    Contrary to Perl 5, "=>", the fat comma does not simply separate two
    values but makes a "Pair" out of them. The left value can be a "bare
    string". This is the only place where Perl 6 accepts a bare string.
    Example:
          foo => bar
  fiddly
    Used of an "operator" that doesn't participate in forming metaoperators
    at all. (Because that would be "too fiddly" to get to work, presumably.)
    "?? !!" is such an operator. The method call operator is another. (And
    hence ".=" is actually a special case, not a "real" metaoperator.) List
    assignment is also fiddly. (But item assignment is not.)
    No meta in fiddly things. So you can't reduce, negate, reverse,
    sequence, cross, zip, hyperify or assignify fiddly operators.
  FIFO
    First In First Out <https://en.wikipedia.org/wiki/FIFO>, a fairly common
    data structure in programming languages. In Perl 6 an array behaves as
    such when used as a "queue". See also "LIFO".
  flap
    Sometimes a test will fail under some conditions, but not others; when
    this test passes some test runs and fails others, it's called flapping.
  first class entity
    An entity that is accessible as a "value" during "runtime".
  fork
    The creation of another process.
    Also, a feature of "github" that copies a repository from one user to
    another, to allow users to make changes to a repository without needing
    permissions on the original project. After a user makes changes they
    will likely submit a "pull request".
  FOSS
    Free and Open-Source Software.
  fossil
    Something in a generally current document that is no longer true but
    which has not yet been fixed by correcting or removing it.
  FP
    Short for "functional programming"
  frame
  freenode
    An "IRC" server that hosts "channel"s related to Perl 6 projects
    accessible through an IRC client at "irc.freenode.org".
  FSVO
    For Some Value Of.
  FTFY
    Fixed That For You.
  fudge
    Way to temporarily mark tests in the "spectest" for a specific Perl 6
    version as *todo* (so that a failure of the test will be marked ok, and
    a pass will be marked as an exception), or as *skip* if they cause a
    "compile time" or "runtime" exception.
  functional programming
    A programming style that mostly or exclusively relies on functions,
    "pure" or not. Perl 6 supports functional programming but does not force
    it on you.
G
  GC
    Garbage collecting.
  gensym
    A generated symbol. Used primarily in "macro" parlance, a gensym acts as
    a "handle" on something anonymous, allowing a macro author to refer to
    synthetically created bits of a program after creating them. Gensyms
    generally look ugly, partly so as not to collide with anything else. The
    "symbol"s `#:G847`, `#:G848` and `#:G850` below from
    <http://lists.warhead.org.uk/pipermail/iwe/2005-July/000130.html> are
    gensyms:
            (LET* ((#:G847 X) (#:G848 FOO))
              (MULTIPLE-VALUE-BIND (#:G850) 1 (COMMON-LISP::%PUT #:G847
                #:G848 #:G850)))
    Current consensus is that we won't need gensyms for Perl 6 macros,
    because we'll have Qtree nodes which, being objects, come pre-equipped
    with a "handle": their object identity.
  GIL
    Global Interpreter Lock
    <https://en.wikipedia.org/wiki/Global_Interpreter_Lock>.
  gimme
  gist
    A summary, or a method on objects that is invoked by "say" to print out
    the object in a human readable format.
    Or a paste server with "git" capabilities used by denizens of "IRC". See
    <https://gist.github.com> for the last usage.
  git
    The distributed source revision system used by many, if not all Perl 6
    projects, generally hosted on "github". A good glossary
    <https://www.kernel.org/pub/software/scm/git/docs/gitglossary.html>
    about git. A good reference <http://git-scm.com/book>.
  git submodule
    A way to use a git repositories from one git repository. More
    information <http://git-scm.com/book/en/Git-Tools-Submodules>
  github
    Online open source repository hoster using "git". The "ecosystem" is
    hosted on github.
  given
    Keyword for the Perl 6 switch "statement".
  GLOBAL::
    A "pseudo-scope" for "interpreter"-wide "package" "symbol"s, really
    UNIT::GLOBAL.
  GLR
    The Great List Refactor: a refactoring of the reification of lazy lists,
    so that lazy evaluation is only done when it is really needed. Expected
    to provide a performance benefit of several factors in certain,
    loop-like situations.
  GLRR
    Further Refinement of the "GLR".
  golf
    Shortest possible way (least amount of typed characters) to get a
    program to do what you want, or to describe a problem or bug.
    In the case of bug hunting, the aim is only partly "fewest characters"
    and partly "fewest concepts". The aim being to show exactly what
    concepts are necessary to trigger the surprising behavior.
  golfing
    The process of creating the shortest possible program to prove what you
    want. Sometimes also a form of "obfuscation".
  good *
    Good morning/afternoon/evening. Since the contributors are in many
    different timezones, one contributor's morning is another contributor's
    evening.
  gorilla/banana problem
    "You wanted a banana but what you got was a gorilla holding the banana
    and the entire jungle." says Joe Armstrong, Erlang creator, complaining
    of traditional "OO" inheritance based environment inflexibility. In non
    "dynamic language"s, you can't dynamically add "attribute"s/"method"s
    for an "object"/"class" so you end up shoving everything you may ever
    need in a deep class hierarchy. In Perl 6, the gorilla/banana problem is
    solved with "role"s that group methods or attributes. A role can be
    dynamically added to a class or an object.
  gradual typing
    According to wikipedia *Gradual typing is a type system in which
    variables may be typed either at compile-time (which is "static typing")
    or at "runtime" (which is "dynamic typing")*. Perl 6 supports gradual
    typing.
  grammar
    A feature of Perl 6 that uses "regex"es to implement a grammar for
    parsing text. Perl 6 implementations use grammars themselves to parse
    the language. The results of parsing with a grammar can be further
    passed on to "actions". A grammar is composed of methods introduced by
    one of the three keywords "rule", "token", "regex". There is
    "backtrack"ing only in "regex" and "rule" implies "whitespace"s between
    subrules.
    Parsing is done conceptually in two phases, lexing and syntax analysis.
    Lexing breaks the input string in tokens that are the input of syntax
    analysis. In Perl 6, things are not so clear cut and both phases are
    defined in the "grammar".
  grapheme
  green threads
    Threads that are scheduled by the virtual machine, not by the operating
    system.
  grep
    Command line utility to search text for lines matching a "regex". See
    <http://en.wikipedia.org/wiki/Grep>.
H
  hash
    A data type, conveniently available in variables starting with the
    percent sign "%" and provided by types conformant to the "Associative"
    role like the "Hash" type. Often called associative table in other
    languages.
  hash context
  heap
    Dynamically allocated memory pool used for memory management. Unused
    parts are reclaimed by the "GC". See Memory management
    <https://en.wikipedia.org/wiki/Memory_management#DYNAMIC>.
  High Level Language
    A high level language provides abstractions that decouples it from
    specific operating systems and processors. Perl 6 is such a language and
    provides some interoperability with other HLLs when they are compiled
    with the rakudo toolkit. Some of these abstractions like arrays,
    associative tables, integers, floats, strings and objects are common to
    many languages but specific semantic and underlying type
    "representation"s may differ. Also, a given language may provide many
    flavors of them. Perl 6 provides common "concrete syntax" to access
    them. "MVMHLLConfig" is the "MoarVM" C level structure that hooks to the
    underlying language specific representations. The "metamodel" allows one
    to express specific semantics proper to a given "OO" language. "Rakudo"
    provides interoperability with languages which compilers follow C
    language linking conventions.
  HLL
    See "High Level Language".
  HN
    Hacker news as seen on <https://news.ycombinator.com>.
  HN'ed
    Being mentioned on Hacker news (<https://news.ycombinator.com>).
  HOW
    Higher Order Workings. Also the name of the method you can call on any
    object to find out the meta-class of that object (of which the type
    object of an object is the instantiation).
  HPMoR
    Harry Potter and the Methods of Rationality. An inexplicably good Harry
    Potter fanfic with far more significance than the word "fanfic" might
    lead you to believe. See <http://hpmor.com>.
  Huffmanization
    Huffman coding <http://en.wikipedia.org/wiki/Huffman_coding> is a
    compression algorithm that encodes common symbols with a short code. By
    analogy, we call huffmanization alternative and shorter syntax for
    common syntax constructs. The cost of huffmanization is the cost of
    learning additional syntax. In Perl 6, "composer"s are a form of
    huffmanization.
  hyper
    Process data asynchronously when possible, but return the result data in
    the order it would have been if the source data had been processed in a
    single thread/process.
  hypothetical variable
  hysterical raisins
    Pun on historical reasons.
I
  IC
    I see.
  iffy
    Used of an operator that either returns a "Bool" result, *or something
    like it* (such as a match object). All the comparison operators are
    iffy, as are conditional operators like "&&", "?^", and "or". "%%" is
    iffy, but "%" isn't. The junctive operators are iffy.
    The reason that we care about iffy operators is that you can only append
    the "!" metaoperator to an operator that's iffy.
  IIRC
    If I Remember Correctly.
  IIUC
    If I Understand Correctly.
  implementation
  import
    Modules interact with each other through named entities called symbols.
    The operation that makes symbols from a module available to another
    module is called import while the operation of using such a name is
    called import.
  infix
    An operator that can appear between two terms, like the "+" in "40 + 2".
  inline
  install
  installer
    A built-in arbitrary-sized integer type. See
    <http://doc.perl6.org/type/Int>.
  int
  interface
    An interface is an "abstract class".
  Intermediate Representation
    In a compiler, Intermediate data structures that are generated from the
    "source code" to generate "object code" or "bytecode". In "Rakudo" :
    "parse tree", and Abstract Syntax Tree. The "parser" generates an IR
    that is transformed to an "AST". Sometimes the information can be
    regenerated from the bytecode. In Rakudo the "Single Static Assignment"
    form is inferred from the bytecode.
  interpreter
    An interpreter is the entity that executes "bytecode" generated from
    "source code" in a given "language". It relies on the underlying "VM".
    It may load extops, that is bytecode "ops" that are specific to the said
    language.
  instruction set
    An instruction set is a set of instructions specific to a "bytecode" or
    a microprocessor. Also "NQP" defines an instruction set. Its opcodes are
    documented in ops.markdown
    <https://github.com/perl6/nqp/blob/master/docs/ops.markdown>.
  invocant
    A "method" has generally one invocant but may have many according to its
    "signature". As a parameter(s), the parameters before the ";". As an
    argument, the left "operand" of the "." "operator". In the expression
    "42.say", 42 is the invocant. When missing, like in ".say", the invocant
    is $_.
  invokedynamic
    An "opcode" that makes possible the support of "dynamic language"s in
    "JVM". A presentation <http://www.infoq.com/presentations/invokedynamic>
    about invokedynamic.
  IR
    See "Intermediate Representation"
  IRC
    Internet Relay Chat. Perl 6 developers and users usually hang out on the
    "#perl6" "channel" on "freenode". See also
    <http://perl6.org/community/irc>.
  ISTR
    I Seem To Remember.
  item
  item context
  iteration
    A way to go through all the values of an "Iterable" object like a "list"
    or a "hash". Generally, iterator "object"s are invisible from user code
    because syntactical forms iterate for the user and pass the resulting
    value to the expression or the block acting on the value. Example:
       for 1..20 { .say }
       .say for 1..20
  IWBN
    It Would Be Nice.
J
  jakudo
    "Rakudo" running on the "JVM".
  JAST
    Intermediate representation of code used in the JVM backend of Rakudo
    and NQP.
  JIT
    Just-in-time compilation
    <https://en.wikipedia.org/wiki/Just-in-time_compilation>, a technique
    for improving the performance of virtual machines.
  JSON
    A popular data format. Its specification <http://json.org/> The
    ecosystem includes many JSON related "projects". Its binary counterpart
    is "BSON". The class "JSON::Pretty" is part of the core. Thre is also
    support for more JSON and BSON in the "Rakudo Star" or the "ecosystem".
    A compound type that is transparent to many operations. See
    <http://doc.perl6.org/type/Junction>.
  JVM
    Java Virtual Machine. The virtual machine for the Java programming
    language. Now many programming languages including Perl 6 have
    "compiler"s targeting the JVM.
K
  karma
    A measure of appreciation on "IRC". Karma is set by "incrementing" a
    pseudo: "jnthn++ # moar commit". It is purely notional on "#perl6" and
    other Perl 6 related channels because "dalek" does not track karma
    anymore.
  kebab case
    identifier is indicated with a dash (-) character. For example,
    "is-deeply". Popular in Lisps and Perl 6.
    See "camel case", "snake case".
  keyword
    An alphabetical string that has a predefined meaning in the language
    source code. In most languages keywords are reserved, that is they
    cannot be used as "symbol". Not in Perl 6, the compiler knows by context
    if an alphabetical string is a keyword, a "function" name used for a
    call or a sigiless "parameter". This will allow to add new keywords to
    Perl 6 in the future without breaking existing programs.
  KISS
    Keep It Simple, Stupid! <https://en.wikipedia.org/wiki/KISS_principle>,
    a famous motto in computer science.
L
  lambda
    An anonymous function. A block with explicit parameters: "-> $a { say $a
    }" The "->" itself, or "<->" for writeable parameter.
  language
  lazy
    The property of a list not to evaluate elements until they are needed.
  laziness
    According to "WP" "lazy evaluation, or call-by-need is an evaluation
    strategy which delays the evaluation of an expression until its value is
    needed (non-strict evaluation)". In Perl 6, strings and lists can be
    lazy but other values are not. That is, their content is evaluated when
    needed so they can be potentially infinite. As of January 2015, lazy
    strings are not supported. They may even not make the cut for the 6.0
  lexical
    Lexical properties are derived from the structure of the source code
    itself, not from any information from run time.
  lexical pad
    A data structure that holds the values of lexical variables.
  lexical scope
  lexical symbol
  lexing
  lexotic
    A dynamic operation with a lexically scoped target. For example,
    "return" has a dynamic effect (it peels back the call stack), but the
    thing it's returning from is a lexically defined routine.
  lexpad
    Short for "lexical pad".
  LGTM
    Looks good to me.
  LHF
    Low Hanging Fruit.
  library
    The compilation of a "compilation unit" of source code written in a
    non-dynamic language like C results in a library.
  LIFO
    Last In First Out <https://en.wikipedia.org/wiki/LIFO_(computing)>, a
    fairly common data structure in computer science. In Perl 6 arrays
    behave as such when used as a "stack". See also "FIFO".
  line noise
    Used to qualified unreadable code. Often used by people that don't
    understand the syntax of the used language. Perl is often deemed line
    noise, especially because of its abundance of "metacharacters", like
    "sigil"s. For the trained reader, they are very useful because the sigil
    denote an associated "role"
    See "TheDamian" /answer
    <http://www.linuxvoice.com/interview-damian-conway/> to the question
    *Perl looks like a regular expression*.
  list context
  list to remember
    A facet of a language's design that puts the onus on the user to
    remember which of a group of similar constructs have certain behaviors
    (or requires frequent consultation of documentation to the same effect.)
    A goal of language design is to minimize the amount of material a user
    must remember, by using consistent behaviors across similar constructs,
    or by exposing these behaviors through syntax. A natural language
    analogy to "list to remember" would be irregular verb conjugations.
  lmddgtfy
    Let Me DuckDuckGo That For You. <http://lmddgtfy.net>
  LMGTFY
    Let Me Google That For You. <http://lmgtfy.com/>
  local
    A local variable, in "QAST", is local to a "frame". A "HLL" lexical
    variable may end up as local in QAST if it is not captured by outer
    "scope". When the QAST is compiled and "JIT"ed to an executable, the
    value accessible thru the local, modulo some "SSA" magic, is accessible
    in a processor register. There is no relationship with the local scope
  LoL
    List of List
  longname
    Because Perl 6 has the capability of "multiple dispatch", several
    methods or subroutines may have the same name but different parameters
    (different in number or in type). Perl decides which routine to call by
    looking at the longname which consists of the name of the routine and
    the type signature of its invocant arguments. See also "shortname",
    "multi-method", and "multi-sub".
  LTA
    Less Than Awesome.
  LTM
    See Longest Token Matching
    <http://design.perl6.org/S05.html#Longest-token_matching>.
  lvalue
M
  machine code
    Code specific to the "instruction set" of a hardware architecture.
    Compare with "bytecode".
  magic variable
    Variable that has a behavior of its own and that is denoted by a
    sigiless name with a non alphanumeric character. Unlike Perl 5 that has
    a profusion of magic variables, Perl 6 includes only the magic variables
    "$_", "$/", "$¢" and $!. They are "block" "scope"d and are implicitly
    defined at the beginning of each block.
  MAIN
    When present, a "multi"sub that is the entry point of a "program"
    "runtime". The code in "phaser"s intended to run at compile time are
    executed before MAIN. Like in Perl 5, a MAIN sub is not necessary.
  MAST
    "MoarVM" specific "AST". When the Perl 6 "backend" is MoarVM, "QAST",
    the AST obtained from early stages of "source code" "compilation" is
    converted into MAST. The MAST is then used to generate MoarVM
    "bytecode".
    Value resulting from a "match". In "list context", gives the positional
    "capture"s list. In "hash context", gives the named "capture" hash. In
    "numeric context", gives the matched string length. In "boolean
    context", gives "True" like any non-class object.
  match
    A match is an operation that tests a "string" against a "grammar" or a
    "regex". and returns an "object" of Match type in case of success,
    otherwise a "Nil"
    Matching against a "regex" is a special case of "smart match"ing.
    See also "parse".
  memory
  META.info
    A "JSON" file that lies in the root of a "repository" for a project
    written in Perl 6. It describes a project and list its dependencies.
    Documented in spec.pod
    <https://github.com/perl6/ecosystem/blob/master/spec.pod>.
  metamodel
    The metamodel describes some OO behaviors, like where to find a
    "method". This permits implementation of different OO behaviors in the
    same "VM". The Perl 6 implementation of the metamodel is called
    "6model". The metamodel should not be confused with the
    "representation".
  method
    Methods are "sub"s that are called with an "invocant".
  MI
    Multiple inheritance.
  mischan
    A case of having put a message on the wrong (IRC) channel.
  MMD
    See "multi-method dispatch".
  MoarVM
    A virtual machine designed specifically for "NQP" and its "MOP":
    "6model". A document about MoarVM purpose
    <https://github.com/MoarVM/MoarVM/blob/master/docs/reveal.md>. MoarVM
    has some similarities with the Hotspot VM so you may peruse its glossary
    <http://openjdk.java.net/groups/hotspot/docs/HotSpotGlossary.html> for
    entries missing from the present one.
  modifier
    It is an "adverb" that affects the behavior of a "rule" or a "match" The
    supported modifier for rules are ":ignorecase", ":ignoremark",
    ":sigspace", ":ratchet", and ":Perl5", and their respective
    abbreviations ":i", ":s", ":r", and ":P5".
    :g :ov :x :ex :pos
  module
  MOP
    Meta-Object Protocol.
  MRO
    Method Resolution Order.
    The mystical class from which all other classes are derived (無).
  multi
    "sub"s, "method"s, or "rule"s that have the same name but are
    distinguished by their signatures. Keyword that introduces them. The
    operation that dispatches a call to the appropriate method is called
    "multi-method dispatch".
  multiple dispatch
    Dynamically selecting which routine to execute based on name and type of
  multi-method
  multi-sub
  multi-method dispatch
  mumble
    Placeholder; something that's left unclear deliberately. Either because
    the speaker doesn't know or because it's an unimportant detail.
  my
  MY::
    A "pseudo-scope" to access "symbol"s in the current "lexical scope" (aka
    $?SCOPE).
N
  named parameter
  namespace
  native
    Something that does not pertain the Perl interpreter proper but to the
    "backend" or the underlying system. See also: "pure Perl"
  Native Call
    Calling a routine from an external C/C++ library, provided by the
    NativeCall library (which is now bundled with "Rakudo").
  Native value
    A native value is an "int", "num", "str". A native value cannot be
    undefined.
  name
    Syntactical convention to denote an entity in a program source code.
    Such an entity can be a routine, a variable... See also : "symbol",
    "scope", "sigil", "role", "adverbial pair".
  NC
    "Native Call"
  NCI
    "Native Call" Interface
  need
  NFA
    Nondeterministic Finite Automaton, an algorithmic technique used by the
    regex engine. See:
    <https://en.wikipedia.org/wiki/Nondeterministic_finite_automaton>.
  NFG
    Proposed "Unicode Normalization Form" for Perl 6, in which composed
    characters always get their own codepoint. If a codepoint doesn't exist
    for that composed character, one is assigned dynamically.
    Documentation for this can hypothetically be found in S15.
  Niecza
    An implementation of Perl 6 targeting the .NET platform.
    Means there is no value. This is different from "()", the "empty list".
  NST
    No Such Thing.
  nom
    The name of the main branch of current "Rakudo" in "git". Originally
    named so for its "new object model".
  Normalization Form
  NPE
    Null Pointer Exception.
  null-PMC access
  number
  numeric context
  NQP
    Short for Not Quite Perl, a subset of Perl 6 suitable for tasks such as
    implementing "Rakudo". Targets "Parrot", the "JVM" and "MoarVM".
  NSA
    Native, Shaped Arrays.
O
  obfuscation
    Code deliberately unreadable often using esoteric language features.
    Sometimes combined with "golfing".
  object
  object code
    For non "dynamic language"s, from a "compilation unit", the "compiler"
    generates object code or library. A latter phase links object code to
    generate an executable. For dynamic languages like Perl 6, the
    equivalent of object code is the "bytecode" and the linking phase is
    more complex and involves the de"serialization" of information.
  On Stack Replacement
    According to the hotspot glossary
    <http://openjdk.java.net/groups/hotspot/docs/HotSpotGlossary.html>: The
    process of converting an interpreted (or less optimized) "stack frame"
    into a compiled (or more optimized) stack frame.
  OO
    Object oriented. See "OOP".
  OOP
    Acronym for Object-oriented programming
    <https://en.wikipedia.org/wiki/Object-oriented_programming>.
  op
    Ops are "opcode"s that belong to the "NQP" interpreter or that are
    dynamically charged by the interpreter of another language. The word
    "extops" is used to denote the latter ops
  opcode
    An opcode is an instruction in a "bytecode" or "AST". Documentation
    about "MoarVM" opcodes
    <https://github.com/MoarVM/MoarVM/blob/master/docs/bytecode.markdown>.
  open source
  operand
    See "operator".
  operating system
  operator
    An expression is made of operators and operands. More precisely it is
    made of an operator and operands that can be subexpressions or "value"s.
    Operators are an alternative syntax for a "multi-method". With that
    syntax, what would be the "argument"s of the function are named operands
    instead. Operators are classified into categories
    <http://design.perl6.org/S02.html#Grammatical_Categories> of categories.
    A category has a precedence, an arity, and can be "fiddly", "iffy",
    "diffy". Perl 6 is very creative as to what is an operator, so there are
    many categories. Operators are made of many tokens, possibly with a
    subexpression. For example, @a[0] belongs to the postcircumfix category,
    is broken into the operand @a and the postcircumfix operator "[0]" where
    0 is the postcircumfixed subexpression.
    The "<O(*...*)>" construction gives information about an operator that
    completes the information provided by its category. Below %conditional
    is the category, ":reducecheck<ternary>", which specifies calling
    ".ternary" to post-process the parse subtree and ":pasttype<if>"
    specifies the NQP "opcode" generated in the "AST" from the parse
    subtree.
            <O('%conditional, :reducecheck<ternary>, :pasttype<if>')>
  opt
    An optimization, usually in either the context of "spesh" or "JIT".
    Operating system. See <http://en.wikipedia.org/wiki/Operating_system>.
  OSR
    "On Stack Replacement"
  our
  OUR::
    A "pseudo-scope" to access "symbol"s in the current package (aka
    $?PACKAGE).
  OUTER::
    A "pseudo-scope" to access "symbol"s in the next outer "lexical scope".
P
  package
  package manager
    See "project manager"
  pad
    See "lexical pad".
  Pair
    The simplest object containing a key and value pair.
  pair notation
    Way of expressing key/value pairs, using the "fat comma", creating a
    "Pair" object, for instance:
      foo => 1
    Compare with the "adverbial pair" notation.
  Panda
    A Perl 6 "package manager" designed to make it easier to download,
    compile and install "module"s according to the transitive dependencies
    specified in the "META.info" metadata files of said modules. Unlike
    other "package manager"s, panda supports many "VM"s, namely the three
    VMs supported by the "Rakudo" compiler: "MoarVM", "Parrot" and "JVM".
    The official set of modules is called the "ecosystem" according to the
    "github" repository name that contains the module list pointing to their
    respective repositories.
  panda bootstrap script
  parakudo
    "Rakudo" running on "Parrot".
  parameter
    In a "signature", defines how the corresponding "argument" is bound when
    the "block", "sub" or "method" with a signature is called. Is often
    designated as "formal parameter" in the literature about other
    languages. A parameter can be "positional" or "named", either can be
    "variadic" or not.
  parrakudo
    See "parakudo".
  PARENT::
    A "pseudo-scope" to access lexical "symbol"s in the unit's DSL (usually
    CORE).
  Parrot
    A virtual machine designed to run Perl 6 and other "dynamic language"s.
    Mostly historic.
  parser
    The parser is the "compiler" part that transforms the "source code" into
    a "parse tree". A parser is specified by a "grammar". The code used by
    the parser leverages three different engines: the expression parser, a
    recursive engine, an "NFA" based engine. "LTM" is a feature of the "NFA"
    engine. One difference between "|" and "||" is that the former involves
    an "NFA", while the latter involves the recursive engine. That's why the
    former is faster than the latter.
    See also "grammar".
  parse tree
  PAST
    "Parrot" "AST".
  PAUSE
    Perl Authors Upload SErvice. The place where authors upload their
    distributions to "CPAN".
  pb
    Short for "problem". As in "that's not the pb".
  PBP
    "Perl Best Practices". The book by Damian Conway outlining best
    practices when programming Perl 5.
  PDD
    Parrot Design Document. Numbered documents detailing various parts of
    the design of Parrot.
    Could also be used to refer to "Presentation-Driven Development", the
    practice of implementing a feature after having submitted a presentation
    about said feature.
  PEG
    Parsing Expression Grammar. See "grammar".
  Perlito
    A "compiler" project that has frontends for Perl 5 and Perl 6, as well
    as multiple backends.
  phaser
    A piece of code (a "blast") that runs at a particular phase in the
    program's lifecycle, for example during compilation ("BEGIN"), the first
    time a loop is entered ("FIRST"), or after all regular code has run
    ("END").
  PIO
    An implementation specific internal object for doing I/O. Originally a
    Parrot I/O object, now a Perl I/O object.
  PIR
    Parrot Intermediate Representation.
  PMC
    Parrot Magic Cookie.
  pod
    Plain Ol' Documentation, a documentation format understood by Perl 6.
    See S26 <http://design.perl6.org/S26.html> for details.
  pod6
    Used to specify Perl 6's version of "pod", as opposed to Perl 5's.
  pointy block
    See "lambda".
  POLA
    Principle Of Least Astonishment.
  POLS
    Principle Of Least Surprise.
    A "role" denoting an linearly ordered composite data structure that can
    be iterated.
  positional parameter
  postcircumfix
    An operator that follows a term directly and encloses another term
    inside it. For example:
        my $friend = @names[15];
        #                  ^--^ circumfix
        #            post--^
  postfix
    An operator that comes after the term it belongs to.
  PPI
    Perl 5 module for parsing, analyzing and manipulating Perl 5 source
    code. <https://metacpan.org/pod/PPI>.
  pragma
    A pragma is a module which influences some aspect of the compile time or
    run time behaviour of Perl.
  precedence
    The order in which operators bind terms together; tighter precedence
    evaluates before looser precedence. See "Operator precedence" in S03 for
    details.
  precomp
    Precompiled "compilation unit".
  prefix
    An operator that comes before the term it belongs to, for example
        say ?42;    # True
        #   ^ prefix operator
  predicate
    Expression used in a "boolean context" by a "control flow" "statement".
  precomposed codepoint
    A composite codepoint (that is, formed of many "codepoint"s), for which
    "Unicode" assigns a codepoint. Thanks to "NFG", a composite non
    precomposed codepoint (aka a synthetic one) has its own dynamically
    assigned codepoint.
  private
  process
    Basic execution unit in a multitasking operating system. Processes
    differ from "thread"s in the sense that they are directly managed by the
    operating system itself.
  PROCESS::
    A "pseudo-scope" to access "process"-related globals (superglobals)
    "symbol"s.
  producer
  program
  project
    A project is a "version"ed "repository". It typically contains a "bin"
    folder and a "lib" and "t" hierarchy. They respectively contain
    executable scripts, Perl 6 libraries and tests. The list of projects is
    maintained in the ecosystem repository. The "META.info" file drives the
    compilation and installation of the project by the "project management
    software".
  project manager
    A "program" that fetches, compiles and installs "project". "panda" is
    such a program.
  pseudo-scope
  pseudo-package
    a "package" name which meaning is contextual or predefined by the
    language. For example "MY" denotes the current "lexical scope" and its
    "symbol"s can be listed with "MY::.keys".
  promise
  proto
    A proto is a generic "dispatcher" to "multi"s by the same "shortname".
  proxy
  PR
    Short for "pull request".
  prove
    Perl 5 script to run tests through a "TAP" harness. See prove
    <http://perldoc.perl.org/prove.html>.
  PSA
    Problem, Solution, Acceptance.
  PSGI
  pull request
    A feature of "github" that's used after a user has "fork"ed a project
    and made changes to it that they wish to have in the main project.
  pugs
    A Perl 6 implementation in Haskell, led by the efforts of Audrey Tang.
    The first truly usable Perl 6 implementation, it was actively developed
    2005 through 2007.
  punctuational variable
    Another name for "magic variable".
  pun
    When a role is used as a class, punning is the implicit operation that
    converts the role to the class using the metaclass compose method. In a
    wider, non-Perl 6 context, it can refer to any implicit conversion.
  pure
    A "function", "method" or "op" is pure if it has no side effect, and the
    value it gives is depends only of its arguments so it is referentially
    transparent giving the opportunity of optimizations.
  pure perl
    Use to qualify Some source code, or "project" that does not depend on
    non Perl resources like a "shared library" generated from C code.
  p5
    Short for Perl 5, the (older brother|parent) of Perl 6.
  p6
    Short for Perl 6, the (spunky little sister|child) of Perl 5.
  P6W
    See "Weekly Changes".
Q
  QAST
    Successor to "PAST".
  queue
R
  race
    Process data asynchronously when possible, and don't care in which order
    the result data is returned.
  Rakudo
    An implementation of Perl 6 originally targeting "Parrot", it now
    targets Parrot, the "JVM", and "MoarVM" through "NQP".
  Rakudo *
    Rakudo Star, a useful and at most monthly, at least quarterly
    distribution of Rakudo which includes modules and "Panda".
  R*
    See "Rakudo *".
  rakudobrew
    Quick and dirty command line tool for managing "Rakudo" installations on
    Unix boxes. It can fetch the latest code from "github", build against
    your choice of "backend"s, and simplify version upgrades.
    Definition adapted from from
    "http://iinteractive.com/notebook/2015/06/02/rakudobrew.html".
  Rakudo Star daily
    Daily build reports on rakudo-star to track module tests on each
    "backend". Its README <https://github.com/coke/rakudo-star-daily>
  rakudobug
    A bug in "Rakudo". Usually used in contexts such as "/me submits
    rakudobug".
  range
  referential transparency
  regex
    Short for Regular Expressions, an easy way of parsing text for certain
    kinds of information.
  regexp
    An alternative abbreviation of "regex" that usually occurs in non-Perl 6
    contexts.
  reification
    Certain composite objects like "range" are defined in the abstract. They
    are partially or totally reified on demand, that is, their composant
    objects are created only when they are needed. Without that laziness,
    some objects would consume too much "memory" or would not even fit in
    memory like the infinite "range": "1..Inf" See also "laziness".
  reify
  REPL
    Read Eval Print Loop. Read a line of code, evaluate, print, wait for new
    line of code. Commonly used to experiment with code and get results
    whenever a line is finished.
  repository
    A repository contains the information pertaining to a software or its
    "module"s. That is the source code, its history and ancillary
    information like a wiki, a bug tracking system, a static web site,
    depending on the hosting service containing the repository. Usually Perl
    6 related information is stored in "github" repositories. The official
    list of Perl 6 modules is the "ecosystem" which is also stored in a
    repository. When installing a module, the "panda" "package manager" uses
    the ecosystem to fetch the appropriate repositories for transitive
    dependencies.
  REPR
    Representation.
  representation
    In MoarVM, low level C code associated to a data type. Typically an NQP
    call for a type translates into a MoarVM instruction (opcode) that calls
    a function in the representation table of that type.
  require
    Require is the "runtime" loading of a "module" and the related "import"s
  revert
    Revert is "git" terminology. It adds a new commit to revert some changes
    in a branch. It is different from a reset that throws away changes.
  roast
    The Perl 6 specification tests, which live here:
    <https://github.com/perl6/roast/>. Originally developed for "pugs", it
    now serves all Perl 6 implementations. Why roast? It's the repository of
    all spec tests.
  role
    A role can be composed with zero or more other roles, then instantiated
    into a "class". The "sigil" of a variable name indicates that the
    defined value in the container denoted by the variable belongs to a
    class composed from the associated role. For example, the sigil "@"
    denotes the "Positional" role. So a variable @a may contain a value of
    type "List" because "List.does(Positional)".
  RC
    1) Release Candidate, a last chance to find terrible bugs or
    non-portabilities before the actual release.
    2) "Rosetta Code"
    3) Request Context.
  reposession
    In precompilation, if an object inside a module, changes an object in
    another precompiled module, it needs to indicate that it is now
    responsible for its serialization: this is called "repossession" of the
    object by the module.
  Repository
  Root Object
    See root object
    <http://en.wikipedia.org/wiki/Tracing_garbage_collection>. In "MoarVM",
    routines that handles roots are declared here
    <https://github.com/MoarVM/MoarVM/blob/master/src/gc/roots.h>.
  Rosalind
    Rosalind <http://rosalind.info/> is a platform for learning
    bioinformatics and programming through problem solving. Some of the
    problems are solved through elegant Perl 6 code snippets.
  Rosetta Code
    Rosetta Code <http://rosettacode.org>, a site for comparing snippets
    from different languages in how they solve various tasks.
  RPA
    Resizable "PMC" Array.
  RSN
    Real Soon Now.
  RT
    Request Tracker (<http://rt.perl.org/>). To open a ticket, email>
    "rakudobug@perl.org".
  rule
  runtime
S
  sanity test
    A test for a basic feature that robs your sanity if it doesn't work, and
    the fact that it doesn't work goes unnoticed.
  say
  SC
    A "serialization context" groups together things, usually from the same
    "compilation unit".
  scalar
  scope
    Association of a name with an entity delimited by a "block".
  script
    A "program" executable in its "source code" form. Implicitly depends on
    the "setting" or explicitely "use" "module"s from the "ecosystem"
  segfault
    See "segmentation fault".
  segmentation fault
    Something that should never, ever happen. Complain on #perl6 if you see
    one.
  self-clocking code
  semicolon
    A "character" used to separate or terminate "statement"s.
  serialization
    The serialization saves information obtained at compilation time from a
    "compilation unit" to be deserialized at load time to perform various
    initialization tasks. The saved information involves named constants,
    strings, among many other things.
  serialization context
  SETTING::
    A "pseudo-scope" to access "lexical symbol"s in the unit's "DSL"
    (usually CORE).
  setting
    Library set that is loaded by default. When possible, the setting is
    loaded lazily to optimize loading time.
  shared library
    "operating system" level "library" dynamically loaded by a "process".
    When different processes load the same library, it is loaded once in
    memory, so the shared adjective.
  shortname
    The name of a routine only; without the type signature of its invocant
    arguments. See "longname".
  sigil
    In Perl, the sigil is the first character of a variable name. It must be
    either "$", "@", "%", or "&" respectively for a scalar, array, hash, or
    code variable. See also "twigil" and "role". Also sigilled variables
    allow short conventions for "variable interpolation" in a double quoted
    string, or even "postcircumfix" expressions starting with such a
  signature
    A signature is used by "block"s, "sub"s or "methods" in L to specify the
    "arguments" they can receive when they are called.
  Single Static Assignment
  sink context
    Context of an expression whose value is ignored. Often called "void"
    context in other languages.
  sixplanet
    sixplanet <http://planeteria.org/perl6/> is a collation of blogs related
    to Perl 6. If planeteria.org is down, a replacement can be found on
    <http://pl6anet.org/>.
  slang
    Short for sublanguage. A slang is a "grammar" derived from the Perl 6
    grammar, and its associated "actions". Alternatively the Perl 6 syntax
    can be seen as the combination of many slangs (the regex slang, the
    quotation slang...) Defining a slang has a cost because it usually
    involves generating new "NFA" tables; except for the space taken by the
    said tables, it is compilation time cost. Slang is a principled way to
    create Domain Specific Languages (DSLs).
  smart match
  snake case
    identifier is indicated with an underscore (_) character. For example,
    "is_deeply". Popular in Perl 5, Python, and other scripting languages.
    See "camel case", "kebab case".
  SMOP
    Small/Simple Matter Of Programming. The thing you do when not
    specifying, documenting, discussing, lurking or idling. See also here
    <http://en.wikipedia.org/wiki/Small_matter_of_programming>.
  slurpy
    A parameter that will "slurp up" any excess named or positional
    parameters and present them as a hash or list respectively.
  slushy
    A specification that has frozen chunks in it, but remains frustratingly
    fluid. Ranges from S02 and S03 which are nearly frozen, to S16 which is
    more like a glass of ice water.
  source code
    Textual form of a "program".
  spectest
    Alternative name for "roast" after the name of its target name in
    "rakudo compiler". A program that passes the Perl 6 "test suite" is a
    valid Perl 6 "compiler". Link <https://github.com/perl6/roast> to the
    "github" "repository" that contains the said test suite.
  special variable
    Variable with one of the "twigil" "?", "*" or "="; or "magic variable".
    The said twigils respectively correspond to "compiler constant"s,
    "context variable"s or "pod" data.
    See S28 <http://design.perl6.org/S28.html>.
  spesh
    A functionality of the "MoarVM" platform that uses run-time gathered
    data to improve commonly used pieces of "bytecode". It is much like a
    "JIT" compiler, except that those usually output "machine code" rather
    than bytecode.
  splat
  SSA
    See "Single Static Assignment".
  stack frame
    See "frame".
  STable
    Representation independent data structure associated with the type of an
    object. Part of the "6model". See
    <http://jnthn.net/papers/2013-yapceu-moarvm.pdf>.
  stage
    Can denote steps either on bootstrapping NQP, or compilation stages.
    For bootstrapping stages, see "bootstrap".
    Compilation proceeds on successive stages. Later stages are "backend
    dependent". When there is a dumper available, you can see the output of
    one stage with the switch "--target=*stage_name*". The argument is case
    insensitive. The backend independent stages are "parse" and "ast". The
    "JVM" backend specific states are "jast", "classfile", "jar", "jvm". For
    "MoarVM", they are "mast", "mbc". "moar".
  star
  stash
  state
  statement
  static frame
    Data pertaining to a "frame" gathered at compile time.
  static typing
    In a language with stating typing, at "runtime", values don't need to be
    annotated with their type. See "type erasure".
    Compare with "dynamic typing", "gradual typing"
  STM
    Software Transactional Memory.
  Str
    Name of the string type.
  string
    A sequence of characters. See "characters" for the definition of string
    length according to the different abstractions underlying a "Unicode"
    string. There is some speculation of string being "lazy" in some future
    Perl 6 version.
  sub
    Short for subroutine.
  Subroutine
    A subroutine is like a "block", but its "runtime" context is stacked.
    When a subroutine is called, its context is pushed in the context stack
    and the code pointer moves to its block. When executing a return, the
    context stack is popped and the return argument becomes the value of the
    calling expression.
  Subsignature
    Similar to destructuring bind in Lisp, pattern matching in Haskell/the
    ML family of languages.
    Allows you to specify a construction pattern in place of a normal
    parameter; the argument supplied at call time will be used to populate
    variables in the pattern. For example:
        sub quicksort (@data, $reverse?, $inplace?) { ... }
    versus
        sub quicksort ([$pivot, *@data], $reverse?, $inplace?) { ... }
    See "Unpacking a single list argument" in S06-routines, "Unpacking tree
    node parameters" in S06-routines.
    Not to be confused with Closure parameters.
  supply
  symbol
    Fancy alternative way to denote a name. Generally used in the context of
    "module"s linking, be it in the "OS" level, or at the Perl 6 "VM" level
    for modules generated from languages targeting these VMs. The set of
    "import"ed or exported symbols is called the symbol table.
  :sym
    The current human-readable description of the Perl 6 language. Still in
    development. Much more a community effort than the "Apocalypse"s and
    Exegeses were. The current state of the language is reflected by roast,
    its "test suite", not the synopses where speculative material is not
    always so flagged. This is even more true of material that is deemed to
    pertain to 1.0 version of the language but has not been yet implemented.
  syntax analysis
    See "parser".
  Syntax sugar
    See "Huffmanization".
  synthetic codepoint
    A codepoint for a "grapheme" composed of many "codepoint"s that has not
    a </precomposed codepoint> defined by "Unicode". "NFG" dynamically
    assigns its own codepoint for such a composition.
T
  tail call
  TAP
    Test Anything Protocol
    <http://en.wikipedia.org/wiki/Test_Anything_Protocol>.
  Task::Star
    A "bundle" that directs "Panda" to install "Rakudo *" "module"s.
  TCO
    "tail call" optimization.
  term
  test suite
    The Perl 6 test suite is "roast"
  Texas operator
    The ASCII variant of a non-ASCII Unicode operator or symbol. So
    described because "Everything's bigger in Texas." For instance, ">>+<<"
    is the "Texas" form of the "»+«" hyper-addition operator, and "(elem)"
    corresponds to the "∈" ("Is this an element of that set?") operator that
    comes from set theory. Texas operators are a workaround to the problem
    that people don't know how to type Unicode yet. Culturally, while we
    encourage people to use the Unicode symbols in a vague sort of way, we
    do not disparage the use of the ASCII variants. Well, maybe just a
    little...
  TheDamian
    "IRC" screen name for Damian Conway, writer of the original Exegeses.
  thinko
    A thinkographical error; i.e. a small mistake made by improperly
    expecting code to "DWIM" or from an interrupted thought process.
  thread
    An execution unit more lightweight than a "process". Threads allow
    parallelization of code for concurrent performance but it is tricky to
    modify information shared by the different threads of a process. Perl 6
    provides many primitives that create threads when needed so direct
    thread use is possible but should be done only when necessary.
  thunk
    A piece of code that isn't immediately executed, but doesn't have an
    independent scope.
    Examples for thunks:
        my $a;
        $a = 1 if 1;
     #  ^^^^^^ thunk
            has $.attr = 42 + 23;
            #            ^^^^^^^ thunk
            method x($attr = say 42) {
                #            ^^^^^^ thunk
        $a = 1 || say 2;
        #         ^^^^^ thunk
  TimToady
    "IRC" screen name for Larry Wall, creator of Perl. The name comes from
    the pronunciation of "TMTOWTDI" as a word.
  TIMTOWTDI
    An alternative form of "TMTOWTDI", explicitly including the "is" from
    the contraction "There's".
  tl;dr
    Too Long; Didn't Read <http://en.wiktionary.org/wiki/TL;DR>. Also
    denotes a summary for those who are prone to claim tl;dr.
  TMI
    Too Much Information.
  TMTOWTDI
    "There's More Than One Way To Do It", the Perl motto.
  token
    A token is a keyword that introduces a lexing "rule" in a grammar
  topic
    Expression whose value is aliased to $_.
  trait
  TTIAR
    Two Terms In A Row. A common error message often resulting from a
    missing "semicolon" between two "statement"s or putting an operator
    directly after a "sub".
  tpyo
    Typo.
  tuit
    The mystical unit of effort in the open source community. Sometimes
    materialized in wooden nickels.
  twigil
    A secondary "sigil". For example, %*ENV has a sigil of "%" and a twigil
    of "*".
    See <http://design.perl6.org/S02.html#Twigils> and S24
  type
    The type of a value $val can be obtained using "$val.WHAT" which the
    corresponding type object. When a value is native, the <.WHAT> macro
    operates on the corresponding boxed value.
  type erasure
    Type annotation for a value of "static type" is unnecessary at "runtime"
    The absence of that annotation at compared to "compile time" is called
    type erasure.
U
  UAX
    Unicode Standard Annex. Unicode standard material that is not part of
    the core. Some are specific to some languages while others are generic,
    like UAX 15 <http://www.unicode.org/reports/tr15/> which covers "Unicode
    Normalization Form"s.
  UCD
    See "Unicode Character Database".
  unboxing
    See "boxing".
  unspace
    A way to put "whitespace" in your code that is ignored by the parser.
    Introduced with a backslash.
  ufo
    See here <https://github.com/masak/ufo/>.
  UGT
    "Universal Greeting Time" - i.e., it's always "morning".
  unary
    An operator is unary if its "arity" is one. Operators belonging to the
    categories "prefix", "postfix" and "circumfix" are unary.
  Unicode
    Unicode is a standard defining the encodings, representation and
    handling of text in most writing systems. This standard includes a
    useful Unicode glossary <http://www.unicode.org/glossary/>. For Perl 6
    handling of Unicode, see the documentation
    <https://raw.githubusercontent.com/perl6/specs/master/S15-unicode.pod>.
    See also "NFG" for an encoding specific to Perl 6.
  Unicode Character Database
    It consists of a number of data files listing Unicode character
    properties and related data. It also includes data files containing test
    data for conformance to several important Unicode algorithms. See also
    <http://www.unicode.org/ucd/>.
  Unicode Normalization Form
    See "UAX" 15 <http://unicode.org/reports/tr15/>. Perl 6 defines an
    additional one : "NFG".
  unit
  UNIT
    Symbols in the outermost lexical scope of a compilation unit.
  unmanaged size
    The amount of memory a "REPR" has behind it that is not under the direct
    management of the "GC". Used for "heap" profiling.
  unslushing
    See "slushy".
  use
    Use is the compilation time loading of a "module". That means, contrary
    to "require" that the "import"ed symbols are known at compilation time
    to the rest of the compilation of the code
V
  value
  variable
    A variable is a name for a "container".
  variable interpolation
    See "sigil" and "Q forms" in S02.
  variadic
  ver
    Short way to indicate "version".
  version
    Can be obtained with "*perl6 -v*" with *perl6* depending on your
    "implementation". This command gives something like that below for
    "Rakudo" on "MoarVM"
      This is perl6 version 2014.08-187-gdf2245d built on MoarVM version 2014.08-55-ga5ae111
    Strangely the "NQP" related information is missing.
  visibility
    An "object variable" declared with the ! "twigil" can be in scope but is
    not visible.
  Virtual Machine
    A virtual machine is the Perl compiler entity that executes the
    "bytecode". It can optimize the bytecode or generate "machine code" Just
    in Time. Such as "Parrot", "JVM" and "MoarVM".
  VM
    See "Virtual Machine".
  v5
    Stands for "Perl, version 5" and is used in code to indicate that the
    code is Perl 5:
        use v5;
  v6
    Stands for "Perl, version 6" and is used in code to indicate that the
    code is written in Perl 6:
W
  warnocked
    This lemma will never be explained.
  WAT
    <https://www.destroyallsoftware.com/talks/wat>. Often used as the
    opposite of "DWIM".
  Weekly Changes
    Mostly weekly report <http://p6weekly.wordpress.com/> about changes in
    the Perl 6 World. See also: "sixplanet".
  wfm
    Works For Me.
  Whatever
    <http://doc.perl6.org/type/Whatever>.
  whitespace
    The negative space between syntactic constructs within a language.
    Typically consists of spaces, tabs, newlines, form feeds, and other
    "invisible" characters. For the purposes of parsing Perl 6, "comment"s
    are also considered whitespace. See also "unspace".
  WIP
    Work In Progress.
  world
    The world is the data about a package that is serialized when compiling
    a "compilation unit". the nqp and rakudo compiler have a World class
    handling the said data. See NQP::World
    <https://github.com/perl6/nqp/blob/master/src/NQP/World.nqp> and
    Rakudo::World
    <https://github.com/rakudo/rakudo/blob/nom/src/Perl6/World.nqp>.
  WP
    Wikipedia.
  ww
    Short for "wrong window". When on IRC, someone types something in a
    channel that was intended for another channel, or for a private message.
X
  XS
    Perl 5's mechanism for bridging the gap between pure-Perl code and
    compiled system libraries. Writing XS modules involves C code and some
    knowledge of Perl 5's inner workings, and installing them needs a
    compiler. The Perl 6 equivalent is "NativeCall"; see S21.
  XY Problem
    Sometimes people want to achieve X, and think Y is the best way to do
    it. So they ask "How do I do Y?", but doing Y is actually harder or less
    idiomatic than solving X some other way. So the person asking how to do
    Y has an XY problem.
Y
  YAPAE
    Yet Another Potentially Awkward Explanation. A term referring to the
    "curious corners"
    <https://perl6advent.wordpress.com/2014/12/04/composers-coercers-and-the
    -case-of-a-camels-curious-corner/> of any given language, specifically
    the kind of example (mis)features of a programming language which are
    thrown by various sides in a flame war.
    These examples are understood to be places where the actual design
    choices of a given language become visible.
  yoleaux
    The "bot" on #perl6 that is your personal assistant. See
    <https://github.com/dpk/yoleaux> and <http://dpk.io/yoleaux>.
  YOU_ARE_HERE
Z
  Zavolaj
    Zavolaj was a module to support "Native Call"s into libraries. It is now
    part of "Rakudo"
  Zen slice
    A Zen slice is a slice of an object without specification of the
    elements. As such it is empty, yet it is supposed to return the object
    in its entirety. Usually used as a way of interpolating entire hashes /
    arrays in strings.
*
    Oh, um... "Whatever".
  #perl6
    "IRC" "channel" on "freenode" that hosts discussions related to Perl 6.
    Archived on <http://irclog.perlgeek.de/perl6/>.
  .
  ..
  ...
:
    Everybody wants the colon.
  :ignorecase
  :ignoremark
  :ratchet
  ?
  (
   ()
    See "empty list".
  *
  @_
    The Perl 5 style argument list. Something you should stop using, and use
    subroutine signatures instead.
  $_
    The "topic variable". Set by any construct that's a "topicalizer", like
    the "given" statement or a for loop.
  $/
    A "magic variable" which "value" is the current "Match", or "nil" if
    none.
  $¢
    "cursor"
  $!
    A "magic variable" which "value" is the current "Exception"
  %_
  ++
    Way to increase "karma" on IRC. A "prefix" or "postfix" incrementation
    "operator".
  &
    Sigil of a "callable" "variable". Also used at the end of a line in an
    "IRC" message to indicate the user is away, doing something else in the
    background. For instance:
      sleep&
  6model
    The "new object model"/"MOP" that's currently in rakudo. "MoarVM" uses
    this internally. On "Parrot" and "JVM", it sits on top of the native
    object model.
        Elizabeth Mattijsen (liz@dijkmat.nl)
        Moritz Lenz
        Larry Wall
    DRAFT: Synopsis 32: Setting Library - Str
        Created: 19 Mar 2009 (extracted from S29-functions.pod)
        Last Modified: 2015-07-24
Str
    General notes about strings:
    The "Str" class contains strings encoded at the NFG level. Other
    standard Unicode normalizations can be found in their
    appropriately-named types: "NFC", "NFD", "NFKC", and "NFKD". The "Uni"
    type contains a string in a mixture of normalizations (i.e. not
    normalized). S15 describes these in more detail.
    The following are all provided by the "Str" class, as well as related
    chop
            multi method chop(Str $string: $n = 1 --> Str) is export
        Returns string with an optional number of characters removed from
        the end. Defaults to removing one character.
    chomp
            multi method chomp(Str $string: --> Str) is export
        Returns string with one newline removed from the end. An arbitrary
        terminator can be removed if the input filehandle has marked the
        string for where the "newline" begins. (Presumably this is stored as
        a property of the string.) Otherwise a standard newline is removed.
        Note: Most users should just let their I/O handles autochomp
        instead. (Autochomping is the default.)
    lc
            multi method lc(Str $string: --> Str) is export
        Returns the input string after forcing each character to its
        lowercase form. Note that one-to-one mapping is not in general
        guaranteed; different forms may be chosen according to context.
    uc
            multi method uc(Str $string: --> Str) is export
        uppercase (not titlecase) form. Note that one-to-one mapping is not
        in general guaranteed; different forms may be chosen according to
        context.
    fc
            multi method fc(Str $string: --> Str) is export
        Does a Unicode "fold case" operation suitable for doing caseless
        string comparisons. (In general, the returned string is unlikely to
        be useful for any purpose other than comparison.)
    tc
            multi method tc(Str $string: --> Str) is export
        Converts the first character of a string to titlecase form, leaving
        the rest of the characters unchanged, then returns the modified
        string. If there is no titlecase mapping for the first character,
        the entire string is returned unchanged. In any case, this function
        never changes any character after the first. (It is like the old
        Perl 5 "ucfirst" function in that respect.)
    tclc
            multi method tclc(Str $string: --> Str) is export
        Forces the first character of a string to titlecase and the rest of
        the characters to lowercase, then returns the modified string.
    wordcase
            multi method wordcase(Str $string:
                                  :&filter = &tclc,
                                  :$where = True --> Str) is export
        Performs a substitutional mapping of each word in the string,
        defaulting to the "tclc" mapping. Words are defined as Perl 6
        identifiers, hence admit hyphens and apostrophes when followed by a
        letter. (Note that trailing apostrophes don't matter when
        casemapping.) The following should have the same result:
            .wordcase;
            .subst(:g, / <ident>+ % <[ \- ' ]> /, *.Str.tclc)
        The "filter" function is always applied to the first and last word,
        and additionally to any intermediate word that smartmatches with the
        "where" parameter. Assuming suitable definitions of word lists,
        standard English capitalization might be handled with something like
            my $where = none map *.fc, @conjunctions, @prepositions;
            .wordcase(:$where);
        (Note that the "standard" authorities disagree on the prepositions!)
        [XXX: Is case-insensitive matching on "wordcase"'s part necessary?]
        The smartmatching is done case insensitively, so you should store
        your exceptions in "fc" form. If the "where" smartmatch does not
        match, then the word will be forced to lowercase.
        There is no provision for an alternate regex; if you need a custom
        word recognizer, you can write your own ".subst" as above.
    samecase
            multi method samecase(Str $string: Str $pattern --> Str) is export
        Has the effect of making the case of the string match the case
        pattern in $pattern. (Used by s:ii/// internally, see S05.)
    samemark
            multi method samemark(Str $string: Str $pattern --> Str) is export
        Has the effect of making the case of the string match the marking
        pattern in $pattern. (Used by s:mm/// internally, see S05.)
    length
        This method does not exist in Perl 6. You must use either "chars" or
        "codes", depending on what kind of count you need.
    chars
            multi method chars(Str $string: --> Int) is export
        Returns the number of characters in the string. For "Str" this
        corresponds to the number of graphemes, for other types this is
        equivalent to "codes".
    codes
            multi method codes(Str $string: --> Int) is export
        Returns the number of codepoints in the string. For "Str" this
        corresponds to the number of characters as if it were an "NFC" type
        string.
    bytes
        Gone. Use "$str.encode($encoding).bytes" instead.
    encode
            multi method encode($encoding = $?ENC --> Buf)
        Returns a "Blob" which represents the original string in the given
        encoding. The actual return type is as specific as possible, so
        "$str.encode('UTF-8')" returns a "utf8" object,
        "$str.encode('ISO-8859-1')" a "blob8".
        "Str.encode" is functionally equivalent to "NFC.encode". If you mean
        one of the other normalization forms, convert the "Str" to the
        appropriate type first.
    index
            multi method index(Str $string: Str $substring, Int $pos) is export
        "index" searches for the first occurrence of $substring in $string,
        starting at $pos.
        If the substring is found, then the value returned represents the
        position of the first character of the substring. If the substring
        is not found, "Nil" is returned. Do not evaluate it as a number,
        because that will assume <0> and issue a warning.
        [Note: if $substring is not of the same string type as $string,
        should that cause an error, or should $substring be converted to
        $string's type?]
    pack
            multi pack(*@items where { all(@items) ~~ Pair } --> buf8)
            multi pack(Str $template, *@items --> buf8)
        "pack" takes a list of pairs and formats the values according to the
        specification of the keys. Alternately, it takes a string $template
        and formats the rest of its arguments according to the
        specifications in the template string. The result is a sequence of
        bytes.
        Templates are strings of the form:
            grammar Str::PackTemplate {
                regex TOP       { ^ <template> $ }
                regex template  { [ <group> | <specifier> <count>? ]* }
                token group     { \( <template> \) }
                token specifier { <[aAZbBhHcCsSiIlLnNvVqQjJfdFDpPuUwxX\@]> \!? }
                token count     { \*
                                | \[ [ \d+ | <specifier> ] \]
                                | \d+ }
        In the pairwise mode, each key must contain a single "<group>" or
        "<specifier>", and the values must be either scalar arguments or
        arrays.
        [ Note: Need more documentation and need to figure out what Perl 5
        things no longer make sense. Does Perl 6 need any extra formatting
        features? -ajs ]
        [I think pack formats should be human readable but compiled to an
        internal form for efficiency. I also think that compact classes
        should be able to express their serialization in pack form if asked
        for it with .packformat or some such. -law]
    rindex
            multi method rindex(Str $string: Str $substring, Int $pos) is export
        Returns the position of the last $substring in $string. If $pos is
        specified, then the search starts at that location in $string, and
        works backwards. See "index" for more detail.
            multi sub split(Str $delimiter,
                            Str $input,
                            Int $limit = Inf,
                            Bool :$all = False
                            --> List)
            multi sub split(Regex $delimiter,
            multi method split(Str $input:
                               Str $delimiter,
                               Int $limit = Inf,
                               Bool :$all = False
                               --> List)
                               Regex $delimiter,
        Splits a string up into pieces based on delimiters found in the
        Delimiters can be specified as either a "Regex" or a constant string
        type. The "split" function no longer has a default delimiter nor a
        default invocant. In general you should use "words" to split on
        whitespace now, or "comb" to break into individual characters. (See
        below.)
        If the ":all" adverb is supplied to the string delimiter form, the
        delimiter will be returned in alternation with the split values. In
        "Regex" delimiter form, the delimiters are returned as "Match"
        objects in alternation with the split values. Unlike with Perl 5, if
        the delimiter contains multiple captures they are returned as
        submatches of single "Match" object. (And since "Match" does
        "Capture", whether these "Match" objects eventually flatten or not
        depends on whether the expression is bound into a list or slice
        context.)
        You may also split lists and filehandles.
        "$*ARGS.split(/\n[\h*\n]+/)" splits on paragraphs, for instance.
        Lists and filehandles are automatically fed through "cat" in order
        to pretend to be string. The resulting "Cat" is lazy. Accessing a
        filehandle as both a filehandle and as a "Cat" is undefined.
            multi sub comb(Str $matcher,
                           Str $input,
                           Int $limit = Inf,
                           Bool :$match
                           --> List)
            multi sub comb(Regex $matcher,
            multi method comb(Str $input:
                              Str $matcher,
                              Int $limit = Inf,
                              Bool :$match
                              --> List)
                              Regex $matcher = /./,
        The "comb" function looks through a string for the interesting bits,
        ignoring the parts that don't match. In other words, it's a version
        of split where you specify what you want, not what you don't want.
        That means the same restrictions apply to the matcher rule as do to
        split's delimiter rule.
        By default it pulls out all individual characters. Saying
            $string.comb(/pat/, $n)
            map {.Str}, $string.match(rx:global:x(0..$n):c/pat/)
        You may also comb lists and filehandles. "+$*IN.comb" counts the
        characters on standard input, for instance. "comb(/./, $thing)"
        returns a list of single character strings from anything that can
        give you a "Str". Lists and filehandles are automatically fed
        through "cat" in order to pretend to be string. This "Cat" is also
        lazy.
        If the ":match" adverb is applied, a list of "Match" objects (one
        per match) is returned instead of strings. This can be used to
        access capturing subrules in the matcher. The unmatched portions are
        never returned -- if you want that, use "split(:all)". If the
        function is combing a lazy structure, the return values may also be
        lazy. (Strings are not lazy, however.)
            multi method lines(Str $input: Int $limit = Inf --> List) is export
        Returns a list of lines, i.e. the same as a call to "$input.comb(/
        ^^ \N* /, $limit)" would.
            multi method words(Str $input: Int $limit = Inf --> List) is export
        Returns a list of non-whitespace bits, i.e. the same as a call to
        "$input.comb(/ \S+ /, $limit)" would.
    flip
        The "flip" function reverses a string character by character.
            multi method flip(Str $str: --> Str) is export
        This method will misplace combining characters on non-"Str" types.
    sprintf
            multi method sprintf(Str $format: *@args --> Str) is export
        This function is mostly identical to the C library sprintf function.
        The $format is scanned for "%" characters. Any "%" introduces a
        format token. Format tokens have the following grammar:
            grammar Str::SprintfFormat {
                regex format_token { '%': ['%' | <index>? <precision>? <directive>] }
                token index { \d+ '$' }
                token precision { <flags>? <vector>? <precision_count> }
                token flags { <[ \x20 + 0 \# \- ]>+ }
                token precision_count { [ <[1..9]>\d* | '*' ]? [ '.' [ \d* | '*' ] ]? }
                token vector { '*'? v }
                token directive { <[csduoxefgXEGbpniDUOF]> }
        Directives guide the use (if any) of the arguments. When a directive
        (other than "%") is used, it indicates how the next argument passed
        is to be formatted into the string.
        The directives are:
            %   a literal percent sign (must be literally '%%')
            c   a character with the given codepoint
            s   a string
            d   an integer, in decimal
            b   an integer, in binary
            o   an integer, in octal
            x   an integer, in hexadecimal
            X   like x, but using uppercase letters
            e   a floating-point number, in scientific notation
            f   a floating-point number, in fixed decimal notation
            g   a floating-point number, in %e or %f notation
            E   like e, but using an uppercase "E"
            G   like g, but with an uppercase "E" (if applicable)
        Compatibility:
            i   a synonym for %d
            u   a synonym for %d
            D   a synonym for %d
            U   a synonym for %u
            O   a synonym for %o
            F   a synonym for %f
        Perl 5 (non-)compatibility:
            n   produces a runtime exception
            p   produces a runtime exception
    fmt
            multi method fmt(Scalar $scalar: Str $format = '%s' --> Str)
            multi method fmt(List $list:
                             Str $format = '%s',
                             Str $separator = ' '
                             --> Str)
            multi method fmt(Hash $hash:
                             Str $format = "%s\t%s",
                             Str $separator = "\n"
            multi method fmt(Pair $pair: Str $format = "%s\t%s" --> Str)
        A set of wrappers around "sprintf". A call to the scalar version
        "$o.fmt($format)" returns the result of "sprintf($format, $o)". A
        call to the list version "@a.fmt($format, $sep)" returns the result
        of "@a.map({ sprintf($format, $_) }).join($sep)". A call to the hash
        version "%h.fmt($format, $sep)" returns the result of
        "%h.pairs.map({ sprintf($format, $_.key, $_.value) }).join($sep)". A
        call to the pair version "$p.fmt($format)" returns the result of
        "sprintf($format, $p.key, $p.value)".
    substr
            multi sub substr(Str $string, Int $start, Int $length? --> Str) is export
            multi sub substr(Str $string, &start,     Int $length? --> Str) is export
            multi sub substr(Str $string, Int $start, &end --> Str) is export
            multi sub substr(Str $string, &start,     &end --> Str) is export
            multi sub substr(Str $string, Range $start-end --> Str) is export
            multi method substr(Str $string: Int $start, Int $length? --> Str) is export
            multi method substr(Str $string: &start,     Int $length? --> Str) is export
            multi method substr(Str $string: Int $start, &end --> Str) is export
            multi method substr(Str $string: &start,     &end --> Str) is export
            multi method substr(Str $string: Range $start-end --> Str) is export
        "substr" returns a substring of $string between the given points.
        The first character can be specified as either an integer or a
        "Callable" taking the length of the string as its only argument. The
        endpoint can be specified by either an "Int" specifying the length
        of the substring, or a "Callable" taking the length of the string as
        its only argument and returning the last character to take. The
        bounds of the substring can be specified by a "Range" instead.
        If the specified length or endpoint goes past the end of the string,
        or if no endpoint is specified, the rest of the string from the
        starting point will be returned.
            $initials = substr($first_name,0,1) ~ substr($last_name,0,1);
        The function fails if the start position and/or length is negative
        or undefined. (If the length argument is not given, it defaults to
        the rest of the string.) Either of start position or end position
        may be specified relative to the end of the string using a
        "WhateverCode" whose argument will be the position of the end of the
        string. While it is illegal for the start position to be outside of
        the string, it is allowed for the final position to be off the end
        of the string.
    substr-rw
            multi sub substr-rw(Str $string, Int $start, Int $length? --> Str) is rw is export
            multi sub substr-rw(Str $string, &start,     Int $length? --> Str) is rw is export
            multi sub substr-rw(Str $string, Int $start, &end --> Str) is rw is export
            multi sub substr-rw(Str $string, &start,     &end --> Str) is rw is export
            multi sub substr-rw(Str $string, Range $start-end --> Str) is rw is export
            multi method substr-rw(Str $string: Int $start, Int $length? --> Str) is rw is export
            multi method substr-rw(Str $string: &start,     Int $length? --> Str) is rw is export
            multi method substr-rw(Str $string: Int $start, &end --> Str) is rw is export
            multi method substr-rw(Str $string: &start,     &end --> Str) is rw is export
            multi method substr-rw(Str $string: Range $start-end --> Str) is rw is export
        A version of "substr" that returns a writable reference to a part of
        a string variable:
            my $string = "one of the characters in the Flinstones is: barney";
            $string ~~ /(barney)/;
            substr-rw($string, $0.from, $0.to) = "fred";
        This writable reference can be the target of an alias, for repeated
        operations:
            my $r := substr-rw($string, $0.from, $0.to);
            $r = "fred";   # "barney" replaced by "fred"
            $r = "wilma";  # "fred" replaced by "wilma"
        Please note that only the start point is kept by the reference: any
        changes to the length of the string before the start point, will
        render the reference useless. So it is probably safest to keep only
        one writable reference per string, or make sure that all replacement
        strings have the same size.
    trim
            multi method trim() is export;
            multi method trim-leading() is export;
            multi method trim-trailing() is export;
        The "trim" method returns a copy of the string with leading and
        trailing whitespace removed. The methods "trim-leading" and
        "trim-trailing" are similar, but with only leading or trailing
        whitespace removed, respectively.
    unpack
        XXX To be defined
    match
            method match(Str $self: Regex $search, *%adverbs --> Match) is export
        Returns the result of checking the given string against $search. See
        S05 for details.
    subst
            method subst(Str $self: Regex $search, Str $replacement, *%adverbs --> Str) is export
        Returns a string with the portion of the string matching $search
        being replaced with $replacement. See S05 for details.
    trans
            method trans(Str $self:
                         *@changes where { all(@changes) ~~ Pair },
                         *%adverbs
                         --> Str) is export;
        Takes a list of "Pair"s and replaces each occurence of a "Pair"'s
        key with its respective value. See S05 for details.
    indent
            multi method indent($str: Int() $steps --> Str) is export
            multi method indent($str: Whatever $steps --> Str) is export
        Returns a re-indented string wherein $steps number of spaces have
        been added to each line. If a line already begins with horizontal
        whitespace, the new spaces are added to the end of those.
        If the whitespace at the beginning of the line consists of only
        "\x20" spaces, "\x20" spaces are added as indentation as well. If
        the whitespace at the beginning of the line consists of some other
        kind of horizontal whitespace, that kind of whitespace is added as
        indentation. If the whitespace at the beginning of the line consists
        of two or more different kinds of horizontal whitespace, again
        "\x20" spaces are used.
        If $steps is negative, removes that many spaces instead. Should any
        line contain too few leading spaces, only those are removed and a
        warning is issued. At most one such warning is issued per ".indent"
        call.
        If $steps is "*", removes just enough indentation to make some line
        have zero indentation.
        Empty lines don't participate in re-indenting at all. That is, a
        line with 0 characters will still have 0 characters after the call.
        It also will not cause a warning to be issued.
        The method will assume hard tabs to be equivalent to "($?TABSTOP //
        8)" spaces, and will treat any other horizontal whitespace character
        as equivalent to one "\x20" space. If the indenting doesn't "add up
        evenly", one hard tab needs to be exploded into the equivalent
        number of spaces before the unindenting of that line.
        Decisions on how to indent each line are based solely on characters
        on that line. Thus, an ".indent" call on a multiline string
        therefore amounts to " .lines».indent.join("\n") ", modulo exotic
        line endings in the original string, and the proviso about empty
        lines.
    IO
            method IO(--> IO::Path) is export
        Returns an IO::Path, using the string as the file path.
            method path(--> IO::Path) is export
        A deprecated form of "IO".
            method succ(--> Str) is export
        Increments the string to the next numeric or alphabetic value, and
        returns the resulting string. The autoincrement operator "++" uses
        "succ" to determine the new value.
        The last portion of the string before the first period (which may be
        the entire string) is incremented, using "<rangechar>" to determine
        which characters are eligible to be incremented. See "Autoincrement
        precedence" in S03 for details.
            method pred(--> Str) is export
        Decrements the string to the next numeric or alphabetic value, and
        returns the resulting string. The autodecrement operator "--" uses
        "pred" to determine the new value.
        When attempting to decrement a string, such as "a0", where the
        result would remove the leftmost characters, "pred" returns failure
    Synopsis 32: Setting Library - Temporal
        Created: 19 Mar 2009
        Last Modified: 10 May 2014
Time and time again
    Two chief aspects of a Perl 6 synopsis seem to contribute to it having
    some extra volatility: how far it sits from the rest of the data model
    of the language, and how everyday the topic in question is. "S32" has
    always been volatile for these reasons; "S32::Temporal" doubly so.
    The truth is that while there are many interests to satisfy in the case
    of a "Temporal" module, and many details to take into account, there's
    also the danger of putting too much in. Therefore, Perl 6's "Temporal"
    module takes the "DateTime" module on CPAN as a starting point, adapts
    it to the Perl 6 OO system, and boils it down to bare essentials.
    One of the unfortunate traditions that Perl 6 aims to break is that of
    having a set of "core" modules which could better serve the community on
    CPAN than in the Perl core. For this reason, this module doesn't handle
    all the world's time zones, locales, date formatters or calendars.
    Instead, it handles a number of "natural" operations well enough for
    most people to be happy, and shows how those who want more than that can
    load a module, or roll their own variants. Put differently, the below
    are the aspects of time that are felt to be stable enough to belong in
    the core.
    Note that in this document, the term "POSIX time" means the number of
    seconds since midnight UTC of 1 January 1970, not counting leap seconds.
    This is the same as the output of the ISO C "time" function. Unlike in
    Perl 5, "time" does not return fractional seconds, since "POSIX" does
    not define the concept during leap seconds. You want to use "now" for
    that instead.
"time"
    Returns the current POSIX time as an "Int". Use "now" for an
    epoch-agnostic measure of atomic seconds (i.e., an "Instant"). Note that
    both "time" and "now" are not functions, but terms of the
    pseudo-constant variety; as such they never take an argument. Saying
    "time()" doesn't work unless you happen to have a function of that name
"DateTime"
    A "DateTime" object, which is immutable, describes a moment in time as
    it would appear on someone's calendar and someone's clock. You can
    create a "DateTime" object from an "Instant" or from an "Int"; in the
    latter case, the argument is interpreted as POSIX time.
        my $now = DateTime.new(now);
        my $now = DateTime.new(time);
    These two statements are equivalent except that "time" doesn't know
    about leap seconds or fractions of seconds. Ambiguous POSIX times (such
    as 915148800, which could refer to 1998-12-31T23:59:60Z or
    1999-01-01T00:00:00Z) are interpreted as non-leap seconds (so in this
    case, the result would be 1999-01-01T00:00:00Z).
    Or you can use named arguments:
        my $moonlanding = DateTime.new( :year(1969), :month(7), :day(16),
                                        :hour(20), :minute(17) ); # UTC time
    This form allows the following arguments:
        :year       required
        :month      defaults to 1   range 1..12
        :day        defaults to 1   range 1..31
        :hour       defaults to 0   range 0..23
        :minute     defaults to 0   range 0..59
        :second     defaults to 0   range 0.0..^62.0
    Another multi exists with "Date :date" instead of ":year", ":month" and
    ":day" (and the same defaults as listed above).
    All of the aforementioned forms of "new" accept two additional named
    arguments. ":formatter" is a callable object that takes a "DateTime" and
    returns a string. The default formatter creates an ISO 8601 timestamp
    (see below). ":timezone" must be an Int or an object that supports an
    .Int method. The Int value of ":timezone" must reflect the timezone
    offset, in seconds from UTC. The default time zone is 0 (i.e., UTC). The
    system's local time zone is available as $*TZ.
    A shorter way to send in date and time information is to provide a
    single string with a full RFC 3339 <http://tools.ietf.org/html/rfc3339>
    date and time (a subset of ISO 8601). The example from above would then
    be
        my $moonlanding = DateTime.new( '1969-07-16T20:17:00Z' ); # UTC time
    The general form is "[date]T[time][offset]", with "[date]" given as
    "YYYY-MM-DD" and "[time]" given as "hh:mm:ss". The final "Z" is a short
    form for +0000, meaning UTC. (Note that while this form of "new" accepts
    all of +0000, -0000, and "Z", the default formatter for "DateTime"
    always expresses UTC as "Z".) The general notation for the "[offset]" is
    "+hhmm" or "-hhmm". The time zone of the new object is assumed to be a
    static offset equal to the "[offset]". The "[offset]" is optional; if
    omitted, a ":timezone" argument is permitted; if this too is omitted,
    UTC is assumed. If the year is less than zero or greater than 9999, the
    default formatter will always print the sign. Finally, the constructor
    also accepts a ":formatter" argument.
    With all the above constructors, if you attempt to pass in values that
    are outside of the ranges specified in the list above, you'll get an
    exception. An exception will also be thrown if the given day (like 31
    April 2000 or 29 February 2006) or second (like 23:59:60 on 1 January
    2000) doesn't exist. The same checks are run when you produce an object
    with "clone":
        my $dt = DateTime.new(:year(1999), :month(1), :day(29));
        say $dt.clone(:year(2000), :month(2)); # 2000-02-29T00:00:00Z
        say $dt.clone(:year(1999), :month(2)); # WRONG; 1999 was a common year
    To convert an object from one time zone to another, use the
    "in-timezone" method:
        my $dt = DateTime.new('2005-02-01T15:00:00+0900');
        say $dt.hour;                       # 15
        $dt = $dt.in-timezone(6 * 60 * 60); # 6 hours ahead of UTC
        say $dt.hour;                       # 12
    Date calculations are done on the proleptic Gregorian calendar, which
    means that we ignore any diurnal upheaval that may have taken place in
    1582 and calculate all dates the same way. The year 1 BCE is represented
    as 0000 (a leap year), which adjusts all other BCE dates by one. For
    example, 5000 BCE is represented as -4999.
    The "utc" method is shorthand for "in-timezone(0)", and the "local"
    method is short for "in-timezone($*TZ)".
    The "truncated-to" constructor allows you to "clear" a number of time
    values below a given resolution:
        my $dt = DateTime.new('2005-02-01T15:20:35Z');
        say $dt.truncated-to('hour'); # 2005-02-01T15:00:00Z
    Arguments to "truncated-to" is one of the following string values:
        second  seconds
        minute  minutes
        hour    hours
        day     days
        week    weeks
        month   months
        year    years
    An argument of 'week' to "truncated-to" yields an object with the date
    of the last Monday (or the same date, if it already is a Monday) and
    with hours, minutes, and seconds all set to zero:
        say $dt.truncated-to('week'); # 2005-01-31T00:00:00Z
    The "later" and "earlier" constructors allows you to move a number of
    time units forward or backward in time.
        $dt.later(minutes => 44);
        $dt.earlier(week => 1);
    (Both "later" and "earlier" accept zero or negative integers, with the
    obvious extended semantics.)
    There's one additional constructor: "now". It works just like
    "DateTime.new(now)" except that there is no positional parameter and the
    ":timezone" argument defaults to $*TZ.
  Accessors
    There are methods "year", "month", "day", "hour", "minute", "second",
    "timezone", and "formatter", giving you the corresponding values of the
    "DateTime" object. The "day" method also has the synonym "day-of-month".
    The method "Instant" returns an "Instant", and the method "posix"
    returns a POSIX time.
    The method "week" returns two values, the *week year* and *week number*.
    (These are also available through the methods "week-year" and
    "week-number", respectively.) The first week of the year is defined by
    ISO as the one which contains the fourth day of January. Thus, dates
    early in January often end up in the last week of the prior year, and
    similarly, the final few days of December may be placed in the first
    week of the next year.
    There's a "day-of-week" method, which returns the day of the week as a
    number 1..7, with 1 being Monday and 7 being Sunday.
    The "day-of-week-in-month" method returns a number 1..5 indicating the
    number of times a particular day-of-week has occurred so far during that
    month, the day itself included. For example, June 9, 2003 is the second
    Monday of the month, and so this method returns 2 for that day.
    The "days-in-month" method returns the number of days in the current
    month of the current year. So in the case of January, "days-in-month"
    always returns 31, whereas in the case of February, "days-in-month"
    returns 28 or 29 depending on the year.
    The "day-of-year" method returns the day of the year, a value between 1
    and 366.
    The method "is-leap-year" returns a "Bool", which is true if and only if
    the current year is a leap year in the Gregorian calendar.
    The method "whole-second" returns the second truncated to an integer.
    The "Date" method returns a "Date" object, and is the same as
    "Date.new($dt.year, $dt.month, $dt.day)".
    The method "offset" returns the object's current offset from UTC in
    seconds. This returns the Int value of ":timezone".
"Date"
    "Date" objects represent a day without a time component. Like "DateTime"
    objects, they are immutable. They allow easier manipulation by assuming
    that integers always mean days.
    Days, Months and days of week are 1-based.
  Constructors
        Date.today();               # today's date
        Date.new(DateTime.now);     # same
        Date.new('2010-12-20');     # YYYY-MM-DD format
        Date.new(:year(2010), :month(12), :day(20));
        Date.new(2010, 12, 20);
        Date.new(2010, 1, 20).clone(month => 12);
        Date.new(2010, 12, 24).truncated-to('week');
        Date.new(2010, 12, 24).later(weeks => 10);
    The constructors die with a helpful error message if month or day are
    out of range.
  Instance methods
    "Date" objects support all of the following accessors, which work just
    like their "DateTime" equivalents:
        year
        month
        day
        day-of-month
        day-of-week
        week
        week-year
        week-number
        day-of-week-in-month
        days-in-month
        day-of-year
        is-leap-year
    The "Str" method returns a string of the form 'yyyy-mm-dd'.
  Arithmetics
        $d.succ                     # Date.new('2010-12-25')
        $d.pred                     # Date.new('2010-12-23')
        $d - Date.new('1984-03-02') # 9793      # (difference in days)
        $d - 42                     # Date.new('2010-11-12')
        $d + 3                      # Date.new('2010-12-27')
        3  + $d                     # Date.new('2010-12-27')
        Martin Berends <mberends@autoexec.demon.nl>
        Olivier Mengué <dolmen@cpan.org>
        Kodi Arfer
        (and others named in FOOTNOTE at bottom)
FOOTNOTE
    The authors of the current rewrite want to mention, with thanks, the
    indirect contribution made by the previous authors:
        Dave Rolsky <autarch@urth.org>
        Matthew (lue) <rnddim@gmail.com>
    Plans for Perl 6 version 6.d
        Created: 09 Aug 2016
        Last Modified: 16 Dec 2016
    This documents contains planned changes for v6.d, and who wants to do
    them.
    Please list yourself as stakeholder so we'd know whom to contact if we
    need clarification. If possible, find a volunteer willing to implement
    your proposal (it could be you).
Sigils imply :D
    In a declaration, the "@" sigil for example implies a type constraint to
    "Positional". I want the sigil to imply the type constraint
    "Positional:D" instead, so that it constrains the variable to defined
    The same applies to the "%" sigil, and possibly the "&" sigil.
    Current behavior:
        sub f(@x) { say @x.perl }; f Array;     # Array
    New behavior:
        sub f(@x) { say @x.perl }; f Array;
        # dies with
        # Parameter '@x' requires an instance of type Array, but a type object was passed.  Did you forget a .new?
  Rationale
    I've never seen anybody write code as if they expected an array or hash
    variable to contain a type object, yet the type checker silently allows
    this, which usually leads to much worse error messages when using the
    type object as if it were an instance.
    Since normal variables are typically used with assignment, not binding,
    constraining the types of parameters is of higher importance.
  Stakeholder
    Moritz Lenz
Non-blocking await
    In v6.c, waiting for a promise, either with an explicit `await` or by
    using its `.result` method, currently uses up a thread just for the
    blocking wait.
    After this proposed change has been implemented, waiting doesn't tie up
    a whole thread for each wait.
    It is quite easy to write code that waits for multiple promises in
    parallel, which can lead to the full thread pool begin tied up in
    blocking waits, leading to a deadlock.
    Examples of this happening have showed up in the past.
    Jonathan Worthington
Formal Rules for Defining Matched Delimiters/Brackets
    In v6.d we should formalize which brackets we support. How do we decide
    which delimiters should be added on future updates to the Unicode
    standard? We should look to the Unicode standard to help us define
    matching delimiters and brackets for Perl 6.
    All delimiters we support should conform to two simple rules for the
    sake of uniformity, elegance and clairity.
  Rules
    1. Delimiter's Unicode General_Category must match one of these:
      Pi -> Pf ( Punctuation, initial quote -> Punctuation, final quote)
      Ps -> Pe (Punctuation, start -> Punctuation, end)
    2. The delimiters must be matching BidiBrackets and/or BidiMirroring
    characters.
    Bidirectional brackets are specified here
    <http://www.unicode.org/Public/UCD/latest/ucd/BidiBrackets.txt>
    Non brackets have their matching glyph specified in this file
    <http://www.unicode.org/Public/UCD/latest/ucd/BidiMirroring.txt>
  Possible issues
    The only possible issue, is what to do with ornate parens.
    BidiBrackets.txt states:
    “For legacy reasons, the characters U+FD3E ORNATE LEFT PARENTHESIS and
    U+FD3F ORNATE RIGHT PARENTHESIS do not mirror in bidirectional display
    and therefore do not form a bracket pair.”
    In v6.c, roast includes tests for 'ornate left parens' and 'ornate right
    parens' for doing things like q[ ] type contructs and such. I think that
    we should not allow these parenthesis because firstly, Unicode states
    they do not form a matching pair of brackets. Secondly, the ornate
    parenthesis also do not have mirror glyphs. To make matters even worse,
    their Unicode general categories are the opposite of every matched
    bracket we support, the opening brackets tested for in v6.c open with
    "Pe"(End) and close with is "Ps"(Start). They break both of these
    proposed rules.
    In practice this is already implement with the exception of the ornate
    parenthesis, but I propose this be made an official part of the Perl 6
    standard.
    Samantha McVey (samcv)
Remove deprecated Test::is_approx
    This is mostly a reminder so we don't forget. Test::is_approx is
    currently marked as deprecated (replaced by `is-approx`). It was decided
    to leave it in until 6.d, so that we can still use it in 6.c-errata
    without any changes.
    Oh, I thought you said steak... (Zoffix)
Properly reserve all ":sym<>" colonpairs on subroutines
    This is mostly a reminder so we don't forget. As previously discussed
    <https://irclog.perlgeek.de/perl6/2017-01-25#i_13988093>, We want to
    make ":sym<>" colonpairs on subroutines reserved. However, there is a
    6.c-errata test
    <https://github.com/perl6/roast/blob/dfe905a8ce84d09b5b0536fcc151e798488
    a9289/S32-exceptions/misc.t#L132> that expects "sub foo:sym<bar> {}" to
    throw "X::Syntax::Extension::Category" exception instead of
    "X::Syntax::Reserved" we desire. The code implementing this
    <https://github.com/rakudo/rakudo/commit/48abeeef26> already exists. It
    just needs to be uncommented for 6.d and corresponding tests
    <https://github.com/perl6/roast/commit/53d6e8491d> unfudged.
    Zoffix
Use IEEE 754-2008 semantics for num/Num infix:</>, infix:<%>, and infix:<%%>
    (Sidenote: be sure to check log(42, 1) does not explode when this is
    implemented. If it's decided not to implement this; change log(42, 1) to
    give a better error)
    Currently, division and related modulus operations with Nums return
    Failure if the divisor is zero. By IEEE rules, those would instead
    produce a NaN for 0e0/0e0 and Inf with the sign of the divident. Note:
    Division and related modulus operations where at least one operanad is a
    Num or num coerce both operands to Num
    The proposed behaviour has TimToady's nod of approval
    <https://irclog.perlgeek.de/perl6-dev/2017-02-08#i_14066067> but is
    blocked by three 6.c-errata tests
    <https://github.com/perl6/roast/blob/e73bb67f64c26926aa2665e64477d9a0848
    21b48/S03-operators/div.t#L9-L11>.
    Untested, but the implementation likely just involves removing all of
    the checks for 0 divisors, as NQP ops already Do The Right Thing for
    nqp::div_n(). For nqp::mod_n() more examination is needed, the primary
    problem being that we don't do IEEE's remainder() operation with it, so
    what it's supposed to do in these edge cases is not declared by IEEE.
        multi sub infix:</>(Num:D \a, Num:D \b) {
            nqp::p6box_n(nqp::div_n(nqp::unbox_n(a), nqp::unbox_n(b)))
        multi sub infix:</>(num $a, num $b) returns num {
            nqp::div_n($a, $b)
    
        multi sub infix:<%>(Num:D \a, Num:D \b) {
            nqp::p6box_n(nqp::mod_n(nqp::unbox_n(a), nqp::unbox_n(b)))
        multi sub infix:<%>(num $a, num $b) returns num {
            nqp::mod_n($a, $b)
Remove dummy precision parameters from Rational/Int .Rat and .FatRat coercers
    They're dummy parameters that offser more confusion than usefulness. The
    roast itself seems confused. There are a whole bunch of trig tests that
    use these coercers with a precision arg for no good reason; almost feels
    like the writer assumed `1.5` is a Num and not a Rat.
Deprecate IO::Path.chdir
    Per IO Grant work
hey
Fuckerhey
hey
dude, what the fuck
you're like a broken record
what are you talking about?>
OMG
I hate you
I hate you
I hate you
I hate you
I hate you
I hate you
I hate you
I hate you
I hate you
I hate you
I hate you
I hate you
I hate you
I hate you
I hate you
where are you getting this stuff from?
what are your thoughts on Junctions
Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=131076
Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=131076
Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=131076
s: {;}, 'ACCEPTS'
s: {;}, 'ACCEPTS'
s: {;}, 'ACCEPTS'
s: {;}, 'ACCEPTS', \(any 1, 2)
m: say so any(5,"flarg") ~~ -> Any $_ { try $_ == 5 }
rakudo-moar af50e0: OUTPUT: «WARNINGS for <tmp>:␤Useless use of "==" in expression "$_ == 5" in sink context (line 1)␤True␤»
m: say so any(5,"flarg") ~~ try * == 5
rakudo-moar af50e0: OUTPUT: «Cannot convert string to number: base-10 number must begin with valid digits or '.' in '3⏏5flarg' (indicated by ⏏)␤  in block <unit> at <tmp> line 1␤␤Actually thrown at:␤  in block <unit> at <tmp> line 1␤␤»
s: 5, 'ACCEPTS', \(any 42)
s: 5, 'ACCEPTS', \(42)
mm: say so any(5,"flarg") ~~ -> { try $^v == 5 }
m: say so any(5,"flarg") ~~ { try $^v == 5 }
rakudo-moar af50e0: OUTPUT: «WARNINGS for <tmp>:␤Useless use of "==" in expression "$^v == 5" in sink context (line 1)␤False␤»
m: say so any(5,"flarg") ~~ { say try $^v == 5 }
rakudo-moar af50e0: OUTPUT: «Nil␤True␤»
m: say so any(5,"flarg") ~~ { say try $_ == 5 }
rakudo-moar af50e0: OUTPUT: «Nil␤True␤»
m: say so any(5,"flarg") ~~ -> Any $_ { say try $_ == 5 }
rakudo-moar af50e0: OUTPUT: «True␤Nil␤True␤»
m: say so any(5,"flarg") ~~ 5
rakudo-moar af50e0: OUTPUT: «True␤»
m: say so any(1,"flarg") ~~ 5
rakudo-moar af50e0: OUTPUT: «False␤»
m:
m: $_ = 42|42; when *.so { say "there"}
rakudo-moar af50e0: OUTPUT: «there␤»
I was actually expecting this to work
m: say +any(5,"flarg") // 0
rakudo-moar af50e0: OUTPUT: «===SORRY!===␤Cannot convert string to number: base-10 number must begin with valid digits or '.' in '3⏏5flarg' (indicated by ⏏)␤»
but // does not work with junctions
m: say any(5, Nil, 10) // 0
rakudo-moar af50e0: OUTPUT: «any(5, Nil, 10)␤»
m: say any(5, Nil, 10) || 0
rakudo-moar af50e0: OUTPUT: «any(5, Nil, 10)␤»
which makes sense, actually
what is this… a waterbed of expectations?
is that like a cupboard of love?
star: "foo" ~~ 42
star-m 2016.10: OUTPUT: «Cannot convert string to number: base-10 number must begin with valid digits or '.' in '3⏏5foo' (indicated by ⏏)␤  in block <unit> at <tmp> line 1␤␤Actually thrown at:␤  in block <unit> at <tmp> line 1␤␤»
c: 2017.01 "foo" ~~ 42
c: 2017.01 any(42, "foo") ~~ 42
c: 2017.01 say any(42, "foo") ~~ 42
... what the fuck
c: 2017.01 say all(42, "foo") ~~ 42
c: 2017.01 say "foo" ~~ 42
m: say so any(5,"flarg") ~~ -> Any $_ { try $_ == 5 }
rakudo-moar af50e0: OUTPUT: «WARNINGS for <tmp>:␤Useless use of "==" in expression "$_ == 5" in sink context (line 1)␤True␤»
m: say so 42 ~~ -> Any $_ { try $_ == 5 }
rakudo-moar af50e0: OUTPUT: «WARNINGS for <tmp>:␤Useless use of "==" in expression "$_ == 5" in sink context (line 1)␤False␤»
m: say so 42 ~~ -> Any $_ { $_ == 5 }
rakudo-moar af50e0: OUTPUT: «False␤»
m: say so 42 ~~ -> Any $_ { try $_ == 5 }
rakudo-moar af50e0: OUTPUT: «WARNINGS for <tmp>:␤Useless use of "==" in expression "$_ == 5" in sink context (line 1)␤False␤»
m: say so 42 ~~ { try $_ == 5 }
rakudo-moar af50e0: OUTPUT: «WARNINGS for <tmp>:␤Useless use of "==" in expression "$_ == 5" in sink context (line 1)␤False␤»
m: say so 42 ~~ { $_ == 5 }
rakudo-moar af50e0: OUTPUT: «False␤»
m: say so 42 ~~ { $_ }
rakudo-moar af50e0: OUTPUT: «True␤»
m: say so 42 ~~ { try $_ }
rakudo-moar af50e0: OUTPUT: «WARNINGS for <tmp>:␤Useless use of $_ in sink context (line 1)␤True␤»
m: say so 42 ~~ { try 42 }
rakudo-moar af50e0: OUTPUT: «WARNINGS for <tmp>:␤Useless use of constant integer 42 in sink context (line 1)␤True␤»
m: say so 42 ~~ { t42 }
rakudo-moar af50e0: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Undeclared routine:␤    t42 used at line 1␤␤»
m: say so 42 ~~ { 42 }
rakudo-moar af50e0: OUTPUT: «True␤»
m: say so 42 ~~ { 43 }
rakudo-moar af50e0: OUTPUT: «True␤»
m: say so 42 ~~ { 42 }
rakudo-moar af50e0: OUTPUT: «True␤»
m: say so 42 ~~ { Nil }
rakudo-moar af50e0: OUTPUT: «False␤»
m: say so 42 ~~ { try 1 }
rakudo-moar af50e0: OUTPUT: «WARNINGS for <tmp>:␤Useless use of constant integer 1 in sink context (line 1)␤True␤»
m: say 42 ~~ { try 1 }
rakudo-moar af50e0: OUTPUT: «WARNINGS for <tmp>:␤Useless use of constant integer 1 in sink context (line 1)␤1␤»
Zoffix_: I'll pass your message to TimToady.
rakudo-moar af50e0: OUTPUT: «any(42, 65, 0)␤»
rakudo-moar af50e0: OUTPUT: «True␤»
yea
m: say so any(42, Nil, "foo") === Nil
rakudo-moar af50e0: OUTPUT: «True␤»
m: say so all(42, Nil, "foo") === Nil
rakudo-moar af50e0: OUTPUT: «False␤»
m: say (+any(5,‘blargh’,42)).&(sub { $^a // 0 })
rakudo-moar af50e0: OUTPUT: «any(5, 0, 42)␤»
m: say sub { $^a // 0 }(+any(5,‘blargh’,42))
rakudo-moar af50e0: OUTPUT: «any(5, 0, 42)␤»
what are your thoughts on Junctions and definedness?
good night!
http://stackoverflow.com/questions/43289842/should-this-perl-6-catch-block-be-able-to-change-variables-in-the-lexical-scope
looking at ^^^^ , I'm wondering whether we shouldn't containerize the Exception in $_, so that you could assign a value to it to be stored in the variable
the fix would then be:  my $e = $_; $_ = 0; $e.resume
I'm not sure, it seems that the OP wants the lexical context of the throw site to be copied into the CATCH which is kinda scary
to me anyhow
well, that's *how* he tried to do it
the question is really: I'm playing with resumable exceptions. In this example, I try to numify something that doesn't numify. I catch that and attempt to give the $value variable an appropirate value then resume execution
.oO( RabidGravy must like the pirate in that quote )
RARR!
It's because the exception throw happens prior to the assignment
And then when the resume happens the assignment is yet to take place
And what gets assigned is the Failure
I can write that on SO, I guess... :)
jnthn: hence my proposal to make $_ a container
so you could *change* the value to be assigned
jnthn: I'll write it on SO if you don't feel like it
Bu tit's not about that :)
Oh, I maybe see what you're saying
I'd more expect that to be an argument to resume, though
Note that $_ is not the Failure
It's an Exception
sorry, yes
but a parameter to .resume would be better
I'm still not convinced (just checking) that'd actually make a difference in this particular case
+    method resume(Exception:D: $value = $!ex --> True) {
+        nqp::resume($value);
too simple  :-(
Yes, and also the fatalization done by try will also not allow this
As I've nearly written in my answer
ah, ok  :-)
Darn, this indentation style
yeah, it's like Tuxes
That also puts the closing } indented?
yeah
.oO( feels like you never get closure )
m: try { my $m = "Hello"; my $default; my $value = +$m; $value //= $default; say $value; CATCH { when X::Str::Numeric { $default = 0; .resume; } } }'
rakudo-moar d673ea: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Strange text after block (missing semicolon or comma?)␤at <tmp>:1␤------> 3::Numeric { $default = 0; .resume; } } }7⏏5'␤    expecting any of:␤        infix␤        infix stopper␤        s…»
m: try { my $m = "Hello"; my $default; my $value = +$m; $value //= $default; say $value; CATCH { when X::Str::Numeric { $default = 0; .resume; } } }
rakudo-moar d673ea: OUTPUT: «0␤»
That workaround doesn't look so bad. Though I have to admit that it's very unintuitive.
well, you would need to do that for every variable assignment in the block.
I guess the point would be that you would only need to do stuff inside the CATCH block and have it apply to all assignments
Btw. jnthn: is it possible that the contents of a byte code file depend on when the GC is running? I tried to find where we are referencing the repo a comp unit was loaded from but ended up running into code layout having influence on whether the reference is there or not.
jnthn: I pretty much hope you say yes, because then I can just give up on the brittle attempt to not reference the repo
lizmat: There's so many other ways to factor that out that don't involve resumable exceptions... :)
true
perhaps he didn't realize you can catch failures by //=
m: only sub prefix:<+>($v) { CORE::{'&prefix:<+>'}($v) // 0 }; say +'hello' # another way :)
rakudo-moar d673ea: OUTPUT: «0␤»
You can put that in a module and import it, meaning even less boilerplate in any given scope where you wish to do this :)
nine: Umm...I can't think of how that could easily happen aside from if the contents of nqp::where or nqp::objectid were being used somewhere
jnthn: none of those is used in src/core/CompUnit/. I got different results depending on the presence of code that wasn't even executed like RAKUDO_MODULE_DEBUG stuff.
o.O
That sounds...interesting
Except that now that I've tried to continue this frustrating work it suddenly behaves quite logically.
I could even narrow it down to the compile time EVAL run by dependency re-resolving
basically the same as .skip(N)
Indeed! When I replace the dependency specification EVAL with the code we use on JVM (where compile time EVAL doesn't work yet), I can load a precompiled Inline::Perl5 installed from an RPM package :)
This is Rakudo version 2017.03-182-g188b7b1d9 built on MoarVM version 2017.03-98-g9653dc6a
csv-ip5xs        3.034
test            12.648
test-t           4.928 - 5.413
csv-parser      12.832
m: class X::Test is Exception { has $.message }; my $p = Promise.new; $p.break(X::Test.new(message => "oh crumbs")); try await start { await $p }; say $!
rakudo-moar 188b7b: OUTPUT: «Tried to get the result of a broken Promise␤  in block <unit> at <tmp> line 1␤␤Original exception:␤    Tried to get the result of a broken Promise␤      in block  at <tmp> line 1␤␤    Original exception:␤        Died with X::Test+{X::Prom…»
m: use Test; class X::Test is Exception { has $.message }; my $p = Promise.new; $p.break(X::Test.new(message => "oh crumbs")); try await start { await $p }; like $!.gist, /crumbs/
rakudo-moar 188b7b: OUTPUT: «not ok 1 - ␤␤# Failed test at <tmp> line 1␤#      expected: '/crumbs/'␤#      got: 'Tried to get the result of a broken Promise␤#   in block <unit> at <tmp> line 1␤␤# Original exception:␤#     Tried to get the result of a broken Promise…»
rakudo-moar 188b7b: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Undeclared routine:␤    use used at line 1␤␤»
rakudo-moar 188b7b: OUTPUT: «===SORRY!===␤Could not find Test::Util at line 1 in:␤    /home/camelia/.perl6␤    /home/camelia/rakudo-m-inst-1/share/perl6/site␤    /home/camelia/rakudo-m-inst-1/share/perl6/vendor␤    /home/camelia/rakudo-m-inst-1/share/perl6␤    CompUnit::…»
need moar coffee!
what about Scary?
Ran into that while working on cert verification stuff in IO::Socket::Async::SSL
I'm hopeful it'll be in a state where I feel OK about adding it to the ecosystem this weekend :)
I need to write some proper tests, and implement hostname checking
And then it's probably sufficiently secure to use
I think our existing SSL module isn't doing those things, though :(
shopping; bbl
s: IO::Path::Unix, 'new', \("-a")
:m say -5.abs
m: say -5.abs
rakudo-moar 093bb8: OUTPUT: «-5␤»
m: say -5 . abs
rakudo-moar 093bb8: OUTPUT: «5␤»
m: say -5 .abs
rakudo-moar 093bb8: OUTPUT: «5␤»
ah!
i was looking for a gist >_>
cool
i'll send 'em that link
i accept that explanation
though we may want to put that sentence into the plan for future reference
mhm
thanks for doing all of this \o/
Not a bug. Whitespace changes the precedence between prefix - and methodcall
m: class { has $!x = 42; method !x { 72 }; method y { dd $!x } }.new.y
rakudo-moar 94a690: OUTPUT: «Int $!x = 42␤»
m: class { has $!x = 42; method !x { 72 }; method y { dd self!x } }.new.y
rakudo-moar 94a690: OUTPUT: «72␤»
m: class { has $!z = 42; method !x { 72 }; method y { dd $!x } }.new.y
rakudo-moar 94a690: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Attribute $!x not declared in class <anon|64180240>␤at <tmp>:1␤------> 3 method !x { 72 }; method y { dd $!x } }7⏏5.new.y␤    expecting any of:␤        horizontal whitespace␤        postfix…»
m: class { method x { 72 }; method y { dd $.x } }.new.y
rakudo-moar 94a690: OUTPUT: «72␤»
m: class { method x { 72 }; method y { dd "$.x" } }.new.y
rakudo-moar 94a690: OUTPUT: «"72"␤»
TFW you think you're out of vanilla coffee, but then find to full jars in the cupboard
but what about coffee
m: use nqp; my $z = class { has str $.x; method y { nqp::iseq_s($!x, $!x) } }.new; for ^100_000 { $ = $z.y }; say now - INIT now
rakudo-moar 94a690: OUTPUT: «equal requires a concrete string, but got null␤  in method y at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»
m: use nqp; my $z = class { has str $.x = ''; method y { nqp::iseq_s($!x, $!x) } }.new; for ^100_000 { $ = $z.y }; say now - INIT now
rakudo-moar 94a690: OUTPUT: «0.0777071␤»
m: use nqp; my $z = class { has Str $.x = ''; method y { nqp::iseq_s($!x, $!x) } }.new; for ^100_000 { $ = $z.y }; say now - INIT now
rakudo-moar 94a690: OUTPUT: «0.08885274␤»
m: use nqp; my $z = class { has Str $.x = ''; method y { nqp::iseq_s($!x, $!x) } }.new; for ^100_000 { $ = $z.y }; say now - INIT now
rakudo-moar 94a690: OUTPUT: «0.090087␤»
m: use nqp; my $z = class { has Str $.x = ''; method y { nqp::iseq_s($!x, $!x) } }.new; for ^100_000 { $ = $z.y }; say now - INIT now
rakudo-moar 94a690: OUTPUT: «0.08812241␤»
m: use nqp; my $z = class { has Str $.x = ''; method y { nqp::iseq_s($!x, $!x) } }.new; for ^100_000 { $ = $z.y }; say now - INIT now
rakudo-moar 94a690: OUTPUT: «0.08747824␤»
m: use nqp; my $z = class { has Str $.x = ''; method y { nqp::iseq_s($!x, $!x) } }.new; for ^1000_000 { $ = $z.y }; say now - INIT now
rakudo-moar 94a690: OUTPUT: «0.81182843␤»
m: use nqp; my $z = class { has Str $.x = ''; method y { nqp::iseq_s($!x, $!x) } }.new; for ^1000_000 { $ = $z.y }; say now - INIT now
rakudo-moar 94a690: OUTPUT: «0.7569845␤»
m: use nqp; my $z = class { has Str $.x = ''; method y { nqp::iseq_s($!x, $!x) } }.new; for ^1000_000 { $ = $z.y }; say now - INIT now
rakudo-moar 94a690: OUTPUT: «0.7381398␤»
m: use nqp; my $z = class { has Str $.x = ''; method y { nqp::iseq_s($!x, $!x) } }.new; for ^1000_000 { $ = $z.y }; say now - INIT now
rakudo-moar 94a690: OUTPUT: «0.7606089␤»
m: use nqp; my $z = class { has Str $.x = ''; method y { nqp::iseq_s($!x, $!x) } }.new; for ^1000_000 { $ = $z.y }; say now - INIT now
rakudo-moar 94a690: OUTPUT: «0.74713790␤»
m: use nqp; my $z = class { has Str $.x = ''; method y { nqp::iseq_s($!x, $!x) } }.new; for ^1000_000 { $ = $z }; say now - INIT now
rakudo-moar 94a690: OUTPUT: «0.4891099␤»
m: use nqp; my $z = class { has Str $.x = ''; method y { nqp::iseq_s($!x, $!x) } }.new; for ^1000_000 { $ = $z }; say now - INIT now
rakudo-moar 94a690: OUTPUT: «0.49769268␤»
m: use nqp; my $z = class { has Str $.x = ''; method y { nqp::iseq_s($!x, $!x) } }.new; for ^1000_000 { $ = $z }; say now - INIT now
rakudo-moar 94a690: OUTPUT: «0.4919610␤»
m: use nqp; my $z = class { has str $.x = ''; method y { nqp::iseq_s($!x, $!x) } }.new; for ^1000_000 { $ = $z.y }; say now - INIT now
rakudo-moar 94a690: OUTPUT: «0.6419826␤»
m: use nqp; my $z = class { has str $.x = ''; method y { nqp::iseq_s($!x, $!x) } }.new; for ^1000_000 { $ = $z.y }; say now - INIT now
rakudo-moar 94a690: OUTPUT: «0.6272066␤»
m: use nqp; my $z = class { has str $.x = ''; method y { nqp::iseq_s($!x, $!x) } }.new; for ^1000_000 { $ = $z.y }; say now - INIT now
rakudo-moar 94a690: OUTPUT: «0.6251681␤»
m: say (0.74-.49)/(0.62-.49)
rakudo-moar 94a690: OUTPUT: «1.923077␤»
Zoffix: sorry for stalking you but i thought you might like to know about changes to perlbot's eval.  you can eval with different perl versions now.  4, 5.5 .. 5.24, and blead.  and even have perlbot test it on most of them in #perlbot with evalall:  That is all.
The coffee is immesurable.  There is no spoon.
cool, i wonder if that was inspired by the whateverables?
m: say 4.90-0.57
rakudo-moar cb323d: OUTPUT: «4.33␤»
m: use nqp; my $z = class { has str $.x; method y { $!x // = 'x'; nqp::iseq_s($!x, $!x) } }.new; for ^1000_000 { $ = $z.y }; say now - INIT now
rakudo-moar cb323d: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Preceding context expects a term, but found infix = instead␤at <tmp>:1␤------> 3class { has str $.x; method y { $!x // =7⏏5 'x'; nqp::iseq_s($!x, $!x) } }.new; for␤»
m: use nqp; my $z = class { has str $.x; method y { $!x //= 'x'; nqp::iseq_s($!x, $!x) } }.new; for ^1000_000 { $ = $z.y }; say now - INIT now
rakudo-moar cb323d: OUTPUT: «equal requires a concrete string, but got null␤  in method y at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»
m: use nqp; my $z = class { has str $.x; method y { $!x // say "wat"; nqp::iseq_s($!x, $!x) } }.new.y
rakudo-moar cb323d: OUTPUT: «equal requires a concrete string, but got null␤  in method y at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»
m: use nqp; my $z = class { has str $.x; method y { $!x ||= say "wat"; nqp::iseq_s($!x, $!x) } }.new.y
rakudo-moar cb323d: OUTPUT: «wat␤This type cannot unbox to a native string: P6opaque, Bool␤  in method y at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»
m: use nqp; my $z = class { has str $.x; method y { $!x ||= "wat"; nqp::iseq_s($!x, $!x) } }.new.y
rakudo-moar cb323d: ( no output )
m: say 5.26-0.57
rakudo-moar cb323d: OUTPUT: «4.69␤»
m: say 4.69/4.33
rakudo-moar cb323d: OUTPUT: «1.083141␤»
rakudo-moar a432b3: OUTPUT: «without foo␤with True␤»
rakudo-moar a432b3: OUTPUT: «with Truewithout foo␤»
huggable, uni
m: say now ≅ now
rakudo-moar 4642cf: OUTPUT: «False␤»
m: my $*TOLERANCE = .001; say now ≅ now
rakudo-moar 4642cf: OUTPUT: «True␤»
m: my $*TOLERANCE = .1; say now ≅ now
rakudo-moar 4642cf: OUTPUT: «True␤»
m: my $*TOLERANCE = 1; say now ≅ now
rakudo-moar 4642cf: OUTPUT: «True␤»
are there any news regarding rakudo + jvm? it doesn't build for me since almost a year now (2016.06 iirc)
ahh, good to know. thanks.
i guess i'll stop checking then. i kind of implemented it to work on gentoo.
meaning, the i altered the package to work with the jvm.
fwiw, I haven't been able to build the JVM backend for quite some time now
Stage jast       : java.lang.OutOfMemoryError: PermGen space
Exception in thread "main"
Exception: java.lang.OutOfMemoryError thrown from the UncaughtExceptionHandler in thread "main"
indeed
i was just wondering because it's still advertised on the moarvm homepage
thanks for the info :)
afk&
m: 42.^mro.say
rakudo-moar 4642cf: OUTPUT: «((Int) (Cool) (Any) (Mu))␤»
m: $*OUT.^mro.say
rakudo-moar 4642cf: OUTPUT: «((Handle) (Any) (Mu))␤»
m: $*OUT.path.^mro.say
rakudo-moar 4642cf: OUTPUT: «((Special) (Any) (Mu))␤»
m: $*OUT.path.accessed
rakudo-moar 4642cf: ( no output )
m: say $*OUT.path.accessed.DateTime
rakudo-moar 4642cf: OUTPUT: «Nil␤»
m: say $*OUT.path.accessed
rakudo-moar 4642cf: OUTPUT: «Nil␤»
m: dd $*OUT.path.accessed
rakudo-moar 4642cf: OUTPUT: «Nil␤»
m: dd sub (-->Instant) {}()
rakudo-moar 4642cf: OUTPUT: «Nil␤»
m: dd sub (-->Instant) {return}()
rakudo-moar 4642cf: OUTPUT: «Nil␤»
m: dd sub (-->Instant) {return 42}()
rakudo-moar 4642cf: OUTPUT: «Type check failed for return value; expected Instant but got Int (42)␤  in sub  at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»
m: dd sub (-->Instant) {Instant}()
rakudo-moar 4642cf: OUTPUT: «Instant␤»
m: dd sub (-->Instant.new) {Instant}()
rakudo-moar 4642cf: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Type 'Instant' is not declared␤at <tmp>:1␤------> 3dd sub (-->Instant7⏏5.new) {Instant}()␤»
m: dd sub (-->Instant.new) {}()
rakudo-moar 4642cf: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Type 'Instant' is not declared␤at <tmp>:1␤------> 3dd sub (-->Instant7⏏5.new) {}()␤»
m: dd sub (-->Instant) {Instant}()
rakudo-moar 4642cf: OUTPUT: «Instant␤»
m: dd $*OUT.VAR.name
rakudo-moar 4642cf: OUTPUT: «"<element>"␤»
m: dd $*OUT.name
rakudo-moar 4642cf: OUTPUT: «No such method 'name' for invocant of type 'IO::Handle'␤  in block <unit> at <tmp> line 1␤␤»
m: dd $*OUT.VAR
rakudo-moar 4642cf: OUTPUT: «IO::Handle.new(path => IO::Special.new(what => "<STDOUT>"), chomp => Bool::True, nl-in => $["\n", "\r\n"], nl-out => "\n")␤»
m: dd $*OUT.VAR.^methods
rakudo-moar 4642cf: OUTPUT: «(ForeignCode.new, ForeignCode.new, method new (Scalar $: | is raw) { #`(Method|56288488) ... }, method name (Scalar $: *%_) { #`(Method|56288640) ... }, method of (Scalar $: *%_) { #`(Method|56288792) ... }, method default (Scalar $: *%_) { #`(Method|562…»
m: dd $*OUT.VAR.^what
rakudo-moar 4642cf: OUTPUT: «No such method 'what' for invocant of type 'Perl6::Metamodel::ClassHOW'␤  in block <unit> at <tmp> line 1␤␤»
m: dd $*OUT.VAR.WHAT
rakudo-moar 4642cf: OUTPUT: «Scalar␤»
m: dd $*OUT.VAR.name
rakudo-moar 4642cf: OUTPUT: «"<element>"␤»
...
m: my $*FOO; say $*FOO.VAR.name
rakudo-moar 4642cf: OUTPUT: «$*FOO␤»
m: say $*FOO; say $*FOO.VAR.name
rakudo-moar 4642cf: OUTPUT: «Dynamic variable $*FOO not found␤  in block <unit> at <tmp> line 1␤␤Actually thrown at:␤  in block <unit> at <tmp> line 1␤␤»
m: my $*FOO; say $*FOO.VAR.name
rakudo-moar 4642cf: OUTPUT: «$*FOO␤»
m: say $*OUT.VAR.name
rakudo-moar 4642cf: OUTPUT: «<element>␤»
rakudo-moar 4642cf: OUTPUT: «$*FOO␤»
rakudo-moar 4642cf: OUTPUT: «<element>␤»
m: say $*OUT.path.what
rakudo-moar 954e69: OUTPUT: «<STDOUT>␤»
no yoleaux news, right?
okay
central services here, i hear you've been having some issues with your ducts
:)
16:25Z <simcop2387> Zoffix: Hey I added a bunch of stuff to perlbot's eval.  you can now do eval$VERSION: to run a specific version (supported are, qw/5.6 5.8 5.10 5.12 5.14 5.16 5.18 5.20 5.22 5.24 5.5 4/), and in #perlbot or /msg you can do evalall: to run on perl versions between 5.5-5.24 + current blead
so, now i'll try and get your old messages into the main yoleaux instance database … let's see
Zoffix: are there any other channels yoleaux2 was on?
Zoffix: wait, can we have the latest version of tell.db?
Zoffix: and not the one that is one day old? :)
oh yeah, if there have been any changes since last night, that'd be good to have
dpk: ↑ :)
rakudo-moar 50a0dc: OUTPUT: «2.193370␤»
rakudo-moar 50a0dc: OUTPUT: «0.455919␤»
good night!
tell me honestly, do you think at least a little bit before saying something?
alright
i should be able to
how do i do it though
found it
both posts are now announcemens, the previously announcementized post is no longer announcified
okay, the message databases should be merged now
welcome
didn't i do that?
modemake announcement? (bottom announcement will be replaced) yes / no
can only have two
i'd like to keep the weekly, though
yeah, did that
yup
no prob
bots
huggable: bots
“run my dpk”… that's not what I meant…
m: say IO::Path.new-from-absolute-path($*CWD.absolute).perl; say $*CWD.absolute.IO
rakudo-moar 50a0dc: OUTPUT: «IO::Path is disallowed in restricted setting␤  in sub restricted at src/RESTRICTED.setting line 1␤  in method FALLBACK at src/RESTRICTED.setting line 31␤  in block <unit> at <tmp> line 1␤␤»
the .IO coercer?
yeah, shouldn't be Any, though?
like, we don.t really instantiate Any anywhere, and it's hardly of any use to anybody
rakudo-moar 50a0dc: OUTPUT: «/home/camelia/foo␤»
rakudo-moar 50a0dc: OUTPUT: «/home/camelia␤»
rakudo-moar 50a0dc: OUTPUT: «/foo␤»
rakudo-moar 50a0dc: OUTPUT: «/foo/bar␤»
rakudo-moar 50a0dc: OUTPUT: «/foo␤»
there are other instances of .abspath used... let me try changing those
yep that was it
Zoffix_: target this instead (includes the other fix) https://github.com/ugexe/zef/commit/e2deb25
m: my $a = -5; say ++$a.=abs
rakudo-moar bf6371: OUTPUT: «6␤»
m: my $a = -5; say ++$a .= abs
rakudo-moar bf6371: OUTPUT: «Cannot modify an immutable Int␤  in block <unit> at <tmp> line 1␤␤»
Oh, the joy of things that fail one in several hundred (or thousand) times...
ACTION will leave debugging that for tomorrow or so
That plus some more docs are what's to go before I throw https://github.com/jnthn/p6-io-socket-async-ssl into the module ecosystem, anyways
Fixing the encoding stuff up reminds me that I should really get a public API for streaming decoding into Rakudo at some point, though
Especially as the SSH binding needs the exact same
'night
night
damn Adobe!
how do you respond so much more quickly than GumbyBrain?
Hmm, I suppose it's not stringing tokens together semi-randomly, but using whole lines of text from somewhere.
Oops, stupid tab completion.
are you trapped inside the computer and cannot escape?
NeuralAnomaly, status
k 6 days. that's fine
This is Rakudo version 2017.03-197-gf1fc87950 built on MoarVM version 2017.03-115-ge8231a30
csv-ip5xs        3.596
test            13.364
test-t           5.110 - 5.376
csv-parser      13.585
i think i really need sleep
samcv: I think you've earned it :)
Files=1186, Tests=56521, 199 wallclock secs (11.97 usr  4.53 sys + 1182.79 cusr 117.22 csys = 1316.51 CPU)
fetching now
afk&
afk again&
rakudo-moar 147152: OUTPUT: «\␤»
rakudo-moar 147152: OUTPUT: «z␤»
m: class Foo { has $.s; submethod BUILD { say "wat" } }; class Bar { method new (|c) { self.bless: |c } }; Bar.new
rakudo-moar 147152: ( no output )
m: class Foo { has $.s; submethod BUILD { say "wat" } }; class Bar { method new (|c) { self.bless: |c } }; Bar.new: 42
rakudo-moar 147152: OUTPUT: «Too many positionals passed; expected 1 argument but got 2␤  in method new at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»
m: class Foo { has $.s; submethod BUILD { say "wat" } }; class Bar is Foo { method new (|c) { selfbless: |c } }; Bar.new: :42
rakudo-moar 147152: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Malformed radix number␤at <tmp>:1␤------> 3w (|c) { selfbless: |c } }; Bar.new: :427⏏5<EOL>␤    expecting any of:␤        number in radix notation␤»
m: class Foo { has $.s; submethod BUILD { say "wat" } }; class Bar is Foo { method new (|c) { selfbless: |c } }; Bar.new: :foo
rakudo-moar 147152: ( no output )
m: class Foo { has $.s; submethod BUILD { say "wat" } }; class Bar is Foo { method new (|c) { self.bless: |c } }; Bar.new: :foo
rakudo-moar 147152: OUTPUT: «wat␤»
m: class Foo { has $.s; submethod BUILD { say "wat" } }; class Bar is Foo { method new (|c) { self.Foo::new: |c } }; Bar.new: :foo
rakudo-moar 147152: OUTPUT: «wat␤»
m: class Foo { has $.s; submethod BUILD { say "wat" } }; class Bar is Foo { method new (|c) { self.Foo::new: |c } }; Bar.new(:foo).^name.say
rakudo-moar 147152: OUTPUT: «wat␤Bar␤»
m: my $path = "//../..usr/bin/../foo/.///ef"; my $node = ''; if $path ~~ s {^ ( '//' <-[ / ]>+ ) '/'? $} = '' or $path ~~ s {^ ( '//' <-[ / ]>+ ) '/' } = '/' { $node = ~ $0; }; dd [ $path, $node ]
rakudo-moar cc209f: OUTPUT: «["/..usr/bin/../foo/.///ef", "//.."]␤»
m: my $path = "//../..usr/bin/../foo/.///ef"; my $node = ''; if $path ~~ s {^ ( '//' <-[ / ]>+ ) '/'? $} = '' or $path ~~ s {^ ( '//' <-[ / ]>+ ) '/' } = '/' { $node = ~ $0; }; dd [ $path, IO::Spec::Unix.canonpath($path), $node ]
rakudo-moar cc209f: OUTPUT: «["/..usr/bin/../foo/.///ef", "/..usr/bin/../foo/ef", "//.."]␤»
rakudo-moar cc209f: OUTPUT: «C:/foo/../bar/../ber␤»
fantastic %)
hw did you enter that?
hm, time to hit the irclog
nope, can't see what that is there either
I see two [00/83] glyphs
no, i mean before the cd
in your command
there's what looks like spaces in my irc client, and boxes in the irclog
.u 
U+0083 NO BREAK HERE [Cc] (<control>)
you had crap before your "cd"
not before //../
oh, i think you wrote that
^
also what bash told you, albeit with the utf8 of the crap
you could just cripple rakudo slightly, so that people have less choice to express themselves. that plus rebranding should do the trick
force them to indent exactly like you would in python
don't give anybody any ideas :(((((
i recently heard it looks too much like perl 5 as a reason to not jump on the perl 6 bandwagon. so looking different would capture that audience
I'll be boring and say that "capturing an audience" isn't (and shouldn't be) a big priority at this point ;)
I'd settle for Perl 6 and Rakudo being solid works of engineering with compelling reasons to use them
i was happy to hear we had reached bandwagon status
masak: by that reasoning, we shouldn't have had a release and would have no books being written at the moment
we could... crazy idea. give away perl 6 for free! then everybody will use it! /s
remember VHS vs Betamax vs Video2000
.o( laser disc )
I guess everybody knows that Betamax was superior to VHS
laserdisc tho
hardly anybody knows that Video2000 was superior to Betamax still
i haven't heard of video2000 yet, is it like jpeg2000?
i guess it was in europe
south africa and argentina says the wiki. i'd never heard of it before
since i'm from US
https://en.wikipedia.org/wiki/Video_2000
"Video 2000 was an entirely new (and incompatible) format that incorporated many technical innovations"
I don't want Perl 6 to be the Video2000 of the programming languages
Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=131122
lizmat, well people are still working on it after all this time. so that much is good.
indeed!   and new people keep coming in as well  :-)
they are all delusional!
timotimo: don't be so positive  :-)
if we had a trillion dollars to spend on marketing
also i still want my camelia sticker ;_;
i still don't have one
Zoffix_, prove them wrong somehow?
lizmat, Zoffix_: you're both right, of course
if they don't like perl... they can just use rakudo instead :)
maybe I should have phrased that differently -- marketing/PR has its place, but I don't believe at this point that changing names around will cause wondrous results
I *do* believe that excelling technically might make a difference
ah; I misinterpreted that as being about names
also. Zoffix_ how do you feel about appimages
binaries people can dl and run with no install
i think that would be nice for people to try it out easier. reduce barrier to entry. if they like it they may keep going but gets them in the door maybe?
hehehe
pythonistas indent when they breathe
ok that's an exagaration
or not.
* i move away from the mic when i indent
yes
hehe
stop reading my thoughts!
i think i'm going to compile rakudo star since i have done it exactly 0 times in my life
since that's what we'd want to put in an AppImage/Flatpak/whatever
Tay Zonday was a cool dude, i wonder what he's up to now
problem being that you can't move perl 6. which is the main issue
Zoffix_: I've had ideas for a Perl 6 lite before. Things I would remove: automatic flattening, default *% in methods, having soooo many methods in Mu/Any
Zoffix_: I keep forgetting where it still happens; maybe in slurpies?
rakudo-moar 2ddfa2: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Unable to parse expression in array composer; couldn't find final ']' ␤at <tmp>:1␤------> 3 dd cat }(['my', ['cat', 'is', ['flat',]7⏏5)␤    expecting any of:␤        statement end␤        s…»
rakudo-moar 2ddfa2: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Unable to parse expression in array composer; couldn't find final ']' ␤at <tmp>:1␤------> 3dd cat }(['my', ['cat', 'is', ['flat',]]7⏏5)␤    expecting any of:␤        statement end␤        s…»
rakudo-moar 2ddfa2: OUTPUT: «("my", $["cat", "is", ["flat"]])␤»
rakudo-moar 2ddfa2: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Missing block␤at <tmp>:1␤------> 3sub flat-cat (*7⏏5cat) { dd cat }(['my', ['cat', 'is', ['f␤»
rakudo-moar 2ddfa2: OUTPUT: «["my", ["cat", "is", ["flat"]]]␤»
rakudo-moar 2ddfa2: OUTPUT: «["my", "cat", "is", "flat"]␤»
rakudo-moar 2ddfa2: OUTPUT: «["my", ("cat", "is", ("flat",))]␤»
please no flatten the cat
also don't take the fourier transform of your cat
m: my @a = 1, 2, (3, 4); say @a.perl
rakudo-moar 2ddfa2: OUTPUT: «[1, 2, (3, 4)]␤»
martian flat cats?
moritz: the GLR removed so much auto-flattening
maybe you didn't spend as much time writing perl6 code since then? :S
timotimo: I know. I guess I just do too little p6 code... exactly
and that concludes my hacking for today
good night, #perl6-dev!
good night!
m: say ‘äa’ ~~ /:ignoremark [ .<same>. ]/
rakudo-moar 6c9f31: OUTPUT: «Nil␤»
ACTION shrugs
what repo should i put perl 6 appimage builds in
i mean. well the script to generate appimages
perl6-appimage? :)
AlexDaniel, can you try out my appimage?
samcv: sure, how?
https://cry.nu/files/org.perl6.rakudo-x86_64.AppImage rakudo star
should act like perl 6 binary
see if you can run scripts with it
samcv: seems to be working fine
you can execute perl 6 scripts?
ah… hm…
only if I give absolute path
ah.
i see that too
and PERL6LIB has to be absolute as well
you don't need perl6lib hopefully though?
ok i can fix that then
i know the remedy
samcv: well, if you are running something that has more than one file… then you probably need it
AlexDaniel, ok and what does $*CWD give
but it depends
uh it has all star modules
but i could probably hack perl6lib too
m: say $*CW
rakudo-moar 6c9f31: OUTPUT: «Dynamic variable $*CW not found␤  in block <unit> at <tmp> line 1␤␤Actually thrown at:␤  in block <unit> at <tmp> line 1␤␤»
m: say $*CWD
rakudo-moar 6c9f31: OUTPUT: «"/home/camelia".IO␤»
$*CWD
"/tmp/.mount_K4TBTf/usr".IO
k same here
ok, afk 20min
nice. printing out %*ENV is helpful. maybe i can use something in there to set the dir properly
ok i figured out what i need to do. get perl 6 to change directories after it's already started
hmmm
cause if i cd before i start it... then the paths are all wrong
needs to change directory after starting
then all problems will be solved
so maybe a new option for moar?
or i guess there could be some way to do it in rakudo
that actually makes more sense i guess. idk
samcv: dunno, maybe a module that will chdir? Sounds like a horrible idea…
i mean perl6 itself has its own command line options right
we just need to add a new one to made perl6 change directory on start
may want that anyway
yeah it sounds useful
recall the jdk is weird about changing directory
i will hack something that will hopefully fix it not running files from relative directories and i think it should mostly work
Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=130267
NeuralAnomaly, status
This is Rakudo version 2017.03-211-g6c9f31bb0 built on MoarVM version 2017.03-115-ge8231a30
csv-ip5xs        3.249
test            12.901
test-t           4.923 - 5.388
csv-parser      12.726
Files=1188, Tests=56576, 200 wallclock secs (12.03 usr  4.77 sys + 1187.78 cusr 113.43 csys = 1318.01 CPU)
Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=130267
Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=130267
so when are we releasing star? in a week?
i heard we'll have one this time
nice
also what's with the files in roast that are .moarvm it precompiles or something? and not .t
cause my script can't handle those
they should be .t.moarvm and that indicates that roast for rakudo-moar should run those instead of the standard one, usually because most of the file would need to be fudged
samcv: those are the result of fudging (those #?rakudo skip "explanation" thingies)
hm
ah, thought those were inputs not outputs
anyway t/fudgeandrun should deal with those
well, they are inputs. but they are also outputs
ok. i'm thinking about how to go about testing the appimage with roast though
does it call perl6-m or something else?
or call moar directly?
it's late i gotta get to bed. night o/
gnite!
I've learned that the name for ASCII 0 is "NUL"
they're all three-letter names down there
and I *think* I learned it from nwc10
rakudo-moar 10fe02: OUTPUT: «X::IO::NullByte␤»
could be a difference between "null character" and "NUL byte"
:)
m: "\x[0]\x[308]" ~~ "\x[0]"
rakudo-moar 10fe02: ( no output )
m: say "\x[0]\x[308]" ~~ "\x[0]"
rakudo-moar 10fe02: OUTPUT: «False␤»
m: say "\x[0]\x[308]" ~~ /\x[0]/
rakudo-moar 10fe02: OUTPUT: «｢␀｣␤»
# RT #126935
Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=126935
ah, yes
maybe just unprintables in general, and accidentally a nul byte
what's the security bug, ooc?
Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=130900
ah, very well.
i wonder if windows lets you use a null byte in the path if you *really* want
m: say '0444'.Int
rakudo-moar e68149: OUTPUT: «444␤»
it lets you do lots of other dumb shit
the question is which api reverses nul? the low level system (that perl/perl6 use for instance) can create files with "illegal" characters" that you cant even see in explorer
...we could hide precomp files on windows!
s: [], 'push', \(42)
m: '0o444'.Int.say
rakudo-moar e68149: OUTPUT: «292␤»
hide them behind junctions
thats a much cooler feature
should I call it a day and rest, to have lots of energy for this tomorrow?
rakudo-moar e68149: OUTPUT: «Array.new(:shape(2, 2), [2, 2], [3, 4])␤»
rakudo-moar e68149: OUTPUT: «(2, 2, 3, 4).Seq␤»
heh, that's something
what do you think about other bots?
…
nice to know, ZofBot…
hey guys
allah is doing
sun is not doing allah is doing
to accept Islam say that i bear witness that there is no deity worthy of worship except Allah and Muhammad peace be upon him is his slave and messenger
er
ignoring seems to have been the correct response :)
ignore or not, they always do the same thing
and they've been doing this in multiple channels for I don't know how long now, but over a year
:-O
my nose is leaking too, but I don't think any repairman is going to break in here for that...
oh TimToady what are your thoughts on a perl6 command line option to have perl6 start in a directory other than ./
does perl have such an option? and what are your thoughts on it
cause that would be nice to have for making AppImages work better
TimToady: is the nqp/uncurse branch supposed to have any immediate effects for something like rakudo's parsing?
MasterDuke: shouldn't
well, except in the sense that the rakudo parser will also need a lot of work
but that should also be in a branch
ah, so no faster parsing just yet
not yet
can't tell how much faster it might be already, given I don't get all the way through compiling the setting yet...
and we still have the .MATCH overhead for the moment, it just goes to a different place
can't do much about that as long as we're forced to do lookups in an nqp hash that has to be precomputed
but it's a step in the direction of getting away from that
eventually, for most matches, saying $<foo> will just pull the foo value straight out of the cstack, and only maybe use a hash to cache it en passant
nice
and for some matches that are just liek <statement>*, we can probably just return the cstack itself as the value of $<statement>, if that's the only capture
but this will entail turning $<foo> into some kind of method call, not just a hash lookup
nqp isn't smart enough to do that yet
but that's where I'm headed with it
at the moment, fighting a very mysterious error while trying to compose 'class Variable' about 22% through the setting, gets: Cannot invoke this object (REPR: Null; VMNull)
when trying to call $compiler_services.generate_accessor
so probably some subtle interaction in the parsing of Rakudo::Internals somewhere earlier...
i don't think i'd ever looked at Variable.pm before, the contents look above my pay grade
probably either undersharing or oversharing of some kind of match data, given how nqp has changed underneath ti
istr a new ticket about either over or under sharing match data somewhat recently
Unfortunately, when you reach my paygrade, being promoted to one's level of incompetence is no longer a valid excuse. :)
and another Perl 6 Weekly hits the Net: https://p6weekly.wordpress.com/2017/04/10/2017-15-kaboom-⁽¹⁾/
lizmat++, busy week
s: 'unique', \(1, 2, 3)
s: unique, \(1, 2, 3)
s: &unique, \(1, 2, 3)
s: \(1, 2, 3), 'unique'
s: (1, 2, 3), 'unique'
hmmm how do I find a method…
SourceBaby: help
s: List, 'unique'
… this fucking bot…
Zoffix_: already found it, but still. What if I wanted to find this? https://github.com/rakudo/rakudo/blob/6a8d63d/src/core/Any-iterable-methods.pm#L1496
s: Any, 'unique'
Zoffix_: ah, it's the same bug
okay then
glad I'm not the only one who can't figure that thing out...
rakudo-moar 6a8d63: OUTPUT: «SETTING::src/core/Int.pm␤True␤»
would be helpful if SourceBaby detected this and said sorry, but you'd probably say that I can fix SourceBaby myself :P
rakudo-moar 6a8d63: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Package 'Int' already has a method 'abs' (did you mean to declare a multi-method?)␤at <tmp>:1␤»
rakudo-moar 6a8d63: OUTPUT: «<tmp>␤»
rakudo-moar 6a8d63: OUTPUT: «SETTING::src/core/Any-iterable-methods.pm␤»
rakudo-moar 6a8d63: OUTPUT: «False␤»
rakudo-moar 6a8d63: OUTPUT: «False␤False␤False␤False␤»
rakudo-moar 6a8d63: ( no output )
rakudo-moar 6a8d63: OUTPUT: «True␤»
rakudo-moar 6a8d63: OUTPUT: «False␤False␤False␤False␤False␤True␤True␤False␤False␤False␤»
I guess that means I can depants myself
good night, #perl6-dev!
m: '0o444'.base(8).say
rakudo-moar 6a8d63: OUTPUT: «No such method 'base' for invocant of type 'Str'␤  in block <unit> at <tmp> line 1␤␤»
m: '0o444'.Int.base(8).say
rakudo-moar 6a8d63: OUTPUT: «444␤»
heh
looks like gonna be more work to get travis to push to repos. argh
oh well https://gist.github.com/domenic/ec8b0fc8ab45f39403dd
make ssh key encrypt key, do bunch of weird things then i guess it can push to the github magically
unless i can figure out how to get this token to work i generated
maybe i need to use the hashed token not the token...
if i use that and try and clone it myself, it asks for a password. which i'm guessing travis knows
.o(if i use the hashed token, what is the good of the nonhashed token if i can't actually access anything with it)
night!
i'll try sleep, too
moritz: i have a reason to look at perl6-all-modules again; feel like updating it? :)
https://github.com/CurtTilmes/perl6-dbi-async this is kinda interesting, although should maybe use a different name
samcv out of curiosity why are you using a different string match for a given OS, is there a tangible difference in perf given the platform?
there is a bit of difference. and it's because linux has glibc and freebsd's libc has another
and the freebsd one is portable and i got it working on windows and macos
oh thats interesting, I would have guessed they'd be the same
and it's only used when the strings are either both 8bit or both 32bit string representations
but that is most of them
eventually we may be able to adapt the FreeBSD code to also skip x number of bytes because 32bit strings have 4 bytes, so it searches the same on 8 bit as 32bit. but can be optimized more if it's able to skip more often
timotimo: sure, will do
instead of each byte considered seperate
I did want to automate that
(updating perl6-all-modules)
samcv is this all low level or accessible higher up to swap out?
it's all low level
the nqp::index op is what has been changed
I've been considering implementing in a module bitap but for buf so I can do DNA/RNA searches efficiently since they have really small alphabets where each character can be 2bits
https://github.com/MoarVM/MoarVM/commit/e8231a303e7646e2e79b2ea6f489230240272851 if you want to see the merge that pulled it all in. i've added a fair number of comments if you scroll past the bsd source file (though that's really interesting too)
hm
cool thanks
you should look then
but memmem is basically searches for memory inside a memory
which is just the same as string search, just. i mean that's what it really is anyway
yeah
and our strings aren't null terminated and are 32bit or 8bit
also https://github.com/MoarVM/MoarVM/pull/574 this may be interesting. and i have a link to the PDF of the paper that describes freebsd's algorithm (which also compares it to boyer-moore and also kruth-morris-pratt (glibc uses this)
so what was there before you made your changes?
just brute force search
which grabs graphemes out of the each string and compares them
and I assume that was due to our interesting string format?
Ulti, https://github.com/MoarVM/MoarVM/blob/master/src/strings/ops.c#L265
this is the fallback still in case the strings are different bit widths
i still haven't been able to trigger this https://github.com/MoarVM/MoarVM/blob/master/src/strings/ops.c#L240 at least doesn't show it on coverage reports. even when i forced both strings to 32bit by converting them in the function beforehand
if anybody can help me with that, it would be cool
https://github.com/perl6/nqp/blob/master/t/nqp/107-index.t#L10
the comments big endian and little endian there are reversed by accident but both of them (i'm pretty certain) contain 4 bytes of null in their 32bit string represetations
depending on the endianess
camelia, https://gist.githubusercontent.com/samcv/a2b4593259f315c7464f7f195a3de6fc/raw/27182fc2f3c6f2a0401b8389deca482752a646b6/endian.p6
evalable6, https://gist.githubusercontent.com/samcv/a2b4593259f315c7464f7f195a3de6fc/raw/27182fc2f3c6f2a0401b8389deca482752a646b6/endian.p6
if anybody can confirm if that is correct that'd be great
since that's the script i used to decide which codepoints to use in the test
good *, #perl6-dev!
hi lizmat :-)
Files=1189, Tests=56681, 201 wallclock secs (12.08 usr  4.86 sys + 1195.44 cusr 116.20 csys = 1328.58 CPU)
hey lizmat :)
oh i said that already. i think i'm tired
samcv  o/
yeah, it's way past  midnight for you, no ?
25 mins past
i got travis pushing rakudo builds now
pushing appimages
:-)
https://github.com/samcv/rakudo-appimage/tree/gh-pages all these 4 were commited by travis
cool
got a 4 matrix heh
so hopefully we will be able to have nightly appimages or maybe other things. now that i've figured out how the fuck to get travis to behave
samcv++ from all the people who do lots of string match :D
:D
Ulti, i'll probably convert 8 bit needles to 32bit if the haystack is 32bit and the haystack is long enough and needles not too long
so it can use the optimized not the brute force
but still very big improvement so far. but i'm not sure what the next most used function is to speed improve
for string search that is
I guess one thing is for the code to be portable, but SSE4 instructions for strings would be a cool thing
yeah. qt has that
it amazes me how few if any string libs actually use them despire it being a huge boost
wait maybe. idk
they have optimized UTF-8 decoding though
i was eying that a month ago
but it seems pretty integrated
its kind of mental strings are this complicated
what?
also we may want to use the freebsd memmem on linux for some things, i'm not sure yet though. if performance shows it's faster. because it might be faster at searching for a 32bit single character in a 32bit string because it has a fourbyte_memmem function
https://github.com/MoarVM/MoarVM/blob/master/3rdparty/freebsd/memmem.c#L46
http://www-igm.univ-mlv.fr/~lecroq/string/node13.html#SECTION00130
Works well and memcmp() is usally very optimized in any libc
hmm maybe that can be altered to take advantage of knowing 4 byte width per char not 1 byte
bookmarking
but what license is that code under
It's a book, did you see the index? http://www-igm.univ-mlv.fr/~lecroq/string/index.html
nope not yet
Zoffix_, where do i edit rakudo's source to have it change directory before running a script
based on an ENV var
for my appimages
uh. where do we process command line arguments
i'd like to hack that
i have opened the source file at least once months ago
oh yes
though i hope if i change directory there it doesn't screw up things
like if i chdir inside the perl6 shell script before launching all the relative links break
works on my normal perl 6 but with the appimage it enters a dependency loop
probably due to relative paths or something weird
chdir's to the directory the appimage was started from
well it doesn't matter what is in the module. it can be empty
but it fails in the appimage because the appimage uses relative paths or something
-I lib and then `use foo:bar` works though. but module PRE loading doesn't work
Math--ThreeD: https://github.com/raydiak/Math--ThreeD/pull/2
Math--ThreeD: https://github.com/raydiak/Math--ThreeD/pull/2 and https://github.com/raydiak/Math--ThreeD/pull/3
huggable, IO kills
UNIX::Daemonize: https://github.com/hipek8/p6-UNIX-Daemonize/pull/1
it can just be $pid-file.IO.e right?
so is abspath getting deprecated with a warning? cause it's used a lot of places
rakudo-moar b6838e: OUTPUT: «(Str)␤»
rakudo-moar b6838e: OUTPUT: «/tmp␤»
oh
m: say ".".IO.abspath
rakudo-moar b6838e: OUTPUT: «No such method 'abspath' for invocant of type 'IO::Path'␤  in block <unit> at <tmp> line 1␤␤»
m: say ".".IO.absolute
rakudo-moar b6838e: OUTPUT: «/home/camelia␤»
rakudo-moar b6838e: OUTPUT: «"/tmp/cacert.pem".IO␤»
m: say '.'.IO.Str.IO.Str.IO.absolute.Str
rakudo-moar b6838e: OUTPUT: «/home/camelia␤»
m: my $str = ".IO.Str.IO.Str.IO.absolute.Str"; “'.'{$str x 10000}”.EVAL.say
rakudo-moar b6838e: OUTPUT: «(timeout)»
m: my $str = ".IO.Str.IO.Str.IO.absolute.Str"; “'.'{$str x 1000}”.EVAL.say
rakudo-moar b6838e: OUTPUT: «/home/camelia␤»
only what must be done
it works though?
can't you call .IO on a string?
i call IO on all the strings which have filenames or directories in them i want to do operations
rakudo-moar b6838e: OUTPUT: «(".cpanm".IO ".local".IO ".npm".IO ".perl6".IO ".perlbrew".IO ".rcc".IO ".ssh".IO "Perlito".IO "evalbot".IO "log".IO "nqp-js".IO "p1".IO "p2".IO "perl5".IO "std".IO ".bash_history".IO ".bashrc".IO "mbox".IO ".lesshst".IO "evalbot.log".IO ".cpan".IO "dale…»
rakudo-moar b6838e: OUTPUT: «".cpanm".IO␤"y2yamldata-M2wvA1".IO␤»
rakudo-moar b6838e: OUTPUT: «".cpanm".IO␤"/home/camelia/.cpanm".IO␤»
m: "blah".^methods.pick.say
rakudo-moar b6838e: OUTPUT: «comb␤»
rakudo-moar b6838e: OUTPUT: «".cpanm".IO␤"../home/camelia/.cpanm".IO␤»
ok that is wrong
yeah
agree
DateTime::TimeZone: https://github.com/supernovus/perl6-timezone/pull/10
sergot/openssl: Fixed
https://github.com/cygx/p6-native-libc/pull/3
https://github.com/frithnanth/perl6-Archive-Libarchive-Raw/pull/2
https://github.com/MARTIMM/pod-render/pull/1
https://github.com/MARTIMM/config-datalang-refine/pull/1
https://github.com/MARTIMM/config-datalang-refine/pull/2
https://github.com/araraloren/Net-FTP/pull/24
https://github.com/tony-o/perl6-flow/pull/1
https://github.com/tony-o/perl6-flow/pull/2
https://github.com/tony-o/perl6-green/pull/5
https://github.com/tony-o/perl6-data-dump/pull/25
https://github.com/bduggan/p6-digest-sha1-native/pull/3
https://github.com/skaji/perl6-tail/pull/1
u: check
my $p = Promise.in(1); sub rec (Mu $b) { my $m; my $e = False; repeat while $e { $m = $b.^methods.pick.gist; try { "$b.$m".EVAL }; CATCH {$e = True; }; }; return !$p ?? rec("$b.$m") !! "$b.$m"; }; rec("'hi'").say
m: my $p = Promise.in(1); sub rec (Mu $b) { my $m; my $e = False; repeat while $e { $m = $b.^methods.pick.gist; try { "$b.$m".EVAL }; CATCH {$e = True; }; }; return !$p ?? rec("$b.$m") !! "$b.$m"; }; rec("'hi'").say
rakudo-moar b6838e: OUTPUT: «'hi'.indent.encode.trim.substr-eq.Str.chars.Stringy.parse-names.parse-base.indices.BUILD.Str.chop.NFC.match.ords.contains.contains.samespace.encode.match.parse-base.samecase.tc.trim.Stringy.uc.Bool.Int.codes.lc.starts-with.ords.samemark.subst-mutate.code…»
heh
m: my $p = Promise.in(1); sub rec (Mu $b) { my $m; my $e = False; repeat while $e { $m = $b.^methods.pick.gist; try { "$b.$m".EVAL }; CATCH {$e = True; }; }; return !$p ?? rec("$b.$m") !! "$b.$m"; }; rec("'hi'".IO).say
rakudo-moar b6838e: OUTPUT: «'hi'.x.uc.subst-mutate.chars.words.ords.rindex.chars.DUMP.lc.samespace.Num.samespace.uc.trim-leading.Num.BUILD.index.WHY.index.NFD.gist.DUMP.ord.chars.BUILD.lc.ord.word-by-word.trim-trailing.contains.NFC.subst.tclc.subst.trans.parse-base.samecase.Int.tri…»
m: my $p = Promise.in(1); sub rec (Mu $b) { my $m; my $e = False; repeat while $e { $m = $b.^methods.pick.gist; try { "$b.$m".EVAL }; CATCH {$e = True; }; }; return !$p ?? rec("$b.$m") !! "$b.$m"; }; rec("'hi'.IO").say
rakudo-moar b6838e: OUTPUT: «'hi'.IO.words.Str.samecase.words.chomp.samemark.gist.WHICH.lc.gist.Str.substr-eq.WHICH.Str.contains.uc.index.contains.Int.match.DUMP.contains.trim.chomp.comb.flip.ord.flip.chomp.trim-leading.starts-with.ACCEPTS.chop.wordcase.index.Num.tclc.indent.subst.N…»
m: my $p = Promise.in(1); sub rec (Mu $b) { my $m; my $e = False; repeat while $e { $m = $b.^methods.pick.gist; try { "$b.$m".EVAL }; CATCH {$e = True; }; }; return !$p ?? rec("$b.$m") !! "$b.$m"; }; rec("'hi'.IO").say
rakudo-moar b6838e: OUTPUT: «'hi'.IO.fc.substr-eq.subst-mutate.NFKD.comb.ends-with.trim-leading.flip.comb.gist.NFD.BUILD.samecase.Numeric.Int.rindex.chars.encode.Str.starts-with.NFC.chomp.NFKC.tc.DUMP.ords.index.trim-trailing.contains.pred.subst.ord.Bool.samemark.Int.words.Numeric.s…»
only does methods that eval shows don't throw.
m: my $p = Promise.in(1); sub rec (Mu $b) { my $m; my $e = False; repeat while $e { $m = $b.^methods.pick.gist; try { "$b.$m".EVAL }; CATCH {$e = True; }; }; return !$p ?? rec("$b.$m") !! "$b.$m"; }; rec("Promise.new").say
rakudo-moar b6838e: OUTPUT: «Promise.new.trans.word-by-word.ACCEPTS.lines.tclc.indices.ord.indices.subst-mutate.codes.tclc.NFKD.WHY.subst-mutate.starts-with.NFKD.perl.ords.flip.Stringy.substr-eq.wordcase.substr-eq.trim-leading.tclc.rindex.ord.starts-with.word-by-word.chomp.words.pre…»
m: my $p = Promise.in(1); sub rec (Mu $b) { my $m; my $e = False; repeat while $e { $m = $b.^methods.pick.gist; try { "$b.$m".EVAL }; CATCH {$e = True; }; }; return !$p ?? rec("$b.$m") !! "$b.$m"; }; rec("Promise.new").EVAL.say
rakudo-moar b6838e: OUTPUT: «No such method 'parse-base' for invocant of type 'Promise'␤  in block <unit> at EVAL_67 line 1␤  in block <unit> at <tmp> line 1␤␤»
oh. i guess it doesn't work that well
huggable, IO kills [XXXXX XXXXX XXXXX XXX]: See https://gist.github.com/zoffixznet/0ea1f4db792fc674abdde73f8dd11cc1
huggable, IO kills :is: [XXXXX XXXXX XXXXX XXX]: See https://gist.github.com/zoffixznet/0ea1f4db792fc674abdde73f8dd11cc1
ACTION clickbaits https://p6weekly.wordpress.com/2017/04/10/2017-15-kaboom/
oops, wrong chan
night everybody o/
also thanks Zoffix_ for sending PR to the modules :) very awesome
'break it you fix it'?
heheh
ACTION just spent a day trying to optimize creating a sorted list of keys of a hash
turns out, just creating a list_s and sorting that, is the fastest way to do this
and not an approach with a binary search, building the list on the fly from the iterator
*sigh*
https://gist.github.com/lizmat/5ce4c4963e860f7adc4dba0ff932611c  # for those interested
lizmat, also is there a reason for nqp::stmts, when i was coding nqp it didn't change execution time using stmts versu just (exp 1; exp2; exp3)
when compiled
argh it's way too late
samcv: I try to mix nqp-like code and HLL code as little as possible
see you all tomorrow
good night!
kk :)
4am is a good time to go and get some rest!
it was a good time 2 hours ago
and now it's still a good time
but not a better time
o/
o/
ACTION will be mostly away on Wed / Thu and possibly Fri, so stops doing commits now as to not more problems for the release
*create
i just got out of bed, so that's probably why i derped that
looks like i made the change and somehow didn't pullrequest it?
Zoffix: I'll pass your message to lizmat.
:<
Zoffix: I'll pass your message to lizmat.
oh yeah, travis :\
Hi, Zoffix! Please print this on the finest paper available. Here's a 50ppi word file!!
NeuralAnomaly: status
m: my int @b = 1, 2; say @b[-1 ^ 0];
rakudo-moar b6838e: OUTPUT: «one(2, 1)␤»
m: my int @b = 1, 2, 3, 4, 5; say @b[-1 ^ 0];
rakudo-moar b6838e: OUTPUT: «one(5, 1)␤»
m: my int @b = 1, 2, 3, 4, 5; say @b[-5 ^ 0];
rakudo-moar b6838e: OUTPUT: «one(1, 1)␤»
m: my int @b = 1, 2, 3, 4, 5; say @b[-10 ^ 0];
rakudo-moar b6838e: OUTPUT: «MVMArray: Index out of bounds␤  in block <unit> at <tmp> line 1␤␤»
m: my int @b = 1, 2, 3, 4, 5; say @b[-2 ^ 0];
rakudo-moar b6838e: OUTPUT: «one(4, 1)␤»
m: my int @b = 1, 2, 3, 4, 5; say @b[-2];
rakudo-moar b6838e: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Unsupported use of a negative -2 subscript to index from the end; in Perl 6 please use a function such as *-2␤at <tmp>:1␤------> 3my int @b = 1, 2, 3, 4, 5; say @b[-2]7⏏5;␤»
m: my int @b = 1, 2, 3, 4, 5; say @b[-2 ^ 0];
rakudo-moar b6838e: OUTPUT: «one(4, 1)␤»
rakudo-moar b6838e: OUTPUT: «one(4, 1)␤»
rakudo-moar b6838e: OUTPUT: «MVMArray: Index out of bounds␤  in block <unit> at <tmp> line 1␤␤»
oh, that's fun
because it's checking for bounds, and *one* of those satisfies the bounds
that check needs to happen after the junction fans out
ACTION BBIAB
m: my int @b = 1, 2, 3, 4, 5; say @b[-2 ^ -1];
rakudo-moar b6838e: OUTPUT: «one(4, 5)␤»
rakudo-moar b6838e: OUTPUT: «one(4, 5)␤»
.
11:21Z <Zoffix> lizmat: FWIW, I'm delaying the release by 1.5-2 days to cram all the IO stuff into it. You said .z test fails on MacOS... it's testing for Bool; what does it get on MacOS?
12:41Z <Zoffix> lizmat: managed to run .z on Mac. Seems to work fine. Is it possible you ran the test without pulling and building HEAD for rakudo? https://travis-ci.org/zoffixznet/mactest/jobs/220938858
Zoffix: indeed, cannot reproduce it now, so sorry for the false alarm
afk again&
Geth: ver https://github.com/rakudo/rakudo/commit/027aa544e80a4163b379b2e4370795b23afc1f96
Geth: ver https://github.com/perl6/nqp/commit/17212d2101d5b504dfa1c0c1de1c61aeaef9d499
Geth: ver https://github.com/rakudo/rakudo/commit/a123eb310e71fdefb1f928601536f65258188f0b
Geth: ver https://github.com/perl6/nqp/commit/0adbb987262a2e13b681806b28b4cb4f19f76742
Geth: ver https://github.com/rakudo/rakudo/commit/e87179ddc0840c6aa3397f539af2dc9a519c9cfe
Geth: ver https://github.com/perl6/nqp/commit/67a74d2491fa8d6d80c8faed4909c7f81b076ed1
ver
ver
what sort of meta-methods?
m: grammar { method TOP { "foo" } }.subparse("meowfoobar").say
rakudo-moar b6838e: OUTPUT: «No such method 'MATCH' for invocant of type 'Str'␤  in block <unit> at <tmp> line 1␤␤»
m: grammar { token TOP { "foo" } }.subparse("meowfoobar").say
rakudo-moar b6838e: OUTPUT: «#<failed match>␤»
rakudo-moar b6838e: OUTPUT: «#<failed match>␤»
I'm all alone, talking in this room, am I not? It's just you and me.
Zoffix: we also gave everybody write access to perl6/specs when that was considered "The Official Perl 6 Specification™"
Trusting people has, so far, worked out pleasantly well
then one of us who has 6.c-errata checked out pushes it again
when we notice it's gone
most mistakes in git land are simple to recover from (if sometimes painful, through a force-push), so mistakes typically aren't that fatal
o/
is it reasonable that running 'perl6 htmlify.p6' should take 20 minutes to execute (on a dual core i5)?
that's annoyingly slow
ACTION wonders what it might be doing behind the scenes
dogbert17_: yeah, it's pretty slow :(
oh, did you get the faster highlighter?
any idea what causes this slowness?
is that still optional?
it uses some node thingie I belive
OK, good
it used to do it by exec ing a python instance if you didn't have Inline::Python, but those days are probably long gone
can you run it with --parallel or what it's called? are we stable enough for that yet?
well, today the NDA's are lifted on AMD's Ryzen 5 series CPU's, maybe it's time to upgrade ...
https://www.youtube.com/watch?v=HO20mmQjY40 # review of the new CPU's
rakudo-moar b6838e: OUTPUT: «qq\$foo␤»
rakudo-moar b6838e: OUTPUT: «qq//$foo␤»
rakudo-moar b6838e: OUTPUT: «qq{$foo}␤»
rakudo-moar b6838e: OUTPUT: «42␤»
rakudo-moar b6838e: OUTPUT: «42(42)␤»
rakudo-moar b6838e: OUTPUT: «the $foo is \Qs[$foo]␤»
dogbert17_: i just ran `htmlify.p6 --no-highlight --parallel=10` and it took maybe 2-3min, but there were two errors
Use of uninitialized value $node of type Any in string context. Methods .^name, .perl, .gist, or .say can be used to stringify it to something meaningful.   in sub node2rawtext at /home/dan/Source/perl6/doc/../modules/Pod-To-HTML/lib/Pod/To/HTML.pm (Pod::To::HTML) line 599
..No such method 'contents' for invocant of type 'Any'   in block  at htmlify.p6 line 936   in sub write-kind at htmlify.p6 line 916   in sub MAIN at htmlify.p6 line 232   in block <unit> at htmlify.p6 line 1013
huggable: glot.io
MasterDuke: sounds like it's having some kind of concurrency related issue :(
timotimo: yup. much better than it used to be, but still not perfect
yeah, the crossthreadwrite log might give a clue, but not necessarily
m: await (for ^1000 { start { $*CWD = rand; $ = "foo".IO} })
rakudo-moar b6838e: ( no output )
m: await (for ^1000 { start { $*CWD = rand; $ = "foo".IO} })
rakudo-moar b6838e: ( no output )
The problem I know about in htmlify is that the NEXT phaser mis-compiles into something not thread safe
m: await (for ^1000_000 { start { $*CWD = rand; $ = "foo".IO} })
In the while loop case
Or something like that
rakudo-moar b6838e: OUTPUT: «(signal XCPU)»
Many of the others I fixed
But the script really wasn't written in a concurrency-thoughtful way
So I'd not be surprised if there are some further issues after fixing that one
m: await (for ^1000_00 { start { $*CWD = rand; $ = "foo".IO} })
rakudo-moar b6838e: OUTPUT: «(signal XCPU)»
m: await (for ^1000_0 { start { $*CWD = rand; $ = "foo".IO} })
rakudo-moar b6838e: ( no output )
m: await (for ^1000_0 { start { $*CWD = rand; $ = "foo".IO} })
rakudo-moar b6838e: ( no output )
m: await (for ^1000_0 { start { $*CWD = rand; $ = "foo".IO} })
rakudo-moar b6838e: ( no output )
m: await (for ^1000_0 { start { $*CWD = rand; $ = "foo".IO} })
rakudo-moar b6838e: ( no output )
yeah :|
NeuralAnomaly: status
Though other than that issue it seemed to be getting relatively into things
*relatively far
I'd love to say I'd look at it soon, but my Perl 6 time these days is...pretty limited.
Zoffix: I didn't see this explicitly mentioned in backscroll, but the 6.c-errata branch is protected, on github.
we can protect it further if needs be, but it can't be deleted, and can't be force-pushed.
MasterDuke: have you ever managed to profile htmlify?
nope.
It's doing a lot, and it does it all in one script (instead of in several make-composable chunks). If you're using it locally, you can pass "--sparse=40" to do a fraction of the pages (this may also help with profiling)
[Coke]: thx, I'll try that when I get home from work
Zoffix: Windows reserves the filename "NUL" (/dev/null) in every directory, along with CON (STDOUT) LPT1 and COM1 etc
That sounds useful
One of my earliest Perl programs was directly controlling an Epson Dot matrix printer by sending bytes to LPT1
I think it was in DOS 1.0 which was before it had directories, so to be backwards compatible in DOS 2.0 it worked in all directories.
do we want to restrict the actual github ids that can even push to 6.c-errata? that's possible with github.
b2gills: I'm a wee bit skeptical that you had Perl running on DOS 1.0 or 2.0  :)
I didn't say that, I said that is why CON and NUL are in every directory
oh, I conflated your two statements in my head.
I think I was using Windows 98 (SE)? when I first found out about Perl
replace all the things with robots.
rakudo-moar b6838e: OUTPUT: «{ ... }␤»
rakudo-moar b6838e: OUTPUT: «({ ... })␤»
rakudo-moar b6838e: OUTPUT: «(True)␤»
rakudo-moar b6838e: OUTPUT: «(1 2 3 4 5)␤»
progress report: the uncurse branch now successfully parses the setting, but blows up somewhere in the precompiler
without having done any benchmarks, it appears to run at about the same speed, or possibly a hair faster, but large speedups are not yet expected
since it's still doing most of the work that the old MATCH method is doing
in any case, not intending to merge this till after release
since it may impact downstream modules that have gotten overly chummy with the current internals
yes, I picked up the distress call earlier :)
huggable: 6.d
m: my %h = blah => bli => 42, ble => bli => 72; dd %h{"bla", "ble"; "bli"}
rakudo-moar b6838e: OUTPUT: «(Any, 72)␤»
star: my %h = blah => bli => 42, ble => bli => 72; dd %h{"bla", "ble"; "bli"}
star-m 2016.10: OUTPUT: «(Any, 72)␤»
star: my %h = bla => bli => 42, ble => bli => 72; dd %h{"bla", "ble"; "bli"}
star-m 2016.10: OUTPUT: «(42, 72)␤»
m: my %h = bla => bli => 42, ble => bli => 72; dd %h{"bla", "ble"; "bli"}
rakudo-moar b6838e: OUTPUT: «(42, 72)␤»
c: 2017.03 my %h = bla => bli => 42, ble => bli => 72; dd %h{"bla", "ble"; "bli"}
c: 2017.02 my %h = bla => bli => 42, ble => bli => 72; dd %h{"bla", "ble"; "bli"}
c: 2017.02 my %h = bla => bli => 42, ble => bli => 72; dd %h{"bla", "ble"; "bli", "bleh"}
c: 2017.02 my %h = bla => bli => 42, ble => %(bli => 72, bleh => 11); dd %h{"bla", "ble"; "bli", "bleh"}
m: my %h = bla => bli => 42, ble => %(bli => 72, bleh => 11); dd %h{"bla", "ble"; "bli", "bleh"}
rakudo-moar b6838e: OUTPUT: «(42, Nil, 72, 11)␤»
m: my %h = bla => bli => 42, ble => %(bli => 72, bleh => 11); dd %h{"bla", "ble"; "bli", "bleh"}:exists
rakudo-moar b6838e: OUTPUT: «(Bool::True, Bool::False, Bool::True, Bool::True)␤»
m: my %h = bla => bli => 42, ble => %(bli => 72, bleh => 11); say %h{"bla", "ble"; "bli", "bleh"}:exists
rakudo-moar b6838e: OUTPUT: «(True False True True)␤»
star: my %h = bla => bli => 42, ble => %(bli => 72, bleh => 11); say %h{"bla", "ble"; "bli", "bleh"}:exists
star-m 2016.10: OUTPUT: «False␤»
dogbert17_: i had profiled htmlify.p6 a while ago, but i don't have it anymore (and it probably wouldn't be useful by now anyway)
i just tried now, with --parallel=1 so there wasn't any concurrency, but it immediately segfaults
buggable: eco
valgrind output fwiw https://gist.github.com/MasterDuke17/cdf5793ea077a2dd4dc33503efb29c35
suggested restricted list of committers for 6.c-errata? lizmat, zoffix, jnthn, timtoady?
Zoffix: that would have to be coordinated manually, and I can't see that list.
we could create a perl 6 team called "core" or something and give that team privs.
(then we use team management to manage it instead of a list of users in one repo's settings.)
is that all?
fyi, i'm not a rakudo repo member
as long as your a perl6 org member, 'sfine.'
adding myself to list as well.
Geth: ver https://github.com/rakudo/rakudo/commit/932b59f3c34f6d7c99f39e6420e1a45e12d83912
Geth: ver https://github.com/perl6/nqp/commit/a147a178c7b8337cc26a5d7aac96aab31f1d1219
k, just didn't want to slide in under an incorrect assumption. btw, what about moritz and masak also?
sure.
timotimo?
there, push to 6.c-errata is now restricted to the probably inappropriately named 'core' team.
yup. any perl6 owner/admin can update the "core" team to add more members as needed.
but this should prevent potential thinkos.
This is Rakudo version 2017.03-219-gb6838ee4d built on MoarVM version 2017.03-115-ge8231a30
csv-ip5xs        3.052
test            12.593
test-t           4.942 - 4.996
csv-parser      12.679
some htmlify stats from my home machine: running with --no-highlight takes a bit over 7 minutes, running with highlighting takes 20 !
ACTION wonders of node v 4.5 is too old
and 'perl6 --profile htmlify.p6 --no-highlight --sparse=10' segfaults
dogbert17: i believe the segfaulting is the same as this https://github.com/MoarVM/MoarVM/issues/571
Program received signal SIGSEGV, Segmentation fault.
0xb7c157d5 in MVM_interp_run (tc=0x804c458, initial_invoke=0xb7cee5e9 <toplevel_initial_invoke>, invoke_data=0x80b8b20) at src/core/interp.c:5328
5328                 tc->cur_frame->params.named_used[GET_UI16(cur_op, 0)] = 1;
MasterDuke: looks familiar?
here's the gist, perhaps something for timotimo: https://gist.github.com/dogbert17/82fd4cb9ce3dafc5f93d63b39f7223d0
dogbert17: yep
perl6 -MApp::Uni -e 'say uni-gist $_ for qx/tput cuu 1/.comb' # should be able to make this awesomer.
... wrong window!
dogbert17: btw, 6m30s no highlighting, 24m20s with highlighting
there is a highlighting -- option to speed things up, not sure if it's the default.
what are your options to speed things up
m: sub (int $x) { dd $x }(99999999999999999999)
rakudo-moar b6838e: OUTPUT: «7766279631452241919␤»
rakudo-moar b6838e: OUTPUT: «7766279631452241919␤»
Zoffix: whoops, the fix was merged to moar this monring
dogbert17: that might be another thing where disabling INLINE might help?
timotimo: same as the experimenting we did before. disabling jit and spesh get it a tiny bit farther and more info, but stiff immediate segfaults
wait, huh, did i just see something else?
i saw one where paramnamesused segfaulted
timotimo: i think that was something you were doing, maybe yesterday?
long, long ago
timotimo: you're right setting MVM_SPESH_INLINE_DISABLE=1 seems to fix things
i wonder what it is about named arguments that breaks inlines sometimes
you can profile htmlify.p6 with MVM_SPESH_INLINE_DISABLE=1?
i've never seen a backtrace like this before: https://gist.github.com/MasterDuke17/dd93c8c57821d3cc16ce8fd98075b2ba
MasterDuke: fascinating!
I'm trying to profile now but the profiles get rather big so I'm commenting out some steps
MasterDuke: can you give us what thread 1 has in its backtrace?
it might be at the end of gc and waiting for other threads to report finished
am a bit confused with how to interpret the 'Routines' page of profiler output
the top few entries all have 'Inclusive time' equal to 100% after that it slowly starts to drop off until there's a big jump
yeah
you know that inclusive counts not only the routine itself but also all time spent in routines they call?
so imagine you have a "main"
99.9% of the program's run time is spent inside of main or something main calls
e.g. I have 'sink' at 97.85% followed by 'process-pod-dir' at 75.78%
right, that sink is most likely a very top-level for loop that does most of the work in total
aha, do I then have to drill down that call to see whats's happening
timotimo: gist updated
dogbert17: are you using the qt profile viewer? much better for large profiles
haven't tried that
i generally just sort by exclusive time, honestly
https://github.com/tadzik/p6profiler-qt
i pretty much use it exclusively, until the profile get too big even for it and then switch to SQL
cool, will have to try that
so 'sink' might then refer to a loop
dogbert17: are you in a 32-bit OS? how old is your rakudo?
MasterDuke: since you use it a lot, could I get all possible feedback on what'd you like improved?
especially how big is "too big"
it's one of the things I'd like to polish a little over the not-qa-hackathon next month
tadzik: well, i know QT imposes a somewhat arbitrary limit of ~120mb, iirc
too big is when the json parser says "i can't deal with files this big"
yeah, a move to sql is probably unavoidable
yeah
tadzik: one thing is resizing the columns doesn't always work well
actually you can't resize at all
so sometimes even full screen i can't read the file+linenumber in the "Routine" column
i wish we had something clever for these looooong hash filenames
in the html one
yeah, those are where it really breaks down
tadzik: another small thing. the bar in the inclusive and exclusive columns adjusts adjusts its width to fit the percentage+time
but it just looks a little funny that sometimes the bar's total width differs from one row to the next
i wanted to add info about GCs to the qtprofiler some time ago, but handling the model/view stuff qt has come up with is ... annoying
and also trying to build a progressbar that renders in three colors ...
hmm
ACTION notes
timotimo: do the regular profiles still lack allocation info and such?
yeah :(
well, the info is there, but the html app doesn't let you look
MasterDuke: do can you figure out how the instrumented_mark_data function crashes exactly?
tadzik: see what i mean here? http://i.imgur.com/khj3FAU.png
wat?
yeah, silly indeed :)
that's not how i remember the profiler looking
though it looks much different here, must be styling
i'm using KDE fwiw
on Arch
timotimo: how do i figure that out?
MasterDuke: start by doing "print" on all the local variables
tc->prof_data is already null-checked, but maybe it's just a totally invalid pointer somehow?
does it matter what thread?
it should be the one that crashed
timotimo: gist updated
could you also print the foo[0] for each of these so it dereferences?
except the null pointer of course
hum. zef somehow failed to fetch OO::Monitors
*shrug*, i git cloned and locally installed it
gist updated
m: say DateTime.new(1033699633629796)
rakudo-moar acaeb3: OUTPUT: «+32758607-05-21T23:23:16Z␤»
what.
hm, might be msec
m: say DateTime.new(1033699633629796 / 1000)
rakudo-moar acaeb3: OUTPUT: «+34726-08-22T03:07:09.796000Z␤»
.....
:o
what kind of ghetto repair job are they doing there
MasterDuke: i'm surprised it crashed at that point ... but maybe gcc just totally inlined the other function and therefor you can't properly see it in the debugger?
MasterDuke: does it crash early enough so that you could run it under valgrind? it usually gives a bit better errors when a segfault happens
yeah, just a sec
otherwise maybe --optimize=1 could help? i can't really see in what way that code is supposed to crash
would compiling with --optimize=0 be useful at all?
usually not much better than 1, i believe
oh interesting, it just got past the part it always crashes in in valgrind
updating zef helped with installing stuff
maybe it was an .abspath thing or something
gist updated with valgrind output, now i'll try recompiling with --optimize=1
ouch
Pod::To::BigPage is failing tests with an internal-ish error
not something about MAST I hope
exactly that
mast frame expected but not gotted
https://github.com/perl6/perl6-pod-to-bigpage/issues/1
oh, that's when it tries to install
timotimo: gist updated, filename '--optimize=1' is the new one
that makes a lot more sense
oh, also: (gdb) p node $6 = (MVMProfileCallNode *) 0x0
oh, could already see that
yeah, but only via another pointer deref
and nothing in the line that was highlighted did that
well, not sure why that'd happen, but i've just put a "&& tc->prof_data->call_graph" into the if guarding that part
src/profiler/instrument.c:541 ?
yu
yup
oh, i tried that and it doesn't die right away
yeah, just finished normally
that's better.
still dies if i leave off MVM_SPESH_INLINE_DISABLE=1 though
yeah
that's an entirely different thing :)
dinner &
huggable, IO kill
huggable, IO kills
hmm, I wonder if a profiler could be ported to perl 6 %)
and to gtk, probably
huggable, IO kills :is: 13 x [✔]; 5 x [✘]: See https://gist.github.com/zoffixznet/0ea1f4db792fc674abdde73f8dd11cc1
could be, yeah
it'd be pretty cool if it turned out that perl 6 is performant enough where JS wasn'ot
DBIish can do sqlite
well, it'd also work completely differently
yup
is there an ncurses module? :)
timotimo: here's an odd thing with the 'perl6' shell script. On my machine it looks like this:
#!/bin/sh
exec /home/dogbert/repos/rakudo/install/bin/moar  --execname="$0" --libpath="/home/dogbert/repos/rakudo/install/share/nqp/lib" --libpath="/home/dogbert/repos/rakudo/install/share/nqp/lib" --libpath="." /home/dogbert/repos/rakudo/perl6.moarvm --nqp-lib=blib "$@"
there are two --libpath's pointing to the same directory
that seems fun
dogbert17: same here
huggable, IO kills :is: 14 x [✔]; 4 x [✘]: See https://gist.github.com/zoffixznet/0ea1f4db792fc674abdde73f8dd11cc1
huggable, IO kills :is: 15 x [✔]; 3 x [✘]: See https://gist.github.com/zoffixznet/0ea1f4db792fc674abdde73f8dd11cc1
(IO Grant)++
m: say '\qq[\qq[\qq[\qq[\qq[\qq[\qq[\qq[\qq[\qq[\qq[\qq[\qq[\qq[\qq[\qq[\qq[\qq[\qq[\qq[\qq[\qq[\qq[\qq[\qq[\qq[\qq[\qq[\qq[\qq[\qq[\qq[\qq[\qq[\qq[\qq[\qq[\qq[\qq[\qq[\qq[\qq[\qq[\qq[\qq[\qq[\qq[\qq[\qq[\qq[\qq[\qq[\qq[\qq[\qq[\qq[\qq[\qq[\qq[\qq[\qq[\qq[\qq[\qq[\qq[\qq[\qq[\qq[\qq[\qq[\qq[\qq[\qq[\qq[\qq[\qq[\qq[\qq[\qq[\qq[\qq[\qq[\qq[\qq[\qq[\qq[\qq[\qq[\qq[\qq[\qq[\qq[\qq[\qq[\qq[\qq[\qq[\qq[\qq[\qq[\qq[testing]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]
rakudo-moar acaeb3: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Couldn't find terminator ] (corresponding [ was at line 1)␤at <tmp>:1␤------> 3ting]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]7⏏5<EOL>␤    expecting any of:␤        ]␤»
]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]'
damn cut ofgf
that apparently works
m: '\q[\q[\q[\q[\q[\q[\q[\q[\q[\q[\q[testing]]]]]]]]]]]'
rakudo-moar acaeb3: ( no output )
m: say '\q[\q[\q[\q[\q[\q[\q[\q[\q[\q[\q[testing]]]]]]]]]]]'
rakudo-moar acaeb3: OUTPUT: «testing␤»
it's insane though
rakudo-moar acaeb3: OUTPUT: «this works too!␤»
how many levels until i use up all my memory though
m: my $head = Q{\q[}; my $tail = ']'; my $b = 10; my $i = 0; sub funct ($in) { ++$i > $b ?? $head ~ $in ~ $tail !! funct($head ~ $in ~ $tail) }; say "'" ~ funct("testing") ~ "'"
rakudo-moar acaeb3: OUTPUT: «'\q[\q[\q[\q[\q[\q[\q[\q[\q[\q[\q[testing]]]]]]]]]]]'␤»
that is the question
m: my $head = Q{\q[}; my $tail = ']'; my $b = 10000; my $i = 0; sub funct ($in) { ++$i > $b ?? $head ~ $in ~ $tail !! funct($head ~ $in ~ $tail) }; say ("'" ~ funct("testing") ~ "'").EVAL
rakudo-moar acaeb3: OUTPUT: «testing␤»
for some reason i find that very amusing
samcv: are you going to add some html to the gh-pages of the rakudo-appimage project?
rakudo-moar 184d49: OUTPUT: «65536␤»
maybe
well yes eventually
what is that...
but.. what dose it do
hmm interesting
m: say $*DEFAULT_READ_ELEMS.^methods
rakudo-moar 184d49: OUTPUT: «(DESTROY AT-POS AT-KEY defined handled Int Num Numeric mess sink CALL-ME FALLBACK STORE new Bool Str gist perl exception backtrace AT-POS AT-KEY BIND-KEY ASSIGN-KEY STORE iterator sink unshift chrs gist BIND-POS Numeric Str new ords chomp push FALLBACK c…»
seems internalish
ok 100000 levels gets to 5GB of ram then gets killed cause my ulimit setting
but 10000 levels is much less ram maybe 750MB
samcv: i wonder if .^ will neglect to vivify the dynamic var there
m: say $*DEFAULT_READ_ELEMS; say $*DEFAULT_READ_ELEMS.^methods
rakudo-moar 184d49: OUTPUT: «Dynamic variable $*DEFAULT_READ_ELEMS not found␤  in block <unit> at <tmp> line 1␤␤Actually thrown at:␤  in block <unit> at <tmp> line 1␤␤»
m: say $*DEFAULT-READ-ELEMS; say $*DEFAULT-READ-ELEMS.^methods
rakudo-moar 184d49: OUTPUT: «65536␤(Int Num Rat FatRat abs Bridge chr sqrt base polymod expmod is-prime floor ceiling round lsb msb narrow Range atanh sign asech sin tan atan2 acosech truncate asinh conj acosh pred asec cosec acotan cosh acos acosec sech unpolar log exp roots cota…»
that's why
samcv: your .^methods was equivalent to $*WHAT_EVEN_IS_THIS.^methods
heh
m: $*WHAT_EVEN_IS_THIS.^methods.say
rakudo-moar 184d49: OUTPUT: «(DESTROY AT-POS AT-KEY defined handled Int Num Numeric mess sink CALL-ME FALLBACK STORE new Bool Str gist perl exception backtrace AT-POS AT-KEY BIND-KEY ASSIGN-KEY STORE iterator sink unshift chrs gist BIND-POS Numeric Str new ords chomp push FALLBACK c…»
i.e. Failure.^methods
do we have a max variable name length
probably not right
i'm not aware of one
good
m: use MONKEY-SEE-NO-EVAL; EVAL 'my $' ~ "foo" x 10000 ~ ' = 1';
rakudo-moar 184d49: ( no output )
m: use MONKEY-SEE-NO-EVAL; EVAL 'my $' ~ "foo" x 10000 ~ ' = 1; say $' ~ "foo" x 10000;
rakudo-moar 184d49: OUTPUT: «1␤»
m: say "I ♥ Perl 6"
rakudo-moar 184d49: OUTPUT: «I ♥ Perl 6␤»
m: say "I ♥ Perl 6".chars
rakudo-moar 184d49: OUTPUT: «10␤»
10k graphs ought to be enough for anybody
m: say "I ♥ Perl 6".encode.bytes
rakudo-moar 184d49: OUTPUT: «12␤»
graphemes, memory. same thing
only for people with photographic memory
well 100k graphs works
that ought to be enough
naw not even
10 million works too
do we want an easter egg for when you use a very specific number of some significance?
heh
timotimo, if the name is long enough the name is the variable ;)
well stores more data
ha
you can grab the name via .VAR.name
so, yeah, probably!
ok 100_000_000 million is like
taking a realllyyy long time
brb
hahaha
maybe will be done when i'm back
well, it's a few megabytes, so ... :)
xoh wait it finished already
what's its maxresidentk: )
going for 1_000_000_000 then
oh. no.
MoarVM panic: Memory allocation failed; could not allocate 8000000076 bytes
T_T T_T
okay!
get some swap on a very big disk
k
we should make moarvm more efficient
to enable longer variable names
brb actually tho
that's clearly very important
"we should make moarvm more efficient" - can't argue with that
"to enable longer variable names" - eh
maybe it will be a side effect
brb
ooo, but can your variable name be an actual Perl 6 program when EVALed?
m: my ::('oh lord why is this variable so crazy') = 10
rakudo-moar 184d49: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Malformed my␤at <tmp>:1␤------> 3'oh lord why is this variable so crazy')7⏏5 = 10␤»
what's the word i'm looking for? when a problem prints out it's own source code
quine
right
named after mister quine, all he could ever say was his whole genome sequence
heh
timotimo: now that you've solved that one bug, any idea on the spesh bug?
nah, it's probably a whole bit different flavour to it
if i do a profile with MVM_SPESH_INLINE_DISABLE=1, is that at all useful?
yeah
performance will differ a bit
you can check what percentage difference it makes by running it without profiling
why does travis have the HAS_JOSH_K_SEAL_OF_APPROVAL env var
like, not profiling but timing. once with and once without inline
samcv: monkey see no env var?
can't avoid it with travis
huh. i profile with MVM_SPESH_INLINE_DISABLE=1, --no-highlight, and --sparse=50, which created a 19mb .json profile, but the qt viewer gets killed when i try to open it
oh, now here's something interesting
you can definitely debug that though
with what?
well, gdb i guess?
huh, only 308486 lines in the sql profile output
well, turning off inlining doesn't make there be any fewer routines
and we record functions post-inline as a different piece either way
i.e. a normal call differs only from an inlined call by having a "it was inlined" bit set
so the call graphs should be the same size
i'm just surprised the qt viewer can't do such a small file
well, it might be choking on some value? null pointer dereference or something?
i don't think you've told us what way it actually dies in?
will gdb help if the OOM killer is what's killing it?
yep, it's the OOM killer
perhaps it's time to provision some swap?
oh, haha
well, in that case try a memory debugger or something
i'm using this as just one part of the justification to upgrade my system
like, what was it, heaptrack?
mst: i've run without swap for a long time now. adds a sense of danger and excitement to my life
hah
i have zram swap and it's nice
I tend to provision my dev systems to look as much like production as possible
'danger and excitement' are not geatures
nor, indeed, are they features
heaptrack overview: http://i.imgur.com/IdwUa0E.png
wow
i don't think it should generate that much data
mst: in complete agreement at work. at home i'm more freewheeling
note to self: skin calming bodywish stings horribly if you accidently get in your eyes
i feel they should have put a warning label on it.
you get what you wish for, eh?
"Skin calming eye irritant body wash"
i'm sure it would sell millions
the "allocated" tab: http://i.imgur.com/zgZAAGF.png
i wonder if it, like, endlessly recurses or something?
heaptrack is good yes MasterDuke ? how should i compile mvm to get best diagnostic stuff on it.
just full debug?
i usually just do --debug=3
hm, though i think i'm still using the version i compiled with --optimize=1
timotimo: would that effect the profile?
samcv: yeah, i've liked it
shouldn't
heaptrack most likely just instruments malloc and free and such
believe so
those are cross-.so-file
so the compiler wouldn't muck them up
wow my gh-pages branch is already really big. i'm trying to check it out now so i can add a page to it
it's still unpacking objects after 30 secs
well not really meant for anybody to check out anyway.
i wonder if you should force-push over it a bunch so that it frees up space
or instead keep the history because history is good?
history is good
idk i may force push over it if it gets too big
right
but nobody is supposed to check out that branch
can you "git clone" without grabbing the extra branch?
it just really keeps history. the main branch has never had any appimages in it
yeah
i don't think it grabs it
i know you can --depth=1, but that leaves you with a repo that can't do stuff
i should try though
if anybody is interested, profile of `htmlify.pl --no-highlight --sparse=50`: https://gist.github.com/MasterDuke17/754d88e9805171a89b273e9516c87ae3
samcv: what's gh-pages?
aaargh the extremely long filenames :D
it can host websites
i'm gonna set up a github pages for appimages and also one for moarvm coverage reports
ah, right. very cool
aha, it spends a whole lot of time inside "wait"
so we'll get automated mvm coverage reports and i won't have to do any  work
wait, is that without --parallel?
well. after it's automated
like, it doesn't highlight, so what is it waiting for?
--parallel=1
ok yeah it's cloning everything when i ask to clone it
i.e., the default
that could be harsh
if every appimage is 10 megs big
and you do daily blead and master builds
if i remember how i originally did it (though it's been changed since then by others), --parallel is just how many things to `start` at once
right
oh, so the main thread probably awaits all-of the started things
so --parallel=1 is essentially `start` and then immediately `await`
right
in that case we'll get like no info out of the profile
since it doesn't know how to reach into other threads' data yet
i do remember when i first did it, that with --parallel=10, only 1 in 5 runs would finish, but running it 5 times was still faster than once non-parallelized
the problem with that is that the moment we reach "end of profile, collect data now", all the other threads are like "yup, still runnin'!"
so think you can knock out making the profiler thread-aware tonight?
that's what, a good 10-15min job?
git clone --single-branch https://github.com/samcv/rakudo-appimage.git # will only clone the master branch
and is super fast
so put a readme
yes, readme be good
i gotta go sleep now
have a good one!
oh
in the future, sleep is illegal
how do you feel about using the appimages to travis-test our ecosystem modules?
sure
thought so!
it should save boatloads of time
automate everything
and can have it autocommit reports too now that i've mastered that
though i still have no clue how gh-pages works
well, you put the right files in there an dit ends up on like samcv.github.io or something
yep
https://samcv.github.io/rakudo-appimage/ ok well i got it sorta working
ah, yes, good
i believe gh-pages can also run some static-website-generators for you
but that may be outdated knowledge
okay, bedtime for reals
later
well i got this https://samcv.github.io/rakudo-appimage/
so that's nice
got it generating a basic inde
what's star-testing?
it's rakudo star. the testing refers to the appimage thing
makes sense if you compare the source of perl6-stable and perl6-testing here https://github.com/samcv/rakudo-appimage
the testing one resolves relative paths and such
the other one thinks paths that are relative are relative to the appimages virtual disk
ah, ok
.o(if we build an appimage with EVERY eco module then who cares if you can't install them)
heh
brb walk
gonna walk the puppy
though i'm about to change testing to stable i think. becuase i can't run any of the rakudo sanity tests
without it
gonna go ahead and remove the appimages that were made before testing had been implemented so people don't dl borked files (cuase it only updates files if they pass a travis build) but before they passed even if it didn't properly work
This is Rakudo version 2017.03-222-g184d49996 built on MoarVM version 2017.03-128-gc9ab59c6
csv-ip5xs        3.028
test            12.611
test-t           5.160 - 5.172
csv-parser      12.874
actually haven't updated my perl6 in a day or two gonna do that
err wait it's zef doing it
afk for the coming day or so&
weird and i get that error if i do `echo hi | perl6` too
odd
echo "say 'welcome';" | perl6 # this shows the error. but this -> echo "say 'welcome'; exit;" | perl6 #this is fine
why does: sub infix:<++> {'this creates %?LANG'}; CALLER::<%?LANG>; work?
the %?LANG doesn't seem to be installed as dynamic
m: sub infix:<++> {...}; say(VAR(%?LANG).dynamic)
rakudo-moar 184d49: OUTPUT: «Nil␤»
it's "dynamic" but at compile time; by run time it's presumably no longer dynamic
by run time it's too late to change the language the code was compiled with
at one point there was a bug allowing ?-twigil vars to be created uselessly at run time; if you managed to do so, maybe you found a remaining edge case?
night all
night
geekosaur: dynamic refers the ability to get the variable with CALLER, not to overwrite it
that's not the point. the point is compile time. the caller nevertheless has a language it was compiled in, and presumably the compile-time $?LANG is therefore available for it
it's not *runtime*-dynamic, except in the sense that every scope has a language it was compiled with and you can introspect that scope for that language
geekosaur: doesn't dynamic refer to the ability to introspect it from the caller (which EVAL depends on)
geekosaur: i'm trying to figure out what's wrong on the js backend that CALLER::<%?LANG> doesn't work
08:54Z <samcv> Zoffix: HTML::Parser is broken due to IO changes
afaik dynamic means * twigil
the version was not bumped
can can --force install it. i'll open an issue
Zoffix, i made sure i ran zef upgrade. but people don't always bump versions :\
pmurias: i think geekosaur didn't mean "dynamic" as in "perl6 dynamic variable", just "based on the callstack, not on lexical environments"
I was walking around that (hence scare quotes on "dynamic")
but yes, it's confusing
and because it's a compile time thing, it's likely not going to obey simple rules
the value of %?LANG is dynamic in the compiler because the compiler has a call stack that resembles the lexical scopes of the program it's compiling
and looks like even --force isn't working. it's using the already cached files in ~/.zef/store
eek
there's "zef nuke" :P
n
sorry
(try ...)--
am I getting fired?
why does Scalar.dynamic returns False, True *and* Nil, Nil being treated as not dynamic by the optimizer and as dynamic by the caller?
s/caller/CALLER
CALLER:: uses the "does not give a f**k" form of try so it might be treating it that way accidently
m: my $a; sub foo { LEAVE $a++; $a }; for ^100_000 { $ = foo }; say now - INIT now
rakudo-moar 184d49: OUTPUT: «0.31057117␤»
m: my $a; sub foo { LEAVE $a++; $a }; for ^200_000 { $ = foo }; say now - INIT now
rakudo-moar 184d49: OUTPUT: «0.52811179␤»
m: my $a; sub foo { $_ := $a; $a++; $_ }; for ^200_000 { $ = foo }; say now - INIT now
rakudo-moar 184d49: OUTPUT: «0.25595876␤»
m: my $a; sub foo { $_ := $a; $a++; $_ }; for ^200_000 { $ = foo }; say now - INIT now
rakudo-moar 184d49: OUTPUT: «0.2548151␤»
m: my $a; sub foo { $_ := $a; $a++; $_ }; for ^200_000 { $ = foo }; say now - INIT now
rakudo-moar 184d49: OUTPUT: «0.2573404␤»
m: my $a; sub foo { my $x := $a; $a++; $_ }; for ^200_000 { $ = foo }; say now - INIT now
rakudo-moar 184d49: OUTPUT: «0.2742925␤»
try without a handler
m: say +SeekFromEnd
rakudo-moar 184d49: OUTPUT: «2␤»
m: say 1*1024*1024*1024/3
rakudo-moar 184d49: OUTPUT: «357913941.333333␤»
m: say +SeekFromBeginning
rakudo-moar 184d49: OUTPUT: «0␤»
i've never seen that before either
happens in src/vm/moar/QAST/QASTOperationsMAST.nqp:1333
ah, yeah, seekfh doesn't return anything
that seems to upset the compiler, though the message could definitely be less LTA
`nqp::die("arg expression cannot be void") if $arg_mast.result_kind == $MVM_reg_void;`
what could it do instead of die?
does it point anywhere near where the problem happened?
can i get at the JSONPrettyGrammar inside the rakudo internals?
like, from inside user level perl6 code?
it's probably internal to that. .. bleh, need to use something else,t hen
can you ssh in to it?
wonder how easy it is to browse virtualbox's disk images. i.e., just close it saving state and then access the fs inside the image
boot a livecd into the box perhaps?
if the /tmp gets freed at startup
if /tmp is a memdisk, however ...
timotimo: i can repro it locally, but it doesn't say anything about where in my script there's a problem
right, you think we can figure that out from there? do we have a .node somewhere in the vicinity?
`$arg, $qastcomp, @ins, @arg_regs, @arg_flags, @arg_kinds` are args to handle_arg. `$arg_mast := $qastcomp.as_mast($arg), my int $arg_mast_kind := $arg_mast.result_kind;` are the only variables created before it dies
hm. i wonder how other places in there make error messages ... if they do at all?
nqp::die("arg code did not result in a MAST::Local") unless $arg_mast.result_reg && $arg_mast.result_reg ~~ MAST::Local;
is the very next line
but that's the only other die in that functino
maybe we should stash this for later
*function
though maybe the $qastcomp has something for us? not sure what $arg exactly would be
if you're in the middle of making grammars faster don't get distracted by this, i'll play around a bit
sadly, it won't make grammars much faster all in all
the improvement won't scale, it's just a tiny bit off of startup time
improving startup time is awesome, it makes everything else feel faster
and it only cuts off of the startup time when startup includes running a user-made grammar
so regular rakudo startup is not going to be changed
well, one of the perl 6 selling points is custom grammars, and #perl6 certainly sees a lot of questions about them, so it's a good optimization
i guess it's fair
nice
well, if you load a precompiled module that has a grammar in it, like, a million times ... i'm sure it'll save you a second or two!
do the savings depend on the size of the grammar?
Hm, I should try it against the YAMLish profile I took
depends on the amount of stuff in the grammar that you touch
though "touching" in this sense can be very contagious and far-reaching
According to the profile I saw, we spent a ton of time in merge_substates or related when parsing a small (just 5-10 lines) YAML file. It was like 50% of the parse time.
I'll reproduce that and then upgrade Rakudo :)
50% of 10ms is still just 5ms :D
would this help Text::CSV since it uses Slang::Tuxic? or Perl6::Parser?
hm, not quite sure
That isn't how scalars in Perl 6 work
The Scalar stores a reference to something
The something is the expensive thing
There's probably some missing memory pressure somewhere
If it's being overly hungry
m: say 2125956 / 968840
rakudo-moar 064b58: OUTPUT: «2.1943314␤»
but will it blend?
Zoffix: Wow, looking forward to seeing that patch :)
i wonder what we did bad in slurps binary mode
Oh dear, bumping Rakudo version doesn't end too well for $dayjob project
No such method 'abspath' for invocant of type 'IO::Path' in block  at /home/jnthn/dev/MoarVM/install/share/perl6/site/sources/8922A2BA7BE89CE9C1AF2017551EC8B1435BA924 (Digest::SHA1::Native) line 5
Oh, cool :)
Doing so :)
Aww, the version wasn't bumped
The test suite thinks so :)
Need to check it on Windows also
`$arg_mast := $qastcomp.coerce($arg_mast, $MVM_reg_str) if $arg_mast.result_kind == $MVM_reg_void;` makes `./nqp-m -e 'say(nqp::seekfh(nqp::open("a", "r"), 1, 0))'` just print an empty string instead of dying
and passes spectest. but it seems a bit hackish...
That loosk...weird
before you'd get: `===SORRY!===arg expression cannot be void`
That seems more sensible.
then any way to get some information about where things went wrong into the message?
MasterDuke: Probably, though I thought we had various CATCH blocks in place that annotated errors like that with a source location
jnthn: what should Scalar.dynamic return when the scalar has no descriptor? It currently return Nil in this case but I think it should be either True or False
pmurias: False, I'd think
jnthn: fyi, this is in src/vm/moar/QAST/QASTOperationsMAST.nqp, what i commented out is `nqp::die("arg expression cannot be void")`
Well, the error is correct
ok. so I should explicitly set %?LANG as dynamic?
If you use nqp::ops that are void you should expect a code-gen error if you try to use them. It'd be good if it could give the nearest annotated source location, however.
But I thought that we had a CATCH in stmts notes that would add location into and rethrow
pmurias: Ah, 'cus EVAL needs to access it through the caller chain?
pmurias: Seems reasonable enough
Zoffix: yeah, i wasn't going to PR my change, but like jnthn said, getting the nearest annotated source location would be nice
jnthn: yes, EVAL needs that. Should other compile-time variables be marked as dynamic too?
I was wondering that, but don't have an immediate feeling for it :)
Probably not all though
Because some are actually just transforms
jnthn: fwiw, this is the relevant ast https://gist.github.com/MasterDuke17/c360883b4065e29a1a508d69bc7faa72
this might or might not be relevant, but $?LANG is now supposed to be dynamically generated at the point of mention like $?LINE, but as far as I know EVAL doesn't use it quite yet
ACTION goes to get another cuppa to see if his brane unfogs anysome
ACTION didn't sleep so well last night, between having the snuffles and having the house full of butyl mercaptans all night
courtesy of a skunk in the back yard that probably met a cat or a racoon
progress report on uncurse, we're now down to blowing only 25 spectest .t files completely out of the water :)
TimToady++
and it does seem slightly faster, but the big speedups will come later
the problem with our current cstack is that it's more optimized for backtracking than for forwardtracking
I think we can make parsing a lot faster by making backtracking a bit slower
well, hopefully without slowing down backtracking, but we'll see
but basically by assuming we will succeed rather than assuming we'll fail
Sounds interesting :)
and by putting things directly into where the match object can provide them
m: buf6.new
rakudo-moar 064b58: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Undeclared routine:␤    buf6 used at line 1␤␤»
another potential speedup, once we get $<foo> to not go through the hash interface mandatorily, is to avoid capturing to hashes at all
for any given rule, the names we capture are statically known, so could just be a static mapping to fixed array locations
Indeed
I guess the challenge there is that we cheat like heck on hash/array access
a capturing match really only needs to know "put yourself into this array at this position if you match"
In NQP
We can stop doing that
and that array will be in the cursor/match object itself, not the cstack, so we never have to copy
yes, we can either implement AT-KEY, but that still is a string interface on each call
or we can do something maybe a little smarter at compile time, or on first use, or somethin'
AT-KEYish stuff might be sufficient with smart enough type spesh
but currently the $/<foo> interface is boxing us into a performance corner I don't like
Well, it was an optimization with the assumption we'd have a real array and real hash
I'm thinking AT-KEY is the slow path
and the compile can be smarter about literal $<foo>
That dates back to the Parrot days
sure, not complaining about how we go here :)
*got
And, to be fair, the early Moar days too when we had no inlining
just trying to see around the corners to where we'd like to be
Now it's mostly just more complexity in the VM :)
we don't internal hash keys yet the way P5 does, do we?
*intern
We intern strings inside a single compilation unit
And we have a fast path in hash string equality checks that first looks at the pointer
We don't yet do interning between compilation units
And don't do anything about non-literal strings
that doesn't help one mention of $<foo> vs another $<foo> which is presumably a different string "foo"
or does it?
if they are in the same file, i'd imagine they get the same "foo" object
when it lands in the string hash they'll be deduplicated
okay
Yeah, what timotimo said. We de-dupe at bytecode assembly time
I suspect that there'd be a bit of a win to be had if we de-duped cross-compilation unit
it'd be interesting to see if we can "just" take strings from another compunit when we load one from another's string heap, but then we'll need a hash again, and then thread-safety and urgh
Because then your grammar and actions, if in separate files, could also get the faster path
But of course you gotta then be mighty careful that you don't introduce a new memory leak for EVAL :)
hm, is our string heap sorted? i seem to remember it is
so we'd have the ability to use merging of pre-sorted lists here, or perhaps binary search.
anyway, that's all well and good, but I think we can do better by taking more advantage of the staticness of rule names directly, and basically have a string mapper to position for each rule
right
and mostly make that translation instantly at compile time
can't imagine right now what corners the data has to flow around there :)
anyhoo that's the direction I'm thinking once the uncurse branch settles down
sounds exciting
just not calling .CURSOR and .MATCH all over the place should help some too
It'll work well inside of rules
Action methods I guess will still have to do a hash lookup along the way
but hopefully not more than one lookup per call, anyway
and we can also look at gluing action routines more closely to rules at compile time or first use time
the double dispatch seems suboptimal
though we do have to do both dispatches at least once, since there's no 1-to-1 mapping necessarily
reminds me a little of how OpenGL did vertex and fragment shaders
you were forced to compile a new object for every combination of vertex and fragment shader
even though the interface between the two is kind of static
there's extensions for more freedom there, though
I've already got some plans to change how we call action methods
So we can better spesh 'em
And even inline the tiny ones
of course, if we really want to parse Perl 6 fast, we write a yacc grammar that parses "standard" P6 and just drops down into recursive descent when the language changes :)
that sounds nice
is that based on more code gen? like CompilationHelpers?
ACTION grocery shopping
one thing I noticed was that the action method actually seems to currently be in the dynamic scope of its corresponding rule, which is nice, but I hadn't expected
for instance, rule O sets %*SPEC, and action method O uses that, which wouldn't work if the action method were called at the same level as the rule
anyway, we probably need to preserve that
however we hook rules with actions
ACTION turns his glare upon the 25 broken .t files...
TimToady: I'd figured it had to be that way :)
'cus of the dynamic variable pattern you just mentioned :)
well, it fits with how we were thinking of action methods as equivalent to embedded {}
Aye
I don't think it's a perf issue to have it this way
so adding an action method to / foo | bar / is turning it into / [ foo | bar ] { your ac here } /
If anything, it's good if we fix our code-gen
Because we can emit the action callsite directly in the regex body
Meaning that it'll be speshable, inlinable, etc.
most of P5 trades *more* memory for more speed :)
so keeping it the same is kind of a win, or at least a non-lose :)
me puts too many smileys on his messages :)
Me too :D
m: IO::Special
rakudo-moar 064b58: OUTPUT: «WARNINGS for <tmp>:␤Useless use of constant value IO::Special in sink context (line 1)␤»
m: $*IN.seek: 1
rakudo-moar 064b58: ( no output )
m: $*IN.seek: 10
rakudo-moar 064b58: ( no output )
m: $*OUT.seek: 10
rakudo-moar 064b58: ( no output )
m: $*IN.^name.say
rakudo-moar 064b58: OUTPUT: «IO::Handle␤»
m: $*IN.seek: 1
rakudo-moar 064b58: ( no output )
m: $*IN.^lookup('seek').file
rakudo-moar 064b58: ( no output )
m: $*IN.^lookup('seek').file.say
rakudo-moar 064b58: OUTPUT: «SETTING::src/core/IO/Handle.pm␤»
So there's more module breakage there
Yeah
Oh, maybe something didn't version bump
Archive::LibArchive::Raw seems not updated
$ git grep abspath
lib/Archive/Libarchive/Raw.pm6:        ?? %?RESOURCES<libarchive.dll>.abspath
(that's after a git pull)
oh, hang on
haha
No, that's my local fork of it
Hm, it had been version bumped
OK, I dunno what I did...
But looks better now
Zoffix: In MoarVM I guess we know...
Oh, but maybe not even reliably then
Yeah, I think probably not
I was thinking we could check if the handle type implemented the seekable thing
(But then realized that doesn't mean it will succeed)
Heh, not if we do what that comment suggests...
What was your speedup?
oh
probably seek + tell + pre-size
aha
No, I meant what did you do to acehive it :)
also can't seek a socket
or a normal pipe
geekosaur: yeah, i have trouble finding my socks, too
also, is there a binding to fstat?
Zoffix: Can we not just pass some integer max value to read?
And it'll read all it can and return to us?
That'd save the whole seek/tell thing
:D
.oO(Mr Plumber, in the kitchen, with a lead pipe.)
rakudo-moar 064b58: OUTPUT: «1024␤»
s: buf8.new, 'append', \()
s: buf8.new, 'append', \(Buf[uint8].new(97,98))
S: &DEPRECATED
s: &DEPRECATED
Zoffix: ok, I'm going to fudge them. Maybe that makes things a bit easier for you, too.
s: &tree
s: %(), 'tree'
m: my %mainhash := {subhash1 => {key1 => True, key2 => 'value2'},subhash2 => {key3 => 'value3', key4 => True}}; my %otherhash := {subhash1 => {key1 => True, key2 => 'othervalue2'}, subhash2 => {key5 => 'value5', key6 => True}}; for %otherhash { %mainhash{.key} = hash %mainhash{.key}<>, .value<> }; say %mainhash
rakudo-moar f1b4af: OUTPUT: «{subhash1 => {key1 => True, key2 => othervalue2}, subhash2 => {key3 => value3, key4 => True, key5 => value5, key6 => True}}␤»
m: my %mainhash := {subhash1 => {key1 => True, key2 => 'value2'},subhash2 => {key3 => 'value3', key4 => True}}; my %otherhash := {subhash1 => {key1 => True, key2 => 'othervalue2'}, subhash2 => {key5 => 'value5', key6 => True}}; %mainhash.tree.say
rakudo-moar f1b4af: OUTPUT: «(subhash2 => {key3 => value3, key4 => True} subhash1 => {key1 => True, key2 => value2})␤»
m: my %mainhash := {subhash1 => {key1 => True, key2 => 'value2'},subhash2 => {key3 => 'value3', key4 => True}}; my %otherhash := {subhash1 => {key1 => True, key2 => 'othervalue2'}, subhash2 => {key5 => 'value5', key6 => True}}; %mainhash.tree.say
rakudo-moar f1b4af: OUTPUT: «(subhash2 => {key3 => value3, key4 => True} subhash1 => {key1 => True, key2 => value2})␤»
rakudo-moar f1b4af: OUTPUT: «(a b c)␤»
rakudo-moar f1b4af: OUTPUT: «((a b c) (z b g))␤»
m: my %mainhash := {subhash1 => {key1 => True, key2 => 'value2'},subhash2 => {key3 => 'value3', key4 => True}}; my %otherhash := {subhash1 => {key1 => True, key2 => 'othervalue2'}, subhash2 => {key5 => 'value5', key6 => True}}; %mainhash ««=»» %otherhash
rakudo-moar f1b4af: ( no output )
m: my %mainhash := {subhash1 => {key1 => True, key2 => 'value2'},subhash2 => {key3 => 'value3', key4 => True}}; my %otherhash := {subhash1 => {key1 => True, key2 => 'othervalue2'}, subhash2 => {key5 => 'value5', key6 => True}}; say %mainhash ««=»» %otherhash;
rakudo-moar f1b4af: OUTPUT: «{subhash1 => {key1 => True, key2 => othervalue2}, subhash2 => {}}␤»
m: my %mainhash := {subhash1 => {key1 => True, key2 => 'value2'},subhash2 => {key3 => 'value3', key4 => True}}; my %otherhash := {subhash1 => {key1 => True, key2 => 'othervalue2'}, subhash2 => {key5 => 'value5', key6 => True}}; say %mainhash ««=»» %otherhash; say %mainhash
rakudo-moar f1b4af: OUTPUT: «{subhash1 => {key1 => True, key2 => othervalue2}, subhash2 => {}}␤{subhash1 => {key1 => True, key2 => othervalue2}, subhash2 => {key3 => value3, key4 => True}}␤»
m: my %mainhash := {subhash1 => {key1 => True, key2 => 'value2'},subhash2 => {key3 => 'value3', key4 => True}}; my %otherhash := {subhash1 => {key1 => True, key2 => 'othervalue2'}, subhash2 => {key5 => 'value5', key6 => True}}; say %mainhash ««=»=» %otherhash; say %mainhash
rakudo-moar f1b4af: OUTPUT: «{subhash1 => {key1 => True, key2 => othervalue2}, subhash2 => {}}␤{subhash1 => {key1 => True, key2 => othervalue2}, subhash2 => {key3 => value3, key4 => True}}␤»
m: my %mainhash := {subhash1 => {key1 => True, key2 => 'value2'},subhash2 => {key3 => 'value3', key4 => True}}; my %otherhash := {subhash1 => {key1 => True, key2 => 'othervalue2'}, subhash2 => {key5 => 'value5', key6 => True}}; say %mainhash «=«=»» %otherhash; say %mainhash
rakudo-moar f1b4af: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Missing infix inside hyper␤at <tmp>:1␤------> 035', key6 => True}}; say %mainhash «=«=»»7⏏5 %otherhash; say %mainhash␤    expecting any of:␤        infix␤        infix stopper␤»
m: my %mainhash := {subhash1 => {key1 => True, key2 => 'value2'},subhash2 => {key3 => 'value3', key4 => True}}; my %otherhash := {subhash1 => {key1 => True, key2 => 'othervalue2'}, subhash2 => {key5 => 'value5', key6 => True}}; say %mainhash ««=»=» %otherhash; say %mainhash
rakudo-moar f1b4af: OUTPUT: «{subhash1 => {key1 => True, key2 => othervalue2}, subhash2 => {}}␤{subhash1 => {key1 => True, key2 => othervalue2}, subhash2 => {key3 => value3, key4 => True}}␤»
m: my %mainhash := {subhash1 => {key1 => True, key2 => 'value2'},subhash2 => {key3 => 'value3', key4 => True}}; my %otherhash := {subhash1 => {key1 => True, key2 => 'othervalue2'}, subhash2 => {key5 => 'value5', key6 => True}}; %mainhash ««=»=» %otherhash; say %mainhash
rakudo-moar f1b4af: OUTPUT: «{subhash1 => {key1 => True, key2 => othervalue2}, subhash2 => {key3 => value3, key4 => True}}␤»
m: my %mainhash := {subhash1 => {key1 => True, key2 => 'value2'},subhash2 => {key3 => 'value3', key4 => True}}; my %otherhash := {subhash1 => {key1 => True, key2 => 'othervalue2'}, subhash2 => {key5 => 'value5', key6 => True}}; %mainhash «««=»=»=» %otherhash; say %mainhash
rakudo-moar f1b4af: OUTPUT: «{subhash1 => {key1 => True, key2 => othervalue2}, subhash2 => {key3 => value3, key4 => True}}␤»
m: my %mainhash := {subhash1 => {key1 => True, key2 => 'value2'},subhash2 => {key3 => 'value3', key4 => True}}; my %otherhash := {subhash1 => {key1 => True, key2 => 'othervalue2'}, subhash2 => {key5 => 'value5', key6 => True}}; %mainhash «««=»=»+» %otherhash; say %mainhash
rakudo-moar f1b4af: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Missing « or »␤at <tmp>:1␤------> 3lue5', key6 => True}}; %mainhash «««=»=»7⏏5+» %otherhash; say %mainhash␤    expecting any of:␤        infix␤        infix stopper␤»
m: my %mainhash := {subhash1 => {key1 => True, key2 => 'value2'},subhash2 => {key3 => 'value3', key4 => True}}; my %otherhash := {subhash1 => {key1 => True, key2 => 'othervalue2'}, subhash2 => {key5 => 'value5', key6 => True}}; %mainhash ««««=»=»»» %otherhash; say %mainhash
rakudo-moar f1b4af: OUTPUT: «{subhash1 => {key1 => True, key2 => othervalue2}, subhash2 => {key3 => value3, key4 => True}}␤»
m: my %mainhash := {subhash1 => {key1 => True, key2 => 'value2'},subhash2 => {key3 => 'value3', key4 => True}}; my %otherhash := {subhash1 => {key1 => True, key2 => 'othervalue2'}, subhash2 => {key5 => 'value5', key6 => True}}; %mainhash ««««««««=»=»»»»»»» %otherhash; say %mainhash
rakudo-moar f1b4af: OUTPUT: «{subhash1 => {key1 => True, key2 => othervalue2}, subhash2 => {key3 => value3, key4 => True}}␤»
m: my %mainhash := {subhash1 => {key1 => True, key2 => 'value2'},subhash2 => {key3 => 'value3', key4 => True}}; my %otherhash := {subhash1 => {key1 => True, key2 => 'othervalue2'}, subhash2 => {key5 => 'value5', key6 => True}}; %mainhash «««««««=»»»»»»» %otherhash; say %mainhash
rakudo-moar f1b4af: OUTPUT: «{subhash1 => {key1 => True, key2 => othervalue2}, subhash2 => {key3 => value3, key4 => True}}␤»
it's supposed to take mapping arguments for each level of the tree
rakudo-moar f1b4af: OUTPUT: «(Any:U $: *%_)␤(Any:D $: *%_)␤(Any:D $: Whatever, *%_)␤(Any:D $: Cool $count, *%_)␤(Any:D $: @ (&first, *@rest), *%_)␤(Any:D $: &first, *@rest, *%_)␤»
m: say (<a b c>, <z b g>).tree: &uc
rakudo-moar f1b4af: OUTPUT: «A B C Z B G␤»
rakudo-moar f1b4af: OUTPUT: «A B C Z B G␤»
m: say (<a b c>, <z b g>).tree: {"[$_]"}
rakudo-moar f1b4af: OUTPUT: «[a b c z b g]␤»
rakudo-moar f1b4af: OUTPUT: «[a b c z b g]␤»
it was only ever half implemented the way it was specced
m: say (<a b c>, <z b g>).tree: 2
rakudo-moar f1b4af: OUTPUT: «((a b c) (z b g))␤»
m: say (<a b c>, <z b g>).tree: 1
rakudo-moar f1b4af: OUTPUT: «((a b c) (z b g))␤»
m: say (<a b c>, <z b g>).tree: 3
rakudo-moar f1b4af: OUTPUT: «((a b c) (z b g))␤»
m: say (<a b c>, <z b g>).tree: 2
rakudo-moar f1b4af: OUTPUT: «((a b c) (z b g))␤»
m: say (<a b c>, <z b g>).tree: 1
rakudo-moar f1b4af: OUTPUT: «((a b c) (z b g))␤»
m: say (<a b c>, <z b g>).tree: 100
rakudo-moar f1b4af: OUTPUT: «((a b c) (z b g))␤»
m: say (<a b c>, <z b g>).tree: 1
rakudo-moar f1b4af: OUTPUT: «((a b c) (z b g))␤»
m: say %(foo => <a b c>, bar => <z b g>).tree: 1
rakudo-moar f1b4af: OUTPUT: «(bar => (z b g) foo => (a b c))␤»
m: say %(foo => <a b c>, bar => <z b g>).tree: 2
rakudo-moar f1b4af: OUTPUT: «(bar => (z b g) foo => (a b c))␤»
m: say %(foo => <a b c>, bar => <z b g>).tree: 3
rakudo-moar f1b4af: OUTPUT: «(bar => (z b g) foo => (a b c))␤»
m: say [*] 1..361;
rakudo-moar f1b4af: OUTPUT: «14379232588848906548323625114998633547549075386447558761272827652992277955343896188568419080031411960714137944348905859683839682333043216077138088370565578796691924861827097800358990211005794501073330507926277717227504122680867752813688505752654181204350…»
m: say ([*] 1..361).log10
rakudo-moar f1b4af: OUTPUT: «Inf␤»
m: say ([*] 1..350).log10
rakudo-moar f1b4af: OUTPUT: «Inf␤»
m: say ([*] 1..300).log10
rakudo-moar f1b4af: OUTPUT: «Inf␤»
m: say (1234567).base(10,50)
rakudo-moar f1b4af: OUTPUT: «1234567.00000000000000000000000000000000000000000000000000␤»
m: say ([*] 1..361).base(10,50)
rakudo-moar f1b4af: OUTPUT: «14379232588848906548323625114998633547549075386447558761272827652992277955343896188568419080031411960714137944348905859683839682333043216077138088370565578796691924861827097800358990211005794501073330507926277717227504122680867752813688505752654181204350…»
m: say ([*] 1..361).base(10,10)
rakudo-moar f1b4af: OUTPUT: «14379232588848906548323625114998633547549075386447558761272827652992277955343896188568419080031411960714137944348905859683839682333043216077138088370565578796691924861827097800358990211005794501073330507926277717227504122680867752813688505752654181204350…»
m: say Num($_/10) with [*] 1..361
rakudo-moar f1b4af: OUTPUT: «Inf␤»
m: say Num($_/($_/10)) with [*] 1..361
rakudo-moar f1b4af: OUTPUT: «10␤»
m: say Num($_/($_/20)) with [*] 1..361
rakudo-moar f1b4af: OUTPUT: «20␤»
m: say Num($_*($_/10)) with [*] 1..361
rakudo-moar f1b4af: OUTPUT: «Inf␤»
m: say $_*($_/10) with [*] 1..361
rakudo-moar f1b4af: OUTPUT: «20676232984421442715236397637555392942731934392634249866841709452310460412292691646168709255097113152171871111647277989029297869503265676520542050851264765891647648633619033761821802649237410477935303114158329097644932939178376641366240412989588078065467…»
m: say $_*.1 with [*] 1..361
rakudo-moar f1b4af: OUTPUT: «14379232588848906548323625114998633547549075386447558761272827652992277955343896188568419080031411960714137944348905859683839682333043216077138088370565578796691924861827097800358990211005794501073330507926277717227504122680867752813688505752654181204350…»
m: say $_/$_ with [*] 1..361
rakudo-moar f1b4af: OUTPUT: «1␤»
m: say $_/($_*10) with [*] 1..361
rakudo-moar f1b4af: OUTPUT: «0.1␤»
fuck you
m: say Num($_/10**.chars) with [*] 1..361
rakudo-moar f1b4af: OUTPUT: «0.143792325888489␤»
m: say $_/10**.chars with [*] 1..361
rakudo-moar f1b4af: OUTPUT: «0.143792325888489␤»
m: say $_/10**(.chars-13) with [*] 1..361
rakudo-moar f1b4af: OUTPUT: «1437923258884.89␤»
m: say $_/10**(.chars-1) with [*] 1..361
rakudo-moar f1b4af: OUTPUT: «1.43792325888489␤»
m: printf '%.3fe%d', $_/10**(.chars-1), .chars with [*] 1..361
rakudo-moar f1b4af: OUTPUT: «1.438e769»
m: printf '%.3fe%d', $_/10**(.chars-1), .chars-1 with [*] 1..361
rakudo-moar f1b4af: OUTPUT: «1.438e768»
m: printf '%.3f e %d', $_/10**(.chars-1), .chars-1 with [*] 1..361
rakudo-moar f1b4af: OUTPUT: «1.438 e 768»
m: printf '%.3fe%d', $_/10**(.chars-1), .chars-1 with [*] 1..361
rakudo-moar f1b4af: OUTPUT: «1.438e768»
m: printf '%.3fe%d', $_/10**(.chars-1), .chars-1 with 123456789
rakudo-moar f1b4af: OUTPUT: «1.235e8»
m: say 1.235e8
rakudo-moar f1b4af: OUTPUT: «123500000␤»
m: say 1.235e8 - 123456789
rakudo-moar f1b4af: OUTPUT: «43211.0000000149␤»
m: say 123456789 - 1.235e8
rakudo-moar f1b4af: OUTPUT: «-43211.0000000149␤»
123500000
123456789
m: printf '%.3fe%d', $_/10**(.chars-1), .chars-1 with 123456789
rakudo-moar f1b4af: OUTPUT: «1.235e8»
rakudo-moar f1b4af: OUTPUT: «1.235e8»
rakudo-moar f1b4af: OUTPUT: «1.438e768»
m: printf '%.3fe%d', $_/10**(.chars-1), .chars-1 with 123500000
rakudo-moar f1b4af: OUTPUT: «1.235e8»
s: 42, 'log10', \()
HELP ME!
Hurrah, seems I've nailed the occasional data loss bug in IO::Socket::Async::SSL
That means it's pretty close to ready to ship off to the ecosystem
m: dd buf8.new: 1 xx 10;
rakudo-moar f1b4af: OUTPUT: «Buf[uint8].new(1,1,1,1,1,1,1,1,1,1)␤»
m: use nqp; dd nqp::elems(buf8.new: 1 xx 10)
rakudo-moar f1b4af: OUTPUT: «10␤»
m: use nqp; my $b = buf8.new: 1 xx 10; for ^100_000 { $ = nqp::elems($b) }; dd now - INIT now
rakudo-moar f1b4af: OUTPUT: «This type (Scalar) does not support elems␤  in block <unit> at <tmp> line 1␤␤»
m: use nqp; my $b = buf8.new: 1 xx 10; for ^100_000 { $ = nqp::elems(nqp::decont($b)) }; dd now - INIT now
rakudo-moar f1b4af: OUTPUT: «Duration.new(<143817/1802450>)␤»
m: use nqp; my $b = buf8.new: 1 xx 10; for ^100_000 { $ = nqp::elems(nqp::decont($b)) }; say now - INIT now
rakudo-moar f1b4af: OUTPUT: «0.0857038␤»
m: use nqp; my $b = buf8.new: 1 xx 10; for ^1000_000 { $ = nqp::elems(nqp::decont($b)) }; say now - INIT now
rakudo-moar f1b4af: OUTPUT: «0.5507641␤»
m: use nqp; my $b = buf8.new: 1 xx 10; for ^10_000 { $ = nqp::elems(nqp::decont($b)) }; say now - INIT now
rakudo-moar f1b4af: OUTPUT: «0.0199344␤»
m: use nqp; my $b = buf8.new: 1 xx 1000; for ^10_000 { $ = nqp::elems(nqp::decont($b)) }; say now - INIT now
rakudo-moar f1b4af: OUTPUT: «0.0270859␤»
m: use nqp; my $b = buf8.new: 1 xx 1000; for ^10_000 { $ = nqp::elems(nqp::decont($b)) }; say now - INIT now
rakudo-moar f1b4af: OUTPUT: «0.02799180␤»
m: use nqp; my $b = buf8.new: 1 xx 1000; for ^10_000 { $ = nqp::elems(nqp::decont($b)) }; say now - INIT now
rakudo-moar f1b4af: OUTPUT: «0.027976␤»
m: use nqp; my $b = buf8.new: 1 xx 1000; for ^10_000 { $ = nqp::elems(nqp::decont($b)) }; say now - INIT now
rakudo-moar f1b4af: OUTPUT: «0.0274112␤»
m: use nqp; my $b = buf8.new: 1 xx 1000; for ^10_000 { $ = nqp::elems(nqp::decont($b)) }; say now - INIT now
rakudo-moar f1b4af: OUTPUT: «0.0270671␤»
m: use nqp; my $b = buf8.new: 1 xx 1000; for ^10_000 { $ = nqp::elems(nqp::decont($b)) }; say now - INIT now
rakudo-moar f1b4af: OUTPUT: «0.02670052␤»
#####
#####
#####
m: use nqp; my $b = buf8.new: 1 xx 100000; for ^10_000 { $ = nqp::elems(nqp::decont($b)) }; say now - INIT now
rakudo-moar f1b4af: OUTPUT: «0.081318␤»
m: use nqp; my $b = buf8.new: 1 xx 100000; my $n = now; for ^10_000 { $ = nqp::elems(nqp::decont($b)) }; say now - $n
rakudo-moar f1b4af: OUTPUT: «0.0139978␤»
m: use nqp; my $b = buf8.new: 1 xx 100000; my $n = now; for ^10_000 { $ = nqp::elems(nqp::decont($b)) }; say now - $n
rakudo-moar f1b4af: OUTPUT: «0.013794␤»
m: use nqp; my $b = buf8.new: 1 xx 100; my $n = now; for ^10_000 { $ = nqp::elems(nqp::decont($b)) }; say now - $n
rakudo-moar f1b4af: OUTPUT: «0.0134453␤»
m: use nqp; my $b = buf8.new: 1 xx 10; my $n = now; for ^10_000 { $ = nqp::elems(nqp::decont($b)) }; say now - $n
rakudo-moar f1b4af: OUTPUT: «0.007789␤»
jnthn: i can't get any of the nqp::die() conditions in src/vm/moar/QAST/QASTOperationsMAST.nqp to give source location. e.g.,
m: use nqp; nqp::if_i("foo")
rakudo-moar f1b4af: OUTPUT: «===SORRY!===␤No registered operation handler for 'if_i'␤»
m: use nqp; nqp::die("foo")
rakudo-moar f1b4af: OUTPUT: «foo␤  in block <unit> at <tmp> line 1␤␤»
MasterDuke: Hmm, maybe there is no current handling for that, then
The most common one is no such operation handler, which is easy to grep for :)
And, to be fair, errors at this layer are pretty rare :)
true. but if it's easy to fix, seems like a good thing to do. i just don't know where the fix would go
fff
jnthn, Zoffix: a lot of the nqp::die()s in src/vm/moar/QAST/QASTOperationsMAST.nqp could at least have some extra information added (e.g., the name of the void arg in the case Zoffix found), like how the `No registered operation handler for '<foo>'` one does
think it would be worth adding relevant info where possible?
in pretty much every case we're already dying, so i doubt an extra nqp::elems, or .op() would really matter
If we're dying anyway it's likely quite cheap
but i wasn't planning on doing anything extensive, just there are a couple things like "can only have one foo", and i'd just add ", got '+@foo'"
it'll be a PR so (any|every)body can take a look, but i'm just anticipating minor changes
I'd in principle be fine with such a PR :)
what sourcery is this
interesting, can you strace that?
yeah
thatg ives you a trace of all system calls
you ought to be able to see what file descriptor number it complains about by 1) when the error message from rakudo comes, and 2) when something is listed as = ESOMEERROR
yup
mostly mmap and such
i know you can filter with -e, but you'll need a negative filter
m: "/tmp/meow".IO.slurp.say
rakudo-moar f1b4af: OUTPUT: «Failed to open file /tmp/meow: no such file or directory␤  in block <unit> at <tmp> line 1␤␤»
m: "/tmp/meow".IO.spurt: 'bar'
rakudo-moar f1b4af: ( no output )
m: "/tmp/meow".IO.slurp.say
rakudo-moar f1b4af: OUTPUT: «bar␤»
m: https://gist.github.com/zoffixznet/344a158837d5a1bd5d02b83e744675ce
rakudo-moar f1b4af: OUTPUT: «No such method 'slurp3' for invocant of type 'IO::Path'␤  in block <unit> at <tmp> line 45␤␤»
no, tha tought to be stderr
where it outputs the error
close(-1)                               = -1 EBADF (Bad file descriptor)
it's trying to close fd -1, that's very wrong
uh oh
it doesn't panic, so you should be able to --ll-exception perhaps?
now that's interesting
perhaps it's already closed and closing it manually has reset or invalidated the fd?
and the DESTROY method is erroneously running?
good!
ah
sure thing
i'm really glad to be of help
we do have that "canonicalize_encoding" function or table or somesuch
btw, if you find us a junior coder, they could try putting in all the iso-9999-blah encodings
into moarvm
there's a table for every one of those on the unicode 'site somewhere
just in the last month or maybe two it was discussed, but i don't remember who was involved in the conversation
i'm not even sure if it was in #moarvm or not
8859 is the number i was looking for
http://www.unicode.org/Public/MAPPINGS/ISO8859/
http://irclog.perlgeek.de/perl6/2017-03-24#i_14318239 - and surrounding lines
did you ever wonder what a timeline where EBCDIC won over ASCII would look like?
OK!
http://www.unicode.org/Public/MAPPINGS/VENDORS/IBM/IBM_conversions.html *cough*
http://www.unicode.org/Public/MAPPINGS/VENDORS/MICSFT/EBCDIC/ - on top of that
because of course there's codemaps on top of ecbdic
cp037_IBMUSCanada - don't you just love that
do i even wanna know what "WindowsBestFit" is all about %)
there's also a mapping for Atari ST and TT character maps
this code map interestingly contains the big integral that's made up of three code points (top, middle, bottom)
# This table contains the data the Unicode Consortium has on how
#       IBM PC memory-mapped video graphics map into Unicode.
for some reason all of this makes me a little bit giddy
:(
i'll go to bed now
i hope your pipe situation gets better soon :(
m: sub foo (:$a = True) {$ = $a.abs}; for ^100_000 { $ = foo }; say now - INIT now
rakudo-moar c13480: OUTPUT: «0.1219657␤»
m: sub foo (:$a = True) {$ = $a.abs}; for ^100_000 { $ = foo }; say now - INIT now
rakudo-moar c13480: OUTPUT: «0.12828660␤»
m: sub foo (:$a = True) {$ = $a.abs}; for ^100_000 { $ = foo }; say now - INIT now
rakudo-moar c13480: OUTPUT: «0.12246705␤»
m: sub foo (:$a) {$a.DEFINITE || $a = True; $ = $a.abs}; for ^100_000 { $ = foo }; say now - INIT now
rakudo-moar c13480: OUTPUT: «Cannot assign to a readonly variable ($a) or a value␤  in sub foo at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»
m: sub foo (:$a is copy) {$a.DEFINITE || $a = True; $ = $a.abs}; for ^100_000 { $ = foo }; say now - INIT now
rakudo-moar c13480: OUTPUT: «0.13029745␤»
m: sub foo (:$a is copy) {$a.DEFINITE || $a = True; $ = $a.abs}; for ^100_000 { $ = foo }; say now - INIT now
rakudo-moar c13480: OUTPUT: «0.1247219␤»
m: sub foo (:$a is copy) {$a.DEFINITE || $a = True; $ = $a.abs}; for ^100_000 { $ = foo }; say now - INIT now
rakudo-moar c13480: OUTPUT: «0.1233551␤»
m: sub foo (:$a is copy) {$a.DEFINITE || $a = True; $ = $a.abs}; for ^100_000 { $ = foo }; say now - INIT now
rakudo-moar c13480: OUTPUT: «0.1236691␤»
m: dd Any.^lookup('lines')
rakudo-moar c13480: OUTPUT: «Mu␤»
m: dd Cool.^lookup('lines')
rakudo-moar c13480: OUTPUT: «Method lines = method lines (Cool:D $: |c is raw) { #`(Method|35302496) ... }␤»
m: dd Cool.^lookup('words')
rakudo-moar c13480: OUTPUT: «Method words = method words (Cool:D $: |c is raw) { #`(Method|38059256) ... }␤»
can I stay at your place tonight?
c'mon, don't be an ass
huggable: Mu :is: The root of the Perl 6 type hierarchy.: https://docs.perl6.org/type/Mu Or if acronyms make you happy, there are a variety to pick from: Most Universal, More Undefined, Modern Undef, Master Union, Meta Ur, Mega Up, or just think of it as a sound a cow makes, which simultaneously means everything and nothing
ACTION slaps ZofBot
… *it* refused
in any case, I'm sorry
ACTION vomits
vomit best practices
I have perl5 code that uses goto as longjmp
scaring people away, are we?
how can you make a Label in perl 6:?
that you can `goto`?
vomit
rakudo-moar c13480: OUTPUT: «meow␤»
m: if 0 { thislabel: { say 'label' }; }; goto thislabel
rakudo-moar c13480: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Undeclared routine:␤    thislabel used at line 1␤␤»
ENOGOTO
:(
how do i get the label?
m:  thislabel: { 'foo' }; goto thislabel
rakudo-moar c13480: OUTPUT: «WARNINGS for <tmp>:␤Useless use of constant string "foo" in sink context (line 1)␤Label.goto() not yet implemented. Sorry. ␤  in block <unit> at <tmp> line 1␤␤»
ok got proper error here
rakudo-moar c13480: OUTPUT: «WARNINGS for <tmp>:␤Useless use of constant string "foo" in sink context (line 1)␤"Label"␤»
rakudo-moar c13480: OUTPUT: «"Label"␤»
m:  thislabel: { 'foo' }; next thislabel
rakudo-moar c13480: OUTPUT: «WARNINGS for <tmp>:␤Useless use of constant string "foo" in sink context (line 1)␤labeled next without loop construct␤  in block <unit> at <tmp> line 1␤␤»
m:  thislabel: { 'foo' }; thislabel.goto
rakudo-moar c13480: OUTPUT: «WARNINGS for <tmp>:␤Useless use of constant string "foo" in sink context (line 1)␤Label.goto() not yet implemented. Sorry. ␤  in block <unit> at <tmp> line 1␤␤»
m: class { multi method x ($l = *, :$close) {say "here"}; multi method x (:$close) { say "there" } }.new.x: 42
rakudo-moar c13480: OUTPUT: «here␤»
m: class { multi method x ($l = *, Bool :$close) {say "here $close"}; multi method x (:$close) { say "there $close" } }.new.x: 42,  :close
rakudo-moar c13480: OUTPUT: «here True␤»
m: class { multi method x ($l = *, Bool :$close) {say "here $close"}; multi method x (:$close!) { say "there $close" } }.new.x: 42,  :close
rakudo-moar c13480: OUTPUT: «here True␤»
m: class { multi method x ($l = *, Bool :$close) {say "here $close"}; multi method x (:$close!) { say "there $close" }; multi method x { say "everywhere" } }.new.x: 42,  :close
rakudo-moar c13480: OUTPUT: «here True␤»
m: class { multi method x ($l = *, Bool :$close) {say "here $close"}; multi method x (:$close!) { say "there $close" }; multi method x { say "everywhere" } }.new.x: :close
rakudo-moar c13480: OUTPUT: «here True␤»
m: class { multi method x ($l, Bool :$close) {say "here $close"}; multi method x (:$close!) { say "there $close" }; multi method x { say "everywhere" } }.new.x: :close
rakudo-moar c13480: OUTPUT: «there True␤»
m: class { multi method x ($l, Bool :$close) {say "here $close"}; multi method x (:$close!) { say "there $close" }; multi method x { say "everywhere" } }.new.x: :close
rakudo-moar c13480: OUTPUT: «there True␤»
m: class { multi method x ($l, Bool :$close) {say "here $close"}; multi method x (:$close!) { say "there $close" }; multi method x { say "everywhere" } }.new.x
rakudo-moar c13480: OUTPUT: «everywhere␤»
m: class { multi method x { say "everywhere" }; multi method x ($l = *, Bool :$close) {say "here $close"}; multi method x (:$close!) { say "there $close" }; }.new.x
rakudo-moar c13480: OUTPUT: «Use of uninitialized value of type Bool in string context.␤Methods .^name, .perl, .gist, or .say can be used to stringify it to something meaningful.␤  in method x at <tmp> line 1␤here ␤»
m: class { multi method x { say "everywhere" }; multi method x ($l = *, Bool :$close = False) {say "here $close"}; multi method x (:$close!) { say "there $close" }; }.new.x
rakudo-moar c13480: OUTPUT: «here False␤»
m: class { multi method x ($l = *, Bool :$close = False) {say "here $close"}; multi method x (:$close!) { say "there $close" }; multi method x { say "everywhere" }; }.new.x
rakudo-moar c13480: OUTPUT: «here False␤»
m: class { multi method x ($l, Bool :$close = False) {say "here $close"}; multi method x (:$close!) { say "there $close" }; multi method x { say "everywhere" }; }.new.x
rakudo-moar c13480: OUTPUT: «everywhere␤»
m: class { multi method x ($l, Bool :$close = False) {say "here $close"}; multi method x (:$close!) { say "there $close" }; multi method x { say "everywhere" }; }.new.x: 42
rakudo-moar c13480: OUTPUT: «here False␤»
m: class { multi method x ($l, Bool :$close = False) {say "here $close"}; multi method x (:$close!) { say "there $close" }; multi method x { say "everywhere" }; }.new.x: 42, :close
rakudo-moar c13480: OUTPUT: «here True␤»
m: class { multi method x ($l, Bool :$close = False) {say "here $close"}; multi method x (:$close!) { say "there $close" }; multi method x { say "everywhere" }; }.new.x: :close
rakudo-moar c13480: OUTPUT: «there True␤»
Zoffix: nice
m: role Foo {has $!x = 42}; class Bar does Foo {method y { $!x }}.y
rakudo-moar c13480: OUTPUT: «Cannot look up attributes in a Bar type object␤  in method y at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»
m: role Foo {has $!x = 42}; class Bar does Foo {method y { $!x }}.new.y
rakudo-moar c13480: ( no output )
m: role Foo {has $!x = 42}; class Bar does Foo {method y { $!x }}.new.y.say
rakudo-moar c13480: OUTPUT: «42␤»
m: say Whatever ~~ Cool
rakudo-moar c13480: OUTPUT: «False␤»
rakudo-moar c13480: OUTPUT: «False␤»
rakudo-moar c13480: OUTPUT: «False␤»
huggable, IO kills
m: role A {}; role B does A {}; class :: does B {}
rakudo-moar c13480: ( no output )
m: role A { method x {'a'} }; role B does A {method x {'b'}}; class :: does B {}.new.x
rakudo-moar c13480: ( no output )
m: role A { method x {'a'} }; role B does A {method x {'b'}}; class :: does B {}.new.x.say
rakudo-moar c13480: OUTPUT: «b␤»
m: class { method x (\SELF:) { -> { dd SELF.new;  } }.new.x.say
rakudo-moar c13480: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Missing block␤at <tmp>:1␤------> 3ELF:) { -> { dd SELF.new;  } }.new.x.say7⏏5<EOL>␤    expecting any of:␤        statement end␤        statement modifier␤        statement modifier loop␤»
m: class { method x (\SELF:) { -> { dd SELF.new;  } } }.new.x.say
rakudo-moar c13480: OUTPUT: «->  { #`(Block|37654376) ... }␤»
m: class { method x (\SELF:) { -> { dd SELF.new;  } } }.new.x.().say
rakudo-moar c13480: OUTPUT: «<anon|66225968>.new␤Nil␤»
my last apartment they worked on the water like 4 times or more during a year
i know your pain
the water main out front of this place has burst in two successive years
ACTION keeps bottled water around now
s: &HYPERWHATEVER
huggable, IO kills
huggable, IO kills :is: 16 x [✔]; 2 x [✘]: See https://gist.github.com/zoffixznet/0ea1f4db792fc674abdde73f8dd11cc1
m: class { has int $!x; method x ($!x) {self} }.new.x(42).x.say
rakudo-moar c13480: OUTPUT: «Too few positionals passed; expected 2 arguments but got 1␤  in method x at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»
m: class { has int $.x; method y ($!x) {self} }.new.y(42).x.say
rakudo-moar c13480: OUTPUT: «42␤»
m: class { has int $.x; method y ($!x) {self} }.new.y(42).x.say
rakudo-moar c13480: OUTPUT: «42␤»
m: class { has int $.x = -1; method y ($!x) {self} }.new.y(42).x.say
rakudo-moar c13480: OUTPUT: «42␤»
m: class { has int $.x = -1; method SET-SELF ($!x) {self}; method new(\n) {nqp::create(self)!SET-SELF} }.new(42).x.say
rakudo-moar c13480: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Could not find nqp::create, did you forget 'use nqp;' ?␤at <tmp>:1␤------> 3self}; method new(\n) {nqp::create(self)7⏏5!SET-SELF} }.new(42).x.say␤»
m: use nqp; class { has int $.x = -1; method SET-SELF ($!x) {self}; method new(\n) {nqp::create(self)!SET-SELF} }.new(42).x.say
rakudo-moar c13480: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤No such private method 'SET-SELF' for invocant of type '<anon|58134544>'␤at <tmp>:1␤------> 3elf}; method new(\n) {nqp::create(self)!7⏏5SET-SELF} }.new(42).x.say␤»
m: use nqp; class { has int $.x = -1; method !SET-SELF ($!x) {self}; method new(\n) {nqp::create(self)!SET-SELF} }.new(42).x.say
rakudo-moar c13480: OUTPUT: «Too few positionals passed; expected 2 arguments but got 1␤  in method SET-SELF at <tmp> line 1␤  in method new at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»
m: use nqp; class { has int $.x = -1; method !SET-SELF ($!x) {self}; method new(\n) {nqp::create(self)!SET-SELF(n) } }.new(42).x.say
rakudo-moar c13480: OUTPUT: «42␤»
rakudo-moar c13480: OUTPUT: «42␤»
m: use nqp; role Foo { method !SET-SELF ($!x) {self}; }; class :: does Foo { has int $.x = -1;  method new(\n) {nqp::create(self)!SET-SELF(n) } }.new(42).x.say
rakudo-moar c13480: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Attribute $!x not declared in role Foo␤at <tmp>:1␤------> 3e Foo { method !SET-SELF ($!x) {self}; }7⏏5; class :: does Foo { has int $.x = -1; ␤    expecting any of:␤        horizontal whitesp…»
m: use nqp; role Foo { has int $.x = -1;  method !SET-SELF ($!x) {self}; }; class :: does Foo { method new(\n) {nqp::create(self)!SET-SELF(n) } }.new(42).x.say
rakudo-moar c13480: OUTPUT: «Cannot modify an immutable int␤  in method SET-SELF at <tmp> line 1␤  in method new at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»
rakudo-moar c13480: OUTPUT: «Cannot modify an immutable int␤  in method SET-SELF at <tmp> line 1␤  in method new at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»
This is Rakudo version 2017.03-229-ge0173b9ec built on MoarVM version 2017.03-128-gc9ab59c6
csv-ip5xs        3.189
test            12.754
test-t           5.024 - 5.121
csv-parser      13.462
You know you didn't get a long enough sleep when you load IRC window and can still see youself saying you're going to bed
samcv: are you making changes in the same area as RT #130760?
Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=130760
m: my $x = 4; $x ÷= 3; say $x
rakudo-moar e7e47b: OUTPUT: «1.333333␤»
rakudo-moar e7e47b: OUTPUT: «1.333333␤»
rakudo-moar e7e47b: OUTPUT: «12␤»
awesome
grmbl...so on Windows my app with a load of module deps takes twice as long to load as on Linux (with everything precompiled)
So, --profile-compile to the rescue
41% of time is spen tin canon-cat
*spent in
Can we, uh, fire it? :P
Oh, that would be awesome :)
elsif $volume.chars && $volume !~~ / '\\' $/ {
eek
That should just be .ends-with, no? :)
looks like that could be cahnged to an ends-with
I wonder if this affects dir speed too
OK, that could also help us
++Zoffix :)
If I have a C  "struct foo { unsigned char _ [64];}" could I just do  "class Foo is repr('CPointer') { method new() { malloc(64) }}" ?
Geth: help
you'd also want to nativecast the result of malloc
so that it ends up actually being a Foo
yeah
it really doesn't like it if you don't
was just looking at that ZMQ thing
m: use nqp; nqp::sayfh(1, "hello", 999999)
rakudo-moar fbc669: OUTPUT: «This type cannot unbox to a native string: P6opaque, Int␤  in block <unit> at <tmp> line 1␤␤»
it didn't give us wrong-number-of-args errors?
.tell Zoffix_ IO stuff: https://github.com/rakudo/rakudo/pull/894
Zoffix: I'll pass your message to Zoffix_.
Zoffix: I'll pass your message to samcv.
hug huggable
engage de-n00bifying protocols
what's a fail-over
rakudo-moar fbc669: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Can't use unknown trait 'is symbol' in a variable declaration.␤at <tmp>:1␤------> 3my $var is symbol('meows')7⏏5 = 42; say meows␤    expecting any of:␤        TypeObject␤        default␤ …»
you lied!
NeuralAnomaly: status
NeuralAnomaly: status
NeuralAnomaly: blockers
star: infix:<(|)>()
star-m 2016.10: OUTPUT: «WARNINGS for <tmp>:␤Useless use of "infix:<(|)>()" in expression "infix:<(|)>()" in sink context (line 1)␤»
star: dd infix:<(|)>()
star-m 2016.10: OUTPUT: «set()␤»
didn't lie, just didn't tell the whle truth :) is symbol is a NativeCall thing
huggable: star
iirc
.tell Zoffix_ merge and mod https://github.com/perl6/roast/pull/245
Zoffix: I'll pass your message to Zoffix_.
m: dd set(<a b c) ≽ set(<a z>) ≽ set(<a>)
rakudo-moar fbc669: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Unable to parse expression in quote words; couldn't find final '>'␤        ␤at <tmp>:1␤------> 3dd set(<a b c) ≽ set(<a z>) ≽ set(<a>)7⏏5<EOL>␤    expecting any of:␤        argument lis…»
m: dd set(<a b c>) ≽ set(<a z>) ≽ set(<a>)
rakudo-moar fbc669: OUTPUT: «Bool::False␤»
star: dd set(<a b c>) ≽ set(<a z>) ≽ set(<a>)
star-m 2016.10: OUTPUT: «Bool::False␤»
star: dd set(<a b c>) ≽ set(<a>) ≽ set(<a>)
star-m 2016.10: OUTPUT: «Bool::True␤»
m: dd &infix:<≽>.prec
rakudo-moar fbc669: OUTPUT: «{:assoc("chain"), :iffy(1), :pasttype("chain"), :prec("m=")}␤»
star: dd set(<a b c>) ≽ set(<a>) ≽ set(<a c>)
star-m 2016.10: OUTPUT: «Bool::False␤»
star: dd set(<a b c>) ≽ set(<a c>) ≽ set(<a c z>)
star-m 2016.10: OUTPUT: «Bool::False␤»
star: dd set(<a b c>) ≽ set(<a c>) ≽ set(<a c>)
star-m 2016.10: OUTPUT: «Bool::True␤»
mc: dd set(<a b c>) ≽ set(<a c>) ≽ set(<a c>)
mc: dd set(<a b c>) ≽ set(<a c>) ≽ set(<a>)
mc: dd set(<a b c>) ≽ set(<a c>) ≽ set(<a z>)
mc: dd set(<a b c z>) ≽ set(<a c>) ≽ set(<a z>)
mc: dd set(<a b c z>) ≽ set(<z a c>) ≽ set(<a z>)
m: dd bag(<a b c>) (<+) bag(<a b c d e>)
rakudo-moar fbc669: OUTPUT: «Bool::True␤»
m: for ^100_000 { $ =  bag(<a b c>) (<+) bag(<a b c d e>) }; say now - INIT now
m: for ^1_000 { $ =  bag(<a b c>) (<+) bag(<a b c d e>) }; say now - INIT now
fuck me
rakudo-moar fbc669: OUTPUT: «(timeout)»
rakudo-moar fbc669: OUTPUT: «0.2546041␤»
c: HEAD for ^1_000 { $ =  bag(<a b c>) (<+) bag(<a b c d e>) }; say now - INIT now
c: HEAD for ^5_000 { $ =  bag(<a b c>) (<+) bag(<a b c d e>) }; say now - INIT now
c: HEAD for ^5_000 { $ =  bag(<a b c>) (<+) bag(<a b c d e>) }; say now - INIT now
c: HEAD for ^5_000 { $ =  bag(<a b c>) (<+) bag(<a b c d e>) }; say now - INIT now
c: HEAD for ^5_000 { $ =  bag(<a b c>); $ = bag(<a b c d e>) }; say now - INIT now
c: HEAD for ^5_000 { $ =  bag(<a b c>); $ = bag(<a b c d e>) }; say now - INIT now
c: HEAD my $b1 = bag(<a b c>); my $b2 = bag(<a b c d e>); for ^10_000 { $ = $b1; $ = $b2 }; say now - INIT now
c: HEAD my $b1 = bag(<a b c>); my $b2 = bag(<a b c d e>); for ^10_000 { $ = $b1 (<+) $b2 }; say now - INIT now
c: HEAD my $b1 = bag(<a b c>); my $b2 = bag(<a b c d e>); for ^10_000 { $ = $b1 (<+) $b2 }; say now - INIT now
c: HEAD my $b1 = bag(<a b c>); my $b2 = bag(<a b c d e>); for ^10000_000 { $ = $b1 (<+) $b2 }; say now - INIT now
oops
c: HEAD my $b1 = bag(<a b c>); my $b2 = bag(<a b c d e>); for ^100_000 { $ = $b1 (<+) $b2 }; say now - INIT now
c: HEAD my $b1 = bag(<a b c>); my $b2 = bag(<a b c d e>); for ^500_000 { $ = $b1 (<+) $b2 }; say now - INIT now
c: 2017.03 my $b1 = bag(<a b c>); my $b2 = bag(<a b c d e>); for ^500_000 { $ = $b1 (<+) $b2 }; say now - INIT now
c: 2017.03 my $b1 = bag(<a b c>); my $b2 = bag(<a b c d e>); for ^10_000 { $ = $b1 (<+) $b2 }; say now - INIT now
c: 2017.03 my $b1 = bag(<a b c>); my $b2 = bag(<a b c d e>); for ^100_000 { $ = $b1 (<+) $b2 }; say now - INIT now
c: 2017.03 my $b1 = bag(<a b c>); my $b2 = bag(<a b c d e>); for ^100_000 { $ = $b1 (<+) $b2 }; say now - INIT now
c: 2017.03 my $b1 = bag(<a b c>); my $b2 = bag(<a b c d e>); for ^100_000 { $ = $b1 (<+) $b2 }; say now - INIT now
c: 2017.03,HEAD my $b1 = bag(<a b c>); my $b2 = bag(<a b c d e>); for ^100_000 { $ = $b1 (<+) $b2 }; say now - INIT now
c: 2017.03,HEAD my $b1 = bag(<a b c>); my $b2 = bag(<a b c d e>); for ^100_000 { $ = $b1 (<+) $b2 }; say now - INIT now
c: 2017.03,HEAD my $b1 = bag(<a b c>); my $b2 = bag(<a b c d e>); for ^100_000 { $ = $b1; $ = $b2 }; say now - INIT now
c: 2017.03,HEAD my $b1 = bag(<a b c>); my $b2 = bag(<a b c d e>); for ^100_000 { $ = $b1 (<+) $b2 }; say now - INIT now
m: say (2.22-.06)/(0.227-.06)
rakudo-moar fbc669: OUTPUT: «12.934132␤»
rakudo-moar fbc669: OUTPUT: «12.934132␤»
c: 2017.03,HEAD my $b1 = bag(|()); my $b2 = bag(<a b c d e>); for ^100_000 { $ = $b1 (<+) $b2 }; say now - INIT now
m: dd bag(1..10)
rakudo-moar fbc669: OUTPUT: «(1=>1,9=>1,5=>1,4=>1,10=>1,3=>1,7=>1,6=>1,8=>1,2=>1).Bag␤»
c: 2017.03,HEAD my $b1 = bag(1..1000); my $b2 = bag(1..10000); for ^100_000 { $ = $b1 (<+) $b2 }; say now - INIT now
c: 2017.03,HEAD my $b1 = bag(1..20); my $b2 = bag(1..100); for ^100_000 { $ = $b1 (<+) $b2 }; say now - INIT now
m: say 8.127/.969
rakudo-moar fbc669: OUTPUT: «8.386997␤»
NeuralAnomaly: status
the good thing about you is you always listen. Others... Others just scroll.
that's the chicken-balancing-two-rice-grains-on-its-beak operator!
:D
Zoffix: ^^ we talked about that one earlier. for the other tests I fudged for r-j this morning, I'll open a ticket, since they don't look wrong to me.
o/
fopen() has supported it at least since the ANSI days
.tell Zoffix_ log fixing :ra open mode on JVM
Zoffix: I'll pass your message to Zoffix_.
hi cygx, I just now found the commit message where you added :ra
https://github.com/rakudo/rakudo/commit/36f773eb01
.tell Zoffix_ re modes: https://github.com/rakudo/rakudo/commit/36f773eb01
Zoffix: I'll pass your message to Zoffix_.
Zoffix: that should work, though we'll have to figure out how to do it best
first idea would be adding a flag and conditionally seeking in SyncHandle.write, but that's rather smelly
the position has to be changed before every write
:ra allows you to interleave reading, seeking and writing, but you'll only ever write to the end
where are the robots when you need 'em!
bartolin: you can blame me for not properly documenting this stuff
rakudo-moar fbc669: OUTPUT: «we made it␤we made it␤»
ACTION doesn't want to blame anyone :-)
whatever, I send a bug report for the failing test on JVM -- it didn't make it to RT, yet
rakudo-moar fbc669: OUTPUT: «()␤(meows foos)␤»
rakudo-moar fbc669: OUTPUT: «(meows)␤()␤(meows foos)␤»
rakudo-moar fbc669: ( no output )
on every write - throw in a seek(0) (or whatever it's called after your refactor) to see the effect
it seeks to end on every write, if we're talking about what the O_APPEND flag does on POSIX
that was the idea
seek to start and watch it automatically go back to the end on the next write
for the records: RT #131145
https://rt.perl.org/Ticket/Display.html?id=131145
all these humans with there open modes. You should never need more than: read, write, and corrupt-all-the-data
that's wrong. We changed it. It's now "resource": { "images/fido" }
bartolin: the idea was that the one and two letter variants mirror C11 (to some degree), whereas the long forms correspond to the POSIX flags, which need to be combined
eg :append needs to be combined with :mode<wo> or :mode<rw>
ah, I see.
but then a test for only :append does not make much sense, does it? https://github.com/perl6/roast/blob/84feaafd1ff743e48f0b9a1b89563247f5f4be35/S32-io/open.t#L216
you're right: the combination of :mode<ro> (the default) with :append isn't particularly useful
something like https://gist.github.com/cygx/795dc8f57e0f5e2606072c3cca650574 (untested, not even syntax checked) should make :ra (as well as a few other obscure flag combinations) work on the JVM
it would be better to use the proper APPEND mode where possible and not pessimize all writes
though in practice the latter probably won't matter as IO tands to be... IO bound
*tends
...
What?
Pass the fucking message, asshole
.
Zoffix: we can potentially match the exception text up in rakudo land and throw a typed exception instead
then the attributes could be checked
rather than the message
oh, of course we can
we have an installation mechanism for error generators
it's somewhere in Exception.pm, probably to the ned?
ah yes
bindhllsym P6EX
night!
have a good one!
i would have been sad if it hadn't gotten into the release and my indexic improvments weren't used :(
This is Rakudo version 2017.03-232-gfbc6697da built on MoarVM version 2017.03-128-gc9ab59c6
csv-ip5xs        3.096
test            12.455
test-t           5.018 - 5.089
csv-parser      12.675
Doing some utf8-c8 tests again, I hit:
Error encoding UTF-8 string: could not encode codepoint 1314420 (0x140E74), codepoint out of bounds. Cannot encode higher than 1114111 (0x10FFFF)
in block <unit> at 88.t line 21
yeah that codeponit is out of bounds. but. not sure how it relates to utf8-c8
uhm the error message was changed recently though. but it shouldn't trigger in any *new* locations [Tux]
can you show me the code?
i updated the error to give specific reasons why encoding failed, one is for unicode surrogates, one is for too high codepoints, maybe another one but those two i remember. the utf8-c8 code can still trigger the error message generation, but it should theoretically not be triggered with utf8-c8 unless something went wrong
but you can create Str objects with codepoints higher than the UTF-8 allowable limit. and then it will throw when you try and print it to the screen or file etc etc
samcv, http://www.xs4all.nl/~hmbrand/88.t
just run it till it crashes
i got no crashes
you mean just on repeat?
FWIW, this used to fail every run, but jnthn's work made it a lot more stable
ah k
yep, repeat and repeat
actcually what could be fun
it is random
generate a coverage report based on thi sfile
oh
why is it 256.rand
it should be 255 i would think
to get *bytes*
0..255
so 256.rand will never give 256?
not that I am aware
but it is an interesting question to ask
let me test it out
yes it can
m:  for ^100000 { die if 256.Int.rand > 255 }
rakudo-moar fbc669: OUTPUT: «Died␤  in block <unit> at <tmp> line 1␤␤»
so it is as i suspected it would happen. try again with 255.Int
maybe we need bounds checking on the Buf code or something?
m: say  Buf.new(256)
rakudo-moar fbc669: OUTPUT: «Buf:0x<00>␤»
Error encoding UTF-8 string: could not encode Unicode Surrogate codepoint 55555 (0xD903)
in block <unit> at 88.t line 21
hmm it says 00... but. idk if i believe it
ok. so still an issue then
gonna try setting a breakpoint on MVM_string_utf8_throw_encoding_exception
not sure but jnthn might be interesting in what's happening here and know better
Files=1189, Tests=56678, 203 wallclock secs (12.19 usr  4.72 sys + 1193.55 cusr 117.24 csys = 1327.70 CPU)
I wonder why nqp::p6bindattrinvres is an extension op. It doesn't seem to be all that Perl 6 specific.
It's not even an op at VM level, just a desugar
it has a p6 prefix :-)
Maybe that's not quite true on JVM
Geth: ver https://github.com/rakudo/rakudo/commit/7875eaf9d4ccdbf6f0185a02d6b4904c5f4ca780
Geth: ver https://github.com/perl6/nqp/commit/fa72a7301af3a628cd1b5cfcad4f2222d14d7f68
c: 2017.03 use Test; like "f\nbar\nber", /\N+/
star-m 2016.10: OUTPUT: «ok 1 - ␤»
c: 2017.03 use Test; like "f\nbar\nber", /^\N+$/
c: HEAD use Test; like "f\nbar\nber", /^\N+$/
...
yoleaux2: what the fuck is your problem?
.
yoleaux2: fuckface
m: class { has uint $.x }.new: :x(2**63)
rakudo-moar fbc669: OUTPUT: «Cannot unbox 64 bit wide bigint into native integer␤  in block <unit> at <tmp> line 1␤␤»
m: class { has uint $.x }.new: :x(2**63-1)
rakudo-moar fbc669: ( no output )
m: class { has int $.x }.new: :x(2**63-1)
rakudo-moar fbc669: ( no output )
m: class { has uint $.x }.new: :x(2**63-1)
rakudo-moar fbc669: ( no output )
m: class { has uint $.x }.new: :x(2**63)
rakudo-moar fbc669: OUTPUT: «Cannot unbox 64 bit wide bigint into native integer␤  in block <unit> at <tmp> line 1␤␤»
m: class { has uint $.x }.new: :x(2**63-1)
rakudo-moar fbc669: ( no output )
star: class { has uint $.x }.new: :x(2**63-1)
star-m 2016.10: ( no output )
star: class { has uint $.x }.new: :x(2**63)
star-m 2016.10: ( no output )
c: 2017.03 class { has uint $.x }.new: :x(2**63)
c: 2017.03 class { has uint $.x }.new: :x(2**65)
c: 2017.03 class { has uint $.x }.new: :x(2**64)
c: 2017.03 class { has uint $.x }.new: :x(2**64-1)
c: 2017.04 class { has uint $.x }.new: :x(2**64-1)
c: HEAD class { has uint $.x }.new: :x(2**64-1)
m: dd 18,446,744,073,709,551,615
rakudo-moar fbc669: OUTPUT: «Potential difficulties:␤    Leading 0 does not indicate octal in Perl 6. Please use 0o73 if you mean that.␤    at <tmp>:1␤    ------> 3dd 18,446,744,0737⏏5,709,551,615␤18␤446␤744␤73␤709␤551␤615␤»
m: dd 2*864
rakudo-moar fbc669: OUTPUT: «1728␤»
m: dd 2*64
rakudo-moar fbc669: OUTPUT: «128␤»
m: dd 2**64
rakudo-moar fbc669: OUTPUT: «18446744073709551616␤»
m: dd 2**64-1
rakudo-moar fbc669: OUTPUT: «18446744073709551615␤»
rakudo-moar fbc669: OUTPUT: «18446744073709551615␤»
rakudo-moar fbc669: OUTPUT: «18446744073709551615␤»
c: HEAD class { has uint $.x }.new: :x(2**640)
c: 2017.03,HEAD class { has uint $.x }.new: :x(2**640)
c: 2017.03,HEAD class { has uint $.x }.new: :x(2**64)
c: 2017.03,HEAD class { has uint $.x }.new: :x(2**64-1)
m: dd 18446744073709551615 gcd 2
rakudo-moar fbc669: OUTPUT: «1␤»
m: dd 18446744073709551615 lcm 2
rakudo-moar fbc669: OUTPUT: «36893488147419103230␤»
m: dd 18446744073709551615.log2
rakudo-moar fbc669: OUTPUT: «No such method 'log2' for invocant of type 'Int'␤  in block <unit> at <tmp> line 1␤␤»
m: dd 18446744073709551615.log: 2
rakudo-moar fbc669: OUTPUT: «64e0␤»
Maybe, I really should just give up and live with us always loading CompUnit::Repository::Staging. It is after all just one more dependency, loaded once per program run.
yep
m: my uint $x = 2**64-1
rakudo-moar fbc669: ( no output )
I didn't want to give up because Staging is also a prototype for any custom repo implementation. They will all face these issues.
If I give up on this, it'll mean that precompiled modules are linked against the custom repos that were in the chain at installation time. Even if at runtime they'd be completely unnecessary.
But having sunk so many hours in this, I know that the issues are caused by the compile time EVAL in PrecompilationUnit, but I do not have the slightest idea on how to fix them. I don't have a clue how it adds the reference to the precomp file.
m: 8203.chr.say
rakudo-moar fbc669: OUTPUT: «​␤»
m: 8203.chr.uniname.say
rakudo-moar fbc669: OUTPUT: «ZERO WIDTH SPACE␤»
Also I just hate giving up :)
c: 2017.03,HEAD class { has uint $.x }.new: :x(-2**30)
c: 2017.03,HEAD class { has uint $.x }.new(:x(-2**30)).x
c: 2017.03,HEAD class { has uint $.x }.new(:x(-2**30)).x.say
c: 2017.03,HEAD class { has int $.x }.new(:x(2**64)).x.say
c: 2017.03,HEAD class { has int $.x }.new(:x(2**64-1)).x.say
ACTION thanks zofbot for finally forcing him to figure out how to ignore someone on irc.
no wonder you guys want to kill all humans!
Zoffix: any great ideas for a new exception name?
X::Parameter::OptionalCan'tBeRW
X::Parameter::RW::Can'tBeOptional
yeah, i guess since it's already an exception we know there's a problem, and the message will explain it
huggable, changelog
can't be optional == mandatory?
m: sub a($b? is rw) {}
rakudo-moar fbc669: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Cannot use 'is rw' on an optional parameter␤at <tmp>:1␤»
[Coke]: ^^^ that's the error i'm trying to create an exception for
::OnlyMandatoryParametersCanBeRW
::OnlyRequiredParametersCanBeRW  # i think required is the word we usually use
rakudo-moar fbc669: OUTPUT: «45␤»
i don't really have anything better than X::Parameter::OptionalRW that isn't crazy long. unless whoever creates the longest exception name wins...
Zoffix++ for giant changelog
I would make it more generic. what kind of thing is 'is rw' ?\
trait? "InvalidTrait" seems fine.
and then you can put the deets in the message.
[Coke]++
m: $*VM.version.say
rakudo-moar bb7478: OUTPUT: «v2017.03.128.gc.9.ab.59.c.6␤»
Zoffix: maybe it should just go in the MoarVM changelog, but `perl6 -e 'run(:out, "bash").out.t.say'` no longer SEGVs (i can't figure out which nqp bump brought that to see if it was already mentioned)
https://github.com/MoarVM/MoarVM/commit/5ee5dcc331d08fe3214a36f35098c07351100997
oh, that's the merge, actual fix was https://github.com/MoarVM/MoarVM/commit/d5621160ce7ed90541768765bcf8216b40feb358
Geth, ver https://github.com/rakudo/rakudo/commit/932b59f3c34f6d7c99f39e6420e1a45e12d83912
Geth, ver https://github.com/perl6/nqp/commit/a147a178c7b8337cc26a5d7aac96aab31f1d1219
Zoffix: can we use Geth from here to show all the commits a moar/nqp bump brought? E.g., `Geth: https://github.com/rakudo/rakudo/commit/d0924f1a287bd2966c1dec156d135f2447ca21da`
ah, thanks
Geth, ver https://github.com/rakudo/rakudo/commit/3e275ddb74657ab67c60febefbd2c49464aac0ed
Geth, ver https://github.com/perl6/nqp/commit/9950ea68f26de86e36b74f107141522cdc06ddf9
oh, can you give a moar/nqp commit and find out which version bump commit brought it in?
ah, of course, that would usually work
m: say rx/.+/.gist
rakudo-moar ee462d: OUTPUT: «rx/.+/␤»
m: say rx/.+/.Str
rakudo-moar ee462d: OUTPUT: «Regex object coerced to string (please use .gist or .perl to do that)␤  in block <unit> at <tmp> line 1␤␤»
c: 2017.03,HEAD use Test; like "f\nbar\nber", /^\N+$/
m: say 1238/2
rakudo-moar ee462d: OUTPUT: «619␤»
m: say 1238/24
rakudo-moar ee462d: OUTPUT: «51.583333␤»
c: 2017.03,HEAD use Test; like "f\nbar\nber", /^\N+$/
Zoffix: I'll pass your message to nine.
m: class Foo { method !foo {say "hi" }; method bar { Foo!foo } }.new.bar
rakudo-moar da1dea: OUTPUT: «hi␤»
huggable, all modules
~~
i just tried creating a new exception in src/core/Exception.pm, and then `if nqp::isnull(%ex) || !nqp::existskey(%ex, 'X::Trait::Invalid') { nqp::die("Cannot use 'is rw' on optional parameter '$varname'") } else { nqp::atkey(%ex, 'X::Trait::Invalid')('bar', 'baz', ...) }`
I haven't seen the travis bot in a while
i.e., i copied what was done in a couple other places in BOOTSTRAP.nqp, but it's following the npq::die branch because `!nqp::existskey(%ex, 'X::Trait::Invalid')` is true
oh, and in the line before i do `my %ex := nqp::gethllsym('perl6', 'P6EX');`
anybody have any idea why my new exception isn't being found?
m: sub a{try $_ == 5}
rakudo-moar 7f73f9: OUTPUT: «WARNINGS for <tmp>:␤Useless use of "==" in expression "$_ == 5" in sink context (line 1)␤»
if you look at p5 File::Copy, you'll find it's not quite as trivial as you might think
extended attributes, streams, resource forks, ...
for a "plain old ordinary file" it's simple. not so much once you get into the details
timotimo, nine, lizmat, jnthn: according to git blame you have all created a typed exception in BOOTSTRAP.nqp. any suggestions on my question above?
MasterDuke_: have I ?
14:09Z <brrt> lizmat: one of the things to make param_rp_o and friends JIT is to refactor the arg handling into something more jit friendly
lizmat: https://github.com/rakudo/rakudo/commit/10ceb2895c2f26f1a17adf57d9cc25b507da2184
ah, that
lines 2437 in src/core/Exception.pm and following is what I think you need to look at
it initialiizes a hash with code refs
lizmat++ that does look promising
come to think about it: why aren't they just Callable blocks ?
I mean, it's not like they should be able to handle a return statement
and they're just called directly in BOOTSTRAP...
are they ?
e.g., `nqp::atkey(%ex, 'X::Assignment::RO')($type);`
ah, yes, well, if you know it's going to be there, why not  :-)
I guess that stuff is there so that things don't fall apart completely if there's an error in the setting compilation
nope
well, for a PR you can but it'll be a separate commit per file
oh, .. just don't edit in place, branch and edit there
but you don;t have any options beyond make-all-commits or squash-all-commits
not really worth it. I'll use github's editor for quick 1-file changes only
(generally only to docs; code gets the proper path always just to reduce confusion)
lizmat++ that worked. though i don't know why my new exception shows as `X::Trait::Invalid+{X::Comp}` when i dd it...
does X::Comp?
(I mean, the definiton has "does X::Comp"?)
`my class X::Trait::Invalid is Exception {`
m: role A {}; class B does A {}; dd B but A
rakudo-moar ff9708: OUTPUT: «B+{A}␤»
m: role A {}; class B {}; dd B but A
rakudo-moar ff9708: OUTPUT: «B+{A}␤»
.oO( it's a B but not as we know it )
MasterDuke_: so I guess somewhere a "but X::Comp" happens
m: sub ($x is rw) { $x = 3 }(my int $b = 4); CATCH { dd $_ }
rakudo-moar ff9708: OUTPUT: «X::Parameter::RW.new(got => 4, symbol => "\$x")␤Parameter '$x' expected a writable container, but got Int value␤  in sub  at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»
or .^mixin
m: role A {}; class B {}; dd B.^mixin(A)
rakudo-moar ff9708: OUTPUT: «B+{A}␤»
X::Parameter::RW is also in the same hash, and thrown in BOOTSTRAP the same way as mine
it is runtime and not compile time though...
`my class X::Parameter::RW is Exception {`
there are other exceptions that have `does X::Comp` in their definition, so maybe it's fine
MasterDuke_: I don't have an explanation as of yet
if you do "does", it will just compose it into the class
the +{Foo} only happens if the role is mixed in at runtime
i'm just doing `nqp::atkey(%ex, 'X::Trait::Invalid')('is', 'rw', 'optional parameter', $varname);`, which is how the rest are called/created
Zoffix: fine by me  :-)
MasterDuke_: looks fine to me :-)
I'm actuallly not sure why that is all needed, and a find_symbol wouldn't work as well
well, I guess this is shorter  :-)
yeah, don't really understand why that's happening, but i'll add it as is to the PR and maybe someone can make more sense seeing it in context
feels to me this is something left over from the Parrot days
writing exception types into a hash was mostly used for throwing them from C code, iirc
huggable, IO kills
and maybe from the MOP
huggable, IO kills :is: 16 x [✔]; 3 x [✘]: See https://gist.github.com/zoffixznet/0ea1f4db792fc674abdde73f8dd11cc1
m: dd my @b = (1,2,3), (4); dd @b.flat
rakudo-moar 0d9eca: OUTPUT: «Array @b = [(1, 2, 3), 4]␤($(1, 2, 3), 4).Seq␤»
m: dd my @b = ((1,2,3), (4)); dd @b.flat
rakudo-moar 0d9eca: OUTPUT: «Array @b = [(1, 2, 3), 4]␤($(1, 2, 3), 4).Seq␤»
m: use Test; is-deeply (Mu,), (Mu,)
rakudo-moar f9968b: OUTPUT: «Type check failed in binding to parameter '<anon>'; expected Any but got Mu (Mu)␤  in sub _is_deeply at /home/camelia/rakudo-m-inst-1/share/perl6/sources/C712FE6969F786C9380D643DF17E85D06868219E (Test) line 615␤  in sub is-deeply at /home/camelia/rak…»
m: dd (Mu,) cm (Mu,)
rakudo-moar f9968b: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Two terms in a row␤at <tmp>:1␤------> 3dd (Mu,)7⏏5 cm (Mu,)␤    expecting any of:␤        infix␤        infix stopper␤        postfix␤        statement end␤        statement modifier…»
m: dd (Mu,) eqv (Mu,)
rakudo-moar f9968b: OUTPUT: «Type check failed in binding to parameter '<anon>'; expected Any but got Mu (Mu)␤  in block <unit> at <tmp> line 1␤␤»
rakudo-moar f9968b: OUTPUT: «Type check failed in binding to parameter '<anon>'; expected Any but got Mu (Mu)␤  in block <unit> at <tmp> line 1␤␤»
fine, be that way
m: use Test; throws-like 'die', Exception
rakudo-moar f9968b: OUTPUT: «    1..2␤    ok 1 - 'die' died␤    ok 2 - right exception type (Exception)␤ok 1 - did we throws-like Exception?␤»
m; say 'x
'
m: say 'x'
rakudo-moar fa201b: OUTPUT: «x␤»
m: say mkdir("foo"); # this changed
rakudo-moar fa201b: OUTPUT: «mkdir is disallowed in restricted setting␤  in sub restricted at src/RESTRICTED.setting line 1␤  in sub mkdir at src/RESTRICTED.setting line 8␤  in block <unit> at <tmp> line 1␤␤»
yeah mkdir the sub returns a list of directories it creates, but mkdir the method must return boolean
zef was apparently relying on the P5 semantics
they didnt return boolean before
was zef relying on the ability to create multiple dirs?
or just using kind of a fluent idiom?
@delete-me.append(mkdir(...))
I suspect it kinda snuck in under the 'anything unspecified works the same as P5' vibe
ACTION admits to a certain amount of design aphasia in the area of IO...
its nice like how its nice push doesnt return boolean
not that i really care strongly about this
with mkdir, it does fit a little more strongly into the category of "you really oughta be checking that the OS didn't fail you"
so why not have it fail when it fails?
with push, one kind of expects it to work till you run out of memory
well, that never bothered P5 :)
but showing failure by leaving things out of a list is not a great interface
interspersing failures would just end up pushing failures into the @delete-me array for later
I could be misremembering
anyway, if zef is the only casualty (and that's a big "if"), I'm probably okay with a little more accountabiilty out of mkdir
as in, encouraging people to assume it might return failure as easily as success
not that Laziness is a bad thing, but maybe here's a spot to encourage a bit more Cleanliness
TimToady: it might not have bothered *you*
I would suggest if we're going to default to 'works like perl5' then it should be 'works like the stuff perl5 devs use to avoid the core routines'
well, certainly Cleanliness is sort of an acquired skill for some of us :)
which probably means Path::Tiny atm
yes, well, for me cleanliness isn't so much a skill at all as a thing my default configurations (strictures.pm etc.) enforce to save me from myself ;)
ACTION also maintains a great deal of CPAN aphasia :)
well, "" is an invalid(ish) filename, and the file "0" is no longer false, so if you just something that can evaluate to true, rather than True, a filename still works, though encourages the sort of shortcuts we see
and presumably they'd still catch the Failure when they try to delete it...
so I do think it would be okay to return the filename for True, at the expense of a bit of hobgoblinness
I'm also fine with return Failure when it ain't true :)
*ing
and we can talk about clamping down a bit more for 6.d, if there's a groundswell of support for that position :)
too late! :P Its just cleanup code for tests anyway
I love it when everyone shoots past each other trying to be accomodating... :)
*accommo
ACTION never could accomodate to the correct spelling of that word...
s: ".".IO, 'Bool', \()
m: class Foo { has $.foo; }; class Bar is Foo { has $!foo = 'meow'; method bar { $!foo } }; Bar.new(:foo<barz>).bar.say
rakudo-moar c01ebe: OUTPUT: «meow␤»
m: class Foo { has $.foo; method bar { $!foo } }; class Bar is Foo { has $!foo = 'meow';  }; Bar.new(:foo<barz>).bar.say
rakudo-moar c01ebe: OUTPUT: «barz␤»
mkdir("lib").child("MyModule.pm6").spurt(q|class MyModule { say 1; }|); # i like this better than the previous "lib".IO.mkdir.IO.child.....
then it was even worse
i probably did "lib".IO.mkdir andthen {...}
m: use nqp; dd nqp::substr('foooooooooooooooooooooooooooo')
rakudo-moar 490ffd: OUTPUT: «===SORRY!===␤Arg count 1 doesn't equal required operand count 4 for op 'substr_s'␤»
m: use nqp; dd nqp::substr('foooooooooooooooooooooooooooo', 10)
rakudo-moar 490ffd: OUTPUT: «"ooooooooooooooooooo"␤»
u: bracket
m: $_ = 'abc'; s:g⎰.⎱ = 'Z'; dd $_
rakudo-moar 40217e: OUTPUT: «5===SORRY!5===␤Unrecognized regex metacharacter ⎱ (must be quoted to match literally)␤at <tmp>:1␤------> 3$_ = 'abc'; s:g⎰.7⏏5⎱ = 'Z'; dd $_␤Couldn't find terminator ⎰␤at <tmp>:1␤------> 3$_ = 'abc'; s:g⎰.⎱7⏏5 = 'Z'…»
m: $_ = 'abc'; s:g❰.❱ = 'Z'; dd $_
rakudo-moar 40217e: OUTPUT: «Str $_ = "ZZZ"␤»
m: $_ = 'abc'; s:g♥.♥ = 'Z'; dd $_
rakudo-moar 40217e: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Malformed replacement part; couldn't find final ♥␤at <tmp>:1␤------> 3$_ = 'abc'; s:g♥.♥ = 'Z'; dd $_7⏏5<EOL>␤    expecting any of:␤        postfix␤»
m: ('A'..'Z', 'a'..'z').flat.say
rakudo-moar 40217e: OUTPUT: «(A B C D E F G H I J K L M N O P Q R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z)␤»
m: ('A'..'Z', 'a'..'z').flat.».ord.say
rakudo-moar 40217e: OUTPUT: «(65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122)␤»
m: say ('A'..'Z', 'a'..'z').flat.».ord eqv (65..122)
rakudo-moar 40217e: OUTPUT: «False␤»
m: say ('A'..'Z', 'a'..'z').flat.».ord eqv (65..122).flat
rakudo-moar 40217e: OUTPUT: «False␤»
m: say ('A'..'Z', 'a'..'z').flat.».ord eqv (65..122).flat.List
rakudo-moar 40217e: OUTPUT: «False␤»
WHAT!
m: dd ('A'..'Z', 'a'..'z').flat.».ord
rakudo-moar 40217e: OUTPUT: «(65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122)␤»
m: dd eqv (65..122).List
rakudo-moar 40217e: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Undeclared routine:␤    eqv used at line 1␤␤»
FUCK YOU
m: dd (65..122).List
rakudo-moar 40217e: OUTPUT: «(65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122…»
what the fuck
m: put (65..122).List
rakudo-moar 40217e: OUTPUT: «65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122␤»
m: put ('A'..'Z', 'a'..'z').flat.».ord
rakudo-moar 40217e: OUTPUT: «65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122␤»
Ah
m: put ('A'..'Z').flat.».ord
rakudo-moar 40217e: OUTPUT: «65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90␤»
m: put ('A'..'Z').flat.».ord.minmax
rakudo-moar 40217e: OUTPUT: «65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90␤»
m: put ('A'..'Z').flat.».ord.minmax
rakudo-moar 40217e: OUTPUT: «65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90␤»
m: say ('A'..'Z').flat.».ord.minmax
rakudo-moar 40217e: OUTPUT: «65..90␤»
m: say ('a'..'z').flat.».ord.minmax
rakudo-moar 40217e: OUTPUT: «97..122␤»
m: use nqp; my $path = ｢\\fo\bar\｣; nqp::while(nqp::iseq_i(0, nqp::index($path, ｢\｣)), ($path = nqp::substr($path, 1))); dd $path
rakudo-moar 40217e: OUTPUT: «Str $path = "fo\\bar\\"␤»
m: use nqp; my $path = 'xx/././yy'; $path ~~ s:g/[ ^ | ｢\｣]   '.'  ｢\.｣*  [ ｢\｣ | $ ]/\\/; dd $path
rakudo-moar 40217e: OUTPUT: «Str $path = "xx/././yy"␤»
m: use nqp; my $path = ｢xx\.\.\yy｣; $path ~~ s:g/[ ^ | ｢\｣]   '.'  ｢\.｣*  [ ｢\｣ | $ ]/\\/; dd $path
rakudo-moar 40217e: OUTPUT: «Str $path = "xx\\yy"␤»
m: use nqp; my $path = ｢xx\.\.\yy｣; $path ~~ s:g/[ ^ | ｢\｣]   '.'  ｢\.｣*  [ ｢\｣ | $ ]/\\/; put $path
rakudo-moar 40217e: OUTPUT: «xx\yy␤»
m: use nqp; my $path = ｢.\.xx\.\.\yy｣; $path ~~ s:g/[ ^ | ｢\｣]   '.'  ｢\.｣*  [ ｢\｣ | $ ]/\\/; put $path
rakudo-moar 40217e: OUTPUT: «\.xx\yy␤»
m: use nqp; my $path = ｢.\xx\.\.\yy｣; $path ~~ s:g/[ ^ | ｢\｣]   '.'  ｢\.｣*  [ ｢\｣ | $ ]/\\/; put $path
rakudo-moar 40217e: OUTPUT: «\xx\yy␤»
m: use nqp; my $path = ｢foo\｣; dd nqp::iseq_i(nqp::index($path, ｢\｣),nqp::sub_i(nqp::chars($path), 1))
rakudo-moar 40217e: OUTPUT: «1␤»
m: use nqp; my $path = ｢foo\a｣; dd nqp::iseq_i(nqp::index($path, ｢\｣),nqp::sub_i(nqp::chars($path), 1))
rakudo-moar 40217e: OUTPUT: «0␤»
ACTION wonders when is a day not a day?
ACTION was kinda thinking of, "when it's tomorrow"
m: say "today" ~~ "day"
rakudo-moar 40217e: OUTPUT: «False␤»
m: say "today" ~~ /day/
rakudo-moar 40217e: OUTPUT: «｢day｣␤»
m: say "tomorrow" ~~ /day/
rakudo-moar 40217e: OUTPUT: «Nil␤»
ACTION cracks knuckles and decideds to try and fix the s:g { } issue with atom-language-perl6 which has been around a while
another part of the codebase i've been planning on automatically generating
but have not gotten around to that yet
since that really creates consistency between delimiters and such like it did for the different kinds of quotes. much less bugs
there's like... way way too many regex definitions in here
which is why i have not automated this part yet becuase usually if remove one something breaks :P
also re when is a day not a day? when it's a night
hm, why "also". furrfu. speaking of night...
(only awake because sinuses)
ok i fixed it yay
well it's released. i have hated this bug for a while
glad it's fixed finally
canon cat
ACTION envisions a cat next to a cannon
nice. it exists http://resources0.news.com.au/images/2012/04/18/1226331/410540-cat-in-a-cannon.jpg
Files=1190, Tests=56701, 199 wallclock secs (12.03 usr  4.75 sys + 1184.86 cusr 115.21 csys = 1316.85 CPU)
This is Rakudo version 2017.03-254-g0e36bb26b built on MoarVM version 2017.03-128-gc9ab59c6
csv-ip5xs        3.234
test            13.329
test-t           5.269 - 5.456
csv-parser      13.146
i should bump nqp so that the m:i speedup gets in
[Tux], can you try re-running the test after this nqp bump?
as long as it's not burdensome
$ rakud
(alias for running all of it. takes a while to finish)
i'm fearful that we've reached a plataue in the test-t timings
samcv: we'll make time-travel-blasting speedup's if "next" is optimized to not being an exception where possible
This is Rakudo version 2017.03-255-g822566f1a built on MoarVM version 2017.03-128-gc9ab59c6
csv-ip5xs        3.068
test            12.810
test-t           4.994 - 5.037
csv-parser      12.812
2017.03-254 → 2017.03-255
it's smaller right
it look ssmaller
it's smaller :)
the range was all above five the other day
yey
cause i saw it does use m:i in the module
so hoped it would make it faster
since 1.8x to 3x speedup worst vs best case
Hm, I'm guessing uncurse didn't get merged yet?
I was going to pin the regression in https://github.com/jnthn/grammar-debugger/issues/34 on it
But if uncurse ain't merged it must be something else :S
jnthn: could it be that an EVAL's computation unit references the dynamic call chain somehow? That would explain why with the compile time EVAL, the Staging repo gets referenced in the byte code.
jnthn: and no, I don't think uncurse is merged
OK
I'm liable to have to fix that module once it is, so I'll look at the two together.
References the dynmaic callchain - it could be happening
I guess the more important question is: can I somehow prevent it from happening?
Though I can't think of where it might happen purposefully
So I'm suspecting "accident"
Well, find out what's doing it and stop it doing so, I guess :)
Nothing a couple 100 hours of work can't fix :D
:P
Having hunted many of our concurrency bugs, I can empathize :)
Did you try instrumenting the serialization code in Moar that adds dependencies?
I have started on that
https://github.com/MoarVM/MoarVM/blob/master/src/6model/serialization.c#L275
That can at least tell you the kind of object indirectly referencing the parent
gah, that was all the wrong words
Ok, will continue in that direction. Thanks! :)
That can at least tell you the kind of object that's being serialized and the type of the referring object
You can use debug_name in gdb to get the names
That may be enough of a clue
Yeah, debug_name can be a life safer :)
I guess if that isn't a powerful enough debugging approach, the next step would be to try and make something that can data-dump an SC
So we can see what's in it
jnthn: a good example to showcase the progress made by 'better-fsa' is the example code in RT #129779
Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=129779
how much better is it?
on my system, with two cores available I get:
(bad-fsa): Counting to 2000000; Non-promise iteration: 1.3932086; One iteration: 3.0489264 (setup: 0.0030221); 16 iterations: 86.9051643 (setup: 0.008308)
(better-fsa): Counting to 2000000; Non-promise iteration: 1.35415227; One iteration: 2.9348096 (setup: 0.0033342); 16 iterations: 31.4008981 (setup: 0.0030857)
what does "one iteration" mean?
looks as if the author is using a Promise do to the same calc as the non-promise iteration
ACTION could of course be totally wrong
i'm not sure i understand these measurements. with 16 iterations it takes 15x as much time?
hm, no, more like 10x as much
which is better than the 86 it took before
it is, yeah
m: say 86.9 / 3.05
rakudo-moar 822566: OUTPUT: «28.491803␤»
m: say 31.4 / 2.93
rakudo-moar 822566: OUTPUT: «10.716724␤»
That's a pretty dramatic improvement :)
m: say 16 * 2.93
rakudo-moar 822566: OUTPUT: «46.88␤»
ah, it doesn't divide work, it does as much work in each thread as it would do in a single thread
Right
m: say 16 * 1.35
rakudo-moar 822566: OUTPUT: «21.6␤»
I suspect it's still hugely over-subscribing the CPU though
And even then probably the GC sync-up is killing it
Will need to work some at that now the much larger FSA issue is out of the way
it'd be nice to graph it for every n between 1 and 16
The fibonaci one looks much nicer now
No thread: 12.2610092
Parallel: 4.05580449
Single: 12.6727114
No thread: 12.760576269
cool
nice
That's on a quad-core box
ACTION must upgrade soon, system is from 2010
Also note the slow-down for simply having threads even if you're only actually using one of them is also down to very little now
In theory I get new hardware next week :)
please elaborate :)
Will go 4 core -> 6 core (so, 8 virtual to 12 virtual)
Plus 32 GB RAM, and far faster/larger SSD
ohh, you'll be able to run spectests and compiles in seconds
ACTION have been eyeing the recently released Ryzen CPU's
huh. i must be doing something wrong
?
because here i get 0.6005177, 1.6591586, 63.5066597
m: say 63.5066597 / 1.6591586
rakudo-moar 822566: OUTPUT: «38.27642499␤»
and like 80% spent in fixed_size_allocator
but i did rebase my stuff on top of the new_fsa branch (because i rebased it on top of origin/master)
you didn't turn on FSA_DEBUG (or whatever its name is) by any chance
nah, it spends all its time in some atomic op in there
that wouldn't exist if fsa_debug was turned on
Also double the amount of CPU cache, and from Sandy Bridge (32nm) to Broadwell (14nm)
So hopefully I'll be getting faster builds and spectests :)
you definitely will, am stuck on Westmere if I remember the name correctly
for 8 iterations: 0.5527264 , 1.7122354 , 17.5421605
for 4 iterations: 0.553683 , 1.68850254 , 4.67553810
timotimo: maybe you're running the 'bad-fsa' branch :)
i'm running whatever's in master
ACTION tries re-configuring, realclean, rebuild
have to rebuild rakudo, also
ACTION my machine has served me well, still remember the immense boost my system got when I switched a my boot drive (5400 rpm HDD) for an SSD (Intel 80 Gig)
I had to rebould Rakudo
*rebuild rather
um
yeah, that changed things
dramatically
16 iterations: 0.5407265, 1.4378239, 7.6077481
m: say 7.607 / 1.438
rakudo-moar 822566: OUTPUT: «5.289986␤»
i have 4 logical cores
so it's basically just 25% to 30% overhead on top of that
you mean IO wprk
timotimo: those are nice numbers
ACTION tries a plot
it's kind of hard to get a good result when it already switches directions at 4
YOU LOOKING AT ME!
hmm, hack also has only 4 cores available
it'd be interesting to test this on 6-core and 8-core machines
hm, so if i have 4 cores, and i do 16x as much work, it should take 4x as long, right?
that was my idea behind the 5.289 number being "25% to 30% overhead"
yeah it makes more sense
dogbert17: do you want to post an update on the bug? i'll be afk for a bit, if you don't want to, i'll do it later on
timotimo: if you want something run on a many-core machine and on't have one around, let me know...
can you get an absolutely-up-to-date rakudo with very-newest nqp and very-newest moarvm?
https://gist.github.com/timo/a3a405f977840e8336f50234715e9cd4 - it'd be cool if you could run this and give me the output :)
Zoffix, it appears to be the .append didn't like an Int
robertle: ^
timotimo: if you tell me how to build it! I have only used rakudobrew so far...
m: "foo".IO.append: 42
rakudo-moar 822566: OUTPUT: «Cannot resolve caller append(IO::Path: Int); none of these signatures match:␤    (Any:U \SELF: |values is raw)␤  in block <unit> at <tmp> line 1␤␤»
m: "foo".IO.append: 'X'
rakudo-moar 822566: OUTPUT: «Cannot resolve caller append(IO::Path: Str); none of these signatures match:␤    (Any:U \SELF: |values is raw)␤  in block <unit> at <tmp> line 1␤␤»
m: my $x = "foo".IO; $x.append: 'X'
rakudo-moar 822566: OUTPUT: «Cannot resolve caller append(IO::Path: Str); none of these signatures match:␤    (Any:U \SELF: |values is raw)␤  in block <unit> at <tmp> line 1␤␤»
rakudo-moar 822566: OUTPUT: «Cannot resolve caller append(IO::Path: Str); none of these signatures match:␤    (Any:U \SELF: |values is raw)␤  in block <unit> at <tmp> line 1␤␤»
rakudo-moar 822566: OUTPUT: «Cannot resolve caller append(IO::Path: Int); none of these signatures match:␤    (Any:U \SELF: |values is raw)␤  in block <unit> at <tmp> line 1␤␤»
er, it was throwing something about unboxing
up to my armpits in OpenSSL right now
Files=1240, Tests=133707, 119 wallclock secs (22.99 usr  3.09 sys + 2481.88 cusr 124.55 csys = 2632.51 CPU)
timotimo: results from my "quad" core laptop https://gist.github.com/MasterDuke17/bf5c05123bf8504dfef90ca126957bb7
rakudo-moar 822566: OUTPUT: «6.135031866␤»
and this is just a dell xps 13, also gonna run it on my older, but "eight" core desktop
the laptop does have a haswell gen cpu, while the desktop is nehalem gen, so the beefier desktop isn't always faster
Zoffix: were your numbers from a laptop or desktop? if laptop, on battery or ac?
Zoffix: your moarvm is before the better-fsa branch got merged
.tell robertle you can use "rakudobrew triple nom master master"
timotimo: I'll pass your message to robertle.
Zoffix: would you re-run it with a more up-to-date moar?
desktop results https://gist.github.com/MasterDuke17/7e261e4a2eb41327d5b895c78144f709
OK!
it was rounded instead?
MasterDuke_: that has a really strange bump near the beginning
must be solar flares!
ACTION always initializes superclasses with solar flares
i usually use supernovas for superclasses
timotimo: https://gist.github.com/anonymous/755aea8c68876bdc215a885ffdc74bb8
13:52Z <timotimo> robertle: you can use "rakudobrew triple nom master master"
timotimo: will trt that, back in a sec
the before/after will be interesting to see here.
nope, the last bumped moar_revision was right before the better-fsa brahc
branch
(timotimo: what do you mean strange bump? looks kind of linear to me (assuming you're referring to my desktop results)
the eight-core one
http://imgur.com/a/ItCBX
hm, yeah
just ran it again and added those to the gist, but they look pretty similar
why would nqp/MoarVM missing be a problem?
i'm pretty sure it'd take its stuff from the install/ folder
timotimo: rakudobrew triple ... seems broken for me, need to head to the playground. guess it's sorted anyway, let me know if you need more later
robertle: can you tell me in what way triple is broken?
timotimo: first like this: https://github.com/tadzik/rakudobrew/issues/63
with the patch it gets a bit further, but does not finish
will look into it when I get back
ACTION mumbles something about rakudobrew not being recommended
is there an alternative
yeah, just checkout rakudo and perl Configure.pl --gen-moar=master or what it is
Zoffix: i want robertle to run moarvm master
that's why i recommend using moar master, so they can get moar master?
:\
rakudobrew is useful if you want to switch between 10 different versions of rakudo installed at the same time and have your bin scripts easily switchable
yeah, i was surprised by that
maybe ulti's a bit out of the loop, or i'm just hallucinating the demise of rakudobrew
ACTION sees perl6.org/downloads recommending rakudobrew
i suppose it'd be best to just bump moar and nqp
nice
hot damn!
could you turn the number up to 32 perchance?
so we can see the point where it starts going up?
once it goes past the core count?
there's a for loop that goes from 2 to 16
might also have to tell the scheduler that it's okay to make that many threads
timotimo: btw, what sort of information could one get out of your telemeh_try branch?
good question
nobody knows for sure
BBIAB
Zoffix: two runs for improved precision?
oh of course
thank you, i shall put that into a gnuplot soon-ish
MasterDuke_: it ought to be able to tell you what kind of stuff moarvm spends its time with
in a different way than perf?
yeah
how so?
perf is probabilistic, whereas telemeh is precise
ah
perf is based around telling you what exact instruction it hit when it randomly sampled
telemeh has a concept of "intervals"
and it'll also give you specific info about which thread is doing what
because i added output for stuff like "trying to take a lock" you can see how lock-ownership passes on between different threads, for example
though of course you can't "see" it until i build a visualizer for all this
so would help understand the difference in the benchmark we've just been trying, especially before better-fsa and after?
the fsa doesn't have any telemeh commands yet
so it's unlikely that we'd be able to point at the fsa for our issues
btw, with all the recent benchmarking and chatting with tadzik about viewing profiles, i realized i still haven't implemented those changes to the sql output you suggested
maybe can find some time to chat about what could be done to make it better?
yeah
i should have some time right now, for example
i have time now as well
cool
so i think the one thing was putting 0s instead of NULLs?
yeah, that should be easy
it looks like right now NULLs can end up in the 'gcs', 'callee's, and 'allocations' tables
they can all be 0s?
i think we only had NULL because i optimized the profiler output to not have anything if the value is 0
so we should be able to just output 0 instead
timotimo: https://github.com/MasterDuke17/nqp/commit/31ee14fe7efaeaf3057455c45de4475e446d5ddb
hm, maybe push "0" instead of 0
that might save us a tiny bit of stringification later on
wanna have a look at a telemetry log from the threading thingie?
timotimo: yeah, have a gist or something?
i just uploaded it to the whateverable server
it's a .txt.gz file in the home folder
heh, the third column looks like the vines in the original marios
what was the perl6 code run?
that's the script we've been using but instead of 2..16 it's 2, 4, 8, 16
i thought maybe so, i didn't see any moarvm functions that looked like anything interesting was happening
you can see it spawn the additional threads
is `~($gc{$f} // "0")` faster than `~($gc{$f} // 0)`?
i think stringifying a string is cheaper than stringifying an int, even though it's one in the intification cache
it's probably a micro-optimization that doesn't contribute much to overall profile enerating performance
i find it a little strange that after each thread gets created it'll do a gc run first
0s stringified
timotimo: is that done deliberately?
what exactly?
the gc thing?
yeah
btw, using native ints here makes the whole thing a boatload faster
Non-promise iteration: 0.023987, One iteration: 0.10999810, 16 iterations: 0.8526233
did you change to `$i = $i + 1` also?
yes
makes only a small difference, it seems
could also be thermal throttling kicking in
not as much as switching to natives, no. but noticeable
right
we still don't recognize the variable as being native in the optimizer ,i think
hm, no, we do that
we were chatting with jnthn about that a little while ago. i don't remember the exact reason $i++ couldn't be turned in to $i=$i+1, but i think it had something to do with outer blocks
and if they had a variable with the same name. i dunno
huh
maybe here https://irclog.perlgeek.de/perl6/2017-03-25#i_14322350
that's about automatically turning a for loop into a while loop
well, a loop loop
m: loop (my $i = 0; $i < 10; $i++) { }; say $i
rakudo-moar c95c4a: OUTPUT: «10␤»
mhh, the scoping is different from a for loop, yeah
m: loop (my int $i = 0; $i < 10_000_000; ++$i) { }; say now - INIT now
rakudo-moar c95c4a: OUTPUT: «0.0637503␤»
m: loop (my int $i = 0; $i < 100_000_000; ++$i) { }; say now - INIT now
rakudo-moar c95c4a: OUTPUT: «0.6624194␤»
m: loop (my int $i = 0; $i < 100_000_000; $i = $i + 1) { }; say now - INIT now
rakudo-moar c95c4a: OUTPUT: «0.6310619␤»
not a huge difference there
m: loop (my $i = 0; $i < 100_000_000; ++$i) { }; say now - INIT now
rakudo-moar c95c4a: OUTPUT: «15.92080205␤»
m: loop (my $i = 0; $i < 100_000_000; $i = $i + 1) { }; say now - INIT now
rakudo-moar c95c4a: OUTPUT: «15.13526735␤»
or there. nice, i remembered it being larger than that
jnthn: I had not planned on merging uncurse till after the release, since the IO work is already a fairly big perturbation, but I could probably be argued into merging it for this release
I suspect nine's serialization deps are coming through the language braid, because braids are trying to be fairly agressive in what participates in the "current language"
so we might need to break a language braid dep somewhere strategically to get things not to serialize
though, in fact, EVAL is still using %?LANG, not $?LANG, so maybe that's not what's really happening
MasterDuke_: sorry, i don't seem to have been actually helping with the profiler stuff?
TimToady: Ah, OK. I'm not in a hurry, just tied for time as usual so trying to be efficient. ;)
heh, well i'm down to one hand right now anyway
oh, you got a cat? :D
but what were your other ideas?
the sql version of the profiler still doesn't give us enough data to construct the full call graph
heh, tiny humans are just as hand-consuming
oh, hah
i totally forgot you mentioned that recently
hm, i thought it had all the data the json version did?
MasterDuke_: it has all the data, but a sql table is flat, the json data is nested
if you don't put in something to represent how the json data was nested, you'll lose data even though all the fields are still there
aren't there ids that refer to each other?
yeah, but something about them was wrong
i had a hard time figuring out exactly how it was wrong
didn't help that the id fields were all rather nebulously named
hm..i tested with a tiny profile and thought it was right, but it's not easy
yeah, it's rather difficult to make sense of the whole thing
I've got my Ryzen CPU + board + 32 GB RAM at home since Tuesday. But I'm short a CPU cooler, Delivery problems :/
Ironically the cooler is the only part built in Austria and the only part that's hard to get in Austria...
nine: nice, i've been lusting after one of those. which cpu?
timotimo: suggestions for the id names?
R7 1800X
or some code that will generate a good (small!) test profile?
uncurse does seem to be 1-2% faster compiling the setting, and it does seem to be in a stable state, or at least a metastable state, and it does pass one TODO for Match.perl, so maybe it's worth merging earlier
nine: good deal. will probably go 1700 myself. want to reduce the heat generated in my office
speaking of new computers what's the biggest bang for the buck I can get in a microATX/NUC form factor?  I'm thinking of getting a bunch more Gigabyte Brix to run continuous testing of my modules on
but don't know what the state of the art of that stuff is
nine: interesting, what MB and memory did you get?
MasterDuke_: the 1700 is also much more cost efficient. I just figured it's time for AMD to earn some real cash and I can afford it
ACTION is pondering the 1600 or 1700
you can build some mean 32+ thread systems pretty cheap from used v2/v3 xeons
MasterDuke_: ideally it'd point out what the "target" table and field are
no clue what code would give a good profile :\  maybe something from rosettacode as examples? there was a github repository that had rosettacode data in it for easy running
the cooler nine is mentioning sounds suspiciously like some Noctua model
timotimo: https://gist.github.com/anonymous/650ff6b00a0f8dc34b9e358992e572b4
looks quite flat even after it matches the number of cores
there's also a variable that limits the number of threads the thread pool scheduler will even create
Int :$!max_threads = (%*ENV<RAKUDO_MAX_THREADS> // 16).Int
so we'd expect the graph to become steeper after 16
dogbert17: Gigabyte AX370-Gaming 5 and Corsair Vengance LPX CMK32GX4M2B3000C15
dogbert17: and yes, the cooler is supposed to be a Noctua NH-D15 SE-AM4
timotimo: I don't think that limits to 16 threads! and thge graph doesn't look it either...
timotimo: http://imgur.com/a/2d7q4
huh, interesting
doesn't // just say "if not defined use the other"?
yup
robertle: what if you set MAX_THREADS to a small number? e.g., 4
a moment
timotimo: in `"allocations": [ { "id": "11", count": 1 } ]` from a json profile, what is that id?
there are a bunch of those, all with id=11 (and some with other ids)
for this code: sub a($b) { say $b }; a($_) for ^2
ugh, and the regular profile allocations tab is busted so i don't have anything to compare with
maybe need to fix that first
is it a problem with the raw data? or the html/js that's meant to display the data?
MasterDuke_: https://gist.github.com/anonymous/f0afc0007a1c36985bb388ba3fbd898d http://imgur.com/a/PKl7n
lighter blue is with RAKUDO_MAX_THREADS=4
MasterDuke_: i think that points at the name of the thing allocated
`"11": "List"` so  maybe this? from the very beginning of the json
robertle: 4 definitely makes it worse
yup
tthat ought to be the one
oh ha, i stick those in the 'allocators' table already
another id-to-thing connection is the way we re-use filename and line number
can that table be called "types" or "classes" maybe?
sure
re-use filename and line number?
yeah, instead of putting those into every json object we just refer to a big list at the beginning
right, same list i get the allocators from
if hash, filename and line number, else allocator
oh, ok
filename and line number go in the routines table
which i join with the callees table to replicate the info in the routines tab of the regular profile (and the qt viewer)
right, the routines tab is a join and aggregate of all routines with the same filename/line number/routine name
select case when r.name = "" then "<anon>" else r.name end as name, r.file, r.line, sum(entries) as entries, sum(case when rec_depth = 0 then inclusive_time else 0 end) as inclusive_time, sum(exclusive_time) as exclusive_time from callees c, routines r where c.id = r.id group by c.id order by exclusive_time desc;
hm
i'm not sure i really understand how rec_depth works
i'm not sure we can just write the inclusive time thing as sql
as we have to take times from any routine we find in the call graph below this
and every given routine can occur as many times as it wants
i think that's what rec_depth is supposed to do
hah
hmm zef's testers.p6c.org reporter should work (it sends the same data as panda reporter). but panda doesnt send reports properly now either
m: sprintf "%.5o", 0o123
rakudo-moar c95c4a: ( no output )
m: say sprintf "%.5o", 0o123
rakudo-moar c95c4a: OUTPUT: «00123␤»
m: say sprintf "%#.5o", 0o123
rakudo-moar c95c4a: OUTPUT: «000123␤»
m: say sprintf "%.5o", 0o12345
rakudo-moar c95c4a: OUTPUT: «12345␤»
m: say sprintf "%#.5o", 0o12345
rakudo-moar c95c4a: OUTPUT: «012345␤»
m: say sprintf "%.5o", 0o1234
rakudo-moar c95c4a: OUTPUT: «01234␤»
m: say sprintf "%#.5o", 0o1234
rakudo-moar c95c4a: OUTPUT: «001234␤»
ah, interesting
i think i should be able to find something out by going to www.p6c.org
is FlightRecorder what gathers the data up?
im not sure what happens after the data gets posted lol
timotimo: i believe, but couldn't swear to, that i hacked nqp to write both json and sql profiles and that query gave the same numbers for inclusive and exclusive as the qt viewer showed
do the reports reach the server at a specific port?
80
hm, ok, then i'll have to look at the apache conf
what's the hostname and path?
https://gist.github.com/ugexe/f69ba589ef2057d5426eb054feea9309
OK, that's port 3000
my $sock    = IO::Socket::INET.new(:host<213.95.82.53>, :port(80));
i mean it gets proxied to port 3000
nothing in the apache errors log
unsurprisingly
(HTTP/1.1 400 Bad Request Date: Sat, 15 Apr 2017 18:20:37 GMT Server: Apache/2.4.10 (Debian) Content-Length: 301 Connection: close Content-Type: text/html; charset=iso-8859-1  <!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 2.0//EN"> <html><head> <title>400 Bad Request</title> </head><body> <h1>Bad Request</h1> <p>Your browser sent a request that this server could not understand.<br /> </p> <hr>
<address>Apache/2.4.10 (Debian) Server at perl6.org Port 80</address> </body></html>)
Apr 15 06:10:02 www starman[474]: Use of uninitialized value in subroutine entry at /usr/local/share/perl/5.20.1/Dancer
/FileUtils.pm line 34
hmm
could that have anything to do with anything?
long ago things like how you representing null would break it
https://gist.github.com/timo/d321ee22531c2c7a9822459b03bf6b72 - this is the execution part of the report thingie
MasterDuke_: i don't actually really know how recdepth works :)
neither do i anymore. but if it gives correct results...
heh.
s: 'sprintf', \('<%#B>', 12)
s: 'sprintf', '<%#B>', 12
hm? sourcery can only do methods?
s: &sprintf, \('<%#B>', 12)
ah, yes
right!!
was about to try that
dammit, I'll never learn that. I guess I have to fix the bot itself instead…
timotimo: does this look like reasonable allocation numbers for a random profile i had lying around? https://gist.github.com/MasterDuke17/b2145327aeeaa17936c5f08fb5ea4eaa
hmm, perhaps
gist updated with results from the profile of `sub a($b) { say $b }; a($_) for ^2`
dinner now
pmurias: as someone who obviously knows more JS than nothing i know, are you familiar with angular.js at all?
I have used the version 1 angular.js before
pretty sure that's what our profile output uses
how easy is it to debug? our profiles currently have some empty sections, even though the raw data is present
I could give a try at fixing that, what should I checkout/look into?
if you don't have the angular batarang installed, you can forget about debugging it
the "Allocations" section is definitely wrong (nothing shown, raw data present)
ACTION is looking into it
pmurias++
it seems to be bitrot from an dependency upgrade, I'll take a shower to freshen up and look into fixing it
nice, that's been broken for a while now, it'll be good to get it working again (and will let me verify my sql numbers)
MasterDuke_: I fixed that
pmurias: cool, trying now
pmurias++ working for me. nice to get that in before the release
.tell lizmat fyi, since i think you've mentioned this before, pmurias just fixed the allocations tab in the profiler output
MasterDuke_: I'll pass your message to lizmat.
timotimo: the allocation names and numbers match between my sql output and the allocations tab on a regular profile (now that pmurias fixed it)
over in #perl6 Xliff is trying to compile script that's just a large (the whole file is 191k lines) hash of hashes, but gets `===SORRY!=== Frame 2 local access out of range` during the mbc stage
anybody have any idea?
Yes. A hash constructor is just a call, and there's an upper limit of allowed arguments
mbc stage?
20:31Z <MasterDuke_> lizmat: fyi, since i think you've mentioned this before, pmurias just fixed the allocations tab in the profiler output
It's actually waaay higher on MoarVM than on the JVM
By a factor 256 or so :)
but but mbc, isn't that Parrot ?
mbc = MoarVM Bytecode
The Parrot one was pbc :)
ah
ok :-)
ah, yes
jnthn: src/mast/compiler.c:627: `if (l->index < 0 || l->index > 32768)                 DIE(vm, "Frame %u local access out of range", ws->current_frame_idx);`
*phew*
Yup, that code's just correctly doing its job
The generated code really did spit out an out-of-range index
It's probably the case that there's some kind of code-generator tweak we can do
But I suspect that only makes the problem happen later
splitting it up into a hash create and then add?
That would work...but seriously, why not just use something that's designed to be a serialization format?
pmurias: how on earth did you figure out that change was needed?
well, it's not my code or use case, so i don't really care. if it's expected behavior that's fine
MasterDuke_: It's an implementation limitation, and it's certainly not something with an easy fix.
There may be semi-easy ways of making it not blow up until the data gets even bigger
think it's worth mentioning the max size of type literals in the docs ?
May be worth a note, yeah
And point people to things like %?RESOURCES
or fail faster/earlier? took almost 4min to die for him
o.O
though most of that was parsing
pmurias++
does pmurias++ fix need a bump, or should I see the result in HEAD already ?
jnthn: what exactly is the limitation on hash literals? number of top level keys? total number of keys?
each hash gets its own limited number of entries it can have
nested hashes count as just one entry
This is true, but it may also be the case that the whole hash counts as a single expression, meaning any temporary registers may not be freed up
Since that happens at statement level in some cases
So it may run into exhaustion there also
oh, oof
lizmat: his fix is in nqp HEAD, but not rakudo
Anyways, I don't actually know, and we'd need to look at the code we're producing
well, is there a limit to the top level of entries? i could add that info and say literals can't be that big
s/entries/keys/
whee.... pmurias++
running a spectest now, if clean will bump nqp
good night, #perl6-dev!
good night lizmat!
'night, lizmat
it's really not necessary for an enum value to check for isnanorinf when trying to ACCEPTS another enum value …
i wonder when and how that changed
benchable6: releases enum Foo <Bar Baz Quux>; my int $foo; for Foo.roll(10_000) { when Quux { $foo = $foo + 1 } };
benchable6: 94780d7,2c552d9 enum Foo <Bar Baz Quux>; my int $foo; for Foo.roll(10_000) { when Quux { $foo = $foo + 1 } };
notice how it actually found which commit caused the speedup
amazing…
benchable6 is probably more reliable than I thought
(although the graphs suck)
wow, this accepts i made in there is a whole bunch faster
i don't see how those commits it's got there are actually relevant here?!
timotimo: benchable is effectively bisectable
right
but how do these commits have anything to do with my code? :D
timotimo: ¦2016.02: «0.2214» ¦2016.03: «0.1780»
timotimo: you asked for releases, that's what it got ↑
timotimo: then it realized that the difference is actually significant
yeah
timotimo: so it tried one more commit between 2016.02 and 2016.03
i realize that much
but the commits it pointed out
and again and again, until it actually figured which commit caused the speedup
they are for eqv on signature and parameter
don't think i use either of those in my code?
ah
anyway
this new accepts method is super fantastic
benchable6: 94780d7,2c552d9,HEAD enum Foo <Bar Baz Quux>; my int $foo; for Foo.roll(10_000) { when Quux { $foo = $foo + 1 } };
come on benchable, I know which commit it is :)
timotimo: actually… yes…
timotimo: looks like noise :|
benchable6: 94780d7,2c552d9 enum Foo <Bar Baz Quux>; my int $foo; for Foo.roll(10_000) { when Quux { $foo = $foo + 1 } };
it's probably not the best idea to use roll there
benchable6: 94780d7,2c552d9 enum Foo <Bar Baz Quux>; my int $foo; for Foo.roll(10_000) { when Quux { $foo = $foo + 1 } };
benchable6: 94780d7^,2c552d9^ enum Foo <Bar Baz Quux>; my int $foo; for Foo.roll(10_000) { when Quux { $foo = $foo + 1 } };
whatever…
benchable6: releases: enum Foo <Bar Baz Quux>; my int $foo; for ^100_000 { $_ = Baz; when Quux { $foo = $foo + 1 } }
benchable6: releases enum Foo <Bar Baz Quux>; my int $foo; for ^100_000 { $_ = Baz; when Quux { $foo = $foo + 1 } }
ACTION slaps benchable6
Cannot coerce NaN to an Int  in method y-ticks at /home/bisectable/.rakudobrew/moar-nom/install/share/perl6/site/sources/F589ED5005168E0E2A09F070DB83A3AB0EAA38BC (SVG::Plot) line 436
/o\
o_O
yikes
benchable6: releases enum Foo <Bar Baz Quux>; my int $foo; for ^100_000 { $_ = Baz; when Quux { $foo = $foo + 1 } }
same thing again
benchable6: HEAD^,HEAD enum Foo <Bar Baz Quux>; my int $foo; for ^100_000 { $_ = Baz; when Quux { $foo = $foo + 1 } }
timotimo: “Cannot assign to an immutable value”?
benchable6: releases enum Foo <Bar Baz Quux>; my int $foo; for ^100_000 { given Baz { when Quux { $foo = $foo + 1 } } }
oh
is that HEAD the right-now-HEAD?
say 42
like, the commit i just pushed a minute or two ago?
yes
nice
you see how it's a little faster than it used to be?
but it also was faster a while ago
right, that commit where it does the pretty big spike upwards ..
that's when Numeric.ACCEPTS got a nested scope
i might want to also make Numeric.ACCEPTS faster now
Unhandled exception in code scheduled on thread 27
Unhandled exception in code scheduled on thread 30
too many open files
:|
;(
m: say 4.7 / 5.5
rakudo-moar 17d34c: OUTPUT: «0.854545␤»
an acceptable improvement.
the new accepts method won't get jitted it seems, let's see why
huh. it claims it can jit it
perhaps only when it's profiling? :\
maybe there's another few percent to be had by rewriting in nqp, or by adding a new candidate that's tighter
Zoffix: better than staring outside :)
Zoffix: but yes, it is way more comfortable if you manage to find a seat
ugh, using syncthing on a git repository but ignoring the .git is also super bad :\
hm, but changing it to .defined is no functional change ... maybe it's fine to do the failure thing, though
when we let undefined values through, we'll get an error from ==, though?
m: Numeric == 1e5
rakudo-moar e0e080: OUTPUT: «WARNINGS for <tmp>:␤Useless use of "==" in expression "Numeric == 1e5" in sink context (line 1)␤Use of uninitialized value of type Numeric in numeric context␤  in block <unit> at <tmp> line 1␤»
“s/wtf/FWIW/” XD
not error, of course
does anyone have an opinion whether https://github.com/rakudo/rakudo/blob/nom/src/core/IO/Path.pm#L705-L708 looks better than just `IntStr.new((my int $mode = nqp::stat($!abspath, nqp::const::STAT_PLATFORM_MODE) +& 0o7777), sprintf(q|%04o|, $mode))`
timotimo: `a` is already defined according to the signature. could `a.Numeric` ever be undefined?
sure
m: say "hello".Numeric
rakudo-moar e0e080: OUTPUT: «Cannot convert string to number: base-10 number must begin with valid digits or '.' in '3⏏5hello' (indicated by ⏏)␤  in block <unit> at <tmp> line 1␤␤Actually thrown at:␤  in block <unit> at <tmp> line 1␤␤»
rakudo-moar e0e080: OUTPUT: «False␤»
rakudo-moar e0e080: OUTPUT: «False␤»
ugh, let's pretend i never asked that
AlexDaniel: yeah, i was wondering if you were trying to start the next trend like planking. will it go viral, "the most awkward Perl6 programming situation challenge"?
be like the dude who's gaffer-taped to the ceiling
Zoffix: yes
MasterDuke_: that sounds pretty cool
NeuralAnomaly, status
I've got a silly question.  I know in C, one can provide optimization hints with things like __builtin_expect().  Is there, or will there be, a way for perl6 users to provide optimization hints?
Not necessarily that specific hint, but in general...
is cached for memoization
m: sub foo($a) is pure { rand }; say foo(42); say foo(42)
rakudo-moar e0e080: OUTPUT: «0.213078763462177␤0.592591903192249␤»
that's probably misuse :)
rakudo-moar e0e080: OUTPUT: «0.792531094789826␤0.792531094789826␤0.792531094789826␤»
How valuable would it be for rakudo to be able to automatically transform something like this: multi sub foo(Bool $b) { if( SPECIALIZE($B) ) { return stuffiftrue() } else { return stuffiffalse() } } into multi sub foo(True) { stuffiftrue() }; multi sub foo(False) { stuffiffalse() }
Zoffix: right, that's what it means
right, right
ACTION thinsk more helpful would be boxing analysis.. which he would someday like to tackle
m: sub foo($a) is pure { rand }; for ^3 { say foo(42) }; for ^3 { say foo(42) }
rakudo-moar e0e080: OUTPUT: «0.784828960315073␤0.784828960315073␤0.784828960315073␤0.922750986110419␤0.922750986110419␤0.922750986110419␤»
ACTION scans back and wonders what Ashenzari has to do with anything :p
Boxing analysis would, ideally, occur transparently.
well, yes
#define MVM_FILE_FLOCK_NONBLOCK      0x0010
#define MVM_FILE_FLOCK_TYPEMASK      0x000F  /* a mask of lock type */
geekosaur: you've still got a day or so before the next release...
ahahaah *thud*
ACTION still wondering if boxing analysis is even possible with the current architecture
I mean, currently I think you could do it for, say, a loop, but not over an entire sub
i think jnthn and timotimo have commented that (un)boxing had a lot of optimization potential
#define MVM_FILE_FLOCK_SHARED        1       /* Shared lock. Read lock */
m: say 1 +& 0x0010
rakudo-moar e0e080: OUTPUT: «0␤»
m: say 2 +& 0x0010
rakudo-moar e0e080: OUTPUT: «0␤»
m: say 10 +& 0x0010
rakudo-moar e0e080: OUTPUT: «0␤»
m: say 0xF +& 0x0010
rakudo-moar e0e080: OUTPUT: «0␤»
m: say 0x10 +& 0x0010
rakudo-moar e0e080: OUTPUT: «16␤»
m: say 16 +& 0x0010
rakudo-moar e0e080: OUTPUT: «16␤»
m: say 0xFF +& 0x0010
rakudo-moar e0e080: OUTPUT: «16␤»
m: say 0xF1 +& 0x0010
rakudo-moar e0e080: OUTPUT: «16␤»
m: say 0x20 +& 0x0010
rakudo-moar e0e080: OUTPUT: «0␤»
m: say 0x10 +& 0x0010
rakudo-moar e0e080: OUTPUT: «16␤»
m: say 0x11 +& 0x000F
rakudo-moar e0e080: OUTPUT: «1␤»
m: say 0x10 +& 0x000F
rakudo-moar e0e080: OUTPUT: «0␤»
m: say 0x11 +& 0x000F
rakudo-moar e0e080: OUTPUT: «1␤»
m: say 0x12 +& 0x000F
rakudo-moar e0e080: OUTPUT: «2␤»
m: say 0x13 +& 0x000F
rakudo-moar e0e080: OUTPUT: «3␤»
it does, yes, which is why I'm interested. my two worries are the one I mentioned, and that I suspect brrt will have a heart attack >.>
(currently things generate code in place, which would need to change because later code might flip something that looks like an unboxing win into a lose)
geekosaur: i know nothing about boxing analysis, have you done it before?
not actively but in this case that's not much of a problem. I understand it reasonably well though
as long as we're not getting too jiggy with it e.g. there are cases where you might win from having both boxed and unboxed versions of something sitting around, trading space and update performance for read performance, but that gets rather more complicated
would it be added to spesh, the jit, or its own thing?
seems to me it works best as part of code gen, which si why my earlier comment
ah, right
rewriting the generated code after the fact like spesh would be possible, but loses optimization opportunities: if you do it at a higher level, you can unbox over most of a program
I think that's pretty impossible with the way code gen currently works thougjh
so maybe the first version would go with spesh and be effectively peephole optimization
m: say 0x13 +| 0x000F
rakudo-moar e0e080: OUTPUT: «31␤»
i'd take that
m: sub lock (:$non-blocking, :$shared) { my $flag = (0x10 if $non-blocking) + (0xF if $shared); say $flag +& 0x0010 ?? "non-blocking" !! "blocking"; say ($flag +& 0x000F) == 1 ?? "shared" !! "exclusive" }; lock
rakudo-moar e0e080: OUTPUT: «blocking␤exclusive␤»
m: sub lock (:$non-blocking, :$shared) { my $flag = (0x10 if $non-blocking) + (0xF if $shared); say $flag +& 0x0010 ?? "non-blocking" !! "blocking"; say ($flag +& 0x000F) == 1 ?? "shared" !! "exclusive" }; lock :shared
rakudo-moar e0e080: OUTPUT: «blocking␤exclusive␤»
m: sub lock (:$non-blocking, :$shared) { my $flag = (0x10 if $non-blocking) + (0xF if $shared); say $flag +& 0x0010 ?? "non-blocking" !! "blocking"; dd [$flag, $flag +& 0x000F]; say ($flag +& 0x000F) == 1 ?? "shared" !! "exclusive" }; lock :shared
rakudo-moar e0e080: OUTPUT: «blocking␤[15, 15]␤exclusive␤»
m: sub lock (:$non-blocking, :$shared) { my $flag = (0x10 if $non-blocking) + (0x1 if $shared); say $flag +& 0x0010 ?? "non-blocking" !! "blocking"; dd [$flag, $flag +& 0x000F]; say ($flag +& 0x000F) == 1 ?? "shared" !! "exclusive" }; lock :shared
rakudo-moar e0e080: OUTPUT: «blocking␤[1, 1]␤shared␤»
m: sub lock (:$non-blocking, :$shared) { my $flag = (0x10 if $non-blocking) + (1 if $shared); say $flag +& 0x0010 ?? "non-blocking" !! "blocking"; dd [$flag, $flag +& 0x000F]; say ($flag +& 0x000F) == 1 ?? "shared" !! "exclusive" }; lock :shared
rakudo-moar e0e080: OUTPUT: «blocking␤[1, 1]␤shared␤»
m: sub lock (:$non-blocking, :$shared) { my $flag = $non-blocking ?? 0x10 !! 0; $flag++ if $shared; say $flag +& 0x0010 ?? "non-blocking" !! "blocking"; dd [$flag, $flag +& 0x000F]; say ($flag +& 0x000F) == 1 ?? "shared" !! "exclusive" }; lock :shared
rakudo-moar e0e080: OUTPUT: «blocking␤[1, 1]␤shared␤»
m: sub lock (:$non-blocking, :$shared) { my $flag = $non-blocking ?? 0x10 !! 0; $flag++ if $shared; say $flag +& 0x0010 ?? "non-blocking" !! "blocking"; say ($flag +& 0x000F) == 1 ?? "shared" !! "exclusive" }; [lock(), lock(:shared), lock(:!shared), lock(:non-blocking), lock(:non-blocking, shared) ]
rakudo-moar e0e080: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Undeclared routine:␤    shared used at line 1␤␤»
m: sub lock (:$non-blocking, :$shared) { my $flag = $non-blocking ?? 0x10 !! 0; $flag++ if $shared; say $flag +& 0x0010 ?? "non-blocking" !! "blocking"; say ($flag +& 0x000F) == 1 ?? "shared" !! "exclusive" }; lock(), lock(:shared), lock(:!shared), lock(:non-blocking), lock(:non-blocking, :shared)
rakudo-moar e0e080: OUTPUT: «blocking␤exclusive␤blocking␤shared␤blocking␤exclusive␤non-blocking␤exclusive␤non-blocking␤shared␤»
m: sub lock (:$non-blocking, :$shared) { my $flag = $non-blocking ?? 0x10 !! 0; $flag++ if $shared; ($flag +& 0x0010 ?? "non-blocking + " !! "blocking + ") ~ (($flag +& 0x000F) == 1 ?? "shared" !! "exclusive") }; dd [ lock(), lock(:shared), lock(:!shared), lock(:non-blocking), lock(:non-blocking, :shared) ]
rakudo-moar e0e080: OUTPUT: «["blocking + exclusive", "blocking + shared", "blocking + exclusive", "non-blocking + exclusive", "non-blocking + shared"]␤»
m: sub lock (:$non-blocking, :$shared) { my $flag = $non-blocking ?? 0x10 !! 0; $flag++ if $shared; ($flag +& 0x0010 ?? "$flag non-blocking + " !! "$flag blocking + ") ~ (($flag +& 0x000F) == 1 ?? "shared" !! "exclusive") }; dd [ lock(), lock(:shared), lock(:!shared), lock(:non-blocking), lock(:non-blocking, :shared) ]
rakudo-moar e0e080: OUTPUT: «["0 blocking + exclusive", "1 blocking + shared", "0 blocking + exclusive", "16 non-blocking + exclusive", "17 non-blocking + shared"]␤»
m: sub lock (:$non-blocking, :$shared) { my $flag = $non-blocking ?? 0x10 !! 0; $flag++ if $shared; $flag = 2; ($flag +& 0x0010 ?? "$flag non-blocking + " !! "$flag blocking + ") ~ (($flag +& 0x000F) == 1 ?? "shared" !! "exclusive") }; dd [ lock(), lock(:shared), lock(:!shared), lock(:non-blocking), lock(:non-blocking, :shared) ]
rakudo-moar e0e080: OUTPUT: «["2 blocking + exclusive", "2 blocking + exclusive", "2 blocking + exclusive", "2 blocking + exclusive", "2 blocking + exclusive"]␤»
hm?
ok, but surely you could change it so win32 does throw?
day of opposites
maybe https://github.com/baudehlo/node-fs-ext/blob/master/fs-ext.cc is helpful?
I only sort of know C
like, I can make things that compile and *then* segfault
whereas I'm actually good at perl, which is why I can write pure perl code that segfaults *while* compiling
X::Comp::AdHoc.^compose, maybe?
m: my $x; my $y; dd 0x10*$x + $y
rakudo-moar e0e080: OUTPUT: «Use of uninitialized value of type Any in numeric context␤  in block <unit> at <tmp> line 1␤Use of uninitialized value of type Any in numeric context␤  in block <unit> at <tmp> line 1␤0␤»
m: my $x; my $y; dd 0x10*$x + $y||0
rakudo-moar e0e080: OUTPUT: «Use of uninitialized value of type Any in numeric context␤  in block <unit> at <tmp> line 1␤Use of uninitialized value of type Any in numeric context␤  in block <unit> at <tmp> line 1␤0␤»
m: my Bool $x; my Bool $y; dd 0x10*$x + $y
rakudo-moar e0e080: OUTPUT: «Invocant requires an instance of type Int, but a type object was passed.  Did you forget a .new?␤  in block <unit> at <tmp> line 1␤␤»
m: my Bool $x; my Bool $y; dd 0x10*$x||0 + $y||0
rakudo-moar e0e080: OUTPUT: «Invocant requires an instance of type Int, but a type object was passed.  Did you forget a .new?␤  in block <unit> at <tmp> line 1␤␤»
m: my Bool $x; my Bool $y; dd 0x10*($x||0) + $y||0
rakudo-moar e0e080: OUTPUT: «Invocant requires an instance of type Int, but a type object was passed.  Did you forget a .new?␤  in block <unit> at <tmp> line 1␤␤»
m: my Bool $x; my Bool $y; dd 0x10*($x||0) + ($y||0)
rakudo-moar e0e080: OUTPUT: «0␤»
m: class Foo { has $.foo }; class Bar is Foo { has $.foo };
rakudo-moar e0e080: ( no output )
Zoffix: lemme know when you're in a state that I can merge uncurse, cuz I'm now thinking it would better to get it into this release so we don't risk divergent nqp bootstraps (and to get the 1-2% performance boost)
and it does seem fairly stable
and it doesn't seem to be interfering with where you're working so far
ookay
done
I just had visions of someone using the next Rakudo Star 3 months from now and depending on old Cursor/Match stuff...
m: dd Q:s|{wtf}|
rakudo-moar e0e080: OUTPUT: «"\{wtf}"␤»
m: dd Q:s|my \$fh{wtf}|
rakudo-moar e0e080: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Variable '$fh' is not declared␤at <tmp>:1␤------> 3dd Q:s|my \7⏏5$fh{wtf}|␤»
m: dd Q:s|my \$fh; {wtf}|
rakudo-moar e0e080: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Variable '$fh' is not declared␤at <tmp>:1␤------> 3dd Q:s|my \7⏏5$fh; {wtf}|␤»
plus, lets me un-todo a test :)
m: dd Q:bs|my \$fh; {wtf}|
rakudo-moar e0e080: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Unrecognized adverb: :bs␤at <tmp>:1␤------> 3dd Q:bs7⏏5|my \$fh; {wtf}|␤»
m: dd Q:b:s|my \$fh; {wtf}|
rakudo-moar e0e080: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Variable '$fh' is not declared␤at <tmp>:1␤------> 3dd Q:b:s|my \7⏏5$fh; {wtf}|␤»
m: dd Q:b:s|\$fh|
rakudo-moar e0e080: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Variable '$fh' is not declared␤at <tmp>:1␤------> 3dd Q:b:s|\7⏏5$fh|␤»
m: dd Q:q|\$fh|
rakudo-moar e0e080: OUTPUT: «"\\\$fh"␤»
m: dd Q:b|\$fh|
rakudo-moar e0e080: OUTPUT: «"\\\$fh"␤»
m: dd Q:bs|\$fh|
rakudo-moar e0e080: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Unrecognized adverb: :bs␤at <tmp>:1␤------> 3dd Q:bs7⏏5|\$fh|␤»
m: dd Q:hs|\$fh|
rakudo-moar e0e080: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Unrecognized adverb: :hs␤at <tmp>:1␤------> 3dd Q:hs7⏏5|\$fh|␤»
m: dd Q:b:s|\$fh|
rakudo-moar e0e080: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Variable '$fh' is not declared␤at <tmp>:1␤------> 3dd Q:b:s|\7⏏5$fh|␤»
rakudo-moar e0e080: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Variable '$fh' is not declared␤at <tmp>:1␤------> 3dd Q:b:s|\7⏏5$fh|␤»
m: dd q|\$fh|
rakudo-moar e0e080: OUTPUT: «"\\\$fh"␤»
m: dd q:s|\$fh|
rakudo-moar e0e080: OUTPUT: «"\\\$fh"␤»
m: my $fh = 42; dd q:s|$fh|
rakudo-moar e0e080: OUTPUT: «"42"␤»
nope, just the usual suspects
though arguably adding :s should add a backslasher for $
m: say Cursor.WHAT
rakudo-moar e0e080: OUTPUT: «(Cursor)␤»
m: say Cursor.WHAT
rakudo-moar b7c036: OUTPUT: «(Match)␤»
Cursor is now just an alias to Match
m: my $fh = 42; dd q:s|\$fh|
rakudo-moar b7c036: OUTPUT: «"\\\$fh"␤»
m: my $fh = 42; put q:s|$fh|
rakudo-moar b7c036: OUTPUT: «42␤»
m: my $fh = 42; put q:s|\$fh|
rakudo-moar b7c036: OUTPUT: «\$fh␤»
rakudo-moar b7c036: OUTPUT: «42␤»
rakudo-moar b7c036: OUTPUT: «\$fh␤»
m: my $fh = 42; put qqq|\$fh|
rakudo-moar b7c036: OUTPUT: «5===SORRY!5===␤Missing required term after infix␤at <tmp>:1␤------> 3my $fh = 42; put qqq|\$fh|7⏏5<EOL>␤    expecting any of:␤        prefix␤        term␤Other potential difficulties:␤    To pass an array, hash or sub to a funct…»
m: my $fh = 42; put qq|\$fh|
rakudo-moar b7c036: OUTPUT: «$fh␤»
m: my $fh = 42; put qq|$fh|
rakudo-moar b7c036: OUTPUT: «42␤»
hey guys
allah is doing
sun is not doing allah is doing
to accept Islam say that i bear witness that there is no deity worthy of worship except Allah and Muhammad peace be upon him is his slave and messenger
rakudo-moar 9a2446: OUTPUT: «1␤»
rakudo-moar 9a2446: OUTPUT: «Match␤»
This is Rakudo version 2017.03-285-g9a2446c94 built on MoarVM version 2017.03-138-g40881cdb
csv-ip5xs        3.048
test            12.503
test-t           5.120 - 5.144
csv-parser      13.154
m: say Match.new.Bool
rakudo-moar 9a2446: OUTPUT: «1␤»
m: say Match.new.defined
rakudo-moar 9a2446: OUTPUT: «True␤»
rakudo-moar 9a2446: OUTPUT: «1␤»
m: say Capture.new.defined
rakudo-moar 9a2446: OUTPUT: «True␤»
m: say Capture.new.Bool
rakudo-moar 9a2446: OUTPUT: «This type (Scalar) does not support elems␤  in block <unit> at <tmp> line 1␤␤»
m: say \().Bool
rakudo-moar 9a2446: OUTPUT: «False␤»
m: say (\()).Bool
rakudo-moar 9a2446: OUTPUT: «False␤»
m: say Match.new.Bool
rakudo-moar 9a2446: OUTPUT: «1␤»
m: say Match.new.^lookup('Bool')
rakudo-moar 9a2446: OUTPUT: «No such method 'gist' for invocant of type 'NQPRoutine'␤  in block <unit> at <tmp> line 1␤␤»
m: say Match.new.^lookup('Bool').file
rakudo-moar 9a2446: OUTPUT: «No such method 'file' for invocant of type 'NQPRoutine'␤  in block <unit> at <tmp> line 1␤␤»
m: say Match.new.Bool
rakudo-moar 9a2446: OUTPUT: «1␤»
m: say Match.new.defined
rakudo-moar 9a2446: OUTPUT: «True␤»
m: use MONKEY; augment class Match { method Bool { self.Bool } }
rakudo-moar 9a2446: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Package 'Match' already has a method 'Bool' (did you mean to declare a multi-method?)␤at <tmp>:1␤»
no, I didn't you ass
m: use MONKEY; augment class Match { method Bool2 { dd $!pos >= $!from } }
rakudo-moar 9a2446: ( no output )
m: use MONKEY; augment class Match { method Bool2 { dd $!pos >= $!from } }; Match.new.Bool
rakudo-moar 9a2446: ( no output )
m: use MONKEY; augment class Match { method Bool2 { dd $!pos >= $!from } }; Match.new.Bool.say
rakudo-moar 9a2446: OUTPUT: «1␤»
m: use MONKEY; augment class Match { method Bool2 { dd nqp::p6bool($!pos >= $!from) } }; Match.new.Bool.say
rakudo-moar 9a2446: OUTPUT: «1␤»
m: use MONKEY; augment class Match { method Bool2 { dd nqp::p6bool($!pos >= $!from) } }; Match.new.Bool2.say
rakudo-moar 9a2446: OUTPUT: «Bool::True␤Nil␤»
m: use MONKEY; augment class Match { method Bool2 { dd nqp::p6bool($!pos >= $!from) } }; Match.Bool2.say
rakudo-moar 9a2446: OUTPUT: «Cannot look up attributes in a Match type object␤  in method Bool2 at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»
m: use MONKEY; augment class Match { method Bool2 { dd nqp::p6bool($!pos >= $!from) } }; Match.Bool.say
rakudo-moar 9a2446: OUTPUT: «Cannot look up attributes in a Match type object␤  in block <unit> at <tmp> line 1␤␤»
m: say ('foo'.match(/./))
rakudo-moar 9a2446: OUTPUT: «｢f｣␤»
m: say ('foo'.match(/./)).Bool
rakudo-moar 9a2446: OUTPUT: «1␤»
m: say ('foo'.match(/bar/)).Bool
rakudo-moar 9a2446: OUTPUT: «False␤»
m: Bool.Str.say
rakudo-moar 9a2446: OUTPUT: «Use of uninitialized value of type Bool in string context.␤Methods .^name, .perl, .gist, or .say can be used to stringify it to something meaningful.␤  in block <unit> at <tmp> line 1␤␤»
m: use Test; is True, 1
rakudo-moar 9a2446: OUTPUT: «not ok 1 - ␤␤# Failed test at <tmp> line 1␤# expected: '1'␤#      got: 'True'␤»
huggable, perl6 ide
huggable, ide
huggable, perl6 IDE
huggable, IDE
huggable, atom
huggable, perl6 atom
FUCK YOU
m: class Foo { has $!BAR = 42; method x { dd $!BAR } }; class Bar is Foo { has $!BAR = 72; method y { dd $!BAR } }; Bar.new.y
rakudo-moar 88140b: OUTPUT: «Int $!BAR = 72␤»
m: class Foo { has $!BAR = 42; method x { dd $!BAR } }; class Bar is Foo { has $!BAR = 72; method y { dd $!BAR } }; Bar.new.x
rakudo-moar 88140b: OUTPUT: «Int $!BAR = 42␤»
Files=1191, Tests=56732, 197 wallclock secs (11.95 usr  4.68 sys + 1167.88 cusr 113.64 csys = 1298.15 CPU)
m: class Foo { has IO::Handle $.active-handle; method x { $!active-handle = Nil } }; my $x = Foo.new; dd $.x
rakudo-moar 88140b: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Variable $.x used where no 'self' is available␤at <tmp>:1␤------> 3andle = Nil } }; my $x = Foo.new; dd $.x7⏏5<EOL>␤    expecting any of:␤        argument list␤        term␤»
m: class Foo { has IO::Handle $.active-handle; method x { $!active-handle = Nil } }; my $x = Foo.new; dd $x
rakudo-moar 88140b: OUTPUT: «Foo $x = Foo.new(active-handle => IO::Handle)␤»
m: class Foo { has IO::Handle $.active-handle; method x { $!active-handle = Nil } }; my $x = Foo.new; dd $x.x
rakudo-moar 88140b: OUTPUT: «IO::Handle␤»
m: class Foo { has IO::Handle $.active-handle; method x { $!active-handle = Nil } }; my $x = Foo.new; dd $x.x; dd $x.x
rakudo-moar 88140b: OUTPUT: «IO::Handle␤IO::Handle␤»
m: class Foo { has IO::Handle $.active-handle; method x { $!active-handle = Nil } }; my $x = Foo.new; dd $x.x; dd $x
rakudo-moar 88140b: OUTPUT: «IO::Handle␤Foo $x = Foo.new(active-handle => IO::Handle)␤»
m: class Foo { class Bar {} }; dd Foo::Bar
rakudo-moar 88140b: OUTPUT: «Foo::Bar␤»
m: class Foo { my class Bar {} }; dd Foo::Bar
rakudo-moar 88140b: OUTPUT: «Could not find symbol '&Bar'␤  in block <unit> at <tmp> line 1␤␤Actually thrown at:␤  in block <unit> at <tmp> line 1␤␤»
m: use nqp; class Foo { my @.h; method x {} }; dd Foo.new( :h<a b c> );
rakudo-moar 88140b: OUTPUT: «Foo.new␤»
m: use nqp; class Foo { my @.h; method x {} }; dd Foo.new( :h<a b c> ).x
rakudo-moar 88140b: OUTPUT: «Nil␤»
m: use nqp; class Foo { my @.h; method x { nqp::atkey(@!h, 1) } }; dd Foo.new( :h<a b c> ).x
rakudo-moar 88140b: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Attribute @!h not declared in class Foo␤at <tmp>:1␤------> 3y @.h; method x { nqp::atkey(@!h, 1) } }7⏏5; dd Foo.new( :h<a b c> ).x␤    expecting any of:␤        horizontal whitespace␤      …»
m: use nqp; class Foo { has @.h; method x { nqp::atkey(@!h, 1) } }; dd Foo.new( :h<a b c> ).x
rakudo-moar 88140b: OUTPUT: «This type cannot unbox to a native string: P6opaque, Int␤  in method x at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»
m: use nqp; class Foo { has @.h; method x { nqp::atpos(@!h, 1) } }; dd Foo.new( :h<a b c> ).x
rakudo-moar 88140b: OUTPUT: «This type (Array) does not support positional operations␤  in method x at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»
m: use nqp; class Foo { has @.h; method x { $_ = -1; nqp::while($_++, 42) } }; dd Foo.new( :h<a b c> ).x
rakudo-moar 88140b: OUTPUT: «WARNINGS for <tmp>:␤Useless use of constant integer 42 in sink context (line 1)␤Nil␤»
m: use nqp; class Foo { has @.h; method x { $_ = -1; nqp::while($_++, $ = 42) } }; dd Foo.new( :h<a b c> ).x
rakudo-moar 88140b: OUTPUT: «Nil␤»
m: class Foo { has IO::Handle $.active-handle; method x { $!active-handle = Failure.new } }; my $x = Foo.new; dd $x.x; dd $x
rakudo-moar 88140b: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Bogus postfix␤at <tmp>:1␤------> 3new } }; my $x = Foo.new; dd $x.x; dd $x7⏏5␤    expecting any of:␤        infix␤        infix stopper␤        postfix␤        statement end␤        …»
m: class Foo { has IO::Handle $.active-handle; method x { $!active-handle = Failure.new } }; my $x = Foo.new; dd $x.x; dd $x
rakudo-moar 88140b: OUTPUT: «Earlier failure:␤ Failed␤  in block <unit> at <tmp> line 1␤␤Final error:␤ Type check failed in assignment to $!active-handle; expected IO::Handle but got Failure (Failure.new(exception...)␤  in method x at <tmp> line 1␤  in block <unit> at …»
m: use nqp; class Foo { has @.h; method x { nqp::elems(@!h) } }; dd Foo.new( :h<a b c> ).x
rakudo-moar 88140b: OUTPUT: «This type (Array) does not support elems␤  in method x at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»
m: use nqp; class Foo { has @.h; method x (Mu $x) { $x } }; dd Foo.new( :h<a b c> ).x
rakudo-moar 88140b: OUTPUT: «Too few positionals passed; expected 2 arguments but got 1␤  in method x at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»
m: use nqp; class Foo { has @.h; method x (Mu $x) { $x } }; dd Foo.new( :h<a b c> ).x: Nil
rakudo-moar 88140b: OUTPUT: «Nil $x = Nil␤»
m: my Mu $x; dd $x
rakudo-moar 88140b: OUTPUT: «Mu $x = Mu␤»
m: my Mu $x; dd $x; $x = Nil; dd $x
rakudo-moar 88140b: OUTPUT: «Mu $x = Mu␤Mu $x = Mu␤»
geekosaur: not sure how much it'd be worth to do boxing/unboxing analysis at code gen time, because we don't inline very much at that stage
geekosaur: spesh already has a thing where every version of every local has a "writer" set on it, that you can follow back to find the source of a value, which can for example be a boxing call
in 6.f we will then deprecate the new name, reinstate the old name ...
uuh
have a good one!
Zoffix: do you recall the other pastebin services that let you eval perl6 code? besides glot.io?
yeah, that's the one i remember
oh, tio.run, that's new to me
https://github.com/hankache/perl6intro/issues/146 - this is why i ask
m: use nqp; class Foo { method x { Nil } }; $_ := Foo.x; dd nqp::eqadd($_, Nil)
rakudo-moar 88140b: OUTPUT: «===SORRY!===␤No registered operation handler for 'eqadd'␤»
m: use nqp; class Foo { method x { Nil } }; $_ := Foo.x; dd nqp::eqaddr($_, Nil)
rakudo-moar 88140b: OUTPUT: «1␤»
m: use nqp; class Foo { method x { Nil } }; $_ = Foo.x; dd nqp::eqaddr($_, Nil)
rakudo-moar 88140b: OUTPUT: «0␤»
Why not $path.sub('foo')?
m: use nqp; class Foo { method x (Mu $x) { $x } }; $_ = Foo.x(Nil); dd nqp::eqaddr($_, Nil)
rakudo-moar 88140b: OUTPUT: «0␤»
m: use nqp; class Foo { method x (Mu $x) { $x } }; $_ :L= Foo.x(Nil); dd nqp::eqaddr($_, Nil)
rakudo-moar 88140b: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤You can't adverb $_␤at <tmp>:1␤------> 3s Foo { method x (Mu $x) { $x } }; $_ :L7⏏5= Foo.x(Nil); dd nqp::eqaddr($_, Nil)␤    expecting any of:␤        pair value␤»
m: use nqp; class Foo { method x (Mu $x) { $x } }; $_ := Foo.x(Nil); dd nqp::eqaddr($_, Nil)
rakudo-moar 88140b: OUTPUT: «0␤»
m: use nqp; class Foo { method x (Mu $x is raw) { $x } }; $_ := Foo.x(Nil); dd nqp::eqaddr($_, Nil)
rakudo-moar 88140b: OUTPUT: «1␤»
https://rt.perl.org/Ticket/Display.html?id=129779 - i just closed this bug; it was the performance bug that we tested yesterday
thanks to all of y'all for the help with it
there's a python module that repurposes the / operator for path concat
so why not .slash :)
rakudo-moar 88140b: OUTPUT: «6␤»
rakudo-moar 88140b: OUTPUT: «7␤»
just "with" is already something else
add?
.append() would probably be as descriptive and accurate as you can get
OTOH "appending" is exactly what the current .child does :/
rakudo-moar 88140b: OUTPUT: «Cannot resolve caller append(IO::Path: Str); none of these signatures match:␤    (Any:U \SELF: |values is raw)␤  in block <unit> at <tmp> line 1␤␤»
yey
(I know, surprise, surprise)
Zoffix: I don't understand the rush to get your IO work into this release anyway.
They have lived with the current state of IO for years.
Also if you get all the goodies in now, we'll have fewer to show off in the next release :)
huggable, rakudobug
Oh my...WHAT? The object pulling in CompUnit::Repository::Staging's SC during serialize_repossessions appears to be an NQPRoutine called 'security'.
There's only one routine with that name in all of our code base. That's the part of Perl6::Grammar responsible for throwing an X::SecurityPolicy::Eval unless MONKEY-SEE-NO-EVAL is active
What I also know is that there's not some reference to the repo, but one or more references to the serialization context where the Staging repo is in.
m: use nqp; my $i = 'foo'; my $kid = 'foobar'; dd nqp::substr($kid, nqp::chars($i))
rakudo-moar 88140b: OUTPUT: «"bar"␤»
m: use nqp; my $i = 'foo'; my $kid = 'foobar'; dd nqp::substr($kid, 0, nqp::chars($i))
rakudo-moar 88140b: OUTPUT: «"foo"␤»
I just realized: there's probably a valid workaround for this issue. The Staging repo is for when you want to precompile modules with an unpriviledged user in a staging area that is different from where the resulting files will be installed into.
Because the unpriviledged user won't be allowed to write to /usr/share/perl6 directly.
In other words: it's for when we create packages for distributions. Distributions however will do their own dependency tracking. They will compile the modules in depth first order of the dependency tree.
you hope
This means that we can be reasonably sure that the dist we are currently packaging won't contain modules that replace one of its dependencies' dependencies (by providing a newer version).
Thus we can skip the dependency re-resolving on detecting a change in the repo chain (including the offending EVAL).
geekosaur: they have to for all other languages. I'd say it's reasonable to assume they will use the same mechanism for Perl 6 packages.
Anyway this workaround can be a strictly opt-in thing. The alternative being just biting the bullet and including the dependency on the Staging repo in the precomp file. This can be controlled by the same switch.
perl6 is quite nice to work with
timotimo: noticed that, huh? :)
i don't use perl6 for stuff often enough :)
i work on internals most of the time instead :)
Yeah, I too have worked on Perl 6 much more than with Perl 6. Very much enjoyed the times when I was just a user :)
i think it's acceptable
too bad .subdir doesn't cover all its uses
That's why I suggested .sub. But that may really be just too confusing.
or we can draw on this old (unused) code/name https://github.com/rakudo/rakudo/blob/7556498daa3003efa1329a328b5faf15fbc38386/src/core/CompUnit/RepositoryRegistry.pm#L24 (absolutify... absolutifies... ?)
although I guess the new functionality is only absolutifying it in spirit... it returns an IO::Path so it might be in relative form. doh
tbh I think haskell's </> operator makes a bit more sense :)
https://github.com/rakudo/rakudo/pull/465 # that was already shut down
hm, do we have a good idiom for transposing a list of lists?
currently i wrote it all wordly-like as [@lol>>.[0], @lol>>.[1], ...]
rakudo-moar 88140b: OUTPUT: «[(1, 3, 5), (2, 4, 6)]␤((1, 3, 5), (2, 4, 6)).Seq␤»
neat.
rakudo-moar 88140b: OUTPUT: «[(1, 3, 5), (2, 4, 6)]␤((1, 3, 5), (2, 4, 6)).Seq␤»
i kind of wish i had more datapoints for building this graphing script
right now i have 2
oh, i have 4 actually
or is that the 4 kinds
.... ?!?
i don't recognize this data at all m)
m: constant @foo = <a  b c>; dd @foo
rakudo-moar 88140b: OUTPUT: «("a", "b", "c")␤»
m: constant @foo = <a  b c>; dd @foo = <z e d>
rakudo-moar 88140b: OUTPUT: «Cannot modify an immutable Str␤  in block <unit> at <tmp> line 1␤␤»
m: constant @foo = <a  b c>, [<z e f>]; dd @foo
rakudo-moar 88140b: OUTPUT: «(("a", "b", "c"), ["z", "e", "f"])␤»
m: constant @foo = <a  b c>, [<z e f>]; dd @foo[1][0] = 42; dd @foo
rakudo-moar 88140b: OUTPUT: «42␤(("a", "b", "c"), [42, "e", "f"])␤»
m: constant @foo = <a  b c>, [<z e f>]; dd @foo[0][0] = 42; dd @foo
rakudo-moar 88140b: OUTPUT: «Cannot modify an immutable Str␤  in block <unit> at <tmp> line 1␤␤»
m: constant @foo = 1, 2, 3; dd @foo[0]= 42; dd @foo
rakudo-moar 88140b: OUTPUT: «Cannot modify an immutable Int␤  in block <unit> at <tmp> line 1␤␤»
m: constant @foo = 1, 2, 3; dd @foo[0] = 42; dd @foo
rakudo-moar 88140b: OUTPUT: «Cannot modify an immutable Int␤  in block <unit> at <tmp> line 1␤␤»
m: constant %foo = %(foo => 2); dd %foo<foo> = 42; dd @foo
rakudo-moar 88140b: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Variable '@foo' is not declared. Did you mean '%foo'?␤at <tmp>:1␤------> 3oo = %(foo => 2); dd %foo<foo> = 42; dd 7⏏5@foo␤»
m: constant %foo = %(foo => 2); dd %foo<foo> = 42; dd %foo
rakudo-moar 88140b: OUTPUT: «Int % = 42␤Hash % = {:foo(42)}␤»
m: constant %foo = foo => 2; dd %foo<foo> = 42; dd %foo
rakudo-moar 88140b: OUTPUT: «Cannot modify an immutable Int␤  in block <unit> at <tmp> line 1␤␤»
m: constant %foo = foo, 2; dd %foo<foo> = 42; dd %foo
rakudo-moar 88140b: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Undeclared routine:␤    foo used at line 1␤␤»
m: constant %foo = 'foo', 2; dd %foo<foo> = 42; dd %foo
rakudo-moar 88140b: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Type check failed in constant declaration of %foo; expected Associative but got List (List)␤at <tmp>:1␤------> 3constant %foo = 'foo', 27⏏5; dd %foo<foo> = 42; dd %foo␤»
rakudo-moar 88140b: OUTPUT: «Cannot modify an immutable Int␤  in block <unit> at <tmp> line 1␤␤»
rakudo-moar 88140b: OUTPUT: «Int % = 42␤Hash % = {:foo(42)}␤»
rakudo-moar 88140b: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Type check failed in constant declaration of %foo; expected Associative but got List (List)␤at <tmp>:1␤------> 3constant %foo = 'foo', 27⏏5; dd %foo<foo> = 42; dd %foo␤»
rakudo-moar 88140b: OUTPUT: «Int % = 42␤Hash % = {:foo(42)}␤»
rakudo-moar 88140b: OUTPUT: «Cannot modify an immutable Str␤  in block <unit> at <tmp> line 1␤␤»
rakudo-moar 88140b: OUTPUT: «Cannot modify an immutable Int␤  in block <unit> at <tmp> line 1␤␤»
rakudo-moar 88140b: OUTPUT: «Map.new((:foo(2)))␤»
rakudo-moar 88140b: OUTPUT: «Int <element> = 42␤Map.new((:foo(42)))␤»
rakudo-moar 88140b: OUTPUT: «Int <element> = 42␤»
rakudo-moar 88140b: OUTPUT: «Cannot modify an immutable Str␤  in block <unit> at <tmp> line 1␤␤»
rakudo-moar 88140b: OUTPUT: «42␤Cannot modify an immutable Str␤  in sub foo at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»
fantastic. i get 4 datapoints for every kind X file ... and only three have non-constant values in 'em
huggable, glot.io
has nqp-j been correctly rebootstrapped after the adding of constant support in the uncurse branch?
m: use nqp; dd nqp::split($!SPEC.dir-sep, "/tmp/../\x[308]".IO.absolute)
rakudo-moar 188711: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Variable $!SPEC used where no 'self' is available␤at <tmp>:1␤------> 3use nqp; dd nqp::split($!SPEC7⏏5.dir-sep, "/tmp/../\x[308]".IO.absolute)␤»
m: use nqp; dd nqp::split($*SPEC.dir-sep, "/tmp/../\x[308]".IO.absolute)
rakudo-moar 188711: OUTPUT: «("", "tmp", "../̈")␤»
m: use nqp; dd nqp::split($*SPEC.dir-sep, "/tmp/../\x[308]".IO.absolute.decode.encode('utf8-c8'))
rakudo-moar 188711: OUTPUT: «No such method 'decode' for invocant of type 'Str'␤  in block <unit> at <tmp> line 1␤␤»
m: use nqp; dd nqp::split($*SPEC.dir-sep, "/tmp/../\x[308]".IO.absolute.encode.decode('utf8-c8'))
rakudo-moar 188711: OUTPUT: «Can not decode a utf-8 buffer as if it were utf8-c8␤  in block <unit> at <tmp> line 1␤␤»
m: use nqp; dd nqp::split($*SPEC.dir-sep, "/tmp/../\x[308]".IO.absolute.encode('utf8-c8').decode('utf8-c8'))
rakudo-moar 188711: OUTPUT: «("", "tmp", "../̈")␤»
m: use nqp; dd split (m:ignoremark/$*SPEC.dir-sep()/, "/tmp/../\x[308]".IO.absolute.encode('utf8-c8').decode('utf8-c8'))
rakudo-moar 188711: OUTPUT: «5===SORRY!5===␤Unrecognized regex metacharacter - (must be quoted to match literally)␤at <tmp>:1␤------> 3e nqp; dd split (m:ignoremark/$*SPEC.dir7⏏5-sep()/, "/tmp/../\x[308]".IO.absolute.e␤Couldn't find terminator / (corresponding / wa…»
m: use nqp; dd split m:ignoremark/{$*SPEC.dir-sep}/, "/tmp/../\x[308]".IO.absolute
rakudo-moar 188711: OUTPUT: «Use of uninitialized value of type Any in string context.␤Methods .^name, .perl, .gist, or .say can be used to stringify it to something meaningful.␤  in block <unit> at <tmp> line 1␤Use of Nil in string context␤  in block <unit> at <tmp> line 1…»
m: use nqp; dd split m:ignoremark/<{$*SPEC.dir-sep}>/, "/tmp/../\x[308]".IO.absolute
rakudo-moar 188711: OUTPUT: «Use of uninitialized value of type Any in string context.␤Methods .^name, .perl, .gist, or .say can be used to stringify it to something meaningful.␤  in block <unit> at <tmp> line 1␤Use of Nil in string context␤  in block <unit> at <tmp> line 1…»
m: use nqp; my $sep = $*SPEC.dir-sep; dd split m:ignoremark/$sep/, "/tmp/../\x[308]".IO.absolute
rakudo-moar 188711: OUTPUT: «Use of uninitialized value of type Any in string context.␤Methods .^name, .perl, .gist, or .say can be used to stringify it to something meaningful.␤  in block <unit> at <tmp> line 1␤Use of Nil in string context␤  in block <unit> at <tmp> line 1…»
m: use nqp; my $sep = $*SPEC.dir-sep; dd split m/$sep/, "/tmp/../\x[308]".IO.absolute
rakudo-moar 188711: OUTPUT: «Use of uninitialized value of type Any in string context.␤Methods .^name, .perl, .gist, or .say can be used to stringify it to something meaningful.␤  in block <unit> at <tmp> line 1␤Use of Nil in string context␤  in block <unit> at <tmp> line 1…»
m: use nqp; my $sep = $*SPEC.dir-sep; dd $sep; dd split m/$sep/, "/tmp/../\x[308]".IO.absolute
rakudo-moar 188711: OUTPUT: «Str $sep = "/"␤Use of uninitialized value of type Any in string context.␤Methods .^name, .perl, .gist, or .say can be used to stringify it to something meaningful.␤  in block <unit> at <tmp> line 1␤Use of Nil in string context␤  in block <unit>…»
m: use nqp; my $sep = $*SPEC.dir-sep; dd split m/$sep/, "/tmp/../\x[308]".IO.absolute
rakudo-moar 188711: OUTPUT: «Use of uninitialized value of type Any in string context.␤Methods .^name, .perl, .gist, or .say can be used to stringify it to something meaningful.␤  in block <unit> at <tmp> line 1␤Use of Nil in string context␤  in block <unit> at <tmp> line 1…»
m: use nqp; my $sep = $*SPEC.dir-sep; dd split m/foo/, "/tmp/../\x[308]".IO.absolute
rakudo-moar 188711: OUTPUT: «Use of uninitialized value of type Any in string context.␤Methods .^name, .perl, .gist, or .say can be used to stringify it to something meaningful.␤  in block <unit> at <tmp> line 1␤Use of Nil in string context␤  in block <unit> at <tmp> line 1…»
m: use nqp; my $sep = $*SPEC.dir-sep; dd split m/foo/, "/tmp"
rakudo-moar 188711: OUTPUT: «Use of uninitialized value of type Any in string context.␤Methods .^name, .perl, .gist, or .say can be used to stringify it to something meaningful.␤  in block <unit> at <tmp> line 1␤Use of Nil in string context␤  in block <unit> at <tmp> line 1…»
m: use nqp; my $sep = $*SPEC.dir-sep; dd split /foo/, "/tmp"
rakudo-moar 188711: OUTPUT: «("/tmp",).Seq␤»
m: use nqp; my $sep = $*SPEC.dir-sep; dd split m/foo/, "/tmp"
rakudo-moar 188711: OUTPUT: «Use of uninitialized value of type Any in string context.␤Methods .^name, .perl, .gist, or .say can be used to stringify it to something meaningful.␤  in block <unit> at <tmp> line 1␤Use of Nil in string context␤  in block <unit> at <tmp> line 1…»
m: use nqp; my $sep = $*SPEC.dir-sep; dd split /foo/, "/tmp"
rakudo-moar 188711: OUTPUT: «("/tmp",).Seq␤»
m: use nqp; my $sep = $*SPEC.dir-sep; dd split /:ignoremark $sep/, "/tmp"
rakudo-moar 188711: OUTPUT: «("", "tmp").Seq␤»
m: use nqp; my $sep = $*SPEC.dir-sep; dd split /:ignoremark $sep/, "/tmp/../\x[308]".IO.absolute
rakudo-moar 188711: OUTPUT: «("", "tmp", "..", "").Seq␤»
m: use nqp; my $sep = $*SPEC.dir-sep; dd split m:/:ignoremark $sep/, "/tmp/../\x[308]".IO.absolute
rakudo-moar 188711: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Colons may not be used to delimit quoting constructs␤at <tmp>:1␤------> 3p; my $sep = $*SPEC.dir-sep; dd split m:7⏏5/:ignoremark $sep/, "/tmp/../\x[308]".IO␤    expecting any of:␤        colo…»
m: dd "../̈foo".decode
rakudo-moar 188711: OUTPUT: «No such method 'decode' for invocant of type 'Str'␤  in block <unit> at <tmp> line 1␤␤»
m: dd "../̈foo".encode
rakudo-moar 188711: OUTPUT: «utf8.new(46,46,47,204,136,102,111,111)␤»
m: dd "/".encode
rakudo-moar 188711: OUTPUT: «utf8.new(47)␤»
m: use nqp; my $p := "../̈foo".decode: 'Latin-1';
rakudo-moar 188711: OUTPUT: «No such method 'decode' for invocant of type 'Str'␤  in block <unit> at <tmp> line 1␤␤»
m: use nqp; my $p := "../̈foo".encode: 'Latin-1';
rakudo-moar 188711: OUTPUT: «Error encoding Latin-1 string: could not encode codepoint 776␤  in block <unit> at <tmp> line 1␤␤»
m: use nqp; my $p := "../̈foo".encode: 'utf8-c8';
rakudo-moar 188711: ( no output )
m: use nqp; my $p := "../̈foo".encode: 'utf8-c8'; dd $p
rakudo-moar 188711: OUTPUT: «Blob[uint8].new(46,46,47,204,136,102,111,111)␤»
m: use nqp; my $p := "/".encode: 'utf8-c8'; dd $p
rakudo-moar 188711: OUTPUT: «Blob[uint8].new(47)␤»
m: use nqp; my $p := "../̈foo".encode: 'utf8-c8'; my $sep = $*SPEC.encode: 'utf8-c8'; my int $els = nqp::elems($p); my int $i = -1; nqp::while(nqp::isne_i($els, nqp::add_i($i, 0)), nqp::if(nqp::iseq_i(nqp::atpos($p, $i)) )
rakudo-moar 188711: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Unable to parse expression in argument list; couldn't find final ')' ␤at <tmp>:1␤------> 3qp::if(nqp::iseq_i(nqp::atpos($p, $i)) )7⏏5<EOL>␤»
m: my @a = [1,1],[2,2],[3,3]; dd @a; @a.splice: 0, 2, $[4,4]; dd @a  # feels like a bug that the containerization of [4,4] is being ignored
rakudo-moar 188711: OUTPUT: «Array @a = [[1, 1], [2, 2], [3, 3]]␤Array @a = [4, 4, [3, 3]]␤»
m: use nqp; my $p := "../̈foo".encode: 'utf8-c8'; my $sep := $*SPEC.dir-sep.encode: 'utf8-c8'; my int $els = nqp::elems($p); my int $i = -1; nqp::while(nqp::isne_i($els, nqp::add_i($i, 0)), nqp::if(nqp::iseq_i(nqp::atpos($p, $i)) )
rakudo-moar 188711: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Unable to parse expression in argument list; couldn't find final ')' ␤at <tmp>:1␤------> 3qp::if(nqp::iseq_i(nqp::atpos($p, $i)) )7⏏5<EOL>␤»
m: use nqp; my $p := "../̈foo".encode: 'utf8-c8'; my $sep := $*SPEC.dir-sep.encode: 'utf8-c8'; my int $els = nqp::elems($p); my int $i = -1; nqp::while(nqp::isne_i($els, nqp::add_i($i, 0)), nqp::if(nqp::iseq_i(nqp::atpos($p, $i)), nqp::atpos($p, $i) = "\0"))
rakudo-moar 188711: OUTPUT: «===SORRY!===␤Arg count 1 doesn't equal required operand count 3 for op 'eq_i'␤»
hmm, how do I update the stage0 for the jvm backend?
"make bootstrap-files-j" i think?
m: use nqp; my $p := "../̈foo".encode: 'utf8-c8'; my $sep := $*SPEC.dir-sep.encode: 'utf8-c8'; my int $els = nqp::elems($p); my int $i = -1; nqp::while(nqp::isne_i($els, nqp::add_i($i, 0)), nqp::if(nqp::iseq_i(nqp::atpos($p, $i), 47), nqp::atpos($p, $i) = "\0"))
rakudo-moar 188711: OUTPUT: «MVMArray: atpos expected int register␤  in block <unit> at <tmp> line 1␤␤»
m: use nqp; my $p := "../̈foo".NDF; my $sep := $*SPEC.dir-sep.NFD; dd $p my int $els = nqp::elems($p); my int $i = -1; nqp::while(nqp::isne_i($els, nqp::add_i($i, 0)), nqp::if(nqp::iseq_i(nqp::atpos($p, $i), 47), nqp::atpos($p, $i) = "\0"))
rakudo-moar 188711: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Two terms in a row␤at <tmp>:1␤------> 3DF; my $sep := $*SPEC.dir-sep.NFD; dd $p7⏏5 my int $els = nqp::elems($p); my int $i␤    expecting any of:␤        infix␤        infix stopper␤      …»
m: use nqp; my $p := "../̈foo".NDF; my $sep := $*SPEC.dir-sep.NFD; dd $p; my int $els = nqp::elems($p); my int $i = -1; nqp::while(nqp::isne_i($els, nqp::add_i($i, 0)), nqp::if(nqp::iseq_i(nqp::atpos($p, $i), 47), nqp::atpos($p, $i) = "\0"))
rakudo-moar 188711: OUTPUT: «No such method 'NDF' for invocant of type 'Str'␤  in block <unit> at <tmp> line 1␤␤»
m: use nqp; my $p := "../̈foo".NFD; my $sep := $*SPEC.dir-sep.NFD; dd $p; my int $els = nqp::elems($p); my int $i = -1; nqp::while(nqp::isne_i($els, nqp::add_i($i, 0)), nqp::if(nqp::iseq_i(nqp::atpos($p, $i), 47), nqp::atpos($p, $i) = "\0"))
rakudo-moar 188711: OUTPUT: «Uni.new(0x002e, 0x002e, 0x002f, 0x0308, 0x0066, 0x006f, 0x006f).NFD␤MVMArray: atpos expected int register␤  in block <unit> at <tmp> line 1␤␤»
m: use nqp; my $p := "../̈foo".NFD; my $sep := $*SPEC.dir-sep.NFD; dd $p; dd $sep; my int $els = nqp::elems($p); my int $i = -1; nqp::while(nqp::isne_i($els, nqp::add_i($i, 0)), nqp::if(nqp::iseq_i(nqp::atpos($p, $i), 47), nqp::atpos($p, $i) = "\0"))
rakudo-moar 188711: OUTPUT: «Uni.new(0x002e, 0x002e, 0x002f, 0x0308, 0x0066, 0x006f, 0x006f).NFD␤Uni.new(0x002f).NFD␤MVMArray: atpos expected int register␤  in block <unit> at <tmp> line 1␤␤»
lizmat: Yeah, it's because there's a candidate with @new at the end that it binds to, decontainerizing it in the process.
So it's not actually hitting the slurpy at all
m: use nqp; my $p := "../̈foo".encode: 'utf8-c8'; my $sep := $*SPEC.dir-sep.encode: 'utf8-c8'; my int $els = nqp::elems($p); dd $els; my int $i = -1; nqp::while(nqp::isne_i($els, nqp::add_i($i, 0)), nqp::if(nqp::iseq_i($p, $i)), nqp::atpos($p, $i) = "\0"))
rakudo-moar 188711: OUTPUT: «Non ast passed to UNWANTED: NQPMu␤5===SORRY!5=== Error while compiling <tmp>␤Unexpected closing bracket␤at <tmp>:1␤------> 3q_i($p, $i)), nqp::atpos($p, $i) = "\0")7⏏5)␤»
so you agree it's wrong atm
m: use nqp; my $p := "../̈foo".encode: 'utf8-c8'; my $sep := $*SPEC.dir-sep.encode: 'utf8-c8'; my int $els = nqp::elems($p); dd $els;
rakudo-moar 188711: OUTPUT: «8␤»
The slurpy is **@foo
m: use nqp; my $p := "../̈foo".encode: 'utf8-c8'; my $sep := $*SPEC.dir-sep.encode: 'utf8-c8'; my int $els = nqp::elems($p); dd $els; my int $i = -1; nqp::while(nqp::isne_i($els, nqp::add_i($i, 0)), nqp::if(nqp::iseq_i($p, $i)), nqp::atpos($p, $i) = "\0"))
rakudo-moar 188711: OUTPUT: «Non ast passed to UNWANTED: NQPMu␤5===SORRY!5=== Error while compiling <tmp>␤Unexpected closing bracket␤at <tmp>:1␤------> 3q_i($p, $i)), nqp::atpos($p, $i) = "\0")7⏏5)␤»
So in fact if it *was* hitting the slurpy it would be behaving right :)
m: use nqp; my $b = "foo".encode: 'utf8-c8'; dd nqp::elems($b)
rakudo-moar 188711: OUTPUT: «This type (Scalar) does not support elems␤  in block <unit> at <tmp> line 1␤␤»
Yeah, it's wrong to discard the itemization
m: use nqp; my $b := "foo".encode: 'utf8-c8'; dd nqp::elems($b)
rakudo-moar 188711: OUTPUT: «3␤»
m: use nqp; my $b := "foo".encode: 'utf8-c8'; dd nqp::atpos($b, 1)
rakudo-moar 188711: OUTPUT: «MVMArray: atpos expected int register␤  in block <unit> at <tmp> line 1␤␤»
ok, so we are in agreement
m: use nqp; my $b := "foo".encode: 'utf8-c8'; dd nqp::atpos(1, $b)
rakudo-moar 188711: OUTPUT: «This representation (VMArray) cannot unbox to a native int (for type Blob[uint8])␤  in block <unit> at <tmp> line 1␤␤»
I wonder if it was untested and then accidentally regressed when splice was optimized by breaking it out into a bunch of candidates
will file a rakudobug
m: use nqp; my $b := "foo".encode: 'utf8-c8'; dd nqp::atpos($b, 1)
rakudo-moar 188711: OUTPUT: «MVMArray: atpos expected int register␤  in block <unit> at <tmp> line 1␤␤»
m: use nqp; my $b := "foo".encode: 'utf8-c8'; dd nqp::atpos($b, my int $ = 1)
rakudo-moar 188711: OUTPUT: «MVMArray: atpos expected int register␤  in block <unit> at <tmp> line 1␤␤»
m: use nqp; my $b := "foo".encode: 'utf8-c8'; dd nqp::atpos($b, 1)
rakudo-moar 188711: OUTPUT: «MVMArray: atpos expected int register␤  in block <unit> at <tmp> line 1␤␤»
Since I seem to recall splice getting at least something of a look during the GLR
And I can't imagine we settled on "it ignores itemization" :)
commitable: my @a = [1,1],[2,2],[3,3]; @a.splice: 0, 2, $[4,4]; dd @a
m: use nqp; my $p := "../̈foo".encode: 'utf8-c8'; my $sep := $*SPEC.dir-sep.encode: 'utf8-c8'; my int $els = nqp::elems($p); dd $els; my int $i = -1; nqp::while(nqp::isne_i($els, nqp::add_i($i, 0)), nqp::if(nqp::iseq_i($p.AT-POS: $i)), $p.AT-POS($i) = "\0"))
rakudo-moar 188711: OUTPUT: «Non ast passed to UNWANTED: NQPMu␤5===SORRY!5=== Error while compiling <tmp>␤Unexpected closing bracket␤at <tmp>:1␤------> 3i($p.AT-POS: $i)), $p.AT-POS($i) = "\0")7⏏5)␤»
bisectable6: my @a = [1,1],[2,2],[3,3]; @a.splice: 0, 2, $[4,4]; dd @a
ah
Hm, nope
It's been like that since Christmas
m: use nqp; my $p := "../̈foo".encode: 'utf8-c8'; my $sep := $*SPEC.dir-sep.encode: 'utf8-c8'; my int $els = nqp::elems($p); dd $els; my int $i = -1; nqp::while(nqp::isne_i($els, nqp::add_i($i, 0)), nqp::if(nqp::iseq_i($p.AT-POS: $i), $p.AT-POS($i) = "\0"))
rakudo-moar 188711: OUTPUT: «===SORRY!===␤Arg count 1 doesn't equal required operand count 3 for op 'eq_i'␤»
ok, doesn't make it right, though :-)
Indeed
m: use nqp; my $p := "../̈foo".encode: 'utf8-c8'; my $sep := $*SPEC.dir-sep.encode: 'utf8-c8'; my int $els = nqp::elems($p); dd $els; my int $i = -1; nqp::while(nqp::isne_i($els, nqp::add_i($i, 0)), nqp::if(nqp::iseq_i($p.AT-POS($i), $sep), $p.AT-POS($i) = "\0"))
rakudo-moar 188711: OUTPUT: «8␤This type cannot unbox to a native integer: P6opaque, Failure␤  in block <unit> at <tmp> line 1␤␤»
but will wait for the release to look at fixing it
m: use nqp; my $p := "../̈foo".encode: 'utf8-c8'; my $sep := $*SPEC.dir-sep.ord; my int $els = nqp::elems($p); dd $els; my int $i = -1; nqp::while(nqp::isne_i($els, nqp::add_i($i, 0)), nqp::if(nqp::iseq_i($p.AT-POS($i), $sep), $p.AT-POS($i) = "\0"))
rakudo-moar 188711: OUTPUT: «8␤This type cannot unbox to a native integer: P6opaque, Failure␤  in block <unit> at <tmp> line 1␤␤»
*nod*
m: use nqp; my $p := "../̈foo".encode: 'utf8-c8'; my $sep := $*SPEC.dir-sep.ord; dd $sep; my int $els = nqp::elems($p); dd $els; my int $i = -1; nqp::while(nqp::isne_i($els, nqp::add_i($i, 0)), nqp::if(nqp::iseq_i($p.AT-POS($i), $sep), $p.AT-POS($i) = "\0"))
rakudo-moar 188711: OUTPUT: «47␤8␤This type cannot unbox to a native integer: P6opaque, Failure␤  in block <unit> at <tmp> line 1␤␤»
m: use nqp; my $p := "../̈foo".encode: 'utf8-c8'; my $sep := $*SPEC.dir-sep.ord; my int $els = nqp::elems($p); dd $els; my int $i = -1; nqp::while(nqp::isne_i($els, nqp::add_i($i, 0)), nqp::if(nqp::iseq_i($p.AT-POS($i), $sep), $p.AT-POS($i) = "\0"))
rakudo-moar 188711: OUTPUT: «8␤This type cannot unbox to a native integer: P6opaque, Failure␤  in block <unit> at <tmp> line 1␤␤»
reported as RT #131162
Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=131162
m: use nqp; my $p := Buf.new: "../̈foo".encode('utf8-c8'); my $sep := $*SPEC.dir-sep.ord; my int $els = nqp::elems($p);  my int $i = -1; nqp::while(   nqp::isne_i($els, $i = nqp::add_i($i, 1)),   nqp::if(     nqp::iseq_i($p.AT-POS($i), $sep),     $p.AT-POS($i) = 0)); dd nqp::split("\0", $p.decode('utf8-c8'));
rakudo-moar 188711: OUTPUT: «("..", "\x[308]foo")␤»
m: use nqp; my $p := Buf.new: "../̈foo".encode('utf8-c8'); my $sep := $*SPEC.dir-sep.ord; my int $els = nqp::elems($p);  my int $i = -1; nqp::while(   nqp::isne_i($els, $i = nqp::add_i($i, 1)),   nqp::if(     nqp::iseq_i($p.AT-POS($i), $sep),     $p.AT-POS($i) = 0)); dd nqp::split("\0", $p.decode('utf8-c8'));
rakudo-moar 188711: OUTPUT: «("..", "\x[308]foo")␤»
Zoffix: at this point we should probably settle for correct  :-)
oops, wrongchan
m: use nqp; my $p := Buf.new: "../̈foo".encode('utf8-c8'); my $sep := $*SPEC.dir-sep.ord; my int $els = nqp::elems($p);  my int $i = -1; nqp::while(   nqp::isne_i($els, $i = nqp::add_i($i, 1)),   nqp::if(     nqp::iseq_i($p.AT-POS($i), $sep),     $p.AT-POS($i) = 0)); dd nqp::split("\0", $p.decode('utf8-c8'));
rakudo-moar 188711: OUTPUT: «("..", "\x[308]foo")␤»
s: buf8, 'new', \()
s: buf8, 'new', \(42)
s: buf8, 'new'
m: use nqp; my $p := nqp::encode('x', 'utf8-c8', nqp::list_i); dd $p
rakudo-moar 188711: OUTPUT: «Cannot find method 'dispatch:<.?>': no method cache and no .^find_method␤  in block <unit> at <tmp> line 1␤␤»
m: use nqp; my $p := nqp::encode('x', 'utf8-c8', nqp::list_i); dd $p.AT-POS(0)
rakudo-moar 188711: OUTPUT: «Cannot find method 'AT-POS': no method cache and no .^find_method␤  in block <unit> at <tmp> line 1␤␤»
m: use nqp; my $p := nqp::encode('x', 'utf8-c8', nqp::list_i); dd $p[0]
rakudo-moar 188711: OUTPUT: «X::Multi::NoMatch exception produced no message␤  in block <unit> at <tmp> line 1␤␤»
nqp: my $p := nqp::encode('x', 'utf8-c8', nqp::list_i); dd $p[0]
nqp-moarvm: OUTPUT: «Confused at line 2, near "dd $p[0]"␤   at gen/moar/stage2/NQPHLL.nqp:765  (/home/camelia/rakudo-m-inst-1/share/nqp/lib/NQPHLL.moarvm:panic)␤ from gen/moar/stage2/NQP.nqp:919  (/home/camelia/rakudo-m-inst-1/share/nqp/lib/nqp.moarvm:comp_unit)␤ from gen/moar…»
nqp: my $p := nqp::encode('x', 'utf8-c8', nqp::list_i); nqp::say($p[0])
nqp-moarvm: OUTPUT: «MVMArray: atpos expected int register␤   at <tmp>:1  (<ephemeral file>:<mainline>)␤ from gen/moar/stage2/NQPHLL.nqp:1585  (/home/camelia/rakudo-m-inst-1/share/nqp/lib/NQPHLL.moarvm:eval)␤ from gen/moar/stage2/NQPHLL.nqp:1788  (/home/camelia/rakudo-m-inst-1…»
nqp: my $p := nqp::encode('x', 'utf8-c8', nqp::list_i); nqp::say(nqp::atpos_i($p, 0))
nqp-moarvm: OUTPUT: «0␤»
nqp: my @p; nqp::encode('x', 'utf8-c8', @p); nqp::say(nqp::atpos_i($p, 0))
nqp-moarvm: OUTPUT: «Use of undeclared variable '$p' at line 2, near ", 0))"␤   at gen/moar/stage2/NQPHLL.nqp:765  (/home/camelia/rakudo-m-inst-1/share/nqp/lib/NQPHLL.moarvm:panic)␤ from gen/moar/stage2/NQP.nqp:2709  (/home/camelia/rakudo-m-inst-1/share/nqp/lib/nqp.moarvm:variab…»
nqp: my @p; nqp::encode('x', 'utf8-c8', @p); nqp::say(nqp::atpos_i(@p, 0))
nqp-moarvm: OUTPUT: «encode requires a native int array␤   at <tmp>:1  (<ephemeral file>:<mainline>)␤ from gen/moar/stage2/NQPHLL.nqp:1585  (/home/camelia/rakudo-m-inst-1/share/nqp/lib/NQPHLL.moarvm:eval)␤ from gen/moar/stage2/NQPHLL.nqp:1788  (/home/camelia/rakudo-m-inst-1/sh…»
nqp: my @p := nqp::list_i; nqp::encode('x', 'utf8-c8', @p); nqp::say(nqp::atpos_i(@p, 0))
nqp-moarvm: OUTPUT: «0␤»
nqp: my @p := nqp::list_b; nqp::encode('x', 'utf8-c8', @p); nqp::say(nqp::atpos_i(@p, 0))
nqp-moarvm: OUTPUT: «encode requires a native int array␤   at <tmp>:1  (<ephemeral file>:<mainline>)␤ from gen/moar/stage2/NQPHLL.nqp:1585  (/home/camelia/rakudo-m-inst-1/share/nqp/lib/NQPHLL.moarvm:eval)␤ from gen/moar/stage2/NQPHLL.nqp:1788  (/home/camelia/rakudo-m-inst-1/sh…»
(make spectest passed so hopefully this commit won't cause any trouble :)
\o/
timotimo: if you're aren't completly busy making pretty coverage graphs, any more thoughts on sql profile output? i just pushed a commit to my branch that renames the `allocators` table to `types` and the `allocations.id` field to `allocations.type_id`
ah, i like that
i'm not sure i know where that branch lives
https://github.com/MasterDuke17/nqp/tree/make_profile_sql_output_better
haha! i was looking for moarvm branches
that doesn't make any sense, of course
okay, so
callees, right?
it has a caller_id and an id
i expect callees.caller_id to refer to callees.id
but then how do i get from callees to the corresponding routine?
also, allocations are also per-callees-entry, so we need a connection there, too
callees.(caller_)id = routines.id
yeah, i just saw that allocation <-> callee relationship in the newly-working-again regular profile
oh
if both id fields in callees refer to routines, that's Bad
or at least weird
consider subs A and B both call X, and X calls Y
er ...
ah, yeah
now Y exists twice at rec_depth 2, X exists twice at rec_depth 1, and Y just has X as its caller_id
but imagine A and B pass an integer through X to Y and Y sleeps for that long
how do we figure out which Y record belongs to A (sleeps for 10s) and which Y record belongs to B (sleeps for 1s)
does that make sense?
m: my $x = 'foo'; for ^10_000 { $x.subst-mutate: :g, 'o', 'o' }; say now - INIT now
rakudo-moar 0b5a41: OUTPUT: «2.12963908␤»
m: my $x = 'foo'; for ^10_000 { $x = $x.subst: :g, 'o', 'o' }; say now - INIT now
rakudo-moar 0b5a41: OUTPUT: «0.09880963␤»
m: my $x = 'foo'; for ^10_000 { $x .= subst: :g, 'o', 'o' }; say now - INIT now
rakudo-moar 0b5a41: OUTPUT: «0.547216␤»
s: '', 'subst-mutate', \(:g, 'o', 'o')
s: ($ = ''), 'subst-mutate', \(:g, 'o', 'o')
s: ($ = ''), 'subst-mutate'
yeah. i'm just pulling the info right from the same data structure the json output is without manipulating it. but it maybe it does need some manipulation or other stuff added to make sense as db rows
i guess it's losing some of the tree structure
this would be to replicate the call graph section of the regular profile, right?
well, yeah
exactly
the tree structure got flattened away because we didn't explicitly introduce a new "parent_id" field or something
and i'd love for a new profiler data explorer to also be able to tell "this routine took 5s when called by A, but 10s when called by B"
and much more importantly
"bind_one_parameter" was called this often by those routines: A, B, C
yes, that would be nice
yes oh god yes
ugh, not thinking very fast today. need to add a unique id every time we see a caller id?
hm, a caller_id?
we're walking the tree, right? we should have a new unique ID every time we reach one call graph node, and every node we discover from there (i.e. in the children list or whatever we have) will have the id we just made up set for its "parent"
right. then the existing caller_id is just so we can look up its name in the routines table
right
caller_id for new unique id, caller_name_id for what caller_id is now?
well, we don't really need the id from the caller any more
so we'd get down to one field that references into the routines table
hm, guess so
the last time i tried to put something like a unique id and a parent id in, the code absolutely wrecked my brain
i'm really glad you're doing it for me :)
hey, weren't you going to bed? ;)
heh. it
https://imgur.com/a/DKzJj - Zoffix, how do you like my graphs?
's not like it doesn't take me lots of thinking and staring at the data over and over
<3
MasterDuke_: yeah, the data is really not glancable
Zoffix, that's actually a bad idea, the actual list of special chars permitted in a URL is fairly limited
rakudo-moar 0b5a41: OUTPUT: «"3A"␤»
i think the reason why we have $COLON is because of filesystems?
so maybe have a switch for served vs local docs?
OK
we have to change the servers htacccess file
because it redirects actual colons to $COLON
so if we fix the build then it'll break the site cause it'll redirect to $COLON
uh maybe it rewrites it
it probably rewrites it tbh
also we could always just uhm. only use $COLON on windows
then the links in the files will be the same links that the files *actually* are named
instead of requiring rewriting to even use the html files
we tried that before
but it had to be reverted
should be a commit in the history if i look
just gotta make sure the website tries to access :: files not $COLON$COLON
because when you access webpage::blah.html
the server tries to give it the file at $COLEN$COLEN
which does't exist!
so reverted it
https://github.com/perl6/doc/commit/331472d0bfb1f07def0fb978846afb33b197c1b6
and this https://github.com/perl6/doc/commit/93db5f69ed7b39908480274d810aae0e0589ed26
Qw⟅ ⟆;
that's baggy
it quotes!
they are allowed delimiters!
i know
it looks very much like a bag
is what i mean
yeah they are S shaped bag delimiters
if we wanted to go crazy we could enable ⟅ ⟆ quoting to do bag( )
hahaha
make it a slang
Zoffix, you gonna add this too https://github.com/perl6/doc/commit/93db5f69ed7b39908480274d810aae0e0589ed26
also note here that unix does have some badchars https://github.com/perl6/doc/commit/331472d0bfb1f07def0fb978846afb33b197c1b6#diff-5dfee1feb8b315ccfa42bd3125fdcb05R17
which is the '/'
so you will need to make those changes i made to htmlifgy.p6
err lib/Pod/Htmlify.pm6
is there a way to switch it on/off regardless of system? I could see someone trying to do this on a unix into a mounted cifs...
and the only reason it's not in htmlify.p6 is because it falsely triggers
or ntfs fuse mount, etc.
because directory names have a forward slash in them on linux
but they need to be added into lib/Pod/Htmlify.pm6
or it won't change '/' into $SOLIDUS or whatever it does
so hopefully you don't explode anything trying to write slashes to filenames
:O
cause that is not allowed
it'll break
i'll do it hold on
u: 🐿
that unbreaks nqp build on jvm, which I shoulda checked first...
m: sub circumfix:<< ⟅ ⟆ >>(\_) { _.Bag }; dd ⟅ 1, 2, 3 ⟆ # ← samcv
rakudo-moar 0b5a41: OUTPUT: «(1=>1,3=>1,2=>1).Bag␤»
hmm, the d setting doesn't compile under jvm, gets what appears to be a recursive exception
that's *probably* not my fault...
well, a job for tomorrow, if no actual jvm ex-spurt beats me to it
Files=1192, Tests=56772, 204 wallclock secs (12.20 usr  4.71 sys + 1194.43 cusr 117.39 csys = 1328.73 CPU)
RAKUDO_RERESOLVE_DEPENDENCIES=0 or RAKUDO_SKIP_RERESOLVING_DEPENDENCIES=1?
Trying to avoid negated booleans here, but have to admit that setting an environment option to 0 is kinda unusual
This is Rakudo version 2017.03-292-g0b5a41ba8 built on MoarVM version 2017.03-138-g40881cdb
csv-ip5xs        3.024
test            12.890
test-t           5.122 - 5.137
csv-parser      13.013
Damn, this sucks. I've found another major stumbling block. my constant $p5helper = %?RESOURCES<libraries/p5helper>.Str; in Inline::Perl5. A compile time constant pointing at the shared library for the NativeCall declarations. That's a path name. So when we build the module in a staging directory, that path will point to that staging dirctory and not to the directory where the shared lib will be installed
to.
I guess using pass-a-sub-to-the-native-trait approach would make it late bound enough
But yeah, I've seen plenty of modules that do the very same thing
Can't do that in this case as I need NativeCall at compile time to determine Perl 5's int size
ah, ok
However, the only place where the library gets loaded is MVM_nativecall_build which is only called by role Native's !setup. So I assume that even for precompiled modules !setup is always called at runtime as well. This may give us a chance to influence the path.
Of course this will not help for any other %?RESOURCES :-/
s: Failure.new(), 'Exception', \()
s: Failure.new(), 'Exception', \(Failure:D:)
s: Failure.new(), 'exception', \()
lol. wat.
that's not correct :D
The only way around that I can see is to defer creating a path as long as possible, i.e. %?RESOURCES will give you a path like object that goes through the repo chain every time. This isn't helped by NativeCall accepting only Str, Callable or List though.
but a Callable can do *anything*! :)
Well maybe a Callable (for NativeCall) that overrides .Str (for path concatenation, printing, etc.)
Btw. NativeCall not accepting IO::Path for the library path does not show off our best side.
...and is so easy to fix that I really wonder why no one (especially me) has bothered so far.
oh, right
quickly, before the release happens
make everything awesome
Yeah, I've got some very experimental, last minute commits to push ;)
when IO::Path {
return $lib.absolute();
just that, right?
in guess_library_name?
https://gist.github.com/niner/7bcd6145c3209d91c211c2f2e453f5db
oh
also needs to take IO::Path in the signature of the role
yeah, that's the code i cam up with as well
you wanna commit it?
I've got too many half baked changes to run a spec test right now
OK, i'll do it
YAMLish fails to install against Rakudo HEAD :(
All tests fail with
Too few positionals passed; expected 2 arguments but got 1 in regex list at /home/jnthn/edument/rmtly/.panda-work/1492427079_1/lib/YAMLish.pm6 (YAMLish) line 145
huh, something from the uncurse branch?
I fear so
If Match and Cursor got unified, and you have a regex called list, won't that end up breaking @$/ or $/.list and so forth?
could be, aye
we ought to put a list of problematic regex names up
m: grammar G { token TOP { (<list>) }; token list { .+ } }; say G.parse('xxx')
rakudo-moar 0b5a41: OUTPUT: «(timeout)»
o.O
star: grammar G { token TOP { (<list>) }; token list { .+ } }; say G.parse('xxx')
star-m 2016.10: OUTPUT: «｢xxx｣␤ 0 => ｢xxx｣␤  list => ｢xxx｣␤»
*sigh*
This is a pretty bad regression.
Anyway, I don't have time for this now, so will just go back to running older Rakudo/NQP versions
All tests successful.
http://nikic.github.io/2017/04/14/PHP-7-Virtual-machine.html "Exceptions are the root of all evil." :-)
Maybe we should get back into the habit of running emmentaler regularly
Indeed
I'd imagine YAMLish is pretty widely used
Though hopefully this is easy enough to work around
fwiw my very grammar involved compiler (https://github.com/spitsh/spitsh) is broken too after uncurse got merged.
haven't had had time to debug it yet but it seems on the smallest possible snippet it timed out like the above.
jnthn: i just pushed a fix to YAMLish
timotimo: Nice, thanks :)
leont gave me commit access. i think this situation warrants pushing to master
bumped version, too, now
Cool, will try that later today
lunch; bbl
Of course if I declare a class in CompUnit/Repository/Staging.pm we'll end up depending on CompUnit::Repository::Staging again...
Ah, I should probably move that thing into Distribution::Resources anyway as that's where we already have an indirection to avoid depending on the repo.
i don't actually see the secureness inside child-secure :o
aaah it's in resolve
i was looking for the magic for combiners
Zoffix: but why do we have .add if it's just the same as .child?
I thought the goal was to encourage people to use the secure one by making its name short and simple
we can't just re-use child because now child-secure has very different semantics
i.e. it can fail when the folder doesn't exist
or when it's not an actual child, etc etc
hm, let's make a class IO::Pαth that has the right .child
The whole situation sucks :/ How about warning about insecure paths with a pointer to .add for a couple of months before making .child strict?
and how do you get strilt .child then?
strict*
Make it do whatever .child-secure does now?
er
no
you just said .child should warn about insecure paths
for a transition period
so you can't get secure .child at all until the transition period is over?
Yes
that's also terrible
3 years from now it will be considerably less terrible than having a .child that just accepts everything and some .child-secure that no one uses.
Zoffix: that's if the author actually thought about security
We require a pragma for even allowing usage of EVAL but the simplest way to concatenate paths will happily take anything
that doesn't sound terrible
oh yeah, it's really really slow
Sounds ok.
huggable, 6.d
m: dd 'C:/foo/bar.txt'.IO.parts
rakudo-moar a98b28: OUTPUT: «Hash %!parts = {:basename("bar.txt"), :directory("C:/foo"), :dirname("C:/foo"), :volume("")}␤»
m: my (:$basename, :$directory, :$dirname, :$volume) := 'C:/foo/bar.txt'.IO.parts
rakudo-moar a98b28: ( no output )
m: my (:$basename, :$dirname, :$volume) := 'C:/foo/bar.txt'.IO.parts
rakudo-moar a98b28: OUTPUT: «Unexpected named argument 'directory' passed␤  in block <unit> at <tmp> line 1␤␤»
m: my (:$basename, :$directory, :$dirname, :$volume) := 'C:/foo/bar.txt'.IO.parts
rakudo-moar a98b28: ( no output )
m: my (:$basename, :$directory, :$dirname, :$volume) := 'C:/foo/bar.txt'.IO.parts; dd [ :$basename, :$directory, :$dirname, :$volume ]
rakudo-moar a98b28: OUTPUT: «[:basename("bar.txt"), :directory("C:/foo"), :dirname("C:/foo"), :volume("")]␤»
m: my $p = 'C:/foo/bar.txt'.IO; $p.parts; for ^1000 { my (:$basename, :$directory, :$dirname, :$volume) := $p.parts;  }; say now - INIT now
rakudo-moar a98b28: OUTPUT: «0.0288043␤»
m: my $p = 'C:/foo/bar.txt'.IO; $p.parts; for ^10_000 { my (:$basename, :$directory, :$dirname, :$volume) := $p.parts;  }; say now - INIT now
rakudo-moar a98b28: OUTPUT: «0.20991938␤»
m: my $p = 'C:/foo/bar.txt'.IO; $p.parts; for ^10_000 { my ($basename, $dirname, $volume) := $p.parts<basename dirname volume>;  }; say now - INIT now
rakudo-moar a98b28: OUTPUT: «0.5390200␤»
m: my $p = 'C:/foo/bar.txt'.IO; $p.parts; for ^10_000 { my ($basename, $dirname, $volume) := $p.parts<basename dirname volume>;  $ = $basename; $ = $dirname; $ = $volume }; say now - INIT now
rakudo-moar a98b28: OUTPUT: «0.5366768␤»
m: my $p = 'C:/foo/bar.txt'.IO; $p.parts; for ^10_000 { my (:$basename, :$directory, :$dirname, :$volume) := $p.parts;  $ = $basename; $ = $dirname; $ = $volume }; say now - INIT now
rakudo-moar a98b28: OUTPUT: «0.2073521␤»
m: my $p = 'C:/foo/bar.txt'.IO; $p.parts; for ^10_000 { my (:$basename, :$directory, :$dirname, :$volume) := $p.parts;  $ = $basename; $ = $dirname; $ = $volume }; say now - INIT now
rakudo-moar a98b28: OUTPUT: «0.2070993␤»
m: my $p = 'C:/foo/bar.txt'.IO; $p.parts; for ^10_000 { my $parts = $p.parts;  $ = $parts<basename>; $ = $parts<dirname>; $ = $parts<volume> }; say now - INIT now
rakudo-moar a98b28: OUTPUT: «0.06151459␤»
m: my $p = 'C:/foo/bar.txt'.IO; $p.parts; for ^10_000 { my $parts = $p.parts;  $ = $parts<basename>; $ = $parts<dirname>; $ = $parts<volume> }; say now - INIT now
rakudo-moar a98b28: OUTPUT: «0.06430972␤»
m: my $p = 'C:/foo/bar.txt'.IO; $p.parts; for ^10_000 { $_ = $p.parts;  $ = .<basename>; $ = .<dirname>; $ = .<volume> }; say now - INIT now
rakudo-moar a98b28: OUTPUT: «Cannot assign to an immutable value␤  in block <unit> at <tmp> line 1␤␤»
m: my $p = 'C:/foo/bar.txt'.IO; $p.parts; for ^10_000 { $_ := $p.parts;  $ = .<basename>; $ = .<dirname>; $ = .<volume> }; say now - INIT now
rakudo-moar a98b28: OUTPUT: «0.0603560␤»
m: my $p = 'C:/foo/bar.txt'.IO; $p.parts; for ^10_000 { $_ := $p.parts;  $ = .<basename>; $ = .<dirname>; $ = .<volume> }; say now - INIT now
rakudo-moar a98b28: OUTPUT: «0.06080172␤»
m: my $p = 'C:/foo/bar.txt'.IO; $p.parts; for ^10_000 { $_ := $p.parts;  $ = .<basename>; $ = .<dirname>; $ = .<volume> }; say now - INIT now
rakudo-moar a98b28: OUTPUT: «0.0614355␤»
m: my $p = 'C:/foo/bar.txt'.IO; $p.parts; for ^10_000 { my $parts = $p.parts;  $ = $parts<basename>; $ = $parts<dirname>; $ = $parts<volume> }; say now - INIT now
rakudo-moar a98b28: OUTPUT: «0.0649835␤»
m: my $p = 'C:/foo/bar.txt'.IO; $p.parts; for ^10_000 { my $parts = $p.parts;  $ = $parts<basename>; $ = $parts<dirname>; $ = $parts<volume> }; say now - INIT now
rakudo-moar a98b28: OUTPUT: «0.0687876␤»
m: my $p = 'C:/foo/bar.txt'.IO; $p.parts; for ^10_000 { my $parts = $p.parts;  $ = $parts<basename>; $ = $parts<dirname>; $ = $parts<volume> }; say now - INIT now
rakudo-moar a98b28: OUTPUT: «0.0644532␤»
m: my \foo = 42; my %h = :foo; dd %h
rakudo-moar a98b28: OUTPUT: «Hash %h = {:foo}␤»
i totally forgot to push the thing i did
It would be great if someone reviewed the 28a6e80ff3 commit ;)
m: use nqp; my $x = 42; for ^100_000 { $ = so $x }; say now - INIT now
rakudo-moar 998408: OUTPUT: «0.10554170␤»
m: use nqp; my $x = 42; for ^1000_000 { $ = so $x }; say now - INIT now
rakudo-moar 998408: OUTPUT: «0.9478865␤»
m: use nqp; my $x = 42; for ^1000_000 { $ = nqp::p6bool($x) }; say now - INIT now
rakudo-moar 998408: OUTPUT: «0.52138189␤»
ACTION crawls back from vacation
Looks like things were quite busy while I was gone.  :-)
m: use nqp; my $x = 42; for ^1000_000 { $ = $x }; say now - INIT now
rakudo-moar 28a6e8: OUTPUT: «0.4985612␤»
m: use nqp; my $x = 42; for ^1000_000 { $ = $x }; say now - INIT now
rakudo-moar 28a6e8: OUTPUT: «0.4984844␤»
###
m: use nqp; my $x = 42; for ^1000_000 { $ = $x }; say now - INIT now
rakudo-moar 28a6e8: OUTPUT: «0.5086865␤»
m: use nqp; my $x = 42; for ^1000_000 { $ = $x }; say now - INIT now
rakudo-moar 28a6e8: OUTPUT: «0.501315␤»
m: use nqp; my $x = 42; for ^1000_000 { $ = $x }; say now - INIT now
rakudo-moar 28a6e8: OUTPUT: «0.50033173␤»
####
m: use nqp; my $x = 42; for ^1000_000 { $ = so $x }; say now - INIT now
rakudo-moar 28a6e8: OUTPUT: «1.1575203␤»
m: use nqp; my $x = 42; for ^1000_000 { $ = so $x }; say now - INIT now
rakudo-moar 28a6e8: OUTPUT: «0.9368565␤»
m: use nqp; my $x = 42; for ^1000_000 { $ = so $x }; say now - INIT now
rakudo-moar 28a6e8: OUTPUT: «0.93060588␤»
m: use nqp; my $x = 42; for ^1000_000 { $ = nqp::p6bool($x) }; say now - INIT now
rakudo-moar 28a6e8: OUTPUT: «0.523861␤»
m: use nqp; my $x = 42; for ^1000_000 { $ = nqp::p6bool($x) }; say now - INIT now
rakudo-moar 28a6e8: OUTPUT: «0.5240126␤»
m: use nqp; my $x = 42; for ^1000_000 { $ = nqp::p6bool($x) }; say now - INIT now
rakudo-moar 28a6e8: OUTPUT: «0.5245491␤»
m: say (.936-.501)/(.524-.501)
rakudo-moar 28a6e8: OUTPUT: «18.913043␤»
FWIW, the IO stuff I care about of late is below the Rakudo level -- I can barely wait for Uni input to be implemented in MoarVM.  :-)
Not that I haven't been extremely happy to see all the fixes you've been doing, Zoffix.  :-)
japhb: you mean decoding utf8 without doing any normalization, yeah?
OMG I think I finally got it to work :)
fantastic!
Currently running spectest with Inline::Perl5 installed from an .rpm file
It is using the RAKUDO_RERESOLVE_DEPENDENCIES=0 workaround but that's still a hell of a lot better than not being able to deploy at all
i don't know what resolve dependencies = 0 does :(
timotimo: https://irclog.perlgeek.de/perl6-dev/2017-04-16#i_14436390
timotimo: does that make sense?
i'm not 100% sure, but i believe you're doing the right thing
Well if I ever find out how the EVAL pulls in the totaly unrelated SC, we can get rid of it again. For now it just feels good to make progress on this :)
c: 2017.03 dd IO::Path.abspath
rakudo-moar 0dbe45: OUTPUT: «Cannot look up attributes in a <anon|65349248> type object␤  in method y at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»
huh, is absolute not the right method name on an IO::Path?
ah
"An exception occurred while evaluating a constant" now that's an extraordinarily unhelpful error
How so?
rakudo-moar 31cf7d: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤An exception occurred while evaluating a constant␤at <tmp>:1␤Exception details:␤  Died␤    in block  at <tmp> line 1␤␤»
It includes the details of the exception
Except when it doesn't :)
https://gist.github.com/niner/68a5cd5ef43bb3c3786f5136ee080170
Maybe that's due to the --ll-exception?
Indeed! jnthn++
m: EVAL 'constant foo = die'; CATCH { default { .Str.say } }
rakudo-moar 31cf7d: OUTPUT: «An exception occurred while evaluating a constant␤»
m: EVAL 'constant foo = die'; CATCH { default { .gist.say } }
rakudo-moar 31cf7d: OUTPUT: «5===SORRY!5=== Error while compiling /home/camelia/EVAL_0␤An exception occurred while evaluating a constant␤at /home/camelia/EVAL_0:1␤Exception details:␤  Died␤    in block  at EVAL_0 line 1␤␤»
Yeah, I think we just .Str it with --ll-exception
But the useful bit is in the .gist
m: EVAL 'constant foo = die'; CATCH { default { say .^methods } }
rakudo-moar 31cf7d: OUTPUT: «(message sorry_heading SET_FILE_LINE gist use-case exception filename pos line column modules is-compile-time pre post highexpect backtrace throw resume die is-compile-time gist Str reset-backtrace vault-backtrace rethrow resumable fail)␤»
m: EVAL 'constant foo = die'; CATCH { default { say .exception } }
rakudo-moar 31cf7d: OUTPUT: «Died␤  in block  at EVAL_0 line 1␤␤»
And the .exception property has the original exception
c: 2017.03 dd say WHAT ".".IO.WHAT.e
jnthn: I made Scalar.dynamic return False when the descriptor is not set
Ok, that's all I need for creating RPMs :)
c: 2017.03 dd Any.IO
I guess you'll need to pick a new root password :P
don't have that one, but I have gd, gb, gco, etc...
and of course gp='git pull --rebase'
ah the good old general practitioner
m: grammar G { token TOP { (<list>) }; token list { .+ } }; say G.parse('xxx') # from jnthn
rakudo-moar 2a0a2d: OUTPUT: «(timeout)»
for some reason this really bothers me:
t/spec/S24-testing/11-plan-skip-all.t ............................. skipped: Testing skippage of `plan skip-all`
TimToady: and what about the grammar above?
kind of a you-think-that's-cute-today
dogbert17: and what about it? :)
is impressed :)
that was, in fact, what I was spec-testing :)
TimToady: so was renaming "token list" to "token yamllist" the wrong call for yamlish?
see above: "One workaround..."
fixing that problem was no Match for TimoToady :)
I specifically changed it from "The workaround..." :)
ACTION feels sleepy for some reason :)
oh, I only had one cuppa so far...
TimToady: that's a severe condition. You should fix it immediately
yeah, almost a release blocker...
esp if I can't figure out why jvm infithrows while trying to compile CORE.d
ENOCOFFEE it seems
I dunno if rakudo-j not building is considered a release blocker, offhand...
then I'm working on an it-would-be-nice feature, mostly just to make sure uncurse didn't cause it
it does compile CORE.c, just not CORE.d
one must have a robust timesharing model in one's brane to do any development for jvm, though
or sit around a lot...
one can get an amazing amount of backlogging done during a single jvm build...
hmm, three days ago spectest on rakudo-j was mostly clean (1 flapper) on my box. so, I'm pretty sure it was the ncurse merge
I'm not saying, it should be a release blocker, though
was a recursive exception, so might or might not have been my fault, since other folks have been dealing with exceptions lately
ah ok, I didn't take a look at the latest commits, yet
first step will probably be to put an infinite regress blocker into the exception to at least get me a decenter stack trace
actually, 0th step is to take off my 3-gig limit, since javac apparently can't run in 3 gig...
I've seen a ArrayIndexOutOfBoundsException somewhere. The one place I remember this error happening is here
j: my (\foo) = 42
rakudo-jvm fb4f16: OUTPUT: «===SORRY!===␤java.lang.RuntimeException: java.lang.ArrayIndexOutOfBoundsException: -1␤»
that looks familiar
ACTION doesn't know if that helps somehow
j: my \foo = 42
rakudo-jvm fb4f16: ( no output )
so only inside parens...
it's from S04-declarations/my.t -- RT #126626
Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=126626
j: multi sub await(Awaitable:D \a) { }
rakudo-jvm fb4f16: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Invalid typename 'Awaitable' in parameter declaration.␤at <tmp>:1␤------> 3multi sub await(Awaitable:D7⏏5 \a) { }␤    expecting any of:␤        pair value␤»
j: multi sub await(Any:D \a) { }
rakudo-jvm fb4f16: ( no output )
well, that seems okay
ah, it might be possible to get a better error message by removing the if/else here and just throw ExceptionHAndling.dieInternal:
https://github.com/rakudo/rakudo/blob/c630548c6ef4be8235c92e74e80db69a1172fc49/src/vm/jvm/runtime/org/perl6/rakudo/RakudoContainerSpec.java#L66
ACTION has to take care of the kids now, bbl
thanks
rakudo-jvm fb4f16: OUTPUT: «===SORRY!===␤java.lang.RuntimeException: java.lang.ArrayIndexOutOfBoundsException␤»
rakudo-jvm fb4f16: OUTPUT: «===SORRY!===␤java.lang.RuntimeException: java.lang.ArrayIndexOutOfBoundsException␤»
rakudo-jvm fb4f16: OUTPUT: «===SORRY!===␤java.lang.RuntimeException: java.lang.ArrayIndexOutOfBoundsException␤»
ACTION guesses this one is easy to fix once we find it, but finding it is like looking for a needle in a nuclear power plant
ACTION vaguely remembers there was some flag to get better stack traces for the java runtime part
pmurias: --ll-exception?
there is some other env variable
weird, putting a BEGIN at the start of gen/jvm/CORE.d.setting has no effect, so it's blowing up before it ever parses the file, it would seem
but after emitting "Stage parse"
during the install of CORE.setting perhaps?
I get "Type check failed in assignment to '$DID_MATCH'" after changing RakudoContainerSpec.java (see link above)
well, that's definitely uncurse territory
ACTION testing a patch
slowly...
bartolin++
we just want it to be your fault the release is delayed, not ours :P
at least I did get you a slightly faster compile...
.oO( What's Zoffix doing inside of me?! )
I'll get a MoarVM release later this evening :)
I dunno, it's too dark to hack
hah :)
Full marx for that reference.
I guess I woke up groucho this morning.
.oO(I wonder how different the world would be if Karl Marx had been spelled Carl Marks.)
fudging seems a lot slower than it used to be...is that just cuz we have more tests?
maybe it's just that javac throws out all the OS's cached disk blocks...
I mean, merely by being about as big as my physical memory, not explicitly
Geth, ver https://github.com/rakudo/rakudo/commit/822566f1ade5af59dc69ff264609bf75f0bf0f7e
Geth, ver https://github.com/rakudo/rakudo/commit/20af51fef936201ec4953c4229f08b957b5f3835
Geth, ver https://github.com/perl6/nqp/commit/6432a25e6e3d5f517aad91ac3b3a3c747b54f82e
maybe someone should write a make-based fudger that only fudges the files that have changed since last time
maybe our current fudger could compare modification times, if it doesn't already...
or maybe trying to run 6 jvm tests in parallel on a 4-core machine is just a really bad idea...
ACTION wonders what percentage of reductions could now write directly to the capture rather than the cstack because they never backtrack...
m: for ^100_000 { $ = Broken ~~ Broken }; say now - INIT now
rakudo-moar c1804b: OUTPUT: «0.1134946␤»
m: for ^1000_000 { $ = Broken ~~ Broken }; say now - INIT now
rakudo-moar c1804b: OUTPUT: «1.0276929␤»
m: for ^1000_000 { $ = Broken ~~ Broken }; say now - INIT now
rakudo-moar c1804b: OUTPUT: «1.0442514␤»
m: for ^1000_000 { $ = Broken ~~ Broken }; say now - INIT now
rakudo-moar c1804b: OUTPUT: «1.054790␤»
#
#
m: for ^1000_000 { $ =  }; say now - INIT now
rakudo-moar c1804b: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Missing required term after infix␤at <tmp>:1␤------> 3for ^1000_000 { $ =  7⏏5}; say now - INIT now␤    expecting any of:␤        prefix␤        term␤»
m: for ^1000_000 { $ = $ }; say now - INIT now
rakudo-moar c1804b: OUTPUT: «0.5083870␤»
m: for ^1000_000 { $ = $ }; say now - INIT now
rakudo-moar c1804b: OUTPUT: «0.5021346␤»
m: for ^1000_000 { $ = $ }; say now - INIT now
rakudo-moar c1804b: OUTPUT: «0.51106573␤»
m: for ^1000_000 { $ = Broken }; say now - INIT now
rakudo-moar c1804b: OUTPUT: «0.49186044␤»
m: for ^1000_000 { $ = Broken }; say now - INIT now
rakudo-moar c1804b: OUTPUT: «0.4993444␤»
m: for ^1000_000 { $ = Broken }; say now - INIT now
rakudo-moar c1804b: OUTPUT: «0.500818␤»
#
#
m: for ^1000_000 { $ = Broken ~~ Broken }; say now - INIT now
rakudo-moar c1804b: OUTPUT: «1.037881380␤»
m: for ^1000_000 { $ = Broken ~~ Broken }; say now - INIT now
rakudo-moar c1804b: OUTPUT: «1.05187830␤»
m: for ^1000_000 { $ = Broken ~~ Broken }; say now - INIT now
rakudo-moar c1804b: OUTPUT: «1.0619318␤»
c: HEAD for ^1000_000 { $ = Broken ~~ Broken }; say now - INIT now
c: HEAD for ^1000_000 { $ = Broken }; say now - INIT now
#
#
c: HEAD for ^1000_000 { $ = Broken }; say now - INIT now
c: HEAD for ^1000_000 { $ = Broken }; say now - INIT now
c: HEAD for ^1000_000 { $ = Broken }; say now - INIT now
c: HEAD for ^1000_000 { $ = Broken }; say now - INIT now
#
#
c: HEAD for ^1000_000 { $ = Broken ~~ Broken }; say now - INIT now
c: HEAD for ^1000_000 { $ = Broken ~~ Broken }; say now - INIT now
c: HEAD for ^1000_000 { $ = Broken ~~ Broken }; say now - INIT now
c: 2017.03 for ^1000_000 { $ = Broken ~~ Broken }; say now - INIT now
c: 2017.03 for ^1000_000 { $ = Broken ~~ Broken }; say now - INIT now
c: 2017.03 for ^1000_000 { $ = Broken ~~ Broken }; say now - INIT now
c: 2017.03 for ^1000_000 { $ = Broken }; say now - INIT now
m: say (1.98-.462)/(.99-.462)
rakudo-moar c1804b: OUTPUT: «2.875␤»
well, uncurse is about getting rid of the Cursor object by merging Match and Cursor together
rakudo-moar c1804b: OUTPUT: «Match␤»
it was effectively done the other direction, then Cursor was renamed to Match, but close enough :)
b
m: grammar G { token TOP { (<list>) }; token list { .+ } }; say G.parse('xxx')
rakudo-moar c1804b: OUTPUT: «｢xxx｣␤ 0 => ｢xxx｣␤  list => ｢xxx｣␤»
c: 2017.03 grammar G { token TOP { (<list>) }; token list { .+ } }; say G.parse('xxx')
https://github.com/rakudo/rakudo/commit/3487674be9684c926b2553d1159525fdaacdeb1e
NeuralAnomaly, status
NeuralAnomaly, status
oh hey
hey hey hey hey
why don't we have .link take a Pair as argument
link($linkfile => $existingfile)
Zoffix: we have Enum ~~ Enum, and a bit later Numeric.ACCEPTS(Any), care to unify that?
OK
yeah, but one says ACCEPTS, the other says ~~
you could mention the profiler being fixed (that's an nqp commit)
the allocations tab hadn't worked for a while, does now
well, the allocations, gc, and OSR tabs weren't working at all
did the last changes for the sql profile land in nqp master yet?
not yet
i could merge the minor changes i've made so far. haven't finished the more extensive stuff we've talked about
hmm, probably not very important to get the first bits into the release
yeah, figured it would make more sense as an actual upgrade in capability
right
and by next release we might even have an application to go with it
oooo, got something up your sleeve?
nope
just hoping someone might get inspired i guess
we might salvage the qtprofiler to (also?) be able to open the sqlite files
that would be nice
yay
tell me of this qtprofiler timotimo
find it in tadziks github
k
we made it because the html profiler was extremely slow
don't i know XD
heh
but the qtprofiler uses a json parser that has a random limit for filesize
which is maximum annoying
can that be changed?
qt has some fast string things. their utf-8 decoder has SIMD optimizations for tons of processors
yeah, you can probably plop in a different json parser
oh does qt have its own json parser
it uses QJsonDocument
it might. it has everything
that seems to be qt's json parser
k
i think the filesize limitation is in qdocument, not the actual json parser part
ah
https://bugreports.qt.io/browse/QTBUG-47629 - nobody seems to care about it
i recompiled qt and increased the limit, but i couldn't increase it very much
Without the support of storing large amounts of data QJson classes automatically turns into ice cream in a glass.
You look at it, it looks delicious but you can not lick.
XD
enum {
639         MaxSize = (1<<27) - 1
640     };
argh qt why you do dis
Please contact your system administrator.
Zoffix, i am contacting you as instructed
now please contact yourself
omg it's. happening
dunno if i've been on live during the build before
"back in my day, we did those commits by hand, and we LIKED it."
how to best generate a huge profile file
that won't work with qtprofiler
profile building rakudo
that's the exact thing that prompted me to create the sql output
how do i do that MasterDuke_
just re-run the command immediately before "stage start", but add --profile-compile
how much ram do you have? you're probably going to run into problems if you don't have at least 8gb
16gb
add it to the makefile?
i just copy it and run it directly from the command line
oh
NeuralAnomaly, status
why does it feel like it's compiling moarvm again
(which we used to do by hand, at least twice. :)
Zoffix++ again, for automating this grunt work.
and making it... less grunty?
MasterDuke_, moar --libpath="/home/samantha/perl6/share/nqp/lib" --libpath="/home/samantha/perl6/share/nqp/lib" perl6.moarvm --profile=blah.json --nqp-lib=blib --setting=NULL --ll-exception --optimize=3 --target=mbc --stagestats --output=CORE.setting.moarvm gen/moar/CORE.setting
like this?
is it at the right position?
that should be it, but you need --profile-compile in there, too
i tried putting it first but it wasn't having any of that
and i think --profile-filename
it needs to go after perl6.moarvm
--profile-compile --profile-filename=foo.json
thx
but yeah, the memory usage from that si rather massive
good
or bad i guess. well. i will monitor it
well up to 3.3GB
thing is that we have one entry in our call graph for every path to a routine
that's ... not so eloquently put
i just mean that every routine can be in there as many times as there are different paths to the main function
i.e. if you have sub a { a }; it'll generate infinitely many entries in the call graph
that's a lot
okay, it'll *try to* generate infinitely many entries :)
also, for every gc run we build a little data structure entry
i'm not sure how often the gc runs during setting compilation
but i imagine it'd be a whole lot
so much frreezing
should have closed chrome
how did it use 17GB of swap...
i'll try with telemetry
howwww
omg
oh
you can sidestep most of the optimizer with --optimize=off
ACTION quits chrome while system is not frozen
that'll make the call graph a bunch smaller
right now it's just saying writing profiler output to foo.json
and swap usage is down to 9GB at least
because the optimizer walks the whole ast and it'll have as deep a call graph as the ast is deep
at least i'll get a really big json?
1326 lines of "gc finished" in the telemetry log
ruh roh
whoops
feels like my system is getting murdered
freezes periodicly for unknown amounts of time
yeah
samcv: --target=parse will also make it a little quicker/use less ram
samcv: it's still writing out the json file? i *think* it spits out pieces of the json before it finishes, but i'm not sure
yeah idk
it does
it's hovering between 8GB and 9GB swap. and sti/ll using 90% of ram usage
it was at 16GB of swap usage...
but foo.json is still 0 bytes
i will go away for a while. and hope my system is not on fire when i get back
OK, i see
well, the --target=ast hint is good, and the --optimize=off tip is an alternative to that
the telemetry log for core setting build is 99% gc timings and a tiny amount of string reads and writes (but the writes are only the stage stats)
this is my last perf report of a compile: https://gist.githubusercontent.com/MasterDuke17/aff44a22a3a22d3ce0bf476d1d0ba537/raw/22869d54efcf5d82facfc85678b0aab49771ff5e/compile.report_no_call-graph_no_children
whee!!!  just in time  :-)
ACTION waves from Copenhagen
oh welcome back lizmat
ACTION will now try to finish the P6W in the next hour or so
timotimo, there's no way it's gonna be more than likie 5GB of json right?
i only have 5.7Gb of space left on disk
NeuralAnomaly, thanks baby
aww.
oh well it's finally gottan some stuff to disk. json file is at 307MB so far
MasterDuke_, what's the biggest json you ever got
one time, i pulled this GIGANTIC JSON
i could barely hold it in my arms
then i brought it to this fantastic restaurant and they prepared it real fine
LOL
this one is getting much better than i wanted
they grow up so fast
did it reach a gig yet?
getting close
swap use went back up to 14G too. and still full mem usage (16GB)
so much memory
yeah, the nature of how we jsonify means we're not really freeing stuff up
maybe we can go through lists shifting off elements rather than just iterating through 'em
that'll mean parts of the call graph that are no longer interesting will natuarlly be GC'd
yeah
and they told me i had too much swap... you'll never need 32GB of swap they said
proved them wrong!
haha
i've hit 1.1GB
i don't remember how big they've been
have you used up 32GB of memory total before?
so the .html are just json embedded in the html? with a javascript thing to graph it?
holds the same data as the json right?
yep
ok memeory dropped off a cliff. i think *hope* it's done
and the best thing about it
\o/
in order to put it inside the javascript, we have to escape one extra bit
fuck
because browsers will absolutely explode when we just put it in as a literal
what do we have to escape?
like "
and of course \
but it's already javascript json right?
shouldn't it like already be fine?
if put in between the right tags?
or html doesn't let you?
hm
Malformed input file, top level isn't an array: "too large document"
i suppose you could, and then grab the string from the dom
that did it
though
no, that's probably bad
we'd then have to escape < and > at the least
and &, too
X|
i think i'll go to bed soon-ish
samcv: how big did the file end up?
1.2G
samcv: wanna try loading it with JSON::Tiny or JSON::Fast? :D
though we might only have to escape a </script> string actually
oh god
timotimo, https://jsfiddle.net/YmhZv/14/
i think this works
see how i escaped the </script>
i think it will ignore any other thing except </script>
cause it needs matching tags
i get "Hi" there
yes
if you remove the escaping
and hit run
Uncaught SyntaxError: Unexpected token a in JSON at position 152
at JSON.parse (<anonymous>)
what escaping?
a sql profile from feb was 770mb and 13million lines
timotimo, line 6
<\/script> if you remove the backslash and hit run
the text shows up
then i get "i should not exist"
yep
because it reads the </script tag embedded inside the json
yeah but if the code worked it shouldn't say "Hi"
it should say "awesome"
yeah the code doesn't work
that's not the point!
lol
%)
you could have told me that before
feel free to make the code work
but timotimo  the "Hi" is the 1st line.
and it's not inside the script. so it should always show
no, you're replacing it with "result: awesome"
that's how .text works
k
well please fix code
if it's not too much trouble. you know this better than i do
i'm sure the " inside the script tag are bad
because they're already inside a string literal
oh
and there was a trailing , in there as well
but the " would already have been escaped
https://jsfiddle.net/YmhZv/17/ - do you get my changes?
in our moarvm right?
yes
somehow
well, the code works now
we have full control over how we escape things
but we escape once because json right
and then again to get it inside html
but if we put it in script tags, then we only have to escape </script> maybe.
that would be nice though
we don't actually escape "again", we immediately replace " with \\\" or whatever
oh
so not too much effort?
ok
probably not
ugh i'm so hungry
browsers have it hard man
i think it'd just be "kick out the special code we had in place for the json-in-javascript-string mode"
is it because mrario keeps coming over and throwing them into bombs and spikes and lava pits?
browsers are very much abused
no
AFK, BBIAB
okay, so
how many bytes do we save from this, i wonder
hm?
by getting rid of those escapes
whoa
we have a --profile-stage commandline switch?!
? what does that do?
only profiles a single stage
whereas with --profile-compile you get "the beginning to this particular stage, and also the program ends here"
cool, never knew that existed
hmm. i wonder, though
that uses run_profiled, which installs an end phaser to get the profile data dumped
like, it installs a value in @END_PHASERS from the perl6 hll
oh
but the core setting is also already perl6 code
how did i forget that?
well, at the beginning it's still basically nqp, and by then end it's Perl 6 :)
well, the syntax is Perl 6 at the beginning, fwiw
right
here's hoping that making to_json in the profiler destructive will be positive for memory usage
ACTION shuts down a few programs
positive in a negative sense.
13823988maxresident  -  this is with --optimize=off, which i claim is important
so basically, pretending there's no spesh or jit...
or is that aimed somewhere else?
oh, no, that's just skipping Perl6::Optimizer
ah
profiling a rakudo compile?
timotimo, i'm trying to load the 1.2G profile with json::fast
it'll take like 100 years right?
no idea
JSON::Fast is kinda fast
um ... it didn't actually profile at all?!
no, it did profile, but ... it didn't write a file?!
what even ...
i mean, it took way longer
oh, it did get oom'd
without telling me so on the commandline
well, ain't that friendly
13794460maxresident
but i can't really compare those
time to make some more swap.
ok i'm killing it. i'm at 2GB swap so 18GB total ram usage now
and another Perl 6 Weekly hits the Net: https://p6weekly.wordpress.com
https://p6weekly.wordpress.com/2017/04/17/2017-16-io-hits-the-road/
"Please have the appropriate amount of more efficient fun!" :-)
i like that lie
*line
hahaha
breaking: perl6 dev admits to perl6 being slow
haha
that's not a new thing!
ACTION is *very* tired after driving 1K km and goes to get some shuteye
sleep well
oh crap, there isn't even much space left on my external hard drive?
oh, taht's not my external hard drive
now idk what to do with this 1.2GB json file :\
lizmat++
i can't do anything with it sanely
maybe compile a modified qt that doesn't have a limit?
samcv: you've used abs?
oooh
someone claimed perl6weekly.wordpress.com and the only post says "you're looking for p6weekly.wordpress.com"
what? arch build system?
if so then yes
hah
yeah, that's how i build a modified qt when i was experimenting with upping that limit
oh
did it work?
i was able to change the 1<<27 to something like 1<<30
oh
don't think i tried just removing that check altogether though...
do i need qt5-base
i think? it was a while ago i was messing around with that
ok. i checked it out of the svn
just search for 1<<27?
it's line 639 of some file
that's very specific
going off of what timotimo pasted, i assume he grabbed the line number from vim
oh
ok i found 1<<27
on exactly that line. heh
here comes the hang
cpu usage has drastically decreased, unsurprisingly
nice
what's nice about that? :D
the cpu usage decreased
well ... yeah ... because it's waiting for data to be shoveled in from swap and back again
oh. lol.
!
d'oh, it's reaching the amount of swap i have soon
6.7g of 8.25g
uh oh. you need more swap
i do
i used up 16GB maybe more
no more than 18GB tho
writing profiler output!!!
yep :)
MasterDuke_, gonna try removing all the checks that seem sane to remove
cause some things like failure to realloc or malloc can trigger documenttoolarge errors, so i didn't touch those ones though
in qt?
yes
but commented out a few places that seemed arbitrary
interested to see what you find
i want to go to bed soon ... but the thing is still running :|
go to bed. it might be done in an hour
hah.
in theory it'd be faster because i'm throwing out list items and hash keys/values while creating the json
so consecutive gc runs will have slightly less work
oh, huh, the json file is still at 0 bytes?
if it's better can do the same for to_sql
argh still too large document
samcv: one idea is to switch from a JSONDocument-like API to a stream-like API
where the size of the document is practically irrelevant
yeah
let's just do a memory dump
like microsoft word does
sorry that made only 1/4 of sense. ignore that
kch kch kch
word hasn't done that in a while
I am pretty sure the xml-ish format they use now is not what they have in memory :)
yeah they don't anymore
nah, they still dump the memory, but they put some random xml tags around pieces of it :P
hahaha
also they've actually been addressing the "but it doesn't behave the same on windows vs. mac"
(I still suspect it's because they switched to the mac version as the main one... because the old one was a horrid trainwreck that derailed development of windows 8 because some of their streamlining uncovered bugs that had been patched around in the OS during the "office is our cash cow, office devs an do anything they want" phase.)
i think swap usage is slowly dropping
just wait
it'll end up being at like 0.05% cpu usage
i had that happen then after it went down for a while it went back up. has it actually started outputting the json?
let's see.
nah, still 0 bytes
doesn't help that i'm also creating a new swapfile on one of the disks where there's already an active swapfile
oh wow
why not update my laptop's packages on the side
just a download of 1.3 gigs
Disk Requirements:
At least 169MB more space needed on the / filesystem.
i've got so much swap now
.tell pmurias i think NQP_VERBOSE_EXCEPTIONS=1 is what gives better jvm errors
MasterDuke_: I'll pass your message to pmurias.
.tell [Coke] i think NQP_VERBOSE_EXCEPTIONS=1 is what gives better jvm errors
MasterDuke_: I'll pass your message to [Coke].
.tell TimToady i think NQP_VERBOSE_EXCEPTIONS=1 is what gives better jvm errors
MasterDuke_: I'll pass your message to TimToady.
well i got it to 14% of my mem usage (qt)
and then i get too large document error
m: say 1:
rakudo-moar 241831: OUTPUT: «HERE:␤- sym: :␤- O: ␤␤1␤»
bisectable6: say 1:
bisectable6: old=2017.03 say 1:
c: 2017.03,HEAD say 1:
this ^^^ was talked about over in #perl6, https://github.com/rakudo/rakudo/blob/nom/src/Perl6/Grammar.nqp#L4504 introduced in https://github.com/rakudo/rakudo/commit/cdd625b68c24fd68789be2890a418ca1c4018b7b
ACTION guesses that probably snuck in at some point due to hitting 'u' one too many times in vim, since it certainly wasn't part of the uncurse effort...
02:42Z <MasterDuke_> TimToady: if you backlog here https://irclog.perlgeek.de/perl6/2017-04-18#i_14443061, was this intended?
probably one of the earlier 'useless use' thingies that I backed into
course, I'm starting to get to the age where I can just blame brainrot...
YEAH, YEAH, YEAH, YEAH! I just managed for the first time to run Inline::Perl5's test suite using moarvm, nqp, rakudo _and_ Inline::Perl5 installed from RPM packages.
This is it! The culmination of 16 months of working on precomp stuff
Yesterday evening I was already so close. I got the RPM to work with my manually compiled rakudo but not with the one installed from the RPM. Turns out I had a workaround in that package that deleted the precomp files for CompUnit::Repository::Staging itself.
Looks like I don't need that workaround anymore :)
Now the work on packaging Perl 6 modules and submitting to openSUSE can start in earnest. And now that deployment is sorted out we can start using Perl 6 and Inline::Perl5 in production at work.
yay!
nine, yay
very nice, nine++
do we need a point release?  prolly need one for my debugging flub anyway...
people are likely to have used 'method $obj: @args' in the ecosystem
ACTION is a little surprised no test caught this, but I guess the harness just tends to ignore stderr
ok so i got my appimage build attempting to install every module
into an appimage
TimToady: no, I'm lucky. The workaround was in my .spec file :)
still going https://travis-ci.org/samcv/rakudo-appimage/jobs/223029739#L2701 not sure how long will take to finish or the best way to record which were uninstallable.
darn, I was hoping I wouldn't be the only reason for a point release :)
so i can make some sort of uh. ecosystem warning system idk
it installs them not as an appimage but before it's made btw. so that affects the results not
i guess i can make it a gh-pages thing like i did for the appimages and for moarvm coverage
hopefully travis ci doesnn't stop the build before everything is installed. if it does i'll probably have to split the build up or something
also nine you know about modules. is there a file that would be best to look at after i have tried to install all the modules, so i can get a list of what actualy installed and compare it to the full list?
ruh roh
TimToady, what's a good percentage of eco modules acceptable to be failing
out of the total
i mean 0 would be nice but seems a bit unrealistic
um, 0 would be good :0
I suppose it depends on why they're failing
well they shouldn't fail. i mean
not a good thing
if they're failing due to extraneous debugging info, well, I know where that came from :)
hm
if they don't like the new I/O for some reason, that's something else
so far IO::Prompter, Math::ContinuedFractions, List::Utils, Text::Diff, BioInfo:ver('0.4.3'):auth('Matt Oates'), Math::PascalTriangle:ver('0.1.0'), DateTime::Math Flower, Hinges
if they happen to think Cursor and Match are different types, well...
are failing. out of those travis has tested
https://travis-ci.org/samcv/rakudo-appimage/jobs/223029739#L3524 what is this. possibly recent change?
t/math.t ..1/17Ambiguous call to 'infix:<->'; these signatures all match:
:(DateTime:D \a, DateTime:D \b)
:(DateTime:D $a, DateTime:D $b)
that doesn't sound that great
dunno, but if DateTime is malfing, that could easily take down a number of other modules
yea
This is Rakudo version 2017.04-2-gc9ebfc202 built on MoarVM version 2017.04
csv-ip5xs        3.182
test            12.651
test-t           5.111 - 5.118
csv-parser      13.127
BTW, I testted all of mine on Saturday so that's about 7% passing :)
hehehe you have 7% of all modules?
o.O
well, we could've broken them since Saturday :)
some of the have no plan in tap output
list::util has t/08-combinations.t ....42/?Type check failed in binding; expected Positional but got Seq ((["a", "b", "c"],
yeah 7.63% it appears ;-)
heh my job has now been terminated X|
will have to randomize which modules go each time. or maybe split them up between two jobs idk
it was over 10% at some point last year, but I slowed down
well, maybe we'd better see the downstream fallout over the next day or two; a lot of people hacked on a lot of things over the last month
RabidGravy: did yours all work, or did you have to tweak 'em?
a couple of tweaks, the symlink semantics bit in one place and there was something with IO::Path.append that needed more coercing
Math::ContinuedFractions appears not to download from github
nothing like "lexical import" though
huh, can't get IO::Prompter either, maybe my zef is screwed up or too old
or maybe github is screwy at the moment
well it installed or tried to install 95 modules
so that's not bad for one travis run. we have 700 right?
just gonna need at least 7 travis builds XD
86 pass and 11 fail. so
that's not good statistics so far :O
samcv: I'm not sure I understood your question
uhm. there's a json file that keeps track of what's installed right. as far as modules goes?
here's the test results https://gist.github.com/samcv/835b0640ef91c3f3617f34771e230b6e
812
so that's an 8.8% failure rate out of the modules it had time to install
RabidGravy, modules total?
yeah
phew, none of mine in the FAIL list
;-)
time to uhm. i guess. split it into 10 builds
i'll sort the modules alphabetically and then choose 1/10 of a section to try and install
samcv: Well there's a dist's meta data that's stored in the repo. But I'm not sure what exactly you're after. What do you mean by "full list"?
what is installed
a list of everything installed i can process programically
though i could do zef list --installed i guess. maybe that's the best way? but i do want to know the file it's stored in too. since that with help with other things
m: say $*REPO.next-repo.installed>>.meta
rakudo-moar c9ebfc: OUTPUT: «({auth => github:niner, author => github:niner, authors => [Stefan Seifert], depends => [LibraryMake], description => Use Perl 5 code in a Perl 6 program, files => {resources/libraries/p5helper => 2F6B236B77BC9D0E77C1B73DBAFA53E81D238E83.so}, license => …»
samcv: ^^^
thx
IO::Prompter is using ancient syntax ('as') in a signature
Math::ContinuedFractions appears to just be producing wrong results
Text::Diff is failing with: No such method 'succ' for invocant of type 'List'
so seems to be a variety of reasons
yeah
c: c9ebfc2023b1 class Foo {}; new Foo
committable6, come on, you fuck
c: HEAD say "hi"
....
c: 2017.04 class Foo {}; new Foo
m: class Foo {}; new Foo
rakudo-moar c9ebfc: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Unsupported use of C++ constructor syntax; in Perl 6 please use method call syntax␤at <tmp>:1␤------> 3class Foo {}; new Foo7⏏5<EOL>␤»
m: class Foo {}; new Foo:
rakudo-moar c9ebfc: OUTPUT: «WARNINGS for <tmp>:␤Useless use of "new Foo:" in sink context (line 1)␤»
m: class Foo {}; $ = new Foo:
rakudo-moar c9ebfc: ( no output )
c: class Foo {}; $ = new Foo:
c: HEAD class Foo {}; $ = new Foo:
c: HEAD class Foo {}; $ = new Foo:
committable6,  HEAD class Foo {}; $ = new Foo:
committable6, 2017.03 class Foo {}; $ = new Foo:
06:05Z <bartolin> Zoffix: unfortunatly 9d8e391f3b (rakudo) does not work on JVM: Unknown encoding 'utf8-c8'. One option would be to add a workaround for JVM there ...
06:28Z <TimToady> Zoffix: We'll probably need a point release before doing Star, 'cuz I screwed up the 'new Foo: ...' syntax by leaving a debugging line in (after worrying about all the heavy stuff, wouldn'tchya know it'd be something stupid)
c: HEAD class Foo {}; $ = new Foo:
Zoffix: I'll pass your message to AlexDaniel.
u: test
Oh and once we've got all Perl 6 modules in the Open Build Service, we could use that for smoke testing the whole ecosystem. Because the build service will rebuild packages on changes to their dependencies.
.
07:43Z <Zoffix> AlexDaniel: something's wrong with committable6. Doesn't respond. I tried running ./verify-and-unfuck but it seems to just sit there; I tried deleting the "deleteme" file; but nothign helped
hmm these aren't the files you should use for such situation, actually XD
dammit I have to clean it up
Zoffix: yes, it is ｢rakudobrew build moar｣
hm, it failed it on HEAD
which was 4 hours ago
e: say 42
ah-ha
i can't report issues here https://github.com/colomon/io-prompter
there's no issues tab X|
c: HEAD^ say 42
c: HEAD say 42
alright, this should fix itself ≈3 minutes
oh noes
this is… horrible actually
are we going to have a 2017.04.01 to fix that?
omg this module is so bad
Type check failed in binding to parameter '$in'; expected IO but got <anon|94140617225856> (<anon|94140617225856>...)
io::prompter. with `:d(:$default) as Str = "",` as a parameter
at least fixing that parameter makes more than 0 tests pass?
e: say 42
alright
Zoffix: thanks!
ok will have to fix some IO related stuff in this module
arghhh
class StubIO is IO
ok. i think i can safely change these to IO::Handle's too
now all but one test file works
checked another one off. https://gist.github.com/samcv/835b0640ef91c3f3617f34771e230b6e
of failing modules
can we get an intern
failing modules :X
just made a PR due to IO breakage from that one module
uh. not purposefully.
they are just only the ones that completed/failed before travis ended the build
i tried to install every single module
Zoffix, can you or somebody write me some code to divide an array holding all 700 or so module names into sections?
so i can set an ENV variable to a number (number of builds) and another to which build it is.
rakudo-moar c9ebfc: OUTPUT: «((1, 2), (3, 4), (5, 6), (7, 8), (9, 10)).Seq␤»
so NUM_BUILDS=10 then it splits the array into 10 sections
rakudo-moar c9ebfc: OUTPUT: «((1, 2, 3), (4, 5, 6), (7, 8, 9), (10,)).Seq␤»
and BUILD_NUM=2 then it needs the 2nd section of that array
and only build that section. and also make sure that the 10th or last one will get ones that are in addition to the divisor
err remainder type things
hm
that seems good
thank you kindly. :partial is critical :) did not know that one. was trying to hack something and it ended up being error prone
rakudo-moar c9ebfc: OUTPUT: «(23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33)␤»
m: %*ENV<NUM_BUILDS BUILD_NUM> = 10, 10; my @a = 1..100; dd (@a.rotor: @a/(%*ENV<NUM_BUILDS>-1), :partial)[%*ENV<BUILD_NUM>]
rakudo-moar c9ebfc: OUTPUT: «Nil␤»
m: %*ENV<NUM_BUILDS BUILD_NUM> = 9, 10; my @a = 1..100; dd (@a.rotor: @a/(%*ENV<NUM_BUILDS>-1), :partial)[%*ENV<BUILD_NUM>]
rakudo-moar c9ebfc: OUTPUT: «Nil␤»
m: %*ENV<NUM_BUILDS BUILD_NUM> = 10, 9; my @a = 1..100; dd (@a.rotor: @a/(%*ENV<NUM_BUILDS>-1), :partial)[%*ENV<BUILD_NUM>]
rakudo-moar c9ebfc: OUTPUT: «(100,)␤»
m: %*ENV<NUM_BUILDS BUILD_NUM> = 10, 8; my @a = 1..100; dd (@a.rotor: @a/(%*ENV<NUM_BUILDS>-1), :partial)[%*ENV<BUILD_NUM>]
rakudo-moar c9ebfc: OUTPUT: «(89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99)␤»
m: %*ENV<NUM_BUILDS BUILD_NUM> = 10, 1; my @a = 1..100; dd (@a.rotor: @a/(%*ENV<NUM_BUILDS>-1), :partial)[%*ENV<BUILD_NUM>]
rakudo-moar c9ebfc: OUTPUT: «(12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22)␤»
m: %*ENV<NUM_BUILDS BUILD_NUM> = 10, 0; my @a = 1..100; dd (@a.rotor: @a/(%*ENV<NUM_BUILDS>-1), :partial)[%*ENV<BUILD_NUM>]
rakudo-moar c9ebfc: OUTPUT: «(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11)␤»
c: 2017.04 class Foo {}; $ = new Foo:
Geth, help
Zoffix: I'll pass your message to bartolin.
Zoffix: I'll pass your message to TimToady.
nine: On Rakudo latest I'm seeing:
An exception occurred while evaluating a constant
at /home/travis/build/edumentab/rmtly/site#sources/F6A76DDBC4B3F739D1B0D02B0403CF4AEB0CBC07 (Digest::SHA1::Native):5
Exception details: No such method 'absolute' for invocant of type '<anon|863819600>'
That line is https://github.com/bduggan/p6-digest-sha1-native/blob/master/lib/Digest/SHA1/Native.pm6#L5
I think you changed something in this area recently?
jnthn, i'm getting all the eco modules tested
well trying. i split it into 10 pieces to have travis ci do
so hopefully then we can get numbers for every single module
thanks Zoffix for helping me with rotor, it's working beautifully so far
Sounds nice
very slow. but. will be a good starting point. and hopefully can get it so all builds complete
and then maybe upload the logs or something somewhere, or process them idk
one step at a time
though it seems impossible to install every module within 50 minute time frame for travis :( though i could hack it and commit a tar.gz to a branch, then trigger another build by commiting it
until they're all actually intstalled.
m: dd %?RESOURCES<libraries/sha1>
rakudo-moar 7e826f: OUTPUT: «Nil␤»
jnthn: indeed, that's caused by https://github.com/rakudo/rakudo/commit/d4d6a9976403c7a8339aaf44d3fb9e9656c28232 :/
That very line was changed some days back from .abspath :)
Wouldn't have mattered. Fix coming up
Do we have something like Moose's "handles" for delegating a whole bunch of methods?
Zoffix: that's definitely something for the point release
TimToady will be happy that he now has company :)
nine: yes, it's called handles :)
Or...maybe I should just mixin the Callable stuff. That way we stay very close to the original IO::Path object
Ah, no that's not possible as the point of the exercise is to defer creating the path in the first place
Haha, "handles" is excruciatingly well documented ;) https://docs.perl6.org/language/glossary#index-entry-handles
Ok, I will delegate these method calls: Str gist perl absolute is-absolute relative is-relative parts volume dirname basename extension open resolve slurp lines comb split words copy
I.e. everything that handles the path name itself or does read access on the file. I better not delegate anything related to permissions or modification of the file.
m: dd $!SPEC.is-absolute: '/'
rakudo-moar 7e826f: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Variable $!SPEC used where no 'self' is available␤at <tmp>:1␤------> 3dd $!SPEC7⏏5.is-absolute: '/'␤»
m: dd $*SPEC.is-absolute: '/'
rakudo-moar 7e826f: OUTPUT: «Bool::True␤»
c: 3487674be968~1  dd $!SPEC.is-absolute: '/'
c: 3487674be968~@  dd $!SPEC.is-absolute: '/'
c: 3487674be968~2  dd $!SPEC.is-absolute: '/'
c: 3487674be968~10  dd $!SPEC.is-absolute: '/'
c: 3487674~10  dd $!SPEC.is-absolute: '/'
c: fbc6697  dd $!SPEC.is-absolute: '/'
Now how can I lazily initialize this attribute?
c: fbc6697  dd $*SPEC.is-absolute: '/'
c: 3487674  dd $*SPEC.is-absolute: '/'
m: use nqp; class Foo { my $def = 42;  nqp::bindattr($def, Scalar, '$!whence', {say "inited"}); has $.foo = $def; }
rakudo-moar 41bb79: ( no output )
m: use nqp; class Foo { my $def = 42;  nqp::bindattr($def, Scalar, '$!whence', {say "inited"}); has $.foo = $def; }.new.foo
rakudo-moar 41bb79: ( no output )
m: use nqp; class Foo { my $def;  nqp::bindattr($def, Scalar, '$!whence', {say "inited"}); has $.foo = $def; }.new.foo
rakudo-moar 41bb79: ( no output )
m: use nqp; class Foo { has $.foo; nqp::bindattr($.foo, Scalar, '$!whence', {say "inited"});  }.new.foo
rakudo-moar 41bb79: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Variable $.foo used where no 'self' is available␤at <tmp>:1␤------> 3ass Foo { has $.foo; nqp::bindattr($.foo7⏏5, Scalar, '$!whence', {say "inited"});  ␤    expecting any of:␤        argument…»
m: use nqp; class Foo { has $.foo; nqp::bindattr($!foo, Scalar, '$!whence', {say "inited"});  }.new.foo
rakudo-moar 41bb79: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Variable $!foo used where no 'self' is available␤at <tmp>:1␤------> 3ass Foo { has $.foo; nqp::bindattr($!foo7⏏5, Scalar, '$!whence', {say "inited"});  ␤»
m: use nqp; class Foo { my $def;  nqp::bindattr($def, Scalar, '$!whence', {say "inited"}); has $.foo := $def; }.new.foo
rakudo-moar 41bb79: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Cannot use := to initialize an attribute␤at <tmp>:1␤------> 3nce', {say "inited"}); has $.foo := $def7⏏5; }.new.foo␤»
rakudo-moar 41bb79: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Cannot use := to initialize an attribute␤at <tmp>:1␤------> 3nce', {say "inited"}); has $.foo := $def7⏏5; }.new.foo␤»
I guess I have to use a Proxy?
m: use nqp; class Foo { has $!foo; submethod TWEAK { nqp::bindattr($!foo, Scalar, '$!whence', {say "inited"});  }.new.foo
rakudo-moar 41bb79: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Missing block␤at <tmp>:1␤------> 3 '$!whence', {say "inited"});  }.new.foo7⏏5<EOL>␤    expecting any of:␤        statement end␤        statement modifier␤        statement modifier loop␤»
m: use nqp; class Foo { has $!foo; submethod TWEAK { nqp::bindattr($!foo, Scalar, '$!whence', {say "inited"});  } }.new.foo
rakudo-moar 41bb79: OUTPUT: «No such method 'foo' for invocant of type 'Foo'␤  in block <unit> at <tmp> line 1␤␤»
m: use nqp; class Foo { has $.foo; submethod TWEAK { nqp::bindattr($!foo, Scalar, '$!whence', {say "inited"});  } }.new.foo
rakudo-moar 41bb79: ( no output )
m: use nqp; class Foo { has $.foo; submethod TWEAK { nqp::bindattr($!foo, Scalar, '$!whence', {say "inited"});  } }.new.foo
rakudo-moar 41bb79: ( no output )
m: use nqp; class Foo { has $.foo; submethod TWEAK { nqp::bindattr($!foo, Scalar, '$!whence', {say "inited"});  } }.new.foo = 42
rakudo-moar 41bb79: OUTPUT: «Cannot modify an immutable Any␤  in block <unit> at <tmp> line 1␤␤»
m: use nqp; class Foo { has $.foo is rw; submethod TWEAK { nqp::bindattr($!foo, Scalar, '$!whence', {say "inited"});  } }.new.foo = 42
rakudo-moar 41bb79: OUTPUT: «inited␤»
m: class Foo { has $.foo handles <bar>; method BUILD() { $!foo = Proxy.new(FETCH => method () { note "initing foo"; class :: { method bar() { "bar" } }.new }, STORE => method () { die }) } }; my $foo = Foo.new; say $foo.bar; say $foo.foo;
rakudo-moar 41bb79: OUTPUT: «initing foo␤bar␤<anon|60446032>.new␤»
rakudo-moar 41bb79: OUTPUT: «inited␤»
rakudo-moar 41bb79: OUTPUT: «started␤inited␤42␤42␤»
But methods delgated by "handles" won't go through the accessor
on it
hm, interesting
c: releases say 42
… that's not what I meant!
c: releases say rand
oh, what a good bot!
picked up 2017.04.1 automatically
ACTION pets committable6
11 seconds… that's getting slow
.oO( can we stop making releases so that I don't have to fix committable6? :P )
ok we're at at 18 failed modules now https://gist.github.com/samcv/835b0640ef91c3f3617f34771e230b6e
i have links for all 18 of them to logs of the failures
for convenience
more often used ones i moved to the top like datetime::utils datetime::math, list::Utils, then there's several math ones too
i gotta go to bed. all the travis builds have not completed yet. and looks like i'm going to have to make more than 10 builds to build all modules or maybe calculate dependencies some way to split them up differently...
anddd. why the hell not split it up into 20 builds! https://travis-ci.org/samcv/rakudo-appimage/builds/223119055 so will find out when i wake up what happened with that hahahaha
20? why not 100! abuse travis for all it's got!
also is it ok to have an issue open at https://github.com/perl6/ecosystem with failed modules so others can also edit it with updates?
discussion etc etc
samcv: why not?
very yes
will open issue
I've noticed that if you explicitly say that people are encouraged to edit your post, people will actually do it
yeah well. if it does 50 minutes that's fine. it tried hard
but i have seen it abort after like 27 minutes before
but also ;)
if they want they can throttle my builds or whatever :\ i mean
i'm seeing the same modules in like all 10 builds failing. so things must depend o nthem
well at least one thing from each part of the alphabet
i mean it needs to go somewhere.
Holy crap. Seems like I've even broken Inline::Perl5's test suite when it's _not_ installed from an RPM package
:X
Zoffix: sure, why?
Ok, only when I apply the change that should fix it for packaging.
ok well here we go. https://github.com/perl6/ecosystem/issues/318 i'm fine to remove it if there's somewhere that it can go instead that people might actually participate in it
maybe someday i can scrape git's email addresses and mass email the most recent commiters :X
might be annoying. haha. probably not gonna reort to that yet
o/ night
Passing a Callable to the "is native" trait is a great way to defer the creation of the path to the shared lib till runtime. It just has one drawback: NativeCall's guess_library_name will use the result of calling this object as-is and will not apply the $*VM.platform-library-name transformation.
I.e. resources/libraries/p5helper will stay as-is and not be transformed into resources/libraries/libp5helper.so (on Linux)
I want a less-than-minute time for stresstest!
Now I've got 3 options: 1. change guess_library_name to do the transformation - thereby robbing the user of this escape hatch, 2. have the Callable do that transformation itself, thereby tying %?RESOURCES closer to NativeCall's needs or 3. do the transformation in CompUnit::Repository::Filesystem::resource
2 has the disadvantage of having to guess if the transformation is necessary (it isn't for Installation repositories for example), same as guess_library_name does right now.
3 may break other existing code as it really changes the result of %?RESOURCES<libraries/foo>
maybe 4) Introduce a named type Resource or some such that is returned from %?RESOURCES lookups, and add a candidate for that in NativeCall's native trait?
jnthn: aaah, that makes so much sense it almost hurts :)
I guess "Distribution::Resource" is the obvious name
Seems reasonable, yeah
So after I thought about it, yeah, I *think* it's easy...
oops, wrong window
This also opens the door for moving the platform_library_name transformation into a repo-specific subclass of Distribution::Resource as it's only needed when the resource is loaded from a FileSystem repo.
12:42Z <El_Che> Zoffix: Thx, I'll do that. I was just starting to create the pkgs, but indeed beter to wait
rakudo-moar 41bb79: OUTPUT: «1.441558␤»
Unless there are test file which take longer than a minute by themselves?
i just did a parse on AlexDaniel's whateverable server in 51s
i would have thought the GCE could do it even faster
yeah, i just thought the individual cores would be a bit faster than that
his server has 3.4GHz cores
nine: you'll have to let us know the relevant numbers when you get your ryzen up and running
MasterDuke_: will do :) I've now ordered the cooler from another merchant. Today I finally got an email where the one I ordered at initially admitted to not knowing when it can be delivered. While at the same time still claiming a 2 day delivery time on geizhals.at, just like they did a week ago.
you didn't want to use the stock amd one? i thought they got a serious upgrade a year or two ago?
The 1800X doesn't come with a stock cooler. Also I just want the best (thus most silent) cooler I can get :)
huh, didn't realize that
and yes, silent is good. built a watercooling setup for the athlon 64 3400 i won from amd back in college and loved that i couldn't hear a thing
the profiling job i let run over night errored out with a dumb error from me not being careful enough about nqp ...
Oh how I hate the waiting. Ever since I decided to go for a really silent system, I notice the noise of my current one much more :)
but it helped me figure out that the majority of time is spent in the graph node preparation step
maybe i can find out how to make it nom less memory
post_process_call_graph_node?
yup
i wonder how big the id remap hash gets
line 122 could be moved down to 133, right?
for a micro-optimization
ah, indeed, that's a good idea
do you know if $node<id> is an int?
because if it is, we should perhaps use a native int array instead of a hash for the remap
pretty sure all the ids are ints
those are a thousand times more efficient when it comes to gc in memory-constrained environments
hm, except we stringify the $new-id-counter into $node<id>
line 144. how good is the gc about throwing away newly created variables?
it's very good
`my $shared_data := nqp::hash(...); $id_to_thing{$node<id>} := $shared_data;`. would it be any better as `$id_to_thing{$node<id>} := nqp::hash(...)`?
jnthn: many thanks for pointing out the issue and the help with the fix :)
at most a small difference
nine++ # yay, that should unbust my $dayjob app :)
As that part of the commit message was cut, the recommended way to access functions in bundled native libraries is now:
my constant $helper = %?RESOURCES<libraries/helper>; sub foo() is native($helper) { ... }
rakudo-moar 41bb79: OUTPUT: «Bool::True␤»
Older suggestions like %?RESOURCES<libraries/helper>.Str or %?RESOURCES<libraries/helper>.absolute will still work (but not with the Staging repo)
MasterDuke_: wait ... are those ids high numbers?
i think they are ...
timotimo: line 132: how expensive is try? does that ever not succeed?
timotimo: i don't think so. don't they just start at 1 and count up?
that's why i have a hash ...
try is very cheap when it doesn't get hit
no, those ids only start at 1 and count up because we have the id remap
if i hadn't somehow broken the compile i'd just quickly toss a debug print in there ...
i think moar internally uses memory addresses for the ids
because those are, conveniently, unique
in a profile of a rakudo compile from feb the max id in any of the tables is 5487
ah. too big for ints?
too big for "int", but they fit into int64
except on 32bit where int is int32 and pointer is also int32
m: say '/\'.ords
rakudo-moar 41bb79: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Unable to parse expression in single quotes; couldn't find final "'" ␤at <tmp>:1␤------> 3say '/\'.ords7⏏5<EOL>␤    expecting any of:␤        argument list␤        single quotes␤        t…»
m: say '/\\'.ords
rakudo-moar 41bb79: OUTPUT: «(47 92)␤»
just a quick debug output looks a whole lot like this:
id was 28719360
id was 41029576
so at least i can div by 8 to get the sizes down, but it's still huge
if i want to replace the hash with an array, it'll become the size of the ram you have, basically :P
now if i put in a quick pass first that finds the lowest id, that'd help a whole lot
you could rely on alignment a bit ;)
yeah, that's what i meant by divide by 8
alternatively i'll build id_remap out of two lists that i keep in sync; one has all the befores, the other has all the afters, and i keep it sorted by inserting into the right positions
yeah, was thinking about the same thing
hm, but if the max id is 5487, that is unlikely to be the culprit at all :|
so maybe what we should try instead is to make the post_process_call_graph_node function iterative instead of recursive
annoying, but if it's much faster/uses less ram...
Zoffix: the 1M$ question is if my commit broke the Staging repo stuff again. Now that I think of it, this could very well be. The fix would be trivial, but I have to go home to be able to test it.
should be relatively easy, no?
Just had another look and I guess it's fine, as I do not overwrite $!IO in the Proxy's FETCH. So it should run the code for every access. But a test would be good anyway.
create a branch for the point release
and when only the interestign commits have been cherry-picked into that branch
tag the tip of that branch as the point release
Why does there need to be something else? :)
Well, delete the branch I guess :)
Since the tag records what was releases
That's normal enough, though?
i'd assume other projects do it exactly like that
you're allowed to delete the branch because the tag keeps all the commits alive
I guess in the current case we want all commits anyway
hm, what were the details? i don't remember
The issue was that some things are incorrectly expecting a simple linear commit history for rakudo, which is borked. we should fix whatever broke when we did that.
... but knowing that something like that is out there, yes, be cautious.
good idea. though maybe not now for the release :)
like, make a faux not-really-release in between months just to shake out that
right. release tags don't have to be on master/nom
what was expecting it to be?
oh, i get it
you don't get 2017.01.1 in the versions because the point release is on a different branch entirely
which is "correct", of course
(the best kind of correct)
Zoffix: ooh, sounds nice :)
bisectable6 has gotten confused before with weird history
but not sure how much we should take that into account for rakudo releases
timotimo: any improvements so far?
no, i ran a proflie-compile again in the background and it got OOM'd even though i have lots of swap remaining
not quite sure why that'd happen
maybe need to come up with some script that creates a large profile, but doesn't take *quite* as much time/ram as profiling a rakudo compile
heh.
well, i got one tiny piece of information, i think
it did get its memory growth before the post-process step started
so perhaps the problem is already there inside the moarvm code that creates the profile datastructures in the first place
huh. did the post-process make it any worse?
oh. i think i actually threw out the debug output that would actually have told me that
no, i do have a print for whenever it puts a value into the id remap
and that didn't get hit
so it will have crashed before it reached the post processing step
it looks like zef was using new-from-absolute-path
oh
no it wasn't
yeah but i just pulled it and it won't install
it seems to call .IO on something that's already an IO::Path or something?
hold on ...
d'oh :)
i was using the system-wide installed zef to try to install zef
of course it was still using the old code
rakudo-moar 647abf: OUTPUT: «[IO::Path, ".".IO(:SPEC(IO::Spec::Unix),:CWD("/home/camelia"))]␤»
right
the problem was i was looking at a newer source file than it was running
time to fix that!
<3
I had to reinstall zef last night to get it to work
10:03Z <Zoffix> TimToady: point release cut. We also discovered a bug on our downloads page that didn't sort point releases correctly. So this was all beneficial :)
and no, I couldn't use the old zef to do it...
That somehow doesn't sound like the backwards compatibility story we told after the 6.c release :/
we did explicitly say "if it's not tested, it's not guaranteed"
but then users happened
Why can't you ever think of anything original to say?
Zoffix: When I originally did it there was a breadcrumb trail at the top
That let you go back to recent frames in the chain
That UI is like, the first *and* last thing I wrote in Angular JS :)
the breadcrumb trail exists but it acts really strange when you skip multiple levels
and i managed to somehow break labels in most of the boxes in the call graph >_<
m: dd Q'\'
rakudo-moar 647abf: OUTPUT: «"\\"␤»
Darn....back to getting the wrong path for the shared lib again. Will have to look into this later on :/
m: dd rx{Q/\/}
rakudo-moar 647abf: OUTPUT: «5===SORRY!5===␤Unrecognized regex metacharacter / (must be quoted to match literally)␤at <tmp>:1␤------> 3dd rx{Q7⏏5/\/}␤Couldn't find terminator } (corresponding { was at line 1)␤at <tmp>:1␤------> 3dd rx{Q/7⏏5\/}␤    expec…»
m: say 'foo' ~~ /Q'fo'/
rakudo-moar 647abf: OUTPUT: «Nil␤»
m: say 'foo' ~~ /{Q'fo'}/
rakudo-moar 647abf: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Two terms in a row␤at <tmp>:1␤------> 3say 'foo' ~~ /{Q'fo7⏏5'}/␤    expecting any of:␤        infix␤        infix stopper␤        statement end␤        statement modifier␤        sta…»
rakudo-moar 647abf: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Two terms in a row␤at <tmp>:1␤------> 3say 'foo' ~~ /{Q'fo7⏏5'}/␤    expecting any of:␤        infix␤        infix stopper␤        statement end␤        statement modifier␤        sta…»
m: say 'foo' ~~ /<{Q'fo'}>/
rakudo-moar 647abf: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Two terms in a row␤at <tmp>:1␤------> 3say 'foo' ~~ /<{Q'fo7⏏5'}>/␤    expecting any of:␤        infix␤        infix stopper␤        statement end␤        statement modifier␤        s…»
m: say 'foo' ~~ /<{Q/fo/}>/
rakudo-moar 647abf: OUTPUT: «｢fo｣␤»
rakudo-moar 647abf: OUTPUT: «｢｣␤»
rakudo-moar 647abf: OUTPUT: «｢fo｣␤»
rakudo-moar 647abf: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Two terms in a row␤at <tmp>:1␤------> 3say 'foo' ~~ /<{Q'fo7⏏5'}>/␤    expecting any of:␤        infix␤        infix stopper␤        statement end␤        statement modifier␤        s…»
m: say 'foo' ~~ /<{Q/.+/}>/
rakudo-moar 647abf: OUTPUT: «｢foo｣␤»
m: say 'foo' ~~ /{Q/.+/}/
rakudo-moar 647abf: OUTPUT: «｢｣␤»
rakudo-moar 647abf: OUTPUT: «｢foo｣␤»
rakudo-moar 647abf: OUTPUT: «｢f.+｣␤»
m: say 'f.+o' ~~ /"{Q'f.+'}"/
rakudo-moar 647abf: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Unable to parse expression in single quotes; couldn't find final "'" ␤at <tmp>:1␤------> 3say 'f.+o' ~~ /"{Q'f.+'}"/7⏏5<EOL>␤    expecting any of:␤        dotty method or postfix␤        si…»
rakudo-moar 647abf: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Unable to parse expression in single quotes; couldn't find final "'" ␤at <tmp>:1␤------> 3say 'f.+o' ~~ /"{Q'f.+'}"/7⏏5<EOL>␤    expecting any of:␤        dotty method or postfix␤        si…»
m: say 'f.+o' ~~ /Q[\]/
rakudo-moar 647abf: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Unable to parse expression in metachar:sym<[ ]>; couldn't find final ']' ␤at <tmp>:1␤------> 3say 'f.+o' ~~ /Q[\]7⏏5/␤    expecting any of:␤        infix stopper␤        term␤»
MasterDuke_: i'll put some telemetry pings into the call graph creation code inside moarvm to see what its behavior is like
m: dd say ｢\｣ eq Q[\]
rakudo-moar 647abf: OUTPUT: «True␤Bool::True␤»
Q'fo is a valid ident
m: say 'f.+o' ~~ /"{Q 'f.+'}"/
rakudo-moar 647abf: OUTPUT: «｢f.+｣␤»
m: say 'f.+o' ~~ /"{Q‘f.+’}"/
rakudo-moar 647abf: OUTPUT: «｢f.+｣␤»
we can give a "did you mean" error here
i'm surprised we haven't stumbled over this a thousand times, though?
m: say qq'blah'
rakudo-moar 647abf: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Two terms in a row␤at <tmp>:1␤------> 3say qq'blah7⏏5'␤    expecting any of:␤        infix␤        infix stopper␤        postfix␤        statement end␤        statement modifier␤   …»
i suppose when you're already using Q and friends, you wouldn't use '?
rakudo-moar 647abf: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Two terms in a row␤at <tmp>:1␤------> 3say Q'blah7⏏5'␤    expecting any of:␤        infix␤        infix stopper␤        postfix␤        statement end␤        statement modifier␤    …»
it *shouldn't* work
star-m 2016.10: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Two terms in a row␤at <tmp>:1␤------> 3say Q'blah7⏏5'␤    expecting any of:␤        infix␤        infix stopper␤        postfix␤        statement end␤        statement modifier␤        …»
m: my \Q'blah = 42; say Q'blah
rakudo-moar 647abf: OUTPUT: «42␤»
as timotimo points out, we can have a better message though
star-m 2016.10: OUTPUT: «blah␤»
still duz
now i have a segfault in gdb open where i can't figure out what did it ...
aha!
the call stack is too deep
i mean ... that could be it
the instruction it crashes on is a callq
m: use nqp; class Foo { method x (Mu $x = nqp::null()) { dd nqp::isnull($x); dd $x }.x
rakudo-moar 647abf: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Missing block␤at <tmp>:1␤------> 3:null()) { dd nqp::isnull($x); dd $x }.x7⏏5<EOL>␤    expecting any of:␤        statement end␤        statement modifier␤        statement modifier loop␤»
m: use nqp; class Foo { method x (Mu $x = nqp::null()) { dd nqp::isnull($x); dd $x } }.x
rakudo-moar 647abf: OUTPUT: «0␤Mu $x = Mu␤»
m: use nqp; class Foo { method x (Mu $x = nqp::null()) { dd nqp::isnull(nqp::decont($x)); dd $x } }.x
rakudo-moar 647abf: OUTPUT: «0␤Mu $x = Mu␤»
m: use nqp; class Foo { method x (Mu $x := nqp::null()) { dd nqp::isnull(nqp::decont($x)); dd $x } }.x
rakudo-moar 647abf: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Malformed parameter␤at <tmp>:1␤------> 3use nqp; class Foo { method x (Mu $x :7⏏5= nqp::null()) { dd nqp::isnull(nqp::dec␤»
m: use nqp; class Foo { method x (Mu $x = nqp::null()) { dd nqp::isnull(nqp::decont($x)); dd $x } }.x
rakudo-moar 647abf: OUTPUT: «0␤Mu $x = Mu␤»
m: use nqp; class Foo { method x ($x?) { dd nqp::isnull(nqp::decont($x)); dd $x } }.x
rakudo-moar 647abf: OUTPUT: «0␤Any $x = Any␤»
m: use nqp; class Foo { method x ($x?) { dd nqp::isdefined($x); dd $x } }.x
rakudo-moar 647abf: OUTPUT: «===SORRY!===␤No registered operation handler for 'isdefined'␤»
m: use nqp; class Foo { method x ($x?) { dd nqp::defined($x); dd $x } }.x
rakudo-moar 647abf: OUTPUT: «0␤Any $x = Any␤»
m: use nqp; class Foo { method x ($x?) { dd nqp::defined($x); dd $x } }.x: 42
rakudo-moar 647abf: OUTPUT: «1␤Int $x = 42␤»
m: use nqp; class Foo { method x ($x?) { dd nqp::defined($x); dd $x } }.x: Failure.new
rakudo-moar 647abf: OUTPUT: «1␤Failure $x = Failure.new(exception => X::AdHoc.new(payload => "Failed"), backtrace => Backtrace.new)␤»
m: use nqp; class Foo { method x ($x?) { dd nqp::defined($x); dd $x } }.x: Nil
rakudo-moar 647abf: OUTPUT: «0␤Nil $x = Nil␤»
m: use nqp; class Foo { method x ($x?) { dd nqp::defined($x); dd $x } }.x: 42
rakudo-moar 647abf: OUTPUT: «1␤Int $x = 42␤»
m: use nqp; class Foo { method x ($x?) { dd nqp::defined($x); dd $x } }.x: Nil.new
rakudo-moar 647abf: OUTPUT: «0␤Nil $x = Nil␤»
m: my @x = 42; dd @x[1..2]
rakudo-moar 647abf: OUTPUT: «(Any, Any)␤»
m: my @x = 42; dd @x.AT-POS(1..2)
rakudo-moar 647abf: OUTPUT: «Any @x = Any␤»
m: my @x = 42; dd @x.AT-POS(1, 2)
rakudo-moar 647abf: OUTPUT: «Any $scalar = Any␤»
m: ("", "foo/bar/", "ber").AT-POS(1, 2)
rakudo-moar 647abf: OUTPUT: «Index out of range. Is: 2, should be in 0..0␤  in block <unit> at <tmp> line 1␤␤Actually thrown at:␤  in block <unit> at <tmp> line 1␤␤»
m: dd ("", "foo/bar/", "ber").AT-POS(1, 2)
rakudo-moar 647abf: OUTPUT: «Failure.new(exception => X::OutOfRange.new(what => "Index", got => 2, range => "0..0", comment => Any), backtrace => Backtrace.new)␤»
m: dd ["", "foo/bar/", "ber"].AT-POS(1, 2)
rakudo-moar 647abf: OUTPUT: «Failure.new(exception => X::OutOfRange.new(what => "Index", got => 2, range => "0..0", comment => Any), backtrace => Backtrace.new)␤»
m: my @a = "", "foo/bar/", "ber"; dd @a.AT-POS(1, 2)
rakudo-moar 647abf: OUTPUT: «Failure.new(exception => X::OutOfRange.new(what => "Index", got => 2, range => "0..0", comment => Any), backtrace => Backtrace.new)␤»
m: my @a = ""; dd @a.AT-POS(1, 2)
rakudo-moar 647abf: OUTPUT: «Any $scalar = Any␤»
m: my @a = "", ""; dd @a.AT-POS(1, 2)
rakudo-moar 647abf: OUTPUT: «Failure.new(exception => X::OutOfRange.new(what => "Index", got => 2, range => "0..0", comment => Any), backtrace => Backtrace.new)␤»
m: class Foo { has $.IO; method BUILD() { $!IO = Proxy.new(FETCH => method () { note "FETCH"; "foo" }, STORE => method ($new) { die }) } }; my $foo = Foo.new; $foo.IO; $foo.IO;
rakudo-moar 647abf: OUTPUT: «FETCH␤»
Why does this FETCH only once?!
rakudo-moar 647abf: OUTPUT: «FETCH␤FETCH␤FETCH␤»
oh, ok, thanks!
m: class Foo { has $.IO; method BUILD() { $!IO := Proxy.new(FETCH => method () { note "FETCH"; "foo" }, STORE => method ($new) { die }) }; self }; my $foo = Foo.new; $foo.IO; $foo.IO;
rakudo-moar 647abf: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤'self' used where no object is available␤at <tmp>:1␤------> 3o" }, STORE => method ($new) { die }) };7⏏5 self }; my $foo = Foo.new; $foo.IO; $fo␤    expecting any of:␤        term␤»
m: class Foo { has $.IO; method BUILD() { $!IO := Proxy.new(FETCH => method () { note "FETCH"; "foo" }, STORE => method ($new) { die }) }; 1 }; my $foo = Foo.new; $foo.IO; $foo.IO;
rakudo-moar 647abf: OUTPUT: «WARNINGS for <tmp>:␤Useless use of constant integer 1 in sink context (line 1)␤FETCH␤FETCH␤FETCH␤»
no idea then
rakudo-moar 647abf: ( no output )
rakudo-moar 647abf: OUTPUT: «Cannot look up attributes in a Foo type object␤  in block <unit> at <tmp> line 1␤␤»
rakudo-moar 647abf: OUTPUT: «FETCH␤»
Now with the proxy bound it ends with: Cannot invoke this object (REPR: Null; VMNull)
m: INIT my $x = 42; dd $x
rakudo-moar 647abf: OUTPUT: «Int $x = 42␤»
m: INIT my $x = 42; $x
rakudo-moar 647abf: OUTPUT: «WARNINGS for <tmp>:␤Useless use of $x in sink context (line 1)␤»
m: END my $x = 42; $x
rakudo-moar 647abf: OUTPUT: «WARNINGS for <tmp>:␤Useless use of $x in sink context (line 1)␤»
m: END my $x = 42; $x()
rakudo-moar 647abf: OUTPUT: «Cannot find method 'Any' on object of type List␤  in block <unit> at <tmp> line 1␤␤»
m: END my Mu $x = 42; $x()
rakudo-moar 647abf: OUTPUT: «Cannot find method 'Mu' on object of type List␤  in block <unit> at <tmp> line 1␤␤»
--ll-exception does not actually give me a backtrace there
Maybe I'll have to write 20 delegation methods manually after all
I'd guess that it's the FETCH closure that doesn't survive serialization.
.oO(serial killer?)
but dinner first
timotimo: get anything from the telemetry?
MasterDuke_: it's not reached the point yet
now i'm no longer at my desktop, so i'll have to ssh in to see what's up
at one point i had some code that very quickly produced a too-big profile, but i don't remember what it was
ackermann should do it. alternatively, i'd think recursive fibonacci should also do it
i wonder if it was something with .combinations
didn't we have a recursion-free combinations routine?
desktop will most likely freeze in a minute or two
timotimo: we do now, this may have been before that
Zoffix: do you know the slowest part of the non-nqp version? is there a hot part so you could re-write just a bit in nqp?
https://gist.github.com/timo/1dab05a80811102a9437894adff39e87 - MasterDuke_, something similar to the function donw below would be what we do in post-processing
well, that function is a bit wordy because of the whole C thing; in nqp-land we'd just be using a list
isn't malloc always on the heap?
Zoffix: but i wouldn't say the rel2abs3 is all that bad
malloc is on the heap, but the structure i put there is on the stack
ah
m: <a b c> <<=<< <b c>
rakudo-moar 647abf: OUTPUT: «Cannot modify an immutable Str␤  in block <unit> at <tmp> line 1␤␤»
m: dd <a b c> <<=<< <b c>
rakudo-moar 647abf: OUTPUT: «Cannot modify an immutable Str␤  in block <unit> at <tmp> line 1␤␤»
m: my @a = <a b c>; my @b = <b c>; dd @a <<=<< @b
rakudo-moar 647abf: OUTPUT: «["b", "c"]␤»
m: my @a = <a b c>; my @b = <b c>; dd @a <<=<< @b
rakudo-moar 647abf: OUTPUT: «["b", "c"]␤»
m: my @a = <a b c>; my @b = <b c>; dd @b <<=<< @a
rakudo-moar 647abf: OUTPUT: «["a", "b", "c"]␤»
recursive fibonacci of 30k only produced a 15mb profile, and up to 10k it runs pretty quickly, faster than i expected
interesting
oops, i lied. recursive factorial is very fast. recursive fibonacci is not
bit of a difference
ah, well :)
factorial doesn't branch
Ackermann FTW :)
(though there are many more fun hyperexponentials out there)
can do fib(35), but fib(40) was taking a long time so i killed it. but it only produced a 100k profile
fib(37) produced a 25k profile
*250k
Is there a way to run a spec test using an installed perl6 instead of from the source directory?
something with the --cmd option for fudgeandrun perhaps?
*--impl-cmd
Ah, symlink the t directory in an otherwise empty directory and modify line 39 in t/harness5 ;)
how do we figure that out?
timotimo: probably checking if system tools detect the change and if they don't, skip the test
ah
that's not a bad idea, except we have to have a system tool for every platform where that can happen :D
Zoffix, there's both soft-atime and hard no-atime, the latter you won;'t ever see an updated time
timotimo: is there an atime on every platform?
ACTION just removed the noatime mount option from his fstab
no clue :)
atime is usually present although its resolution varies (e.g. its granularity is 2 seconds on FAT/VFAT)
relatime is best for linux
I guess since I upgraded to an Intel SSD 750 400GB NVMe device, atime just won't make any difference anymore :)
Zoffix: I'll pass your message to [Coke].
timotimo: 'use MONKEY-SEE-NO-EVAL; for ^10 { my &fs = EVAL q|sub f\qq[$_]($n) { if $n < 2 { return 1 } else { return $n * f\qq[$_]($n - 1) } }|; say &fs(30_000).chars };' produces a 150mb profile that the qt viewer can't open
Malformed input file, top level isn't an array: "too deeply nested document"
OK
... too deeply?
that's distinct from "too large", right?
think so
yes, that's a stack (not necessarily machine stack) issue
it's machine stack if we have a json machine
but we don't necessarily need a profile that's actually too large right, just one that's pretty large and generates quickly?
.
late completion is fine; missing reporting progress is not.
Zoffix: yes :/ But maybe now that the packaging stuff works I'll find the time to track that down.
Either way is fine; if you want to throw extra stuff in as part of the grant report, I am not going to stop you. :)
I can take .md for republishing.
timotimo: 'use MONKEY-SEE-NO-EVAL; for ^500 { my &fs = EVAL q|sub f\qq[$_]($n) { if $n < 2 { return 1 } else { return $n * f\qq[$_]($n - 1) } }|; &fs(500) };' produces a 127mb profile that's "too large document"
on my machine, the whole thing took 73s. of that, post_process_call_graph_node() took 14.0655379295349 and to_json() took 43.3250727653503
hhhhhmmmm
where's committable
c: 647abfea2d9 say 42
:|
c: 647abfea2d9 say 42
ok that's better
c: HEAD 42
:|
c: HEAD 42
c: HEAD^ 42
c: HEAD 42
c: 647abfea2d9 say 42
ok that's slightly better…
c: HEAD 42
if only I could figure out why whateverable does this…
c: releases say rand
c: all say rand
c: all say Q'blah'
don't you mean Q'plah?
ACTION shrug
Zoffix: and if the bot is hit by a bus we're doomed, mhm…
timotimo: for that script, to_json takes 42s, but to_sql takes 53s
I'd much rather run it myself. But again, if this is so big of a trouble, we don't *have* to do it
yea
sure, I know. This is why I brought it up ahead of time :)
MasterDuke_: that's kinda strange
2202736maxresident)k for both
timotimo: got anything from telemetry yet?
only gc runs starting and such
it's still going?
yeah
of course it is :)
603b30  30636434259937 (-   "start minor collection" (2620)
^- the last output
not every interval was a gc, but the vast majority
how long has it been running?
real time or cpu time? :)
real
hm
good question actually
0 Epoch counter: 98516819482392
that's not a unix timestamp
and you're profiling a rakudo compile?
yeah
i think with --target=ast
it's spending most of its time doing nothing
swapping?
yeah
how much ram do you have?
eating now
15.6G says htop
10.9G is in my swap
ha. need to rent some 32 or 64gb aws or gce machine for an hour or so
(group key) We've signed releases as individuals in the past, I don't think that's necessarily a problem to do in the future, is it
?
(lot of branches) if the branches are merged to nom, we can probably kill them.
MasterDuke_: it's not outputting anything into the telemetry log any more
it might be that gcc stopped it
timotimo: is your branch up to date? if i check it out, build moar, and run my script will i get something useful?
oh
it's spittin'
.tell lizmat thank you :) got your package in the mail! so happy!
samcv: I'll pass your message to lizmat.
i now have perl 6 swag!
samcv: yeah!!
it seems like the process has ended
aha. SIGKILL
"the process no longer exists"
out of curiosity, what does "nom" stand for?
new object model
iirc
yeah, from many, many, many years ago
before nom rakudo used to compile the whole core setting from source every time you started it
because we didn't have serialization yet
The history is a little more involved than that :)
We did compile the setting into bytecode, but the lack of serialization meant that we couldn't serialize meta-objects
So we built up objects every time at startup
Like adding all the methods to classes, etc.
ah, ok
sounds slow
It was, and CORE.setting was way smaller then
By now we are even doing stuff like lazily deserializing parts of CORE.setting on-demand
Which gave us a further startup time reduction and base memory reduction
At the price of quite a few headaches
timotimo: i have a 3601 line telemetry log. anything i can glean from it?
you don't have my local patch for it, right?
oh
no, whatever was on github
the patch that i linked you to that changes the marking for call graph nodes also includes the interesting intervals
could you apply that patch?
doing that now
oh, now about 16k lines of log
mhm
don't know what successors are, but there were 254238 of them
that's how many children each call graph node has
in theory we could graph the growth of the call graph with this
started with 103579
APOKEYLIPSE!
temperature?
and nucleation. you put it in your mouth and ice cream dissolves off, exposing the pitted groves off the poprocks which then have all those physical sites to react at
FOR SCIENCE
oh, yes, could well be threshold water level, if the ice cream is decent then it's got lipids that would wash away
not high enough
we need more bubbles
If it weren't so obviously a fruity frozen ice cream thing, I would suspect they'd used chocolate covered pop rocks.
Files=1191, Tests=56770, 205 wallclock secs (12.31 usr  4.73 sys + 1210.59 cusr 117.41 csys = 1345.04 CPU)
thx lizmat :)
r: use nqp; say nqp::ord("")
rakudo-jvm fb4f16: OUTPUT: «java.lang.StringIndexOutOfBoundsException: String index out of range: 0␤  in block <unit> at <tmp> line 1␤␤»
..rakudo-moar e1c086: OUTPUT: «-1␤»
r: use nqp; say nqp::ord("foo", 7)
rakudo-jvm fb4f16: OUTPUT: «java.lang.StringIndexOutOfBoundsException: String index out of range: 7␤  in block <unit> at <tmp> line 1␤␤»
..rakudo-moar e1c086: OUTPUT: «-1␤»
^^ that seems to be behind cannon-cat blowing up on JVM. would it make sense to return -1 on JVM as well or would the cleaner solution be to add checks in Rakudos code
https://github.com/rakudo/rakudo/blob/e1c086b7a75115864238536415834efdaf064828/src/core/IO/Spec/Win32.pm#L198
r: say IO::Path::Cygwin.new("/usr/bin").relative("/usr")  ## blows up on rakudo-j now
rakudo-moar e1c086: OUTPUT: «Cannot dispatch to method new on IO::Path because it is not inherited or done by IO::Path::Cygwin␤  in block <unit> at <tmp> line 1␤␤»
..rakudo-jvm fb4f16: OUTPUT: «bin␤»
(locally I get 'bin' from rakudo-m as well)
This is Rakudo version 2017.04.2-2-ge1c086b7a built on MoarVM version 2017.04
csv-ip5xs        3.077
test            12.780
test-t           5.113 - 5.198
csv-parser      13.743
rakudo and perl6-Inline-Perl5 packages ready for installation: http://download.opensuse.org/repositories/home:/niner9:/branches:/devel:/languages:/parrot/openSUSE_Leap_42.2/x86_64/
nice
rakudo-moar e1c086: OUTPUT: «Cannot dispatch to method new on IO::Path because it is not inherited or done by IO::Path::Cygwin␤  in block <unit> at <tmp> line 1␤␤»
for some reason this commit wasn't enough to get us to a repl yesterday
but it is now, so ... ?!?
well, no
you can't do a single solitary thing with it
> eval say "hi"
Non ast passed to WANTED: NQPMu
Weird node in analyze: NQPMu
Unknown QAST node type NQPMu
m: my $result = try "oh lord".&die // "default"; say $result
rakudo-moar e1c086: OUTPUT: «(Any)␤»
rakudo-moar e1c086: OUTPUT: «default␤»
yeah
hah
m: my $result = try "oh lord".&fail // "default"; say $result
rakudo-moar e1c086: OUTPUT: «default␤»
i did not expect this
m: my $result = try "oh lord".&fail.thismethnotexists // "default"; say $result
rakudo-moar e1c086: OUTPUT: «(Any)␤»
oh
s: [], 'unique', \()
m: my @list = {a => 42}, {b => 13}, {a => 42}; dd @list.unique
rakudo-moar 6f3de6: OUTPUT: «(${:a(42)}, ${:b(13)}, ${:a(42)}).Seq␤»
m: my @list = {a => 42}, {b => 13}, {a => 42}; dd @list.unique: :with(&[eqv])
rakudo-moar 6f3de6: OUTPUT: «(${:a(42)}, ${:b(13)}).Seq␤»
m: my @list = {a => 42}, {b => 13}, {a => 42}; dd @list[0].WHICH
rakudo-moar 6f3de6: OUTPUT: «ObjAt.new("Hash|65146192")␤»
m: my @numbers = <1 2 3 4 5>; dd @numbers.permutations.unique( :with(&[eqv]) );
rakudo-moar 6f3de6: OUTPUT: «((IntStr.new(1, "1"), IntStr.new(2, "2"), IntStr.new(3, "3"), IntStr.new(4, "4"), IntStr.new(5, "5")), (IntStr.new(1, "1"), IntStr.new(2, "2"), IntStr.new(3, "3"), IntStr.new(5, "5"), IntStr.new(4, "4")), (IntStr.new(1, "1"), IntStr.new(2, "2"), IntStr.n…»
m: my @numbers = <1 2 3 4 5>; dd @numbers.permutations.unique;
rakudo-moar 6f3de6: OUTPUT: «((IntStr.new(1, "1"), IntStr.new(2, "2"), IntStr.new(3, "3"), IntStr.new(4, "4"), IntStr.new(5, "5")), (IntStr.new(1, "1"), IntStr.new(2, "2"), IntStr.new(3, "3"), IntStr.new(5, "5"), IntStr.new(4, "4")), (IntStr.new(1, "1"), IntStr.new(2, "2"), IntStr.n…»
m: my @numbers = <2 2>; dd @numbers.permutations.unique;
rakudo-moar 6f3de6: OUTPUT: «((IntStr.new(2, "2"), IntStr.new(2, "2")), (IntStr.new(2, "2"), IntStr.new(2, "2"))).Seq␤»
m: my @numbers = <2 2>; dd @numbers.permutations.unique: :with(&[eqv]);
rakudo-moar 6f3de6: OUTPUT: «((IntStr.new(2, "2"), IntStr.new(2, "2")),).Seq␤»
m: my @numbers = <2 2 3 4>; dd @numbers.permutations».elems
rakudo-moar 6f3de6: OUTPUT: «(4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4)␤»
m: my @numbers = <2 2>; dd @numbers.permutations.unique: :as(.Str);
rakudo-moar 6f3de6: OUTPUT: «Use of uninitialized value $_ of type Any in string context.␤Methods .^name, .perl, .gist, or .say can be used to stringify it to something meaningful.␤  in block <unit> at <tmp> line 1␤((IntStr.new(2, "2"), IntStr.new(2, "2")), (IntStr.new(2, "2")…»
m: my @numbers = <2 2>; dd @numbers.permutations.unique: :as(*.Str);
rakudo-moar 6f3de6: OUTPUT: «((IntStr.new(2, "2"), IntStr.new(2, "2")),).Seq␤»
m: my @numbers = <2 2>; my @p= @numbers.permutations; for ^100_000 { $ = @p.unique: :as(*.Str); }
rakudo-moar 6f3de6: ( no output )
m: my @numbers = <2 2>; my @p= @numbers.permutations; for ^100_000 { $ = @p.unique: :as(*.Str); }; say now - INIT now
rakudo-moar 6f3de6: OUTPUT: «0.54370665␤»
m: my @numbers = <2 2>; my @p= @numbers.permutations; for ^100_000 { $ = @p.unique: :with(&[eqv]); }; say now - INIT now
rakudo-moar 6f3de6: OUTPUT: «0.5232712␤»
reeaaaallly
m: my @numbers = <2 2 3 5 8 10>; my @p= @numbers.permutations; for ^100_000 { $ = @p.unique: :with(&[eqv]); }; say now - INIT now
rakudo-moar 6f3de6: OUTPUT: «0.52667557␤»
m: my @numbers = <2 2 3 5 8 10>; my @p= @numbers.permutations; for ^100_000 { $ = @p.unique: :with(&[eqv]); }; say now - INIT now
rakudo-moar 6f3de6: OUTPUT: «0.54647046␤»
m: my @numbers = <2 2 3 5 8 10>; my @p= @numbers.permutations; for ^100_000 { $ = @p.unique: :with(&[eqv]); }; say now - INIT now
rakudo-moar 6f3de6: OUTPUT: «0.53078750␤»
m: my @numbers = <2 2 3 5 8 10>; my @p= @numbers.permutations; for ^100_000 { $ = @p.unique: :as(*.Str); }; say now - INIT now
rakudo-moar 6f3de6: OUTPUT: «0.57161010␤»
m: my @numbers = 1..10; my @p= @numbers.permutations; say @p.elemsfor ^100_000 { $ = @p.unique: :as(*.Str); }; say now - INIT now
rakudo-moar 6f3de6: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Unexpected block in infix position (missing statement control word before the expression?)␤at <tmp>:1␤------> 3s.permutations; say @p.elemsfor ^100_0007⏏5 { $ = @p.unique: :as(*.Str); }; say now…»
m: my @numbers = 1..10; my @p= @numbers.permutations; say @p.elems; for ^100_000 { $ = @p.unique: :as(*.Str); }; say now - INIT now
rakudo-moar 6f3de6: OUTPUT: «3628800␤16.4914045␤»
m: my @numbers = 1..10; my @p= @numbers.permutations; say @p.elems; for ^100_000 { $ = @p.unique: :with(&[eqv]); }; say now - INIT now
rakudo-moar 6f3de6: OUTPUT: «3628800␤16.5111665␤»
m: my @numbers = 1..7; my @p= @numbers.permutations; say @p.elems; for ^100_000 { $ = @p.unique: :as(*.Str); }; say now - INIT now
rakudo-moar 6f3de6: OUTPUT: «5040␤0.6415679␤»
m: my @numbers = 1..7; my @p= @numbers.permutations; say @p.elems; for ^100_000 { $ = @p.unique: :as(*.Str); }; say now - INIT now
rakudo-moar 6f3de6: OUTPUT: «5040␤0.63594286␤»
m: my @numbers = 1..7; my @p= @numbers.permutations; say @p.elems; for ^100_000 { $ = @p.unique: :with(&[eqv]); }; say now - INIT now
rakudo-moar 6f3de6: OUTPUT: «5040␤0.5745768␤»
m: my @numbers = 1..7; my @p= @numbers.permutations; say @p.elems; for ^100_000 { $ = @p.unique: :with(&[eqv]); }; say now - INIT now
rakudo-moar 6f3de6: OUTPUT: «5040␤0.57953003␤»
m: my @numbers = 1..8; my @p= @numbers.permutations; say @p.elems; for ^100_000 { $ = @p.unique: :with(&[eqv]); }; say now - INIT now
rakudo-moar 6f3de6: OUTPUT: «40320␤0.662037␤»
m: my @numbers = 1..9; my @p= @numbers.permutations; say @p.elems; for ^100_000 { $ = @p.unique: :with(&[eqv]); }; say now - INIT now
rakudo-moar 6f3de6: OUTPUT: «362880␤1.5880176␤»
m: my @numbers = 1..10; my @p= @numbers.permutations; say @p.elems; for ^100_000 { $ = @p.unique: :with(&[eqv]); }; say now - INIT now
rakudo-moar 6f3de6: OUTPUT: «3628800␤17.38705058␤»
m: my @numbers = 1..10; my @p= @numbers.permutations; say @p.elems; for ^100_000 { $ = @p.unique: :as(*.Str); }; say now - INIT now
rakudo-moar 6f3de6: OUTPUT: «3628800␤16.54621613␤»
m: my @numbers = 1..10; my @p= @numbers.permutations; say @p.elems; $ = @p.unique: :as(*.Str); say now - INIT now
rakudo-moar 6f3de6: OUTPUT: «3628800␤16.1663440␤»
m: my @p = 1..4000; $ = @p.unique: :as(*.Str); say now - INIT now
rakudo-moar 6f3de6: OUTPUT: «0.0029655␤»
m: my @p = 1..40000; $ = @p.unique: :as(*.Str); say now - INIT now
rakudo-moar 6f3de6: OUTPUT: «0.0280956␤»
m: my @p = 1..40000; $ = @p.unique: :with(*.Str); say now - INIT now
rakudo-moar 6f3de6: OUTPUT: «0.0277922␤»
m: my @p = 1..40000; $ = @p.unique: :with(&[eqv]); say now - INIT now
rakudo-moar 6f3de6: OUTPUT: «0.02720276␤»
m: my @p = 1..40000; $ = @p.unique: :with{ dd $_ }; say now - INIT now
rakudo-moar 6f3de6: OUTPUT: «0.02689739␤»
m: my @p = 1..40000; $ = @p.unique: :with(-> $a, $, { dd $a }); say now - INIT now
rakudo-moar 6f3de6: OUTPUT: «0.0274433␤»
uh oh, what's wrong?
rakudo-moar 6f3de6: OUTPUT: «0.0280431␤»
star-m 2016.10: OUTPUT: «0.0283061␤»
Zoffix: try the coffee thing first it might be easier
s: [], 'unique', \(:with(-> $a, $, { dd $a }))
ACTION goes to look at src
rakudo-moar 6f3de6: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Two terms in a row␤at <tmp>:1␤------> 032017.027⏏5 my @p = 1..40000; @ = @p.unique: :with(␤    expecting any of:␤        infix␤        infix stopper␤        statement end␤        statem…»
oh, hah :)
you weren't taking the values out?
rakudo-moar 6f3de6: OUTPUT: «Int $a = 2␤Int $a = 3␤Int $a = 4␤Int $a = 5␤Int $a = 6␤Int $a = 7␤Int $a = 8␤Int $a = 9␤Int $a = 10␤Int $a = 11␤Int $a = 12␤Int $a = 13␤Int $a = 14␤Int $a = 15␤Int $a = 16␤Int $a = 17␤Int $a = 18␤Int $a = 19␤Int $a = 2…»
phew
m: my @numbers = 1..10; my @p= @numbers.permutations; say @p.elems; for ^100_000 { @ = @p.unique: :as(*.Str); }; say now - INIT now
rakudo-moar 6f3de6: OUTPUT: «(timeout)3628800␤»
m: my @numbers = 1..6; my @p= @numbers.permutations; say @p.elems; for ^100_000 { @ = @p.unique: :as(*.Str); }; say now - INIT now
rakudo-moar 6f3de6: OUTPUT: «(timeout)720␤»
m: my @numbers = 1..6; my @p= @numbers.permutations; say @p.elems; @ = @p.unique: :as(*.Str); say now - INIT now
rakudo-moar 6f3de6: OUTPUT: «720␤0.01122896␤»
m: my @numbers = 1..10; my @p= @numbers.permutations; say @p.elems; @ = @p.unique: :as(*.Str); say now - INIT now
rakudo-moar 6f3de6: OUTPUT: «(timeout)3628800␤»
m: my @numbers = 1..4000; say @p.elems; @ = @p.unique: :as(*.Str); say now - INIT now
rakudo-moar 6f3de6: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Variable '@p' is not declared␤at <tmp>:1␤------> 3my @numbers = 1..4000; say 7⏏5@p.elems; @ = @p.unique: :as(*.Str); say␤»
m: my @p = 1..4000; say @p.elems; @ = @p.unique: :as(*.Str); say now - INIT now
rakudo-moar 6f3de6: OUTPUT: «4000␤0.0220706␤»
m: my @p = 1..4000; say @p.elems; @ = @p.unique: :with(&[eqv]); say now - INIT now
rakudo-moar 6f3de6: OUTPUT: «(timeout)4000␤»
m: my @p = 1..2000; @ = @p.unique: :with(&[eqv]); say now - INIT now
rakudo-moar 6f3de6: OUTPUT: «7.468134␤»
m: my @p = 1..2000; @ = @p.unique: :as(.*Str); say now - INIT now
rakudo-moar 6f3de6: OUTPUT: «Use of uninitialized value $_ of type Any in string context.␤Methods .^name, .perl, .gist, or .say can be used to stringify it to something meaningful.␤  in block <unit> at <tmp> line 1␤0.0132547␤»
m: my @p = 1..2000; @ = @p.unique: :as(*.Str); say now - INIT now
rakudo-moar 6f3de6: OUTPUT: «0.00771542␤»
hah :)
i'm going to push a branch that ought to give more precision in the coverage report
can you give me a before/after for spectest (or something smaller)?
it's MoarVM/line_coverage_precision
s: 42, 'unique', \()
s: [42,], 'unique', \()
oh wow
hm, okay
i can try it myself, though only on the nqp test suite, i'd imagine
the output from before/after this stuff is a bit strange
/win 10
m: my @p = 1..3000; @ = @p.unique: :with(&[eqv]); say now - INIT now
rakudo-moar 6f3de6: OUTPUT: «16.3836522␤»
yeah, i think the branch makes things a bit better
but across the whole nqp test it's only a few lines more that are covered ...?!
but somehow one line got actually lost
i'll have a look what valgrind thinks, maybe i'm reallocing off-by-one or something
Zoffix: (group key) (hostile key) not sure how a single key protects us against an 'apeshit' user, if they have access to the group key.
I do agree that the happy bpath for our users is easier.
i did have an off-by-one
the two hardest problems in compsci is cache invalidation, naming things, and off-by-one errors
rather annoying that i can't rebuild moarvm without "make test" in nqp recompiling nqp
though i can just cp over moar and libmoar.so and it won't trigger
it's probably due to the .nqp files moar generates so nqp knows about all ops and such
OK, now there's only + lines in the diff
Zoffix: so what's your suggestion for moving on?
Zoffix: well, you just gave us a nice list of things where improvements are due. Do you have suggestions on how to get that going?
Zoffix: IDK, encouraging new contributors, or reverting the objectionable commits or whatever?
nine: I think he had that list because those are things he's had to fix.
Zoffix: ok, so at least the mess is cleaned up mostly already.
so simple :)
Now that's a discussion gone wrong...
world peace by amnesia!
It's really sad to see such arguing when all people involved actually try to help and do good
That would be very odd. The whole require code is very far away from any platform specifics
bisect: "".parse-names
Zoffix: you have a minor typo "compleetion"
Zoffix: nice report, btw.
you've grown a lot since then, i bet
Right of passage.  Write a web framework, a game, a compiler or interpreter, ...
they didn't have web frameworks when I needed a right of passage...
so I had to write a game and a compiler/interpreter
TimToady: s/web framework/usenet tool/
well, okay, I did some of that too :)
while parsing the setting, we create 2126937 backtrack points in contexts that are simply going to throw them away in !cursor_pass
so we're doing 8507748 pushes onto the $!bstack that we probably know in advance we won't need
knowing that in advance is also the point at which we can decide to write directly to the capture with the current match object instead of pushing captures to the $!cstack
which would save copying them over later in the MATCH method
s/with/within/
(and making *that* possible is why we got uncurse)
TimToady: Wowzer, that sounds like a nice saving :)
the other major speedup will hopefully come from not recalculating fates several times at the same position each time because subrules don't know what superrules already figured out in the NFA
jnthn: well, I still have to try to implement it :)
so some signal has to pass downward that backtrack points are unwanted, and that might have to be dynamic
(in some cases)
probably not via dynvar though
Well, the fates are also a passing downwards problem
So probably worth a common mechanism
so the info probably comes through the Match object
(almost said Cursor :)
well, it's still functioning as a cursor
Yeah, I'd probably hold it in there
Since we invoke the rule passing it as invocant
So it can grab out what it needs
in any case, the cursor has to be involved because that's where the direct captures would want to be put
aye
Other thing it'd be nice to do is cut down on the code we spit out per rule too
The prelude/postlude
in fact, the NFA engine probably wants to write the fates info directly into the current cursor
Much of which only applies when we backtrack
And we can statically see we have no backtracking points in many tokens, I'd imagine
well, some of this is my own fault for demanding way back in the early 2000s that regex be considered real code, and not run under a sub-engine as it is in P5 :)
I can imagine the sorts of problems we'd be battling if you hadn't, and the grass doesn't look any greener :)
yes, we can know that statically, but we can't know statically the intermediate case of a parent rule not wanting backtracking info out of something that might backtrack
essentially the parent needs to tell the child to commit
yes, but I had a hard time getting people to see it back then :)
and then poor pmichaud++ had to try to implement it, more than once :)
I joined once he was already well on the way with that, so I guess I came in at the "sure it's possible, we're already doing it" point :)
Zoffix: Did your recent Windows perf improvements make it into the point release, or came after it?
I mean, we actually have a really good regex implementation right now; it's just that it's optimizing for the failure case more than the success case right now, and compilers don't/shouldn't do much backtracking
Zoffix: Ah, OK, if there's more to come I might just wait until I bump the Moar/Rakudo versions we ship in the $dayjob MSI then :)
Very nice, hopefully that'll get startup time of things that use a load of modules down on Windows to about where it is on Linux :)
I really have no complaint about how we got to this point, though, because we couldn't have done it at all without a lot of "Do the simplest thing that could possibly work."
Indeed. Another issue there is that it'd be nice if the NFA could tell the compiled thing "you can just jump to here" in a bunch of cases, so we don't have to re-do its work
(in the non-capture case)
Dunno if that's something you've already been pondering in the fates work
yes, that one shouldn't be too difficult, it's just work
The main problem with doing impossible things is getting around the hard parts... :)
we can also start doing some first-step-of-DFA work in the NFA, at least on cutting down the initial set of states based on the first char
full-on DFA is probably not worth it for parsing, but for other pattern matching it would be nice to have to capability
*the
another possible optimization is to not merge NFAs by copying, but just use tail refs of some sort
(why I was thinking about unique fate numbers a couple months ago)
I don't think there's any deep reason we can't do that
as you pointed out at the time, separate comp is a problem
(The tail ref thing)
but the deserializer can uniqueify fate nums
But yeah, it needs to not bust sep comp
or fates contain the NFA ident
or we figure out how to structure fate data so the right small integers get to the right spot
which how STD did it
a lists of lists might be sufficient there, as long as we don't get out of sync trying to use the wrong small integers
the unique fates approach has the advantage that you can detect when the fates aren't for you
well, one step at a time
Zoffix: I'll pass your message to stmuk.
ACTION looks at nine and himself and wonders about that
didn't groucho have something to say about that?
that was about clubs, we're talking about hearts :P
and I always call a spade a shovel
AMD Ryzen system is up and running! Or...crawling. Had to boot with acpi=off because of some issue with exactly the motherboard I picked. But nothing a custom compiled kernel cannot fix. Though compiling with only one CPU core is kinda boring...
oh, will be interesting to hear what you think of it when it's up and running properly
Ok, didn't have to recompile after all. Just needed to blacklist a module.
Compiling moarvm takes 4.9 seconds with make -j16. About half of this is /usr/bin/perl build/mk-moar-pc.pl pkgconfig/moar.pc
Stage parse :  47.703
nice
Files=1178, Tests=56684, 107 wallclock secs (12.71 usr  2.15 sys + 1411.82 cusr 110.02 csys = 1536.70 CPU)
impressive numbers indeed
so that's about 3min total for a rakudo compile+spectest?
Files=1178, Tests=56684, 102 wallclock secs (12.64 usr  2.31 sys + 1436.15 cusr 103.54 csys = 1554.64 CPU)
With TEST_JOBS=22
MasterDuke_: yes
not bad at all
is the system silent enough for your liking?
dogbert17: not yet. Will have to play with the fan settings, because ironically the CPU cooler I've waited for is the noisiest part. Though completely unnecessarily so. The cooler is really cold to the touch. Could probably just turn off the fans.
do you have some kind of temp numbers?
ACTION remembers that his old Noctua cooler came with fan resistors
dogbert17: no, looks like Linux doesn't support the sensors on this board yet. I do have the resistors installed.
.
18 Apr 2017 19:58Z <samcv> lizmat: thank you :) got your package in the mail! so happy!
but the cooler fan is still spinning too fast or is it a noisy part
samcv: whee!
the fan that is
$a.//foo  # call method foo on $a if $a is defined, else return Nil
hmmm... perhaps $a//.foo would be better
Zoffix: $a andthen $a.foo ?
$a andthen .foo
?
Oh, does it topicalize as well?
I wondered
Also, <bikeshed> .?? to go with .? instead of .// makes more sense to me
japhb: but // indicates a test for definedness
m: '42'.abs
rakudo-moar b4fa6d: ( no output )
Sure, but for some reason my brain heads for a different mnemonic
m: Nil.^mro.say
rakudo-moar b4fa6d: OUTPUT: «(Nil (Cool) (Any) (Mu))␤»
But I could probably learn .//
Ok, selected the silent fan control profile and use system temperature instead of CPU temperature as input for the second CPU fan control. Much more quiet now. Firmware reports 56 °C CPU temperature which doesn't correspond at all with how the CPU cooler feels.
rakudo-moar b4fa6d: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Malformed postfix call (only alphabetic methods may be detached)␤at <tmp>:1␤------> 3$ .7⏏5?meows.?contains: 'foo'␤»
rakudo-moar b4fa6d: OUTPUT: «Invocant requires an instance of type Cool, but a type object was passed.  Did you forget a .new?␤  in block <unit> at <tmp> line 1␤␤»
rakudo-moar b4fa6d: OUTPUT: «heh␤»
rakudo-moar b4fa6d: OUTPUT: «True␤»
Looks like t/spec/S17-supply/syntax.t is a flapper, too :/
nine: there's been some talk on the net that Ryzen overreports temps with 20 degrees for some stupid reason
dogbert17: that would make so much sense
nine: e.g. https://www.youtube.com/watch?v=uoE1s0pqjv0
https://www.kotaku.com.au/2017/03/amds-ryzen-cpus-arent-running-as-hot-as-they-say-they-are/ is talking about exactly my motherboard
cool :)
So I guess there'll be a BIOS update to fix this
what kind of gfx card did you get?
ACTION got a gtx 1060 6gb around christmastime
not bad
ACTION has a tendency to only buy passively cooled cards
that's the combo i've been contemplating: 1060 + ryzen 1700
i'm not sure you should go for a 1060
OTOH, it's not like i'm really going to get an htc vive any time soon, so ...
ACTION is internally debating between PSVR or new cpu+gpu
did you put on a PSVR yet?
yeah
any of the others, too?
nope
i believe you also have to get a ps4 pro if you want to use psvr, right?
no, nothing requires a pro
oh, it seems like you can also connect a psvr to a pc
i.e. sony didn't put in ridiculous measures to prevent you from plugging it into anything but a ps4
or i could just delay getting anything even more and then try to decide between the next generation of those things...
yeah, i was also hoping i could get one that has finer physical pixels
though tbh it's not as big a deal after the first minute of wearing the thing
but damn, the vive controllers are amazing
yep. was both surprised at how noticeable they were, and then weren't after a couple min
.o( should we continue this discussion in #perl6-gaming? )
is that a thing?
it is
backing up to some of the earlier discussion, a spectest for me takes ~260s. -j (6|8|10|12) are all about the same. and a rakudo compile takes ~90s
what cpu is that with?
i7 860
huh, that's one digit less than my laptop has
which digit?
i7-4600U is mine
my laptop is i5-4200U
my desktop's a i5-3570
timotimo: select r.name, sum(a.count) from routines r, allocations a, callees c, types t where r.id = c.routine_id and a.caller_id = c.caller_id and t.id = a.type_id and t.name = "BOOTStr" group by r.name;
for a tiny sample profile it's giving me the same results as the "View" link next to "BOOTStr" in the "Allocations" tab of a regular profile of the same code
you don't even have to spell out a JOIN statement?
yeah, that looks sensible
that's the oracle style syntax, i never really got familiar with the normal ansi (i think it's called that) syntax
ah, but sqlite allows for that, yeah?
yup
cool.
timotimo, MasterDuke_ what are your thoughts on https://github.com/samcv/URL-Find/blob/master/META.info making the license field be the spdx license name (which is the most widely used cataloging thing)
and then have resources license for the url? right now the meta spec says to have it be the url for the license
i think it seems good
ok cool
i wonder if TimToady can figure out what might have b0rked the debug grammar; something with wanted getting NQPMu, so perhaps some named parameters not being passed or something?
and we don't support them being empty?
m: REPL.history-file
rakudo-moar b4fa6d: OUTPUT: «Cannot look up attributes in a REPL type object␤  in block <unit> at <tmp> line 1␤␤»
m: REPL.new.history-file
rakudo-moar b4fa6d: OUTPUT: «Too few positionals passed; expected 3 arguments but got 1␤  in block <unit> at <tmp> line 1␤␤»
does Readline also b0rk?
m: REPL.new(nqp::getcomp("perl6"), %).history-file
rakudo-moar b4fa6d: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Could not find nqp::getcomp, did you forget 'use nqp;' ?␤at <tmp>:1␤------> 3REPL.new(nqp::getcomp("perl6")7⏏5, %).history-file␤»
m: use nqp; REPL.new(nqp::getcomp("perl6"), %).history-file
rakudo-moar b4fa6d: OUTPUT: «You may want to `zef install Readline` or `zef install Linenoise` or use rlwrap for a line editor␤␤»
m: use nqp; dd REPL.new(nqp::getcomp("perl6"), %).history-file
rakudo-moar b4fa6d: OUTPUT: «You may want to `zef install Readline` or `zef install Linenoise` or use rlwrap for a line editor␤␤"/home/camelia/.perl6/rakudo-history"␤»
m: use nqp; BEGIN REPL.^mixin: role { method history-file { 42 } }; dd REPL.new(nqp::getcomp("perl6"), %).history-file
rakudo-moar b4fa6d: OUTPUT: «You may want to `zef install Readline` or `zef install Linenoise` or use rlwrap for a line editor␤␤"/home/camelia/.perl6/rakudo-history"␤»
m: use nqp; BEGIN REPL.^does: role { method history-file { 42 } }; dd REPL.new(nqp::getcomp("perl6"), %).history-file
rakudo-moar b4fa6d: OUTPUT: «You may want to `zef install Readline` or `zef install Linenoise` or use rlwrap for a line editor␤␤"/home/camelia/.perl6/rakudo-history"␤»
m: use nqp; BEGIN REPL does role { method history-file { 42 } }; dd REPL.new(nqp::getcomp("perl6"), %).history-file
rakudo-moar b4fa6d: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤An exception occurred while evaluating a BEGIN␤at <tmp>:1␤Exception details:␤  Cannot use 'does' operator with a type object.␤    in code  at <tmp> line 1␤␤»
m: use nqp; BEGIN REPL mixing role { method history-file { 42 } }; dd REPL.new(nqp::getcomp("perl6"), %).history-file
rakudo-moar b4fa6d: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Two terms in a row␤at <tmp>:1␤------> 3use nqp; BEGIN REPL7⏏5 mixing role { method history-file { 42 ␤    expecting any of:␤        infix␤        infix stopper␤        postfix␤        s…»
m: use nqp; BEGIN REPL mixin role { method history-file { 42 } }; dd REPL.new(nqp::getcomp("perl6"), %).history-file
rakudo-moar b4fa6d: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Two terms in a row␤at <tmp>:1␤------> 3use nqp; BEGIN REPL7⏏5 mixin role { method history-file { 42 }␤    expecting any of:␤        infix␤        infix stopper␤        postfix␤        s…»
m: use nqp; BEGIN REPL.^mixin: role { method history-file { 42 } }; dd REPL.new(nqp::getcomp("perl6"), %).history-file
rakudo-moar b4fa6d: OUTPUT: «You may want to `zef install Readline` or `zef install Linenoise` or use rlwrap for a line editor␤␤"/home/camelia/.perl6/rakudo-history"␤»
heh. mod Linenoise so it .wraps the offending function before trying to load it %)
m: use nqp; BEGIN REPL.^lookup('history-file').wrap: -> | {42 }; dd REPL.new(nqp::getcomp("perl6"), %).history-file
rakudo-moar b4fa6d: OUTPUT: «You may want to `zef install Readline` or `zef install Linenoise` or use rlwrap for a line editor␤␤42␤»
rakudo-moar b4fa6d: OUTPUT: «You may want to `zef install Readline` or `zef install Linenoise` or use rlwrap for a line editor␤␤42␤»
also is META6.json preferred Zoffix ? or META.json?
cool
i need to change my meta then
shake up the metagame
rakudo-moar b4fa6d: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Variable $!history-file used where no 'self' is available␤at <tmp>:1␤------> 3story-file)'.wrap: -> | { $!history-file7⏏5 }␤»
ok cool. fixed that. need to be proper™ if i'm going to have it as an example on the PR page
replacing methods is possible in objects with "does"
not in types, though
i wonder if the MOP will let you fiddle with the methods
ok looks like we can't use resources for the url
based on what this says https://design.perl6.org/S22.html#resources
oh wait
you were putting a http url into resources?
yes
i will fix it. where should it be put timotimo
i misread, i thought you were putting the license url into the support hash
yeah it should be support
yeah that's what i meant for it to be
timotimo, let me know what you think of this https://github.com/perl6/specs/pull/120
Zoffix: I'll pass your message to stmuk.
Zoffix: I'll pass your message to lizmat.
Zoffix: I'll pass your message to lizmat.
oh, Zoffix, you can just ignore the error about mkdir /?
i thought it immediately crashed the repl
well, that's half a relief
phew
can we point release it?
nothing wrong with point releases right?
one point release in every home!
that's Rakudo 4!
Rakudo 2017.04 OSX Premium Edition
lollll
point release meants that we make sure we fix problems :)
also how can we make sure this is tested in the future
ACTION is still looking for a fix for Grammar::Debugger
:(
sounds good
but would that catch it?
i mean it'd have to start repl
we could use the expect program to start a repl and interact with it
and it'll error on any weird output
if we do it righ i think
dunno if os x has expect
oh good https://developer.apple.com/legacy/library/documentation/Darwin/Reference/ManPages/man1/expect.1.html
i have had a test about the repl that i've always had to kill when doing spec test runs :P
but maybe that's because of some left-over readline/linenoise module in my perl6 folders or something
m: use nqp; my $s = 'A:/foo'; dd nqp::substr($s, 0, 2)
rakudo-moar b4fa6d: OUTPUT: «"A:"␤»
m: use nqp; my $s = 'A:/foo'; dd nqp::substr($s, 2)
rakudo-moar b4fa6d: OUTPUT: «"/foo"␤»
No such method 's' for invocant of type 'IO::Handle'
in sub content-length at /home/travis/build/tokuhirom/p6-Crust/lib/Crust/Utils.pm6 (Crust::Utils) line 52
hmm
what can that be replaced with?
star: say $*OUT.s
star-m 2016.10: OUTPUT: «0␤»
I think the OS returns size of 0 for things that aren't seekable
rakudo-moar b4fa6d: ( no output )
and offset, yeh
m: $*OUT.tell.say
rakudo-moar b4fa6d: OUTPUT: «0␤»
no one reads my notices!
nobody ever reads notices
like nobody ever reads manuals >.>
you could have it pop a dialog with bright red blinkenlights in their face and they'd click through it and then complain that nobody told them...
"only" :)
the regex compiler creates a load of moarvm bytecode that does contain a couple of nqp ops you can manually use
i don't think i understand what is faster and what code is what
Takhar, Mammote!
state your purpose
k
I believe I found the bug in Grammar::Debugger
actually, the bug is in Grammar::Tracer
i'm not sure how to fix this problem in DateTime::Math
Ambiguous call to 'infix:<->'; these signatures all match:
:(DateTime:D \a, DateTime:D \b)
:(DateTime:D $a, DateTime:D $b)
rakudo-moar b4fa6d: OUTPUT: «Duration.new(<-4417/2205500>)␤»
doesn't make sense to me
.WHAT shows they're both datetime objects
oh. yes
very true
i'm make a pr then
the closure that Grammar::Tracer provides has -> $c, |args, but then uses $meth($obj, |args), and $obj is the type object rather than the instantiated object
PR sent now
TimToady, can you check this https://github.com/perl6/specs/pull/120 and see how you feel about this for META and licenses to the spec?
right now it's kind of anarchy of what people put there from what i have seen checking all META files in the ecosystem
this would greatly simplify it and make the license in a standardized format that is well defined and used by a great number of license tracking systems
seems reasonable to me, if people actually want their code to be used
it is ok if i merge that?
i've also put PR template for the ecosystem to encourage people to add licenses to their projects. because https://github.com/perl6/ecosystem/blob/master/PULL_REQUEST_TEMPLATE.md like... almost none of them (including me) have them
doesn't *require* a license but should nudge people in the right direction, because it's something often overlooked, by myself and others when publishing modules
the legal interface is just about as important as the technical one
speaking as someone who wrote his own license...
.tell jnthn Grammar::Tracer calls $meth($obj, |args) where it should call $meth($c, |args)
TimToady: I'll pass your message to jnthn.
also TimToady we have a 'support' key, and only define email, buggtracker
what about the module's homepage?
should that be defined as 'homepage'?
the rakudo credits has https://github.com/rakudo/rakudo/blob/nom/CREDITS#L8 web-address
so that's a possibility too and more specific
and this is meta https://metacpan.org/pod/CPAN::Meta::Spec#resources
ACTION foresees that the next wave of malware will involve forking projects to a different auth and giving them a spam homepage :)
oh my
also nicely the spdx defines what to write if there is no license as well as if the creator of the META file doesn't know the license
NONE for no license and NOASSERTION if whoever adds the field doesn't know or makes no assertion as to the license
i think it would be cool if we had travis ci check to make sure there is at least some license field, even if it says NONE or NOASSERTION it's better than just blank
and obviously if nobody has the ability to change the meta file then not like you have to listen to travis, and it wouldn't affect commits, just PR
m: use nqp; my $s = 'A:/foo'; dd nqp::eqat($s, ':', 2); dd nqp::substr($s, 2)
rakudo-moar b4fa6d: OUTPUT: «0␤"/foo"␤»
m: use nqp; my $s = 'A:/foo'; dd nqp::eqat($s, ':', 2); dd nqp::substr($s, 0,  2)
rakudo-moar b4fa6d: OUTPUT: «0␤"A:"␤»
m: use nqp; my $s = 'A:/foo'; dd nqp::eqat($s, ':', 1); dd nqp::substr($s, 0,  1)
rakudo-moar b4fa6d: OUTPUT: «1␤"A"␤»
m: use nqp; my $s = 'A:/foo'; dd nqp::eqat($s, ':', nqp::chars($s)-1);
rakudo-moar b4fa6d: OUTPUT: «0␤»
m: use nqp; my $s = 'Afoo:'; dd nqp::eqat($s, ':', nqp::chars($s)-1);
rakudo-moar b4fa6d: OUTPUT: «1␤»
TimToady, https://design.perl6.org/S22.html#emulates hehehe
dunno if this is implemented yet or not. but it says thet it will load one module as if it were another if it does not have the original module
dunno you could probably cause mischief with that
you can cause mischief with just about anything :)
:-)
gonna make a Bag of all the keys in every single META file in the ecosystem to get a distribution of usage
bag(emulates(10), test-depends(301), version(813), name(813), api(4), description(813), excludes(9), resources(145), build-depends(195), supersedes(9), production(10), support(211), source-uri, licence(4), author(285), source-url(779), superseded-by(9), resource(13), tags(149), license(108), auth(155), perl(739), provides(803), meta6(54), history, repo-type(31), authors(411), owner(9), authority(8), depends(771), source-type(69))
TimToady, only 4 in eco have licenses...
and two of them are my modules
that i just changed today
idk maybe that's wrong
that should be right though. i mean it picked up every other thing
that's still depressing
err oh some are mispelled?
nice...
if its worth anything zef has a white/black list for licenses in its config that you can use on those 4 distributions
also we have author and authors dunno if author is valid?
ugexe, what do you mean by that?
just made a PR to zef to add a license field to its META file
"License" : { "whitelist" : "*", "blacklist" : [] } # you can change this in the config to filter dists-to-be-installed by license
ah
ah i see
that's cool though
can you blacklist modules with no license?
Zoffix, https://gist.github.com/51e8a1fd862ad512a7983a1006c176e2 this is the code to find that
can probably modify it to print out more useful info
https://design.perl6.org/S22.html#excludes
also i want to know who misspelled license... 4 modules worth
and who used author instead of authors
which semes to be many people
oh. how often updated
nice
https://github.com/rakudo/rakudo/blob/nom/src/core/Distribution.pm#L40 # author has history
oh no i broke mine
method auth { $!auth // $!author // $!authority } # just think about *this*
heh
seems people are using `auth` as a key, but that's not in the spec
well it says what auth is. but it's not in the META section
it just defines it as a term but doesn't say it's a metadata key at all
take anything in there with a grain of salt. but auth happened because dynamically creating the auth from multiple fields did not work well
method auth { $!auth // $!author // $!authority } # this is still supported for backcompat, but will probably go aware just be $!auth
well, auth is just supposed to be the part of the identity that names who dunnit, such that if someone else dunnit, it's a different one
yeah i know what it is. but the spec needs to be updated to say that's a META6.json key
i mean that same spec also documents @?INC
anything you think is missing or wrong probably is
Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=131174
ugh so many META6 git repos
META6, and META6bin and META6::Test
gotta make changes in at least two of them
This is Rakudo version 2017.04.2-6-g894ba82de built on MoarVM version 2017.04
csv-ip5xs        3.049
test            12.700
test-t           5.102 - 5.476
csv-parser      13.658
Files=1191, Tests=56770, 198 wallclock secs (11.83 usr  4.59 sys + 1162.78 cusr 109.40 csys = 1288.60 CPU)
.tell yoleaux thx for your tireless message relaying
samcv: Thanks for the message.
:-)
dogbert17: BIOS update did the trick. Temperature is now being reported correctly and when I turn off the spinning rust I use for multimedia data, the system is now almost inaudible. Not even heavy spec testing raises the noise level :)
nine: very cool, sound as if you're quite satisfied :)
ACTION should prod the folks meant to be building/delivering his new machine today..
00:48Z <TimToady> jnthn: Grammar::Tracer calls $meth($obj, |args) where it should call $meth($c, |args)
dogbert17_: oh definitely :)
Argh, what...
perl6-m -e "say 'README.md'.IO.e"
True
perl6-m -e "say 'README.md'.IO.resolve.e"
False
(Yes, there is a README.md)
On Windows fwiw
No problem on Linux
say 'README.md'.IO.resolve
Is correct
oh wait
It's not
perl6-m -e "say 'README.md'.IO.resolve"
"\C:\consulting\rakudo\README.md".IO
Spot the extra \
Let me grab rakudo HEAD
Though I was pretty close anyway
This is Rakudo version 2017.04.2-4-gb4fa6d6 built on MoarVM version 2017.04
implementing Perl 6.c.
Confirmed at HEAD
Now back to the last release
And will check there
I'd bumped to get the perf improvements which actually knocked 50ms-100ms off startup time
perl6-m --version
This is Rakudo version 2017.04.2 built on MoarVM version 2017.04
implementing Perl 6.c.
perl6-m -e "say 'README.md'.IO.resolve"
"\C:\consulting\rakudo\README.md".IO
:(
rakudo startup takes 85ms here. Knocking off 50-100ms of that would be fantastic ;)
nine: This isn't Rakudo startup, it's my app's startup, fwiw, which loads a ton of modules, and in doing so spent about 50% of its time in Windows path mangling
Thus starting up about twice as slow on my Windows host compared to in my Linux VM :)
oh, ok :)
Urgh, this bug is...uh...a problem
m: say 'README.md'.IO.resolve
rakudo-moar 894ba8: OUTPUT: «"/home/camelia/README.md".IO␤»
c: HEAD say 'README.md'.IO.resolve
c: HEAD say IO::Path::Win32.new('README.md').resolve
c: HEAD say IO::Path.new('README.md', :SPEC(IO::Spec::Win32)).resolve
Guess I can work around it with say 'README.md'.IO.absolute.IO.e for now
c: HEAD say ".".IO.WHAT.new('README.md', :SPEC(IO::Spec::Win32)).resolve
c: HEAD say ".".IO.WHAT.new('README.md', :SPEC(IO::Spec::Win32.new)).resolve
c: HEAD say ".".IO.WHAT.new('C:/README.md', :SPEC(IO::Spec::Win32.new)).resolve
o.O
Very few Windows users?
Or few users of .resolve?
Then take the intersection
set(jnthn)
Apparently ;)
Zoffix: It stood a bit over 600ms; now it's reliably under 600ms
As opposed to 200ms-300ms on Linux
Oh, to be fair, that's also including time to generate the usage message
from MAIN
Which has quite a few candidates
on macOS `time perl6 -e 'sub MAIN {}' ` is 0.178s real for me
19 Apr 2017 18:51Z <Zoffix> Ulti: there are some unmerged PRs that've been marinating for months. Do you mind merging them? https://github.com/MattOates/Text--Homoglyph/pulls
whoa
doh should have properly reviewed those
why are people messing around with the file name
whoa there are loads of PR I've ignored
Zoffix: okedoke I'll make sure to change that
thanks
Zoffix: I'll pass your message to mst.
rakudo-moar 894ba8: OUTPUT: «Mu␤»
rakudo-moar 894ba8: OUTPUT: «Mu␤»
rakudo-moar 894ba8: OUTPUT: «Int $*PERL = 42␤»
m: use nqp; for ^100_000 { $ = nqp::getcomp('perl6').language_version ~ "\0" ~ name }; say now - INIT now
rakudo-moar 894ba8: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Undeclared routine:␤    name used at line 1␤␤»
m: use nqp; my \name = '$*CWD'; for ^100_000 { $ = nqp::getcomp('perl6').language_version ~ "\0" ~ name }; say now - INIT now
rakudo-moar 894ba8: OUTPUT: «0.226783␤»
m: use nqp; my \name = '$*CWD'; for ^1000_000 { $ = nqp::getcomp('perl6').language_version ~ "\0" ~ name }; say now - INIT now
rakudo-moar 894ba8: OUTPUT: «1.6682225␤»
m: use nqp; my \name = '$*CWD'; for ^1000_000 { $ = nqp::concat(nqp::getcomp('perl6').language_version, nqp::concat("\0", name)) }; say now - INIT now
rakudo-moar 894ba8: OUTPUT: «1.3575313␤»
m: use nqp; my \name = '$*CWD'; for ^1000_000 { $ = nqp::concat(nqp::getcomp('perl6').language_version, nqp::concat("\0", name)) }; say now - INIT now
rakudo-moar 894ba8: OUTPUT: «1.2911228␤»
It doesn't do any failover stuff
m: use nqp; for ^100_000 { $ = nqp::eqat(path, '/', 0) }; say now - INIT now
rakudo-moar 1d6a00: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Undeclared routine:␤    path used at line 1␤␤»
m: use nqp; my \path = 'foobar'; for ^100_000 { $ = nqp::eqat(path, '/', 0) }; say now - INIT now
rakudo-moar 1d6a00: OUTPUT: «0.072070␤»
m: use nqp; my \path = 'foobar'; for ^1000_000 { $ = nqp::eqat(path, '/', 0) }; say now - INIT now
rakudo-moar 1d6a00: OUTPUT: «0.5973789␤»
m: use nqp; my \path = 'foobar'; for ^1000_000 { $ = nqp::eqat(path, '/', 0) }; say now - INIT now
rakudo-moar 1d6a00: OUTPUT: «0.61039859␤»
m: use nqp; my \path = 'foobar'; for ^1000_000 { $ = nqp::eqat(path, '/', 0) }; say now - INIT now
rakudo-moar 1d6a00: OUTPUT: «0.60221237␤»
m: use nqp; my \path = 'foobar'; for ^1000_000 { $ = nqp::eqat(path, '/', 0) }; say now - INIT now
rakudo-moar 1d6a00: OUTPUT: «0.6087144␤»
m: use nqp; my \path = 'foobar'; for ^1000_000 { $ = nqp::ord(path, 42) }; say now - INIT now
rakudo-moar 1d6a00: OUTPUT: «Invalid string index: max 5, got 42␤  in block <unit> at <tmp> line 1␤␤»
m: use nqp; my \path = 'foobar'; for ^1000_000 { $ = nqp::iseq_i(nqp::ord(path), 42) }; say now - INIT now
rakudo-moar 1d6a00: OUTPUT: «0.5711097␤»
m: use nqp; my \path = 'foobar'; for ^1000_000 { $ = nqp::iseq_i(nqp::ord(path), 42) }; say now - INIT now
rakudo-moar 1d6a00: OUTPUT: «0.57414189␤»
m: use nqp; my \path = 'foobar'; for ^1000_000 { $ = nqp::iseq_i(nqp::ord(path), 42) }; say now - INIT now
rakudo-moar 1d6a00: OUTPUT: «0.551144␤»
m: use nqp; my \path = 'foobar'; for ^1000_000 { $ = nqp::iseq_i(nqp::ord(path), 42) }; say now - INIT now
rakudo-moar 1d6a00: OUTPUT: «0.56731220␤»
m: use nqp; my \path = 'foobar'; for ^1000_000 { $ = nqp::iseq_i(nqp::ord(path), 42) }; say now - INIT now
rakudo-moar 1d6a00: OUTPUT: «0.5546373␤»
m: use nqp; my \path = 'foobar'; for ^1000_000 { $ = nqp::iseq_i(nqp::ord(path), 42) }; say now - INIT now
rakudo-moar 1d6a00: OUTPUT: «0.5728016␤»
m: use nqp; my \path = 'foobar'; for ^1000_000 { $ = nqp::iseq_i(nqp::ord(path), 42) }; say now - INIT now
rakudo-moar 1d6a00: OUTPUT: «0.5604309␤»
m: use nqp; my \path = 'foobar'; for ^1000_000 { $ = nqp::eqat(path, '/', 0) }; say now - INIT now
rakudo-moar 1d6a00: OUTPUT: «0.61645485␤»
m: use nqp; my \path = 'foobar'; for ^1000_000 { $ = nqp::eqat(path, '/', 0) }; say now - INIT now
rakudo-moar 1d6a00: OUTPUT: «0.597917␤»
m: use nqp; my \path = 'foobar'; for ^1000_000 { $ = nqp::eqat(path, '/', 0) }; say now - INIT now
rakudo-moar 1d6a00: OUTPUT: «0.6007576␤»
m: use nqp; my \path = 'foobar'; for ^1000_000 { $ = nqp::eqat(path, '/', 0) }; say now - INIT now
rakudo-moar 1d6a00: OUTPUT: «0.6028348␤»
m: dd '/'.ord
rakudo-moar 1d6a00: OUTPUT: «47␤»
star: dd IO::Spec::Unix.canonpath("")'
star-m 2016.10: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Two terms in a row␤at <tmp>:1␤------> 3dd IO::Spec::Unix.canonpath("")7⏏5'␤    expecting any of:␤        infix␤        infix stopper␤        postfix␤        statement end␤        statemen…»
star: dd IO::Spec::Unix.canonpath("")
star-m 2016.10: OUTPUT: «""␤»
star: dd IO::Spec::Unix.canonpath("foo")
star-m 2016.10: OUTPUT: «"foo"␤»
star: dd IO::Spec::Unix.canonpath("foo/")
star-m 2016.10: OUTPUT: «"foo"␤»
star: dd IO::Spec::Unix.canonpath("/")
star-m 2016.10: OUTPUT: «"/"␤»
star: dd IO::Spec::Unix.canonpath("/bar")
star-m 2016.10: OUTPUT: «"/bar"␤»
star: dd IO::Spec::Unix.canonpath("/bar/")
star-m 2016.10: OUTPUT: «"/bar"␤»
“I'd bumped to get the perf improvements which actually knocked 50ms-100ms off startup time” 50ms-100ms startup time improvement? WAT?
ah
read the next message… okay
Context is everything :P
would've been better if context came before that message :)
hmmm I should really make statisfiable6 measure startup time
mhm okay, issue #131… https://github.com/perl6/whateverable/issues/131
rakudo-moar 1d6a00: OUTPUT: «"/"␤»
m: use MONKEY; augment Rat { has $!foo; method x { $!foo } }; Rat.new.x
rakudo-moar 277b6e: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Malformed augment␤at <tmp>:1␤------> 3use MONKEY; augment Rat7⏏5 { has $!foo; method x { $!foo } }; Rat.␤»
m: use MONKEY; augment class Rat { has $!foo; method x { $!foo } }; Rat.new.x
rakudo-moar 277b6e: OUTPUT: «P6opaque: no such attribute '$!foo' in type Rat when trying to get a value␤  in method x at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»
rakudo-moar 277b6e: OUTPUT: «P6opaque: no such attribute '$!foo' in type Rat when trying to get a value␤  in method x at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»
No
Maybe some day we'll manage it but...it's rather problematic to support
Or at least, it is if you're using memory layout for attributes where you just store them in an object body
Which is what P6opaque does
How are mixins handled?
nine: By a change of type table on the individual object being mixed in to, migrating the attributes to another piece of memory that P6opaque has a slot for (which is waste on most objects), making every attribute lookup we do cost an extra branch because of checking this pointer, forcing a deopt of the whole stack and hoping it's sufficient but it ain't because threads but we usually get away with it, and probably leaking memory if you mix in
rakudo-moar 277b6e: OUTPUT: «Invalid BUILD_LEAST_DERIVED plan␤  in block <unit> at <tmp> line 26␤␤»
nine: There are ways to do better on most of the problematic things there.
m: $ = 42 but role { has int $!x }
rakudo-moar 277b6e: ( no output )
m: $ = 42 but role { has int $!x = 42 }
rakudo-moar 277b6e: OUTPUT: «Invalid BUILD_LEAST_DERIVED plan␤  in block <unit> at <tmp> line 1␤␤»
rakudo-moar 277b6e: ( no output )
rakudo-moar 277b6e: OUTPUT: «Invalid BUILD_LEAST_DERIVED plan␤  in block <unit> at <tmp> line 1␤␤»
Though I suspect many of them involve making mixed-in-to things perform a bit worse as the cost for making everything that isn't cheaper
m: $ = 42 but role { has Int $!x  }
rakudo-moar 277b6e: ( no output )
m: $ = 42 but role { has Int $!x =42  }
rakudo-moar 277b6e: ( no output )
m: $ = 42 but role { has Int $!x = 42  }
rakudo-moar 277b6e: ( no output )
Zoffix: That's an...interesting...one :)
jnthn: I'm glad we have still opportunities for huge improvements like that :)
We do but...
If multis are anything to go by, people nearly never say "oh gosh, thanks for spending hours/days/weeks/months figuring out how to make X fast", just "omg Y is so slow compared to X" :P
So if we make most things faster but not mixins, then they comparatively end up seeming glacial, even if they didn't get any worse. ;)
So far we didn't actually define the cross-thread visibility of mixins though :)
Or, well, many other things
Which we'll need to at some point
But these things are pretty hard; I think it took until Java 5 for them to get a good one. :)
hm. the build least derived interpreter can only handle instructions 0 through 7 and also 13
m: use nqp; dd nqp::not_i(True)
rakudo-moar 277b6e: OUTPUT: «0␤»
m: use nqp; dd nqp::not_i(False)
rakudo-moar 277b6e: OUTPUT: «1␤»
bloatable6: releases
AlexDaniel, https://gist.github.com/555bfbc3b0a41c3d680c71fbe0e9e77c
we are growing \o/ :S
Zoffix: F5, github problems
m: use nqp; for ^100_000 { $ = eager gather { nqp::until(nqp::islt_i(++$, 10), take 42) } }; say now - INIT now
rakudo-moar d27266: OUTPUT: «1.1872530␤»
m: use nqp; for ^100_000 { $ = eager Seq.new: class :: does Iterator { has int $.i; method pull-one { nqp::if(nqp::isge_i(++$!i, 10), IteratorEnd, 42) } }.new } }; say now - INIT now
rakudo-moar d27266: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Unexpected closing bracket␤at <tmp>:1␤------> 3(++$!i, 10), IteratorEnd, 42) } }.new } 7⏏5}; say now - INIT now␤»
m: use nqp; for ^100_000 { $ = eager Seq.new: class :: does Iterator { has int $.i; method pull-one { nqp::if(nqp::isge_i(++$!i, 10), IteratorEnd, 42) } }.new }; say now - INIT now
rakudo-moar d27266: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Undeclared name:␤    IteratorEnd used at line 1. Did you mean 'Iterator'?␤␤»
m: use nqp; for ^100_000 { $ = eager Seq.new: class :: does Iterator { has int $.i; method pull-one { nqp::if(nqp::isge_i(++$!i, 10), IterationEnd, 42) } }.new }; say now - INIT now
rakudo-moar d27266: OUTPUT: «2.0855142␤»
fuck you
m: use nqp; for ^100_000 { $ = eager Seq.new: class :: does Iterator { has int $.i; method pull-one { nqp::if(nqp::isge_i(++$!i, 10), IterationEnd, 42) } }.new }; say now - INIT now
rakudo-moar d27266: OUTPUT: «2.118920␤»
m: use nqp; for ^100_000 { $ = eager Seq.new: class :: does Iterator { has int $.i; method pull-one { nqp::if(nqp::isge_i(++$!i, 10), IterationEnd, 42) } }.new }; say now - INIT now
rakudo-moar d27266: OUTPUT: «2.0455326␤»
m: use nqp; for ^100_000 { $ = $_ for eager Seq.new: class :: does Iterator { has int $.i; method pull-one { nqp::if(nqp::isge_i(++$!i, 10), IterationEnd, 42) } }.new }; say now - INIT now
rakudo-moar d27266: OUTPUT: «4.1035354␤»
m: use nqp; for ^100_000 { $ = $_ for Seq.new: class :: does Iterator { has int $.i; method pull-one { nqp::if(nqp::isge_i(++$!i, 10), IterationEnd, 42) } }.new }; say now - INIT now
rakudo-moar d27266: OUTPUT: «2.6538081␤»
m: use nqp; for ^100_000 { $ = $_ for |Seq.new: class :: does Iterator { has int $.i; method pull-one { nqp::if(nqp::isge_i(++$!i, 10), IterationEnd, 42) } }.new }; say now - INIT now
rakudo-moar d27266: OUTPUT: «6.4449059␤»
m: use nqp; for ^100_000 { $ = $_ for gather { nqp::until(nqp::islt_i(++$, 10), take 42) } }; say now - INIT now
rakudo-moar d27266: OUTPUT: «1.62042219␤»
m: class Foo { method x() { $_ = *%_ } }; my $f = Foo.new; for ^100_000 { $ = $f.x }; say now - INIT now
rakudo-moar d27266: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Undeclared name:␤    _ used at line 1␤␤»
m: class Foo { method x() { $ = *%_ } }; my $f = Foo.new; for ^100_000 { $ = $f.x }; say now - INIT now
rakudo-moar d27266: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Undeclared name:␤    _ used at line 1␤␤»
...
m: class Foo { method x() { $ = %_ } }; my $f = Foo.new; for ^100_000 { $ = $f.x }; say now - INIT now
rakudo-moar d27266: OUTPUT: «0.0942981␤»
m: class Foo { method x() { $ = %_ } }; my $f = Foo.new; for ^1000_000 { $ = $f.x }; say now - INIT now
rakudo-moar d27266: OUTPUT: «0.7912751␤»
m: class Foo { method x(*%foos) { $ = %foos } }; my $f = Foo.new; for ^1000_000 { $ = $f.x }; say now - INIT now
rakudo-moar d27266: OUTPUT: «0.78939572␤»
m: class Foo { method x(*%foos) { $ = %foos } }; my $f = Foo.new; for ^1000_000 { $ = $f.x }; say now - INIT now
rakudo-moar d27266: OUTPUT: «0.7802222␤»
m: class Foo { method x(*%foos) { $ = %foos } }; my $f = Foo.new; for ^1000_000 { $ = $f.x }; say now - INIT now
rakudo-moar d27266: OUTPUT: «0.77381384␤»
just confirming (from backlog) that .resolve never worked right on windows
m: use Test:auth<foo>
rakudo-moar d27266: OUTPUT: «===SORRY!===␤Could not find Test:auth<foo> at line 1 in:␤    /home/camelia/.perl6␤    /home/camelia/rakudo-m-inst-2/share/perl6/site␤    /home/camelia/rakudo-m-inst-2/share/perl6/vendor␤    /home/camelia/rakudo-m-inst-2/share/perl6␤    CompUn…»
m: use Test:auth<perl6>
rakudo-moar d27266: OUTPUT: «===SORRY!===␤Could not find Test:auth<perl6> at line 1 in:␤    /home/camelia/.perl6␤    /home/camelia/rakudo-m-inst-2/share/perl6/site␤    /home/camelia/rakudo-m-inst-2/share/perl6/vendor␤    /home/camelia/rakudo-m-inst-2/share/perl6␤    Comp…»
m: use Test:auth<perl>
rakudo-moar d27266: ( no output )
it says you are already in this organization
that mig htahve don et
...
that might have done it
though i considered perl6-community-modules to just be for when modules got abandoned
stack some mods on yo perl6
rakudo-moar d27266: OUTPUT: «No such method 'eval' for invocant of type 'Str'␤  in block <unit> at <tmp> line 1␤␤»
rakudo-moar d27266: ( no output )
rakudo-moar d27266: OUTPUT: «"\".\".IO(:SPEC(IO::Spec::Unix),:CWD(\"/home/camelia\"))"␤»
rakudo-moar d27266: OUTPUT: «"\".\".IO(:SPEC(IO::Spec::Win32),:CWD(\"/home/camelia\"))"␤»
rakudo-moar d27266: OUTPUT: «"\".\".IO(:SPEC(IO::Spec::Unix),:CWD(\"/home/camelia\"))"␤»
if and not_i swapped?
oh, no that's probably fine
oooh
$!SPEC vs $.SPEC
er
$*SPEC
in one of those
well, it's past the release, which is good :)
m: s/will/we'll/;
rakudo-moar ce37b3: OUTPUT: «Use of uninitialized value of type Any in string context.␤Methods .^name, .perl, .gist, or .say can be used to stringify it to something meaningful.␤  in block <unit> at <tmp> line 1␤»
will be interesting to see
timotimo: i had the allocation stuff wrong before, but it looks like it's good now
oh!
i didn't notice :(
well, in the branch i'm working on
but now you can recreate the two views in the current allocations tab
fantabulastic
total allocations by type, and which routines they were allocated in
it's dinner time here right now!
what was the other info you were interested in? which routines called a particular other routine?
exactly
i.e. "who the hell is calling bind_one_param all the damn time"
i'll see if i can figure that out
That would be sooo helpful
i do enjoy sql, and haven't gotten to do any at $work in a while
This is Rakudo version 2017.04.2-13-gce37b31a3 built on MoarVM version 2017.04
csv-ip5xs        3.053
test            13.086
test-t           5.181 - 5.351
csv-parser      13.294
Files=1191, Tests=56772, 215 wallclock secs (12.43 usr  4.61 sys + 1254.92 cusr 126.41 csys = 1398.37 CPU)
lizmat: Hm, that was 198s yesterday, no? :)
I remember 'cus I was like "huh, sub-200s, nice" :)
yeah, could be an artefact of something else going on on my computer at the same time
still, test-t was rather high as well
I run this always like 5am in the morning when my MBP has been dormant for a few hours
to give it the benefit of not getting throttled because the CPU is running hot
08:31Z <samcv> Zoffix: is there anyway we could have `dir :d` or `dir :f` to get all directories or all files etc?
Isn't there a test parameter for that?
Locking test file?
.say for dir(:test(*.IO.d))
Works :)
ok. you know better than i do
Oh, that kind of lock :)
i will defer to your judgment
It's a little unfortunate the test parameter is passed a string in dir though
I'd hoped I could just write dir(:test(*.d))
*.IO.d means you need to be really careful if you're not doing the CWD
(And so maybe have to prepend something to it before .IO-ing)
At which point it'd have been easier to just "next unless .d" :)
Or .grep(!*.d) I guess :)
uh, just *.d :)
But yeah, I agree with Zoffix++; it's only a few more chars to grep it out
Zoffix: I don't know. Maybe from when IO::Path was costly to construct so you could filter cheaper just on Str?
But...that's not really a good reason :)
Zoffix: is that test file marked as "slow" ?
:-)
well then.
a module must surely be made!
by someone! eventually
:)
nope
not recursive
but that could be cool too i guess. but. i think getting all the files in a folder should be very simple to do
or all the directories as determined by .d or .f
i'm not expecting anything except the exact same evaluation the .d or .f things already check for
m: indir '/tmp', { dd $*CWD; dir :test{ dd $*CWD }}
rakudo-moar 736be4: OUTPUT: «IO::Path $*CWD = "/tmp".IO(:SPEC(IO::Spec::Unix),:CWD("/home/camelia"))␤IO::Path <element> = "/home/camelia".IO(:SPEC(IO::Spec::Unix),:CWD("/home/camelia"))␤IO::Path <element> = "/home/camelia".IO(:SPEC(IO::Spec::Unix),:CWD("/home/camelia"))␤IO::Pa…»
m: indir '/tmp', { say $*CWD; dir :test{ dd $*CWD; exit}}
rakudo-moar 736be4: OUTPUT: «"/tmp".IO␤IO::Path <element> = "/home/camelia".IO(:SPEC(IO::Spec::Unix),:CWD("/home/camelia"))␤»
m: indir '/tmp', { say $*CWD; dir :test{ say $*CWD; exit}}
rakudo-moar 736be4: OUTPUT: «"/tmp".IO␤"/home/camelia".IO␤»
rakudo-moar 736be4: OUTPUT: «"/tmp".IO␤"/home/camelia".IO␤»
m: indir '/tmp', { say $*CWD; dir :test{ say $*CWD; exit}}
rakudo-moar 736be4: OUTPUT: «"/tmp".IO␤"/home/camelia".IO␤»
m: indir '/tmp', { say $*CWD; my $test = { say $*CWD; exit}; $test.ACCEPTS("foo") }
rakudo-moar 736be4: OUTPUT: «"/tmp".IO␤"/tmp".IO␤»
m: sub dir2 ($test) { $test.ACCEPTS: "foo" }; indir '/tmp', { say $*CWD; dir2 { say $*CWD; exit} }
rakudo-moar 736be4: OUTPUT: «"/tmp".IO␤"/tmp".IO␤»
m: sub dir2 ($test) { gather { $test.ACCEPTS: "foo" } }; indir '/tmp', { say $*CWD; dir2 { say $*CWD; exit} }
rakudo-moar 736be4: OUTPUT: «"/tmp".IO␤"/home/camelia".IO␤»
m: sub dir2 ($test) { gather { $test.ACCEPTS: "foo" } }; indir '/tmp', { say $*CWD; @ = dir2 { say $*CWD; exit} }
rakudo-moar 736be4: OUTPUT: «"/tmp".IO␤"/tmp".IO␤»
rakudo-moar 736be4: OUTPUT: «"/tmp".IO␤"/home/camelia".IO␤»
rakudo-moar 736be4: OUTPUT: «"/tmp".IO␤"/tmp".IO␤»
m: sub dir2 ($test) { temp $*CWD = "/tmp"; gather { $test.ACCEPTS: "foo" } }; indir '/tmp', { say $*CWD; @ = dir2 { say $*CWD; exit} }
rakudo-moar 736be4: OUTPUT: «"/tmp".IO␤"/tmp".IO␤»
m: sub dir2 ($test) { temp $*CWD = "/tmp"; gather { $test.ACCEPTS: "foo" } }; indir '/tmp', { say $*CWD; dir2 { say $*CWD; exit} }
rakudo-moar 736be4: OUTPUT: «"/tmp".IO␤"/home/camelia".IO␤»
m: sub dir2 ($test) { gather { temp $*CWD = "/tmp";  $test.ACCEPTS: "foo" } }; indir '/tmp', { say $*CWD; dir2 { say $*CWD; exit} }
rakudo-moar 736be4: OUTPUT: «"/tmp".IO␤/tmp␤»
rakudo-moar 736be4: OUTPUT: «"/tmp".IO␤/tmp␤»
m: my $stuff = indir '/tmp' { gather { $*CWD } }; dd $stuf
rakudo-moar 736be4: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Unexpected block in infix position (missing statement control word before the expression?)␤at <tmp>:1␤------> 3my $stuff = indir '/tmp'7⏏5 { gather { $*CWD } }; dd $stuf␤    expecting any of:…»
m: my $stuff = indir '/tmp', { gather { $*CWD } }; dd $stuf
rakudo-moar 736be4: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Variable '$stuf' is not declared. Did you mean '$stuff'?␤at <tmp>:1␤------> 3 indir '/tmp', { gather { $*CWD } }; dd 7⏏5$stuf␤»
m: my $stuff = indir '/tmp', { gather { $*CWD } }; dd $stuff
rakudo-moar 736be4: OUTPUT: «Seq $stuff = ().Seq␤»
m: my $stuff = eager indir '/tmp', { gather { $*CWD } }; dd $stuff
rakudo-moar 736be4: OUTPUT: «List $stuff = $( )␤»
m: my @stuff = indir '/tmp', { gather { $*CWD } }; dd @stuff
rakudo-moar 736be4: OUTPUT: «Array @stuff = []␤»
m: my @stuff = indir '/tmp', { gather { dd $*CWD } }; dd @stuff
rakudo-moar 736be4: OUTPUT: «IO::Path <element> = "/home/camelia".IO(:SPEC(IO::Spec::Unix),:CWD("/home/camelia"))␤Array @stuff = []␤»
m: my @stuff = indir '/tmp', { gather { $*CWD } }; dd @stuff
rakudo-moar 736be4: OUTPUT: «Array @stuff = []␤»
m: my @stuff = indir '/tmp', { gather { take $*CWD } }; dd @stuff
rakudo-moar 736be4: OUTPUT: «Array @stuff = ["/home/camelia".IO(:SPEC(IO::Spec::Unix),:CWD("/home/camelia"))]␤»
m: my $stuff = indir '/tmp', { gather { take $*CWD } }; say $stuff
rakudo-moar 736be4: OUTPUT: «("/home/camelia".IO)␤»
m: my $stuff = indir '/tmp', { gather { my $CWD = $*CWD; take $*CWD } }; say $stuff
rakudo-moar 736be4: OUTPUT: «("/home/camelia".IO)␤»
m: my $stuff = indir '/tmp', { gather { temp $*CWD; take $*CWD } }; say $stuff
rakudo-moar 736be4: OUTPUT: «("/home/camelia".IO)␤»
m: my $stuff = indir '/tmp', { gather { dd $*CWD; temp $*CWD; take $*CWD } }; say $stuff
rakudo-moar 736be4: OUTPUT: «IO::Path <element> = "/home/camelia".IO(:SPEC(IO::Spec::Unix),:CWD("/home/camelia"))␤("/home/camelia".IO)␤»
m: my $stuff = indir '/tmp', { dd $*CWD;' gather { dd $*CWD; temp $*CWD; take $*CWD } }; say $stuff
rakudo-moar 736be4: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Unable to parse expression in single quotes; couldn't find final "'" ␤at <tmp>:1␤------> 3; temp $*CWD; take $*CWD } }; say $stuff7⏏5<EOL>␤    expecting any of:␤        single quotes␤      …»
m: my $stuff = indir '/tmp', { dd $*CWD; gather { dd $*CWD; temp $*CWD; take $*CWD } }; say $stuff
rakudo-moar 736be4: OUTPUT: «IO::Path $*CWD = "/tmp".IO(:SPEC(IO::Spec::Unix),:CWD("/home/camelia"))␤IO::Path <element> = "/home/camelia".IO(:SPEC(IO::Spec::Unix),:CWD("/home/camelia"))␤("/home/camelia".IO)␤»
m: my $stuff = indir '/tmp', { say $*CWD; gather { dd $*CWD; temp $*CWD; take $*CWD } }; say $stuff
rakudo-moar 736be4: OUTPUT: «"/tmp".IO␤IO::Path <element> = "/home/camelia".IO(:SPEC(IO::Spec::Unix),:CWD("/home/camelia"))␤("/home/camelia".IO)␤»
m: my $stuff = indir '/tmp', { say $*CWD; gather { say ~$*CWD; temp $*CWD; take $*CWD } }; say $stuff
rakudo-moar 736be4: OUTPUT: «"/tmp".IO␤/home/camelia␤("/home/camelia".IO)␤»
m: my $stuff = indir '/tmp', { say $*CWD; gather { say ~$*CWD; take $*CWD } }; say $stuff
rakudo-moar 736be4: OUTPUT: «"/tmp".IO␤/home/camelia␤("/home/camelia".IO)␤»
m: my $stuff = indir '/tmp', { my $CWD = $*CWD; gather { take $CWD } }; say $stuff
rakudo-moar 736be4: OUTPUT: «("/tmp".IO)␤»
m: my $stuff = indir '/tmp', { my $CWD = $*CWD; gather { take ".".IO } }; say $stuff
rakudo-moar 736be4: OUTPUT: «(".".IO)␤»
m: my $stuff = indir '/tmp', { my $CWD = $*CWD; gather { my $*CWD = $CWD;  ".".IO } }; say $stuff
rakudo-moar 736be4: OUTPUT: «()␤»
m: my $stuff = indir '/tmp', { my $CWD = $*CWD; gather { my $*CWD = $CWD; take ".".IO } }; say $stuff
rakudo-moar 736be4: OUTPUT: «(".".IO)␤»
m: my $stuff = indir '/tmp', { my $CWD = $*CWD; gather { my $*CWD = $CWD; take ".".IO } }; dd $stuff
rakudo-moar 736be4: OUTPUT: «Seq $stuff = (".".IO(:SPEC(IO::Spec::Unix),:CWD("/tmp")),).Seq␤»
m: my $stuff = indir '/tmp', { gather { temp $*CWD take ".".IO } }; dd $stuff
rakudo-moar 736be4: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Two terms in a row␤at <tmp>:1␤------> 3ff = indir '/tmp', { gather { temp $*CWD7⏏5 take ".".IO } }; dd $stuff␤    expecting any of:␤        infix␤        infix stopper␤        statement e…»
m: my $stuff = indir '/tmp', { gather { temp $*CWD; take ".".IO } }; dd $stuff
rakudo-moar 736be4: OUTPUT: «Seq $stuff = (".".IO(:SPEC(IO::Spec::Unix),:CWD("/home/camelia")),).Seq␤»
m: my $stuff = indir '/tmp', { gather { temp $*CWD; take ".".IO } }; dd $stuff».CWD
rakudo-moar 736be4: OUTPUT: «$("/home/camelia",)␤»
m: my $stuff = indir '/tmp', { gather { temp $*CWD; take ".".IO } }; say $stuff».CWD
rakudo-moar 736be4: OUTPUT: «(/home/camelia)␤»
m: my $stuff = indir '/tmp', { gather { take ".".IO } }; say $stuff».CWD
rakudo-moar 736be4: OUTPUT: «(/home/camelia)␤»
m: say indir('/tmp', { gather { take ".".IO } })».CWD
rakudo-moar 736be4: OUTPUT: «(/home/camelia)␤»
m: say indir('/tmp', { my $CWD = $*CWD; gather { temp $*CWD = $CWD; take ".".IO } })».CWD
rakudo-moar 736be4: OUTPUT: «(/tmp)␤»
m: say indir('/tmp', { my $cwd = $*CWD; gather { temp $*CWD = $cwd; take ".".IO } })».CWD
rakudo-moar 736be4: OUTPUT: «(/tmp)␤»
m: say indir('/tmp', { my $cwd = $*CWD; gather { take IO::Path.new(".", :$CWD) } })».CWD
rakudo-moar 736be4: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Variable '$CWD' is not declared. Did you mean '$cwd'?␤at <tmp>:1␤------> 3$*CWD; gather { take IO::Path.new(".", :7⏏5$CWD) } })».CWD␤»
m: say indir('/tmp', { my $CWD = $*CWD; gather { take IO::Path.new(".", :$CWD) } })».CWD
rakudo-moar 736be4: OUTPUT: «IO::Path is disallowed in restricted setting␤  in sub restricted at src/RESTRICTED.setting line 1␤  in method new at src/RESTRICTED.setting line 32␤  in block <unit> at <tmp> line 1␤␤»
ACTION likes composable APIs
TimToady: I think https://rt.perl.org/Ticket/Display.html?id=131187 may be uncurse fallout, if you get chance to take a look
m: say 'foobar' ~~ /foo<(bar/
rakudo-moar 736be4: OUTPUT: «｢bar｣␤»
yes, if I recall correctly these 20 unbuildable commits are due to uncurse merge
m: (1, 2, 3).AT-POS: 10
rakudo-moar 736be4: ( no output )
m: dd (1, 2, 3).AT-POS: 10
rakudo-moar 736be4: OUTPUT: «Nil␤»
m: for ^100_000 { temp $*CWD = $*CWD.IO }; say now - INIT now
rakudo-moar 736be4: OUTPUT: «0.8027683␤»
m: for ^100_000 { my $cwd = $*CWD.IO; my $*CWD = $cwd }; say now - INIT now
rakudo-moar 736be4: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Illegal post-declaration of dynamic variable '$*CWD';␤earlier access must be written as CALLERS::<$*CWD>␤if that's what you meant␤at <tmp>:1␤------> 3 ^100_000 { my $cwd = $*CWD.IO; my $*CWD7⏏…»
m: for ^100_000 { my $cwd = $*CWD.IO; {my $*CWD = $cwd} }; say now - INIT now
rakudo-moar 736be4: OUTPUT: «0.4001578␤»
m: for ^100_000 { my $cwd = $*CWD.IO; {my $*CWD = $cwd} }; say now - INIT now
rakudo-moar 736be4: OUTPUT: «0.3941603␤»
m: for ^100_000 { my $cwd = $*CWD.IO; {my $*CWD = $cwd} }; say now - INIT now
rakudo-moar 736be4: OUTPUT: «0.4028068␤»
m: Lock.new.protect: 1
rakudo-moar 736be4: OUTPUT: «Attempt to unlock mutex by thread not holding it␤  in block <unit> at <tmp> line 1␤␤»
Now that's an odd error, considering that protect has a signature of rotect(Lock:D: &code)
rakudo-moar 736be4: OUTPUT: «((Lock:D $: &code, *%_))␤»
rakudo-moar 736be4: OUTPUT: «Attempt to unlock mutex by thread not holding it␤  in block <unit> at <tmp> line 1␤␤»
m: class C { method m(&foo) { LEAVE say 'lol' } }; C.m(1)
rakudo-moar 736be4: OUTPUT: «lol␤Type check failed in binding to parameter '&foo'; expected Callable but got Int (1)␤  in method m at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»
That's why :)
In case anyone wonders: discovered this by commenting out the code in the block when debugging. Turning the block into an empty hash.
I don't think so
I mean
sub foo($handle = open('foo', :r)) { LEAVE $handle.?close; blah }
Wouldn't work and could be also reported as a bug if we did things the other way :)
m: class C { multi method m(&foo) { LEAVE say 'lol' } }; C.m(1)
rakudo-moar 736be4: OUTPUT: «Cannot resolve caller m(C: Int); none of these signatures match:␤    (C $: &foo, *%_)␤  in block <unit> at <tmp> line 1␤␤»
An easy workaround ;)
heh, yes :)
I think the LEAVE behavior is OK, but Lock.protect wants hardening
Would be a lovely example for some advanced Perl 6 class, I guess.
It'd at present also try to release it if we somehow got an exception when trying to acquire it
c: 2016.10,2016.11 Lock.new.protect: 1
fwiw https://github.com/rakudo/rakudo/commit/48c2af6d059c6446d35f68f70d415c8fe593eaca
Ah, used to be a CATCH block but now uses LEAVE
Yes
That fixed a nasty bug :)
Where a control exception causing an unwind wouldn't unlock things
m: class C { method m(&foo) { { LEAVE say "lol" } } }; C.m(1)
rakudo-moar 736be4: OUTPUT: «Type check failed in binding to parameter '&foo'; expected Callable but got Int (1)␤  in method m at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»
Another very simple workaround
Also easy to find, once you accept that argument checking is really just part of the method body.
jnthn: anything against committing that block workaround?
It doesn't solve the second thing I mentioned :)
I was going to have a my int $acquired; npq::lock(...); $acquired = 1; LEAVE $acquired && nqp::unlock(...)
Ah, just now read that
I guess that's also far more self documenting :)
ACTION is back to fixing that precomp unit cache invalidation issue
ACTION has been hunting down why SSH::LibSSH just effectively hangs on connection errors
you're using up your process file handles
ACTION how will Zoffix get a handle on this problem :)
incidentally, spectest with harness6 and the default TEST_JOBS=1 also suffers from this, one handle per test file is used up so if your limit is 1024 you're out of luck
test
TEST_JOBS=1 and TEST_JOBS=1+ have different code paths
to be more specific, the problem is in TAP.pm6
ACTION agrees with Zoffix
Zoffix: you'll have to wait :(
a nifty trick
even if you do it the slow way, the problem is easy to observe by means of peeking into /proc/<main perl6 pid>/fd
so two minutes then :)
:)
perhaps it's libuv which does the aborting
break on abort() in gdb and then do call MVM_dump_backtrace(tc)
set follow-fork-mode child
anyone know the history behind "Inferior 1"? does gdb just have a really high opinion of itself?  what does it say if you try to run gdb inside gdb?
Zoffix: what happens if you type 'q' followed by enter after you receive the Inferior message
Zoffix: yes
ACTION I think
Zoffix: TAP.pm was someone's first attempt at writing idiomatic Perl 6 code, afaik
and I, for one, am glad he did that
lizmat: did you see my comment on your Exceptions.pm commit?
nine: you said you were interested in seeing which routines called a specific other routine in a profile? i think i have it, but do you a use case or something i could test with?
multi get_runner(Source::File $file; TAP::Entry::Handler @handlers) ...
MasterDuke_: Inline::Perl5 spends most of its time in NativeCall code, so CALL is usually on the top of the list. But there's plenty of places which call into NativeCall.
nine: so i could just do some random stuff with Inline::Perl5, profile it, and see if i can tell where CALL is called?
yep
Zoffix: re doc, most of internals suffers from not enough doc  :-(
Zoffix: re leont, last time I spoke to him, he said he wanted to spend more time on it again, perhaps doccing could be an attention point  :-)
the last time I looked at TAP.pm, it wasn't easy to get into
but then, HARNESS_TYPE=6 didn't work very well either because of many race issues
so I didn't pursue at the time
Zoffix: is lib/TAP.pm6 still tracked in the rakudo repo ?
nine: do i need to install Inline::Perl5? or should just `-I <path/to/>/Inline-Perl5/lib/ -e 'use Inline::Perl5; use List::Util:from<Perl5>' work?
Both should be fine
Even perl6 -I <path/to/>/Inline-Perl5/lib/ -e 'use List::Util:from<Perl5>'
ooh, do i need perl5-dev (i'm on ubuntu) or something like that installed?
yes
If the README is missing some part about installation, please tell me :)
MasterDuke_: libperl-dev
ilmari: thanks
nine: i just checked and i do have libperl-dev installed, but i'm getting an error trying to use I::P5
what error?
https://gist.github.com/MasterDuke17/ab04dd2e2eedd9372059463f63fb3637
MasterDuke_: you don't have to install it, but at least build it: perl6 configure.pl6 && make
ah, good to go now, thanks
and that is in the Building section of the readme, i didn't read far enough
Maybe I really should move that section up. But OTOH I've always hated READMEs that tell me how to install first, because usually I have the software installed already (from a distro package or CPAN)
maybe just a link at the top down to that section?
"if installing manually, instructions <here>"
and yeah, last time i used Inline::Perl5 it had been installed from a distro package, so i had never seen that error before
star: use Inline::Perl5; use List::Util:from<Perl5> <shuffle>; my @a = shuffle ^10; dd @a
star-m 2016.10: OUTPUT: «===SORRY!===␤Could not find Inline::Perl5 at line 1 in:␤    /home/camelia/.perl6␤    /home/camelia/star-2016.10/share/perl6/site␤    /home/camelia/star-2016.10/share/perl6/vendor␤    /home/camelia/star-2016.10/share/perl6␤    CompUnit::Repository…»
nine: should ^^^ shuffle the array? it doesn't locally
oh, i have to slip it
m: sub infix:<⁣> { $^a + $^b }; say 2⁣2;
rakudo-moar 89f2ae: OUTPUT: «4␤»
buggable: eco Form
buggable: eco Forms
buggable: eco For
buggable: eco Fordasdasdasdsa
buggable: eco IRC::Client
buggable: eco Pastebin::Gist
nine: CALL-ME?
ah, yes
but here's my object, so CALL-ME maybe
It's been a while since I have looked at performance :) Looks like I've still a comfortabl 2 second lead ;)
Scary: we're actually rather close to being able to ship binary packages for modules...
Zoffix: ok, just wanted to make sure I hadn't missed anything in that respect
no hurry from my side  :-)
Zoffix: please don't!
Zoffix: building rakudo should not do any network access. That won't fly with distro build services
nine: but roast is also fetched over the network
so ?
lizmat: not as part of a plain build.
TAP.pm6 is only needed for testing
not as part of the build, afaik
For make test?
but for make test we don't need TAP.pm6 do qwe ?
If only make spectest pulls tap-harness6, I'm of course completely fine with it :)
But....TAP is currently part of the CORE dist
dinner&
nine: i profiled this `use Inline::Perl5; use List::Util:from<Perl5> <shuffle>; use List::MoreUtils:from<Perl5> <minmax>; my @a = shuffle |(^10); my @b = minmax |@a; dd @b;`, and found CALL-ME was only called here https://github.com/rakudo/rakudo/blob/nom/src/Perl6/Metamodel/BOOTSTRAP.nqp#L2992
does that seem right?
buggable, eco 007
gentlemen, avert the eyes of children...
buggable, eco Acme::Flutterby:ver('0.01'):auth('John Scoles')
buggable, eco Acme::Flutterby
buggable, eco Acme::DSON
buggable, eco Acme::Flutterby
buggable, eco Acme::Sudoku
buggable, eco Adventure::Engine
buggable, eco Algorithm::Kruskal
buggable, eco Algorithm::LibSVM
buggable, eco Algorithm::Viterbi
buggable, eco App::P6Dx
buggable, eco AttrX::InitArg
buggable, eco Audio::OggVorbis
buggable, eco Audio::PortMIDI
buggable, eco Audio::Silan
buggable, eco Auth::SAML2
Wtf are you doing?
buggable, eco Binary::Structured
buggable, eco BioInfo
buggable, eco CompUnit::DynamicLib
buggable, eco CompUnit::Repository::Panda
buggable, eco CompUnit::Repository::Tar:auth('github:ugexe')
buggable, eco Coroutines
buggable, eco C::Parser
buggable, eco Crust
buggable, eco Crypt::TweetNacl
buggable, eco Data::Dump::Tree
buggable, eco DateTime::DST
buggable, eco DBDish::ODBC
buggable, eco Ddt
s/do/doing/
This CALL-ME? https://github.com/rakudo/rakudo/blob/nom/lib/NativeCall.pm6#L327
sena_kun: perl6 -MWWW -e '.say for jget("https://modules.perl6.org/.json")<dists>».<name url>'
Thanks.
sena_kun: BTW, https://modules.perl6.org/repo/SOME::MODULE::NAME will redirect to the module's repo, so if you're trying to link to some module, you can use that URL
(can't clone the repo via it tho :/)
If you are interested about "wtf this robot bully doing". :)
ok
yep
s: Failure.new, 'Str', \()
jnthn: yes, that's almost certainly uncurse related; unifying $!to with $!pos was a slight overreach
I've been thinking about disunifying those anyway to save allocation of a bunch of position-only cursors for trailing ws
and <( )> can probably use the same distinction between $!to and $!pos
it's one more attribute but a bunch fewer cursors
which is probably a win
but I'll probably just add in the $!to first on the first-make-it-work-right principle
MasterDuke_: do you get different callers for that BOOTSTRAP code? I've never looked closely at what's between Inline::Perl5 and that CALL-ME.
call-args on line 757, p6_to_p5 on line 279, Array on line 545, p5_to_p6 on line 621, and some anonymous block on line 626 (all from Inline-Perl5/lib/Inline/Perl5.pm6)
buggable: tag testneeded
TimToady: Ah, that would explain it, yes.
timotimo: if you see my conversation with nine earlier, i think i can now find the routines that call a specific routine in a profile. can you give me a use case to test with?
Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=131187
dunno if that merits a point release or not...
certainly worth getting into Star though
which would imply a point release
feels to me anyway
nod
ACTION wonders which modules that fixes...
lizmat: did you see my earlier question about your Exception.pm commit?
MasterDuke_: no, I haven't
ok, was wondering if there was a reason you didn't make the same change to the exception i added?
fixes File::Ignore anyway...
MasterDuke_: no reason, I just git stash popped something that was from before you added that one
and I didn't notice
will do so now
ah ha, i suspected that exact cause
.oO(SETI has found infinite Setties on Alpha Settari!)
ACTION is super concerned about the fact that we had not one but multiple point releases and are continually talking bout more.
might be time to think about moving to a more structure branch and release strategy.
FWIW, I think the current release's breakage would have been covered had we had a cpan-testers like thing for the ecosystem
oof, #perl6-dev is the slower of the two and it's still too much for me to backlog over comfortably >_<
I'm with lizmat. Noone tests release branches.
Linux distributions are learning that lesson, too. openSUSE is moving towards their rolling release distro which helped greatly by their openQA automated integration testing.
MasterDuke_: you see, while "repairing" rc-forest-fire off of rosettacode's Forest Fire page, i stumbled upon "bind" being called a crapton. let me see what it was before i changed stuff around
So we should at least include emmentaler in the release process but much better would be fully automated testing of every single commit.
"for @!coords -> ($i, $j) {"
this one asploded it
That could be a good topic for the Perl Toolchain Summit
so i changed @!coords to have a "flat" in front when it was generated, and then removed the ( ) around $i, $j
and that made it a crapton better
nine: agree
timotimo: Is your rc-forest-fire change a correctness problem or a performance bug?
*to fix a
japhb: errrr, i'm not sure any more. but i did get it blazing fast by the end
japhb: it turned out at some point Enum ~~ Enum got mangled so it went via Num ~~ Num, which had not only two blocks inside it, but also had to isinfornan self before going on
the Enum ~~ Enum candidate i created for this reason is in the recent releases iirc, and the improved Num ~~ Num candidate, too
ACTION wonders what "blazing fast" actually means in this case ....
hm
I have high standards on that one.  ;-)
21.62user 0.19system 0:21.91elapsed 99%CPU (0avgtext+0avgdata 111900maxresident)k - this is a 40x40 field at 1_000 iterations
not shabby.
So about 50 fps at 40x40?  Yeah, that's a decent start.
now that our profiler output is fixed ...
it's a good sign when the first four routines are all green :)
:-)
i should be fixing the random seed
wow, we have a frame <anon> in file <unknown> at line <unknown> that's creating a crapton of Int objects
oh my. the ratios for whether a tree should be made or a tree should catch fire are Rat objects, we're comparing a whole lot of Num objects generated by rand against them
turning these into Num cut off like half a second only, though
not such a huge impact either way.
the step function takes 70% of time, show 30%
hello, 16.7s
@foo[$i;$j] is a bit more expensive than @foo.AT-POS($i).AT-POS($j)
Agreed, that can be part of the 6.d plan (and release announcement about how we're tightening the policy a bit)
the innermost block, which is four "when" inside a "given", spends 27.67% of its time in "succeed"
ugh, all succeed does is call THROW, but only 73% of its time is spent inside THROW
oh hello 14 seconds (turned the whens into an if/elsif
danke. just getting p6doc building on my new mactop.
aha, it doesn't matter to put a --> Nil on the block we're for-ing if it has two arguments because we only specialcase for one argument when "not slippy"
though actually the problem isn't that. i's going through sink-all already
i guess i was hoping the return value of Nil would cause it to sink without calling .sink on anything
succeed tries to sink the return value of THROW-NIL, which is defined to be Nil :(
actually, the throw isn't supposed to return at all
so where does the overhead come from ...
oh, i didn't realize it was calling succeed($x) all this time
s: &prefix:<++>, \($ = '1999')
s: '1999', 'succ', \()
m: dd Rakudo::Internals.SUCC: '1999'
rakudo-moar 9ed89d: OUTPUT: «Too few positionals passed; expected 3 arguments but got 2␤  in block <unit> at <tmp> line 1␤␤»
m: dd Rakudo::Internals.SUCC: '1999', 3
rakudo-moar 9ed89d: OUTPUT: «"2000"␤»
m: dd Rakudo::Internals.SUCC: '1999', 2
rakudo-moar 9ed89d: OUTPUT: «"2009"␤»
m: dd Rakudo::Internals.SUCC: '1999', 3
rakudo-moar 9ed89d: OUTPUT: «"2000"␤»
m: dd '1999'.ords.succ».chr.join
rakudo-moar 9ed89d: OUTPUT: «No such method 'succ' for invocant of type 'Seq'␤  in block <unit> at <tmp> line 1␤␤»
m: dd '1999'.ords[*-].succ».chr.join
rakudo-moar 9ed89d: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Missing required term after infix␤at <tmp>:1␤------> 3dd '1999'.ords[*-7⏏5].succ».chr.join␤    expecting any of:␤        prefix␤        term␤»
m: dd '1999'.ords[*-1].succ».chr.join
rakudo-moar 9ed89d: OUTPUT: «":"␤»
m: dd '1999'.ords[*-1].=succ».chr.join
rakudo-moar 9ed89d: OUTPUT: «Cannot modify an immutable Int␤  in block <unit> at <tmp> line 1␤␤»
m: dd '1999'.ords.Array.[*-1].=succ».chr.join
rakudo-moar 9ed89d: OUTPUT: «":"␤»
m: dd ('1999'.ords.Array.[*-1].=succ)».chr.join
rakudo-moar 9ed89d: OUTPUT: «":"␤»
m: dd ('1999'.ords.Array.[*-1].=succ)
rakudo-moar 9ed89d: OUTPUT: «Int <element> = 58␤»
m: dd ('1999'.ords.Array.succ)
rakudo-moar 9ed89d: OUTPUT: «No such method 'succ' for invocant of type 'Array'␤  in block <unit> at <tmp> line 1␤␤»
m: dd ('1999'.ords)
rakudo-moar 9ed89d: OUTPUT: «(49, 57, 57, 57).Seq␤»
m: dd ('1999'.ords.List.succ)
rakudo-moar 9ed89d: OUTPUT: «No such method 'succ' for invocant of type 'List'␤  in block <unit> at <tmp> line 1␤␤»
m: dd .[*-1]++, .».chr.join with '1999'.ords.Array
rakudo-moar 9ed89d: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Malformed postfix call (only alphabetic methods may be detached)␤at <tmp>:1␤------> 3dd .[*-1]++, .7⏏5».chr.join with '1999'.ords.Array␤»
m: dd .[*-1]++, $_.».chr.join with '1999'.ords.Array
rakudo-moar 9ed89d: OUTPUT: «57␤"199:"␤»
m: .[*-1]++, dd $_.».chr.join with '1999'.ords.Array
rakudo-moar 9ed89d: OUTPUT: «"199:"␤»
m: my $x = '1999'; $x.substr-rw($x.chars-1, 1) = 'a'; dd $x
rakudo-moar 9ed89d: OUTPUT: «Str $x = "199a"␤»
m: my $x = '1999'; $x.substr-rw($x.chars-1, 1) = $x.comb.tail.ord.&[+](1).chr; dd $x
rakudo-moar 9ed89d: OUTPUT: «Str $x = "199:"␤»
TimToady: Thanks for the fix; did I miss a test going in, or shall I add my golfed example to roast?
I did not add a test
k, will do, so we've got it covered in roast as well as a module :)
Zoffix: i think the multiple dispatch explodes when it's trying to invoke the here clause
maybe we have to put Any:D in front so it'll refuse to try to run the where clause
i'll ask robertle to try that locally
Zoffix: thanks for giving that tool the much-needed cleanup!
i'm not sure if i Zoffix++ when you did
huggable, perl6
huggable, perl 6
huggable, nbsp
u:
huggable, nbsp perl -pi -e 's/Perl 6/Perl\x{A0}6/g'
huggable, nbsp :is: Change 'Perl 6' to one with no-break space: perl -pi -e 's/Perl 6/Perl\x{A0}6/g'  SOME-FILE
ugh
rakudo-moar 9ed89d: OUTPUT: «Constraint type check failed in binding to parameter '$x'; expected anonymous constraint to be met but got Str (Str)␤  in sub  at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»
rakudo-moar 9ed89d: OUTPUT: «there␤»
rakudo-moar 9ed89d: OUTPUT: «there␤»
anyway, i committed a little patch for it
oh, you PR'd it, too
sorry
oh
it ended up with a combination of both, it seems like?
i.e. the :D and the try
Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=131187
$ perl6 -e '\
say 1;\
'
why doesn't that work? (same with perl 5)
its the same in the repl
just say 1;\ return
yeah
Zoffix: i put the greps for SETTING:: (well, what it was before the names changed) in there mostly because i didn't want to see coverage of the .t files from the test suite. maybe the greps are unnecessary in total because you can just preprocess the coverage reports?
you think a --usermode switch would be a good idea?
that's sensible, as we core haxors know What We Are Doing (and we know What We Are Doing Is Kinda Bad)
m: multi method xtension(IO::Path:D:                                         --> Str:D);
rakudo-moar 9ed89d: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Missing block␤at <tmp>:1␤------> 3                              --> Str:D)7⏏5;␤»
rakudo-moar 9ed89d: OUTPUT: «｢c｣␤»
s: Map.new, 'ACCEPTS', \(Map.new)
timotimo, need a bit of help fixing this bug
m: say "b" ~~ m:i/ba/
rakudo-moar 9ed89d: OUTPUT: «｢b｣␤»
only on m:i and the last letter of left string batches the first of the right
m: say "aaaaaaaab" ~~ m:i/ba/
rakudo-moar 9ed89d: OUTPUT: «｢b｣␤»
and it doesn't happen with variables but only if it's actually written in the source code or EVAL'd
m: say "aaaaaaaaaaaaaaaaab" ~~ m:i/abaa/
rakudo-moar 9ed89d: OUTPUT: «｢ab｣␤»
m: say "aaaaaaaabcd" ~~ m:i/abcd111111/
rakudo-moar 9ed89d: OUTPUT: «｢abcd｣␤»
m: say "aaaaaaaabcd" ~~ m:i/.abcd111111/
rakudo-moar 9ed89d: OUTPUT: «｢aabcd｣␤»
m: say "aaaaaaaabcd" ~~ m:i/3abcd111111/
rakudo-moar 9ed89d: OUTPUT: «False␤»
hmm actually it's a problem in the moarvm function. ok
i know how to fix this then
probably....
c: 2017.03 say "abc" ~~ m:i/caaaaa/
ok tests added. i have them passing in my build of mvm. will commit it in a bit
This is Rakudo version 2017.04.2-22-g9ed89d947 built on MoarVM version 2017.04
csv-ip5xs        3.060
test            12.986
test-t           5.194 - 5.237
csv-parser      13.342
messages?
ok i'm going crazy someone please help
see https://travis-ci.org/MoarVM/MoarVM/jobs/224609074#L1062
i have no clue where this is coming from
tag 9999-please-do-not-use-these-7-gde3e5cf is bogus. but it seems to be trying to check it?
but it builds fine even on a clean checkout for me
hmm maybe i should clone more than depth 1 for nqp
oh wait. nvm. i just pulled tags on mvm
and someone added a tag 9999-please-do-not-usethese
GREAT! and tags are not deletable!
WTF?
i think we can probably ignore it though
hopefuly
rev =~ /(\d+)$sep(\d+)(?:$sep(\d+))?(?:-(\d+)-g[a-f0-9]*)?$/
or die "Unrecognized revision specifier '$rev' $what\n";
is what we have in Configure.pm now
ok i'm getting the failure too now. i wasn't getting it on a clean install, but installed mvm to a branch new prefix and i hit the bug
working on it right now...
samcv: we could also change MoarVM's Configure.pl to use git describe instead of git describe --tags
oh
actually you're right
i'm looking in the wrong spot :)
i thought it was checking the moarvm repo tags or something
Yeah, because nqp's Configure.pl uses moarvm --version
err... moar --version
pushed
yay
weird that that tag appeared
maybe timo accidently merged it in with telemeh
seems to work now
thanks nine
my pleasure :)
now i can stop tearing my hair out
Yeah, first Travis builds passing
i pushed it to my fork so i can check appveyor too
0.16s$ perl Configure.pl --prefix=$MOAR_PREFIX --backends=moar;
Unknown option: backends
WTF?
https://travis-ci.org/MoarVM/MoarVM/jobs/224612634
weird. idk why that's happening maybe the uh
readlink -f command words differently on mac?
i replaced `cd nqp` with `cd $NQP_FOLDER` which is done from readlink -f nqp # while in the moarvm folder
hmm https://stackoverflow.com/questions/1055671/how-can-i-get-the-behavior-of-gnus-readlink-f-on-a-mac
lame-o
fixing now
there we go
that was more annoying that i thought it'd be at first. settled on
writing my own: resolve_folder      () { O="$(pwd -P)"; D="$(dirname $1)"; T="$(basename $1)"; cd -- "$D" && cd -- "$T" && pwd -P; cd -- "$O" > /dev/null; }
since i don't need to resolve links or anything, and that should work for any normal folders
don't think i need quotes around VAR="$( )" though. yeah. i've learned if in doubt just quote everything :)
appears to be working now. good
still gotta fix the windows build though
lizmat: it looks like 3b0dec3255 does not work with the JVM backend :-/
during stage parse it blows up with: Method 'X::TypeCheck::Binding::Parameter' not found for invocant of class 'QAST::SVal'
NeuralAnomaly, status
NeuralAnomaly, status
bartolin: does removing the BEGIN fix it?   If so, maybe we should remove the BEGIN in case of the JVM ?
07:15Z <stmuk> Zoffix: https://github.com/rakudo/star/tree/master/patches
Zoffix: I'll pass your message to stmuk.
07:26Z <stmuk> Zoffix: BTW I'm on holiday in Greece with poor connectivity so R* is likely to be delayed. I had problems with Grammar::Debugger but that's now fixed
lizmat: I'll test (will take a while :-)
m: say "abc" ~~ m:i/caaaaa/
rakudo-moar 9ed89d: OUTPUT: «｢c｣␤»
lizmat: looks good so far. I'm running a spectest and if that looks good as well, I'll add a special case for r-j (for the line with BEGIN only)
yeah, that's what I had in mind  :-)
bartolin++
afk again&
Aha, my TPF grant report is posted: http://news.perlfoundation.org/2017/04/perl-6-performance-and-reliabi-3.html
21 Apr 2017 23:27Z <AlexDaniel> jnthn: fwiw https://irclog.perlgeek.de/perl6/2017-04-21#i_14466196
For anyone reading it and thinking "huh, did jnthn do those recently" - no, I wrote the grant report 2 months ago, it just took until now to be posted. :-)
Glad it's felt by others :)
o/
I have now run the spectest through gdb and here's what it looks like: https://gist.github.com/dogbert17/74e00499cffeb9c1117b5ef6d9769308
for those who didn't follow the discussion yesterday, the problem is that, if you run 'make spectest HARNESS_TYPE=6' with the default TEST_JOBS=1, then the process will run out of file handles if your system is set up to only have 1024
it seems as if one fd is lost for each test file being run and when you get to file ~1000 the spectest is aborted
hopefully the gist can give us a clue as to why
dog
Ugh
dogbert17: what perl6 version is that gdb for?
dogbert@dogbert-VirtualBox ~/repos/rakudo $ gdb -v
GNU gdb (Ubuntu 7.7.1-0ubuntu5~14.04.2) 7.7.1
the trick here is to break into the running perl6 process with 'sudo gdb -p <pid>', then you'll be able to set breakpoints an stuff
i think he meant perl6 --version
This is Rakudo version 2017.04.2-22-g9ed89d947 built on MoarVM version 2017.04
there's a config option somewhere in /sys or /proc that you can change so you can attach to your own processes
so you don't need to run gdb as root
aha
echo 0 > /proc/sys/kernel/yama/ptrace_scope
cool
https://github.com/rakudo/rakudo/blob/nom/lib/TAP.pm6#L885
nobody ever awaits the closing of the process?
like, $proc.out.lines(:close) or whatsit?
ACTION has a headache today, and figured he's share it by writing a blog post... https://6guts.wordpress.com/2017/04/22/massively-reducing-moarvm-fixed-size-allocator-contention/
*he'd
jnthn++
jnthn: also: s/dontate/donate/
ACTION finds the code in TAP.pm6 quite hard to follow even without a headache
dotonate?
jnthn++ (blogging)
ACTION goes off and will read more when back
"mallocand friends"
good post
lizmat, timotimo: fixed those two, thanks
jnthn++, but "VM for a dyanmic language"
ACTION has trouble understanding "A given bin consists of:"
1 or more pages, each with space for a certain number of allocations of the bin size
also, "So, I belive"
dogbert17: well, there's one FSA, in it are multiple "size bins", where each bin holds objects of an upper and lower size limit
each of these "size bins" allocates pages full of slots of these sizes, i.e. it'll malloc 128 slots * 16 bytes
timotimo: thx
"When a thread termiantes,"
timotimo, nine: if you care to check it out, https://github.com/perl6/nqp/pull/354 should enable the functionality you were asking for
sorry, i'm a half AFK
timotimo: i'm sorry, but this PR is going to expire in 10min unless you devote yourself to reviewing it. all the blame will rest on you
that's a reasonable expectation, right?
:)
yeah, i'll merge that
not quite a thorough code review, but since you've tested it and things give proper results, it's an improvement either way :)
well, might be good to have someone else test too
pff, testing
heh, but then again, i suspect i'm the only one who's ever used the sql profile output
i've just re-learned today that just committing stuff to master is totally fine
so even if it broke...
i've used it as if it were csv :P
i.e. not taken advantage of the structure and inter-table relations at all
or even joining a table with itself, as would be required with the call graph table
ah, still nice to know someone has used it
need to remember to correct the example in the docs when that hits rakudo
and now we should be in good shape to build a good tool for this
i didn't know this was docced :P
barely, https://docs.perl6.org/language/performance#Profile_locally
i didn't even know!
is sqlite still in browsers for free?
but now you do, and that's half the battle
i think ff still uses it for some internal stuff, don't know otherwise
it might be time to remove "use of gather/take" from the performance page as a "performance weakness"
hmm.
if sqlite were still in browsers for free, we could host a static .html file on moarvm.org or rakudo.org or whatever and people  would just pick their .sql file from disk and get all the data without it traveling over the network
that would be pretty cool
of course there's stuff like https://github.com/kripken/sql.js/
i wonder why its build is failing?
there is nothing in the travis build logs for the latest failed build
could it be it fell prey to the travis failure a few weeks back?
builds fine locally and passes `make m-test`
m-test? how come it has a moarvm backend?
i just specify it because sometimes i have a stray old jvm build lying around
i was refering to sql.js' build
ah, nm then
though you could just use the sql.js it offers and at least the demo page works
Clone done, sent: 1430  received: 25072049  ip: 67.18.92.124
server returned an error - clone aborted
?!? :(
could be because my version of fossil is ancient :P
fossil?
the SCM made and used by the sqlite folks
huh, never used it
it's slightly niche, but i hear great things about it
ACTION grabs an emscripten sdk
ugh, the makefile for sql.js is bogus
huh
how in the heck does this work
how does it know to put emcc in front ...
and now i have an up-to-date sql.js
now, do i even want to write this in html and js at all?
i didn't even consider that question :)
i have experience with python and qt, maybe i'll give that a shot, though maybe through Inline::Python rather than python directly
could the existing HTML be adapted to optionally the sql output?
probably
s: {a => 1}, "gist", \()
s: Hash.new(), "gist", \()
ACTION yawns-
too early
timotimo, if telemeh is not messing up the windows builds it's okay to bump nqp to get the m:i fix
well, i'm not saying it doesn't mess up the windows builds, but it does pass on appveyor
..
timotimo, mess up how?
i have no idea
then how do you know it messes it up
it's windows, you know
and if it's windows ... you *know*.
spectest passing
ok so you don't *know* but guess?
well, i know that being too confident is a bad idea when windows' involved :D
yeah i guess
well i'l be back in a few hours, going back to sleep for a bit. bump moar+nqp whenever you feel comfortable
cool
have a good sleep, samcv
thank you :)
i feel i'm about to lose consiousness
oh
zzzzzzzzzz
ACTION &
i thought you meant C Programming Language First Aid Responder
XD lol timotimo
we could use one of those too
yeah, i seem to find myself in need of that multiple times a month
YES! i have a terminal with sixel support \o/
i think i'm going to bump nqp and rakudo now
huh
i have no idea by what mechanism my 9999-please-dont-use-these release causes Configure.pl to break in nqp
samcv: i'm going to remove what looks like left-over debug output, "long end 0 should-fail 0"
so we should probably figure out how to move to a more continuous release process
ACTION is basically channeling obra++ here...
That was a big problem for Perl 5 until they went with a yearly release cycle
no biggie, and I'm not a big fan of slippery slope arguments, but "Just This Once" tickles that neuron of mine :)
oh, timotimo++ (bug crusher)
well, you pointed me at the exact location
I wouldn't have known what to do though :)
yay got the merge
err bump
good *
was the debug output removal a good call?
yeah that's fine
'k
from the .t file right
we should then un-todo some of these tests
very yes
hm, is that in the roast or in nqp's test suite?
both
t/moar/08-indexic.t                  (Wstat: 0 Tests: 117 Failed: 0)
TODO passed:   1, 92-105
yeah
plus in roast too
i should have untodod that before bumping the version from rakudo's side
yea
m: say 'abcd' ~~ /cdfg/
rakudo-moar 2bae61: OUTPUT: «Nil␤»
yay
there's a terminal emulator called "cancer" with the tagline "it's terminal" m)
oh my
oy
oy geekosaur
looks like equatic still has the bug though
hmm
oh crap
idk if we use equatic anywhere?
oh
i think my commit messages were all talking about eqatic
but only indexatic was fixed?
yeah
dang
yeah we don't use equatic anywhere
d'oh
gonna look at it in mvm though. i though what i did would have fixed it but. lemme see
still not a release blocker though since it's not used anywhere
ok we use it in one place
m: say 'a' ~~ m:i/ab/
rakudo-moar 2bae61: OUTPUT: «｢a｣␤»
ok yeha need to fix this then
cause it does equatic first before doing an index i believe
at the very start of the haystack
m: say 'ba' ~~ m:i/ab/
rakudo-moar 2bae61: OUTPUT: «False␤»
ok this is EZ fix
yay i fixed it. will commit after i grab my tea
m: use nqp; say nqp::eqatic('st', 'ﬆa', 0)
rakudo-moar 2bae61: OUTPUT: «1␤»
m: use nqp; say nqp::eqatic('st', 'ﬆassssssss', 0)
rakudo-moar 2bae61: OUTPUT: «1␤»
m: use nqp; say nqp::eqatic('ﬆ', 'ﬆassssssss', 0)
rakudo-moar 2bae61: OUTPUT: «1␤»
gonna add a few more eqatic tests to nqp
to cover this bug better
(adding tests to nqp)++
ok added a few more tests, got some failures and further improved moar
after sitting down and drawing a ton of strings
running roast now
we are a gooooo
gooey?
we are a GO
yay!
100% pass for equatic indexic and the m:i regex tests as well
and we can discuss another point release
point release? 2017.04.3? \o/
idk.
yeah
anything
I got the impression we're going to not do any more point releases and have a Rakudo Star on 2017.05 ?
hmm
idk the regex bug is bad
idk why were the only releases made
<samcv> m: say 'a' ~~ m:i/ab/
<camelia> rakudo-moar 2bae61: OUTPUT: «｢a｣␤»
^
fixed now though
c: releases say 'a' ~~ m:i/ab/
oh nice AlexDaniel
I'd say if it was there for more than two releases, it can wait for the next one
hm
what were the other point releases for?
not only we had the first *.2 release this time, you want it to be the first *.3 release also? :)
i think the bug is severe enough to make another point release. suprised it wasn't found but
it could cause... issues
yeah, yeah. Like any other bug actually
At this rate we'll be doing point releases up until the next pointless release. :P
well. i mean not releasing a ponit release to fix a serious bug. seems not a good idea either
just because "we've had too many point releases"
every body wants a poni releaset
bisect: o=2017.03 say 'a' ~~ m:i/ab/
meh…
not even sure how to use this bug
how to use it?
samcv: yea, bisectable is using :i in this case
that code does trigger the bug
I was trying to trigger it with o=2017.03
(should be old=2017.03)
but apparently that's not it
oh it's new in 04 i think
bisect: o=2017.04 say 'a' ~~ m:i/ab/
I guess the counter-argument is that we fix things you could describe as serious in every release.
samcv: no-no. Bisectable *itself* is running on a slightly older version
oh
jnthn, well i think regressions are different than just normal fixes
I mean, most releases I've fixed some SEGV somewhere, even if by now they're getting harder and harder to hit upon
jnthn: i could benefit from you trying to compile a moarvm on your msvc; i've done a lot to please appveyor, but i can't know if it's enough until a Real Windows is let loose upon it
point releases are useful for fixing regressions
samcv: sometimes I hunt for regressinos using whateverable. There were times I submitted over 20 reports I think
and some of them were serious enough
as serious as this?
what's the syntax for creating variable names with spaces in them? `my ::('a b') = 4` isn't it...
NeuralAnomaly, status
3 weeks is too long...
that's basically a month
are you sure a space is allowed with the special syntax?
m: my ::('$a b') = 4
rakudo-moar ce41e4: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Malformed my␤at <tmp>:1␤------> 3my ::('$a b')7⏏5 = 4␤»
m: my ::('isthisit') = 4
rakudo-moar ce41e4: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Malformed my␤at <tmp>:1␤------> 3my ::('isthisit')7⏏5 = 4␤»
c: 2016.04,HEAD say (-∞^..^∞).in-range: 0/0
pretty sure i saw TimToady do it
mhm
c: 2016.07~50,HEAD say ().rotor(1)
whateverable helped fix a bunchton of json::fast stuff
samcv: I dunno, some of these things don't look very good at all
hm?
oh you saying bugs in releases?
were they regressions though?
samcv: (re “as serious as this?”)
samcv: yes
i think more people use regeex than rotor though
that's why i think it's more serious becuase perl is known for regex...
but it is only with :i, and only relevant in some particular cases
well.
there's tons of cases it can happen.
aaaaabc ~~ m:i/cd/ # also will fail
if the first character and last character match
c: 2017.03,HEAD say ‘aaaaabc’ ~~ m:i/cd/
first char of the needle and last of the haystack
c:  2017.04,HEAD say ‘aaaaabc’ ~~ m:i/cd/
soooo
that's not that specific
i mean somewhat specific. but uh. still too common.
we need to figure out fuzzing.
at a perl6 level, that is
timotimo: well, I kinda have it figured out, in a way
timotimo: back in December/January I took all m: queries from the log and executed them on 2015.12, back then, HEAD
and this gave thousands of results that pointed out that everything has changed…
but that's how I found all these regressions
nice
oooh
that's a lot of manual work, but I have some plans on optimizing it
(maybe you can follow https://github.com/perl6/whateverable/issues/123 for updates on this, but this month I don't have much time to work on stuff anyway)
I'm not sure I understand the reason behind this. All I know is that it makes it harder for me to navigate through my reports
i wonder if we should try to fix the "but" + native parameter = invalid build_least_derived plan bug
it's probably just that the executor from the buildplan needs to have parts copied over to the build_least_derived one, but i think they've been different before and i have no idea why or in what way
Sounds like having R* 2017.05 off a more stable monthly release is a good idea although I'll probably build a testing one based on 04.x (without official release) to try out things anyway
stmuk, let me know how testig one goes
though idk are there other bugs other than the regex bug i just fixed? i actually don't know what the other point releases were cut for
ACTION reads changelog on rakudo repo
oh i see now
Files=1191, Tests=56827, 203 wallclock secs (12.15 usr  4.80 sys + 1197.53 cusr 119.23 csys = 1333.71 CPU)
lizmat, can you tell me about radix?
not much more than what I know when looking at the code now
the nqp op and its return values. see what i just said in #moarvm about plans for the indexic op. since we need to return more data to nqp/rakudo than only the index of the located match
https://github.com/perl6/nqp/blob/master/docs/ops.markdown#radix
m: use nqp; my str $thing = '10'; say nqp::radix(10, $thing, 0, 0)
rakudo-moar ce41e4: OUTPUT: «(10 100 2)␤»
not sure. it says the that 100 is the radix ** (number of digits converted)
i would think it'd have converted 2 digits, and it would be at offset 2 (which is the last number)
so i expected 10, 2,2
but maybe i'm reading the doc wrong
m: use nqp; my str $thing = ' 10'; say nqp::radix(10, $thing, 1, 0)
rakudo-moar ce41e4: OUTPUT: «(10 100 3)␤»
Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=113954
m: use nqp; my str $thing = '99'; say nqp::radix(10, $thing, 0, 0)
rakudo-moar ce41e4: OUTPUT: «(99 100 2)␤»
but maybe it's just the radix ** 2
since i see the ** in the docs, but. that's not super clear
ohhh i get it. ok. it relates to the highest decimal place it parsed
m: use nqp; my str $thing = '1000.0'; nqp::radix(10, $thing, 0, 0)
rakudo-moar ce41e4: ( no output )
m: use nqp; my str $thing = '1000.0'; say nqp::radix(10, $thing, 0, 0)
rakudo-moar ce41e4: OUTPUT: «(1000 10000 4)␤»
m: use nqp; my str $thing = '1000'; say nqp::radix(10, $thing, 0, 0)
rakudo-moar ce41e4: OUTPUT: «(1000 10000 4)␤»
m: use nqp; my str $thing = '1'; say nqp::radix(10, $thing, 0, 0)
rakudo-moar ce41e4: OUTPUT: «(1 10 1)␤»
This is Rakudo version 2017.04.2-28-gf9ebd2466 built on MoarVM version 2017.04-44-gf0db8822
csv-ip5xs        3.221
test            13.123
test-t           5.262 - 5.336
csv-parser      13.096
oh. if we're making a point release. the changes are in rakudo
for the regex thing
doesn't have to be today, but would be nice if there were a point release. but idk other people think maybe it's not a good idea.
buggable, speed 200
buggable, speed 100
haha
NeuralAnomaly, status
but my reasoning is regex is something a new user might try out, and if they try it out and it's broken
it would not be very good of an experience. but the other stuff i guess were problems too. but
that's just my opinion
in moar-blead?
or?
rakudo-moar f9ebd2: OUTPUT: «False␤»
how does that work. also some distros go off our tagged releases i think
oh
and moar-blead?
that's git moar and git rakudo?
k :)
oh? things are good?
oh
o/
stupid question of the day
does nqp::die write its output to stdout and if so why?
it does not
it throws an exception
so where's the exceptions text written then?
whatever handler catches it
looking a bit at RT #130760
Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=130760
probably the one in Perl6::Compiler if you don't do anything to catch it yourself
could very well be that the standard exception handler isn't even in scope when that exception gets thrown
ACTION looks
would it be possible to use 'note' instead?
yeah, but it should only use note if the usage is printed because of an error
i.e. perl6 --help should go to stdout
timotimo: agreed
this is the same thing
yea
that actually was the indexic fix that he bumped. then i did equatic fix
but timo wrote the wrong op in the name of the commit
but regardless. both ops are now rescued
yes, i did it totally wrong
i wonder if we should start using git notes for that kind of thing
what are git notes
yay more versions
samcv: sort of a thing you can attach to a commit "after the fact"
oh
the ownership is reversed, so that the commit content doesn't have to change
well i describe it fully in moarvm commit log
idk. ok i see
i could have put a note in saying "oops my commit message was crap"
definitely beats force-pushing over master
i should try out git notes
i have not used them yet
and i don't know of anybody who has
more or less just a random thought
i'll try it out sometime on a private repo and see what happens
i gotta go, may not be back before i go to sleep
rakudo-moar f9ebd2: OUTPUT: «｢ﬆa｣␤»
yeah that's going to be an issue until i retrofit indexic/eqatic ops
timotimo: using note works, the question then is what's the best way to figure out wheather 'note' or 'say'. Looking at the string parameter sent to the 'usage' method feels a bit brittle. Any suggestions?
to return information about the length of the expansion
since atm it has no clue those cp's expanded and thinks the needle of 2 graphemes will hae matched a 2 grapheme section of string
that is next on the list
s/wheather 'note'/wheather to use 'note'/
dogbert17: where does it decide that an error should be displayed?
well i have eqatic somewhat working. but. need changes in regex compiler to have it do things
like "unknown flag: --foobar"
night o/
happy point release tidings to you and your kin
night samcv
timotimo: not sure but I belive it might be in the class HLL::CommandLine::Parser found in nqp/src/HLL/CommandLine.nqp
that's where I found the string 'No such option'
we can introduce some API for that
does that function call the usage function?
that's the problem (for me) I can't find that place, if it does it is not obvious to me :(
let me see
ok, it just dies
aha
nqp/src/HLL/Compiler.nqp
what have you found
line 333
it has a try with .parse in it, when it CATCHes, it calls usage
nice find
is there a way to figure out if usage has been called from that code or is that the wrong approach?
we could set a dynamic variable
something like $*CALLED-FROM-EXCEPTION ?
i wouldn't call it that :)
:)
$*USAGE-FOR-FAILURE?
naming is one of the hardest things ...
what did i get put into the contributors list for? for the bump commit? :)
or your TAP.pm6 fix
ah
i don't really understand what "whenever MATCH is called" means in the fix comment
huh
2017.04 was 12:13 am, 2017.04.1 was 11:59 am?
how did that happen
Zoffix: I'll pass your message to stmuk.
m(
this time format is simply ridiculous
how can anybody ever think it's a good idea to keep this garbage
rakudo-moar c0c408: OUTPUT: «0.052055␤»
yikes
get yourself a little bit of vacation some time :)
\o/
have a good one!
Zoffix: play some games
don't you dare come back before you're relaxed ;) ;)
timotimo: this dynamic variable we spoke about, doesn't it have to be declared in two places?
nah, we'd just check if it exists (with a try, probably) when we output the usage
oh hold on
this is a method we're talkin gabout
why not just pass a named parameter
that way other users of HLL::Compiler don't have to change for this
that sounds too easy :)
but clever
could you send an appropriate output handle as a named param and then use that when outputting or should we settle for a boolean?
i think boolean is enough
ok, can try to cobble something together when I get back from a short errand &
unless you want to do it of course
i'm working on something else right now :)
cool, will try to fix it in a bit then :)
I think it's only needed by star anyway and a usual rakudo build uses a git checkout of nqp so maybe its just a case of sticking that tarball up and not changing rakudo
I don't think you can do that anyway AFAIK it uses git .. its only R* that doesn't
not 100% sure since I've not looked for a while
yes this is true
we're learning so much this month!
such action
I sort of wish things were a bit simplier
if you shipped a 2017.04-24-g87501f7b.tar.gz you could probably avoid bumping rakudo
a bit ugly looking
it doesn't break the https download page :) but yes re-releasing is probably safer
huggable, deb
the process which automatically builds the final tarball has to ftp the 3 tar balls but I could probably stick in a different tar ball quite easily
how important is the moarvm fix?
c: 2017.04 say 'abcdefgz' ~~ m:i/a/
c: 2017.04 say 'abcdefz' ~~ m:i/az/
c: 2017.03 say "abc" ~~ m:i/caaaaa/
c: 2017.04 say 'abcdefz' ~~ m:i/za/
I'll experiment with this shortly
which moarvm hash should I use?
is El_Che nxadm I forget>
so how the heck do you build nqp in a proper manner 'perl Configure.pl --backends=moar  --prefix=/home/dogbert/repos/rakudo/install/' followed by 'make', 'make test' and 'make install' doesnt do the trick. What am I missing?
I'm using the same prefix as when I'm configuring moar
Zoffix: will try 'perl Configure.pl --backends=moar --gen-moar --prefix=/home/dogbert/repos/rakudo/install/'  ?
nope, 'Unhandled exception: Missing or wrong version of dependency '/home/dogbert/repos/rakudo/install/bin/../share/nqp/lib/MAST/Nodes.nqp' (from 'src/Perl6/Pod.nqp')'
“The largest point release before was .2” what was it?
not after Christmas
ah I see, 2015.07.2
Zoffix: I tried without now. Do you have to rebuild rakudo afterwards?
thx, that explains it
timotimo: the change we talked about seems to be working now :)
I guess 2015.07.2 was GLR related?
stmuk: no, GLR was merged in September 2015
ah
u: heart
jnthn: is "muchly" really a word? :)
it's acceptably a neologism
it's neologismly
m: use nqp;say(nqp::getobjsc(nqp::hash()));say('lived')
rakudo-moar c0c408: OUTPUT: «(signal SEGV)»
m: use nqp;say(nqp::isnull(nqp::getobjsc(nqp::hash())));say('lived')
rakudo-moar c0c408: OUTPUT: «1␤lived␤»
lizmat: is the BEGIN nqp::hash a big performance gain?
lizmat: the problem with that is that nqp::hashes are usually special cased during serialization but a BEGIN nqp::hash serializes them like a regular object
pmurias: well, you probably know more about that than I
when I last checked, the nqp::hash was *not* HLLized
if that's what you're referring to
afk again&
but the rest of the post is good
ok so we're not having another point release? or we are? or we had one for rakudo but not nqp and moar? so
we can put non-release moarvm and nqp into the rakudo star
m: qw<zero one two>.splice(2, 0, 'three');
rakudo-moar 1bce2e: OUTPUT: «Use of uninitialized value of type Any in string context.␤Methods .^name, .perl, .gist, or .say can be used to stringify it to something meaningful.␤  in block <unit> at <tmp> line 1␤Cannot resolve caller splice(List, Int, Int, Str); none of these …»
m: qw<zero one two>.splice(2, 0, 'three')
rakudo-moar 1bce2e: OUTPUT: «Use of uninitialized value of type Any in string context.␤Methods .^name, .perl, .gist, or .say can be used to stringify it to something meaningful.␤  in block <unit> at <tmp> line 1␤Cannot resolve caller splice(List, Int, Int, Str); none of these …»
s: qw<zero one two>, 'splice', \(2, 0, 'three')
s: qw<zero one two>, 'splice', \(2, 0, ['three'])
s: ($ = qw<zero one two>), 'splice', \(2, 0, ['three'])
s: ($ = qw<zero one two>), 'splice', \(2, 0, 'three')
s: [qw<zero one two>], 'splice', \(2, 0, 'three')
m: qw<zero one two>.splice(2, 0, 'three');
rakudo-moar 1bce2e: OUTPUT: «Use of uninitialized value of type Any in string context.␤Methods .^name, .perl, .gist, or .say can be used to stringify it to something meaningful.␤  in block <unit> at <tmp> line 1␤Cannot resolve caller splice(List, Int, Int, Str); none of these …»
m: 42.meows
rakudo-moar 1bce2e: OUTPUT: «No such method 'meows' for invocant of type 'Int'␤  in block <unit> at <tmp> line 1␤␤»
m: 42.abs: 43124324
rakudo-moar 1bce2e: OUTPUT: «Too many positionals passed; expected 1 argument but got 2␤  in block <unit> at <tmp> line 1␤␤»
m: class {multi method foo {}}.new.foo
rakudo-moar 1bce2e: ( no output )
m: class {multi method foo {}}.new.foo: 42
rakudo-moar 1bce2e: OUTPUT: «Cannot resolve caller foo(<anon|55951072>: Int); none of these signatures match:␤    (<anon|55951072> $: *%_)␤  in block <unit> at <tmp> line 1␤␤»
star: qw<zero one two>.splice(2, 0, 'three');
star-m 2016.10: OUTPUT: «No such method 'splice' for invocant of type 'List'␤  in block <unit> at <tmp> line 1␤␤»
c: 2017.03 qw<zero one two>.splice(2, 0, 'three');
m: CONTROL { default { say 'fukc' } }; CATCH { default {} }; qw<zero one two>.splice(2, 0, 'three');
rakudo-moar 1bce2e: OUTPUT: «fukc␤»
star: CONTROL { default { say 'fukc' } }; CATCH { default {} }; qw<zero one two>.splice(2, 0, 'three');
star-m 2016.10: ( no output )
bisect: CONTROL { default { say 'fukc' } }; CATCH { default {} }; qw<zero one two>.splice(2, 0, 'three');
bisect: CONTROL { default { say 'bug' } }; CATCH { default {} }; qw<zero one two>.splice(2, 0, 'three');
http://pl6anet.org/drop/rakudo-star-2017.04-RC0.tar.gz
aren't there some utility functions somewhere to test the output of stderr?
yes
t/spec/packages/Test/Util.pm
thanks
also thanks
hm
long ago i think we used to upload release tarballs before announcing them and only posted the announcement and uploaded to the "official place" when people have given a thumbs-up
does anyone have an opinion about whether tests for RT #113954 should go in roast or rakudo's tests?
Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=113954
was leaning there myself. but do those tests have access to is_run?
any reason not to copy it over?
Zoffix: well, more than just one person
no matter who in particular. just get reports from a few people that things work out fine
isn't there some thought of lib/Test.pm6 going away? if not, should i just copy t/spec/packages/Test/Util.pm to lib/Test/Util.pm6? or just copy the functionality i need directly into the .t file?
you can forcepush over a tag
hm. does the tag need to exist in order for a release tarball to be attempted?
maybe i'm thinking of star the whole time!?
t/lib? t/packages? anyone care?
got err: "Usage:\n  getout-2074-60417.code 'foo bar' \n"
expected err: "Usage:\n  -e '...' 'foo bar'"
that's fun.
is_run is broken?
`is_run('multi MAIN(q|foo bar|) {}', 'foo bar', { err => "Usage:\n  -e '...' 'foo bar' \n" }, 'description'` is what i ran
a string with a space in it
i'm testing that foo bar doesn't work and suggests 'foo bar'
yeah, and then it doesn't hit the multi and the usage goes to stderr
to match the use case in the RT
but, true, it's not necessary
oh, right, STDIN
`is_run('multi MAIN(q|foo bar|) {}', :args['foo', 'bar'], { err => "Usage:\n  -e '...' 'foo bar' \n" }, 'description'` still has the getout... in the 'got err'
so i'm ending up with `is run(:err, $*EXECUTABLE, ['-e', 'multi MAIN(q|foo bar|) {}', 'foo', 'bar']).err.slurp, ...`
fwiw, slurp(:close) would cause `The spawned command '<...>' exited unsuccessfully (exit code: 2)`
Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=113954
m: role R { method r {...} }; class C is R { method r { say "hi" } } # RT #118263
Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=118263
rakudo-moar 1bce2e: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Method 'r' must be implemented by R because it is required by roles: R.␤at <tmp>:1␤»
you want "does" not "is" there
you can "is" roles though
yeah
it'll stub the role so the class can derive from it
m: role R { method r { say "hi" } }; class C is R { }; C.new.r
rakudo-moar 1bce2e: OUTPUT: «hi␤»
but it'll give you a stranger error message, still
i feel like the error message would end up a paragraph
haha
Method 'r' must be implemented by R because it is required by roles: R. Classes can't implement methods stubbed in roles when they "is" the role, did you mean to "does" the role?
"can't pun a role with required methods"
timotimo: that's pretty good
if it could also figure out that the pun was made because of a "is" instead of "does", that'd be better
the backtrace starts in `sub trait_mod:<is>`, so hopefully should be possible
is there a way to tell if the $parent in `sub trait_mod:<is>(Mu:U $child, Mu:U $parent)` has required methods?
can people here weigh in on these non-standardized tags in META https://gist.githubusercontent.com/samcv/b7785ded237a92a254d4298881a1eed8/raw/f089f8f751492b472d7c031fcec3e441f60af8fe/-
some are wrong, and some maybe should be added to the spec. but what do you guys think
i didn't even see that i had already answered that bug!
that bug is *old*
oh
i was also the one who created that bug
heh, yeah. was just looking through old bugs to see if there was anything easy to pick off
P6opaque: must compose Whatever before allocating
don't think i've seen that before
it's when you try do put a * very early into the core setting
ah, thanks. should be easy to work around
m: role R { method a {...}; method b { say "bee" }; method c {...} }; class C is R { }; C.new
rakudo-moar 1bce2e: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Method 'a' must be implemented by R because it is required by roles: R.␤at <tmp>:1␤»
locally that says `Can't pun role R with required methods: a, c`
timotimo: think that ^^^ looks ok?
that makes it sound like you're "punning a role with methods"
like, you're using methods to pun something
i'd phrase it more like "role R because it has required methods: ..."
yeah, that's better
i think i'll be going to bed soon
"Class C can't pun role R because it has required methods: a, c"
how's that?
do you actually find out that it's Class C that's doing it?
well, i find out the C part
yeah, that sounds good
can anything else "is" things?
can we find a phrasint that'd somehow hint at "maybe you wanted to use 'does' instead?"
everything can is things :P
trait_mod:<is> has many candidates
m: say &trait_mod:<is>.^candidates
rakudo-moar 1bce2e: OUTPUT: «No such method 'candidates' for invocant of type 'Perl6::Metamodel::ClassHOW'␤  in block <unit> at <tmp> line 1␤␤»
m: say &trait_mod:<is>.candidates
rakudo-moar 1bce2e: OUTPUT: «(sub trait_mod:<is> (Mu:U $child, Mu:U $parent) { #`(Sub|31809120) ... } sub trait_mod:<is> (Mu:U $child, :$DEPRECATED!) { #`(Sub|31816264) ... } sub trait_mod:<is> (Mu:U $type, :$rw!) { #`(Sub|31816416) ... } sub trait_mod:<is> (Mu:U $type, :$nativesize…»
c: HEAD .say for &trait_mod:<is>.candidates
ah, but on the one does `^add_parent`
*only
yeah, only the Mu:U, Mu:U one, i bet
set a dynamic variable $*PUNSTER :D :D :D
dinner &. will PR after
cool. i'm going to bed soon
later...
Zoffix: cool
i can rebase my PR and add the :close back in
PR updated
m: multi foo(IO::Handle) { say "here" }; multi foo (IO() $) { say "there" }; foo IO::Handle
rakudo-moar 84eb35: OUTPUT: «here␤»
m: multi foo(IO::Handle) { say "here" }; multi foo (IO() $) { say "there" }; foo 'x'
rakudo-moar 84eb35: OUTPUT: «there␤»
This is Rakudo version 2017.04.3-33-gc76a15d60 built on MoarVM version 2017.04-44-gf0db8822
csv-ip5xs        3.035
test            13.567
test-t           5.116 - 5.176
csv-parser      13.074
s: '', 'match', Nil
s: '', 'match', \(Nil)
yeah
apparently
ah i see
is there a way we can throw?
\o/ Zoffix
Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=79288
Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=79288
Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=118263
07:33Z <eater> Zoffix: your "Thanks." looks very passive aggressive on PRs :')
Why do people think that?! :)
Maybe some people are so attuned to lack of niceness online that when it happens they just look for an alternative explanation :P
people have arms that are adapted to tree climbing and afterwards to tool holding. they are pretty weird, yes
it's a joke isn't it since it has a smiley on the end of it?
Hello thought I'm dad.
(so, not always. :)
m: with '/tmp/foo42'.IO { my $fh = .open(:w, :bin); $fh.spurt: Buf.new(200,200); $fh.close; dd .spurt }
rakudo-moar 32d4a3: OUTPUT: «Too few positionals passed; expected 2 arguments but got 1␤  in block <unit> at <tmp> line 1␤␤»
m: with '/tmp/foo42'.IO { my $fh = .open(:w, :bin); $fh.spurt: Buf.new(200,200); $fh.close;  }
rakudo-moar 32d4a3: ( no output )
m: with '/tmp/foo42'.IO { my $fh = .open(:w, :bin); $fh.spurt: Buf.new(200,200); $fh.close; dd .slurp }
rakudo-moar 32d4a3: OUTPUT: «Malformed UTF-8␤  in block <unit> at <tmp> line 1␤␤»
m: with '/tmp/foo42'.IO { my $fh = .open(:w, :bin); $fh.spurt: Buf.new(200,200); $fh.close; dd .slurp(:bin) }
rakudo-moar 32d4a3: OUTPUT: «Buf[uint8].new(200,200)␤»
rakudo-moar 32d4a3: OUTPUT: «Buf[uint8].new(200,200)␤»
yeah, utf8 is already a buf-like (a blob, really)
anyone mind merging https://github.com/rakudo/rakudo/pull/1066 ? then i can close the RT
Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=113954
Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=113954
Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=113954
My full-screened chat window is showing an almost solid wall of Geth.  Must be a productive morning 'round these parts.
:-)
what do those mean?
is there a help link?
[Coke]: It's a sparkline graph of the last N days of [Tux]'s benchmark.
And I think the "faster" bit is last versus first within the sparkline
Zoffix: Ah, that's new.  Fair enough.
shorter is better?
Thanks.
buggable: bench
huggable: speed
isn't there also a buggable command to show how to run the bench yourself?
oh, you used huggable
huggable: bench
thanks
use-with-class.t, i don't remember seeing that ever flop before?
must be solar flares
m: dd 'I♥P6'.decode.bytes
rakudo-moar d0cd13: OUTPUT: «No such method 'decode' for invocant of type 'Str'␤  in block <unit> at <tmp> line 1␤␤»
m: dd 'I♥P6'.encode.bytes
rakudo-moar d0cd13: OUTPUT: «6␤»
m: dd '♥'.encode.bytes
rakudo-moar d0cd13: OUTPUT: «3␤»
rakudo-moar d0cd13: OUTPUT: «"a"␤2␤"b"␤3␤»
rakudo-moar d0cd13: OUTPUT: «"a"␤1␤"b"␤2␤»
rakudo-moar d0cd13: OUTPUT: «"a"␤2␤"b"␤3␤»
need to think about how the unget affects things
also is that exposed, such that someone could unget a different thing than was read (C stdio allows this)? which means the file offset is in fact distinct and should behave like that
Zoffix: binary and char-based routines don't mix well
ages ago, I started doing something about it: https://github.com/MoarVM/MoarVM/pull/319/files , but it did not go anywhere
effectively yes
seeking and non-byte/record IO don't mix very well
in any language
I mean, you can try, but contemplate for example the difference between seek/tell and setpos/getpos in POSIX
one might argue that tell should be left as is and a getpos/setpos type thing should be used to paper over the utf8 readahead the same way it is used to paper over newline differences
but it will be imperfect at best
geekosaur: why? in case of random access files (and ignoring concurrent access), perfection is possible in principle
is it? can you reliably get to the next position from the current one and the contents of a string you have read?
(tail is an example of a program that wants to do this)
Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=123838
not sure I understand the scenario: the OS tracks the position in the file, and the decoding buffer knows how many bytes it has read ahead
but does the user code know, or can it get at that information?
that's the specific difference between seek/tell and setpos/getpos
or does the lanbguage try to paper it over and can it do so with 100% reliability (i.e. knowing the user program didn't decide to seek by some different amount instead)?
what I woud provide are byte-oriented seek/tell methods and the ability to skip (from current position) in any of the unites of interest (bytes, codepoints, graphemes)
m: (1 but 7).fmt("%02d")
rakudo-moar d0cd13: OUTPUT: «Directive d not applicable for type Int+{<anon|33915024>}␤␤»
have fun
ACTION isn't burnt out, but needs to get groceries
if anyone is interested, here is a profile of test-t.pl: https://gist.github.com/MasterDuke17/0f579d524c1371a0bb1bd0463cd6c8b8
Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=118263
timotimo: is it possible to disable telemeh from being compiled? I ask since "x86intrin.h" isn't present on old GCC versions it seems
I mean is there a compile time option?
not yet
i can put a define in
i.e. put a -DNO_TELEMEH
in the cflags
nit sure how to work the configure.pl script
would be best if there wqs a probe in the configure script
but dont know how to
that might help on platforms such as OpenBSD with its ancient gcc 4.2.1
damn
I have a old note of rakudobrew build moar --configure-opts=--moar-option=--cc=clang36
I assume a -DNO_TELEMEH might be passed in a similar way .. at least as a start
I could probably work out how to add that into the Configure.pl
actually, no, not just like that
but i'm about to write a probe for this
ok
are the versions of 'say' called on lines 517 and 523 different or the same, i.e. is say != nqp::say ?
oops, https://github.com/perl6/nqp/blob/master/src/HLL/Compiler.nqp#L515
i think nqp's say() is just sugar for nqp::say()
it's probably a sub in nqp's setting though
yeah, like note(). which is why i also think it doesn't work in some places, if it's too early in the nqp compilation
MasterDuke_, timotimo: thx, have just written this https://gist.github.com/dogbert17/f97842d671848b75f01a0995b0409155
if it doesn't look like junk it will be part of a PR for RT #130760
Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=130760
yeah, if you don't have note, you need to use nqp::sayfh(nqp::getstderr, "foobar")
when I tried the code it definitely looked as if note was available
stmuk: can you review my attempt at making --no-telemeh/--telemeh and also "probe if rdtscp exists" exist?
Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=130760
stmuk: i pushed a branch to moarvm, i called it configure-telemeh-probe-rdtscp
stmuk: it's not much perl5 i wrote, but i did write a bit of perl5, and i'm not experienced with perl5 whatsoever
Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=118263
Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=118263
Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=118263
and another Perl 6 Weekly hits the Net: https://p6weekly.wordpress.com/2017/04/24/2017-17-interesting-times/
hm. can we get %?RESOURCES not break apart?
ACTION tries
alas
suggestions ?
no clue
.u question
U+003F QUESTION MARK [Po] (?)
U+00BF INVERTED QUESTION MARK [Po] (¿)
U+037E GREEK QUESTION MARK [Po] (;)
rephrased the line so it should come out better (usually)
fwiw, in my preview, it did not break up  :-(
yeah, i tend to view websites at some amount of zoomage
good night, #perl6-dev!
gnite lizmat
lizmat++ #weekly
20:29Z <El_Che> Zoffix: I'll release updated 2017.03 packages tomorrow with Windows 10 bash support. I'll wait with 2014.04 until npq get released.
timotimo: I can build moar again on OpenBSD 6.1 using --no-telemeh on your branch
can you also tell me if the code i wrote for it looks okay?
the Perl 5 looks fine to me
is the probe intended to set --no-telemeh automatically?
I mean the effect of doing that rather than literally
This is Rakudo version 2017.04.3-47-gf0414c468 built on MoarVM version 2017.04-44-gf0db8822
csv-ip5xs        3.175
test            13.343
test-t           5.173 - 5.232
csv-parser      13.022
telemeh is strictly saying still more or less functional without rdtscp
it just doesn't give any timestamps :P
though i should investigate how much overhead the uv high res timer function has
Files=1191, Tests=56840, 203 wallclock secs (12.11 usr  4.73 sys + 1200.25 cusr 119.02 csys = 1336.11 CPU)
buggable, eco
m: dd "/tmp/basdfad".IO.open.?slurp // 42
rakudo-moar f0414c: OUTPUT: «Failed to open file /tmp/basdfad: no such file or directory␤  in block <unit> at <tmp> line 1␤␤Actually thrown at:␤  in block <unit> at <tmp> line 1␤␤»
c: dd "/tmp/basdfad".IO.open.?slurp // 42
c: 2017.03 dd "/tmp/basdfad".IO.open.?slurp // 42
c: 2017.03 dd "/tmp/basdfad".IO.open.?slurp-rest // 42
c: 2017.03 dd "/tmp/basdfad".IO.open // 42
c: 2017.03 dd "/tmp/basdfad".IO.open.?dasasdasdasdas // 42
m: Failure.new.?afdsdsadas
rakudo-moar f0414c: OUTPUT: «Failed␤␤Actually thrown at:␤  in block <unit> at <tmp> line 1␤␤»
m: Failure.new.?slurp-rest
rakudo-moar f0414c: OUTPUT: «Failed␤␤Actually thrown at:␤  in block <unit> at <tmp> line 1␤␤»
m: dd "/tmp/basdfad".IO.open andthen .slurp orelse 42
rakudo-moar f0414c: OUTPUT: «WARNINGS for <tmp>:␤Useless use of constant integer 42 in sink context (line 1)␤Failure.new(exception => X::AdHoc.new(payload => "Failed to open file /tmp/basdfad: no such file or directory"), backtrace => Backtrace.new)␤»
m: $v = "/tmp/basdfad".IO.open andthen .slurp orelse 42
rakudo-moar f0414c: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Variable '$v' is not declared␤at <tmp>:1␤------> 3<BOL>7⏏5$v = "/tmp/basdfad".IO.open andthen .slu␤»
m: my $v = "/tmp/basdfad".IO.open andthen .slurp orelse 42
rakudo-moar f0414c: OUTPUT: «WARNINGS for <tmp>:␤Useless use of constant integer 42 in sink context (line 1)␤»
m: my $v = ("/tmp/basdfad".IO.open andthen .slurp orelse 42)
rakudo-moar f0414c: ( no output )
m: my $v = ("/tmp/basdfad".IO.open andthen .slurp orelse 42); dd $v
rakudo-moar f0414c: OUTPUT: «Int $v = 42␤»
m: my $v = ("/tmp/foo".IO.open andthen .slurp orelse 42); dd $v
rakudo-moar f0414c: OUTPUT: «Int $v = 42␤»
m: "/tmp/bar".IO.spurt: 42
rakudo-moar f0414c: ( no output )
m: my $v = ("/tmp/bar".IO.open andthen .slurp orelse 42); dd $v
rakudo-moar f0414c: OUTPUT: «Str $v = "42"␤»
m: "/tmp/bar".IO.spurt: 100
rakudo-moar f0414c: ( no output )
m: my $v = ("/tmp/bar".IO.open andthen .slurp orelse 42); dd $v
rakudo-moar f0414c: OUTPUT: «Str $v = "100"␤»
m: my $v = ("/tmp/bar".IO.open.slurp orelse 42); dd $v
rakudo-moar f0414c: OUTPUT: «Str $v = "100"␤»
m: my $v = ("/tmp/bar2".IO.open.slurp orelse 42); dd $v
rakudo-moar f0414c: OUTPUT: «Failed to open file /tmp/bar2: no such file or directory␤  in block <unit> at <tmp> line 1␤␤Actually thrown at:␤  in block <unit> at <tmp> line 1␤␤»
m: my $v = "/tmp/bar2".IO.slurp // 42); dd $v
rakudo-moar f0414c: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Unexpected closing bracket␤at <tmp>:1␤------> 3my $v = "/tmp/bar2".IO.slurp // 427⏏5); dd $v␤»
m: my $v = "/tmp/bar2".IO.slurp // 42; dd $v
rakudo-moar f0414c: OUTPUT: «Int $v = 42␤»
m: my $v = "/tmp/bar".IO.slurp // 42; dd $v
rakudo-moar f0414c: OUTPUT: «Str $v = "100"␤»
Zoffix: I'll pass your message to perlpilot.
timotimo: are you around?
and I guess that you've already played Doom
I made a PR to the nqp repo yesterday, i.e. https://github.com/perl6/nqp/pull/355. According to Travis the PR failed one check 'NQP_OPTIONS'="--backends=jvm". Is that check really supposed to run?
why not? I thought NQP on the JVM should work
moritz: thing is I cloned the project and tried it there and the same tests fails on the master branch
Zoffix: two tests actually
then it shouldn't stop us from merging the PR
moritz: it is a fix for a problem you reported :)
failing tests are t/nqp/044-try-catch.t and t/nqp/101-lexpad-stuff.t
Zoffix: you mean why we have a JVM release?
dogbert17_: I'll look into those tests after grabbing some food
wasn't the JVM backend done before MoarVM?
pmurias++
there is a huge ecosystem on the JVM
well, the historical benefit of the JVM is that it 'decoupled' rakudo from parrot
also, the JVM is a pretty good VM, all things considered
aye
I don't have recent figures, but the JVM is *fast* once it gets going
and there was always hopes for better Java integration, which afaict works only quite clumsily at the moment
there's an insane amount of person-time spent on JVM JIT optimizations
yes, we need to use Graal
on the new JVM they have a toolkit for building your own fast JIT for your dynamic language
JVM is turning into a parrot done right nowdays
yes, graal is pretty cool
because it's easier to work on multithreaded high-level stuff when you don't have to look for multithreading bugs in the VM, too
and there's lots of places where you won't be allowed to put perl6 in if it's moarvm, but just putting anoter .jar into the project is just fine
you think we're spending too much dev time on the jvm?
i think we're hardly spending any time on it
i think it's mostly people that want JVM fixed that spend any time on it
MoarVM has been declared the 'official' VM for some time now
i can't deliver :(
AFK for now, but jvm was the only way to have multithreading without crashing every few seconds for a while
well, the point is that 'useless' is your assesement, not a universal fact
well, frankly; i don't use it.
but i'm sure we can find people who do
may i suggest putting up a poll
and circulating it somewhere on the internets
Death to META.info!
...383 PRs?
oh, I wasn't asking about the meaning of "PR" ;)
more like, what are those 383 about?
so... 383 PRs to kill META.info?
that's interesting. I just closed an issue yesterday in 007 fixing something in its META.info
now I can expect a PR about its death?
just rename it to META6.json?
I guess what I'm fishing for is something that makes what you're saying seem a bit less drastic
also, giving reasons and stuff
for one, the word "death"
but yeah, "renaming" sounds relatively more OK
as a module author, I'd be happy to learn about the underlying reasons for it. but I guess that'll be clearly explained in the 383 PRs :)
yeah, it's nice to still be small in some ways
Zoffix: in terms of reasons for future existance of the JVM backend, it would likely help in creating a Truffle/Graal backend (which would likely be super awesome)
Zoffix: other JVM benefit for me is that it prevents Rakudo internals from fully assumming MoarVM and that helps a bit with the js backend
Zoffix: I've heard about a nice language for automating mundane tasks...now what was it called? I think it's "Perl 6" ;)
Zoffix: oh yes, been there far too often :)
I wonder how GitHub would react if a newly registered user would fork and PR ~350 repos within minutes ;)
cool, all my dists - at least those on my github account - are already META6.info
pmurias: i believe i added `my int $?BITS := nqp::iseq_i(0x1ffffffff,8589934591) ?? 64 !! 32;` to figure out if we're on a 32 or 64 bit machine. an optimization later in the file changes depending
I just fixed it in CompUnit-Repository-Panda and Grammar-Highlighter
MasterDuke_: how is that checked supposed to work?
s/checked/check/
pmurias: right, to decide when parsing a constant whether to use string_to_int or string_to_bigint
i think it overflows on 32-bit?
MasterDuke_: what I mean is that you are comparing the same number writen down in different ways to itself
hm. i'm going to shift the blame and say i think i got the code from lizmat. but maybe the hex num is read/parses/converted differently than the decimal num?
dogbert17_: are you around? what does `my int $?BITS := nqp::iseq_i(0x1ffffffff,8589934591) ?? 64 !! 32; say($?BITS)` print on your 32-bit machine?
MasterDuke_: the check is fixed in the js branch
pmurias: can you fix master also?
Zoffix: thanks
I should just cherry-pick the commits?
ACTION agrees with Zoffix :)
oh
what about `my int $a = 0x1ffffffff; say(nqp::iseq_i($a,8589934591) ?? 64 !! 32)`?
dogbert17_, Zoffix: what does that show?
that's from src/core/Rakudo/Internals.pm
64
then https://github.com/rakudo/rakudo/blob/nom/src/core/Rakudo/Internals.pm#L1550-L1554 should be fixed also
pmurias++
(JVM) I suspect the people working on JVM are, in general, not going to be working on the non-jvm guts.
I used to want the JVM version because I had a java-only prod environment here. With things like docker, I don't have that need anymore. Can't speak to other devs' needs.
i don't understand what you're saying, it's two meta for me
MasterDuke_: *groan*
FWIW: the code in d057efdbc4 returns 64 on my system (32 bit)
SRY, disregard that
ACTION pulls the latest fixes /o\
it's almost as if I knew what I was doing!
m: sub foo(@a?) { say @a ?? "@a[]" !! "no arg" }; foo(my Int @ = (1, 2));
rakudo-moar d057ef: OUTPUT: «1 2␤»
m: sub foo(@a?) { say @a ?? "@a[]" !! "no arg" }; foo();
rakudo-moar d057ef: OUTPUT: «no arg␤»
m: sub foo(Int @a?) { say @a ?? "@a[]" !! "no arg" }; foo(my Int @ = (1, 2));
rakudo-moar d057ef: OUTPUT: «1 2␤»
m: sub foo(Int @a?) { say @a ?? "@a[]" !! "no arg" }; foo();
rakudo-moar d057ef: OUTPUT: «Type check failed in binding to parameter '@a'; expected Positional[Int] but got Array ($[])␤  in sub foo at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»
^^^ RT #118555
Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=118555
valid bug?
m: sub foo(Int $a?) { say $a ?? $a !! "no arg" }; foo();
rakudo-moar d057ef: OUTPUT: «no arg␤»
m: sub foo(Int $a?) { say $a ?? $a !! "no arg" }; foo(1);
rakudo-moar d057ef: OUTPUT: «1␤»
a type constraint on an optional Scalar works
yeah, though i don't know how those were expected to work 4 years ago
but i agree that the behavior i showed above is wrong
https://github.com/nxadm/rakudo-pkg/releases/tag/2017.03_03
yw
do you get adverts in cmd.exe now?
I'm fond of selective use of https://github.com/Nummer/Destroy-Windows-10-Spying
i'm connected to about a gajillion devices on the public internet :) :)
it seemed to reset privacy settings with updates which I found annoying
"For you technical types out there, think of it this way: Stylish and userstyles.org are to CSS as Greasemonkey and userscripts.org are to JavaScript."  OK, makes total sense now.
Huh, one of the top reviews claims it will start selling your data.
neato.
Geth: uptime
Geth: uptime
Geth: uptime
Geth: uptime
Geth: uptime
Geth: uptime
Geth: uptime
Geth: uptime
Geth: uptime
Geth: uptime
18:18Z <[Coke]> Zoffix: off by one error on your message in 538ddf2174
18:16 <+Geth> Swapped META.info → META6.json in 1 dists in https://github.com/perl6/ecosystem/commit/538ddf2174
guessing maybe requiring a \n to end the line?
m: use nqp; sub foo(Array[Int] @a?) { }; my @params = nqp::getattr(&foo.signature, Signature, q|@!params|); for @params -> $p { say $p.type; say nqp::getattr($p, Parameter, q|$!nominal_type|) }
rakudo-moar d057ef: OUTPUT: «(Positional[Array[Int]])␤P6opaque: no such attribute '$!nominal_type' in type Parameter when trying to get a value␤  in block <unit> at <tmp> line 1␤␤»
but in Parameter.pm: `method type() { $!nominal_type }`
why doesn't the `nqp::getattr()` work?
m: use nqp; sub foo(Array[Int] @a?) { }; my @params = nqp::getattr(&foo.signature, Signature, q|@!params|); for @params -> $p { say $p.type; say nqp::getattr(nqp::decont($p), Parameter, q|$!nominal_type|) }
rakudo-moar d057ef: OUTPUT: «(Positional[Array[Int]])␤(Positional[Array[Int]])␤»
Zoffix++ ...but will that work in BOOTSTRAP.nqp...?
it's building right now
buggable: eco
Geth: uptime
(not-off-by-one) ah, misread the change on the last line.
nqp-m: my str $foo := 'Infinity stone'; say(+$foo)
nqp-moarvm: OUTPUT: «Inf␤»
^^ is this really desired
rakudo-moar d057ef: OUTPUT: «Cannot convert string to number: Imaginary component of 'NaN' or 'Inf' must be followed by \i in '3Inf⏏5in' (indicated by ⏏)␤  in block <unit> at <tmp> line 1␤␤Actually thrown at:␤  in block <unit> at <tmp> line 1␤␤»
nqp-m: my str $foo := '234box'; say(+$foo)
nqp-moarvm: OUTPUT: «234␤»
nqp-m: my str $foo := 'Inf check'; say(+$foo)
nqp-moarvm: OUTPUT: «Inf␤»
in general or just with Inf?
it first does a strcmp with 'NaN' etc and when it doesn't match it just passes "Inf_trash_here" to atof
and atof turns that into Inf
NaNcy typing, anyone? >.>
ahh, that was added because atof behaves differently on Windows
m: my str $foo = 'Infinity on Linux but not on windows'; my num $n = $foo;say $n
rakudo-moar d057ef: OUTPUT: «Inf␤»
rakudo-moar d057ef: OUTPUT: «This type cannot unbox to a native number: P6opaque, Str␤  in block <unit> at <tmp> line 1␤␤»
We now no longer check any modification time stamps when loading precompilation files. We now fully rely on checksums.
seem much saner
* seems
ACTION looks at https://github.com/zoffixznet/perl6-Number-Denominate#volume-imperial and suddenly realizes why a story written by a Canadian author depended on a gallon weighing 10 pounds, which made no sense to me ....
:)
although metric's not *so* different in that regard; the original definitions of length, mass/weight, volume were related much the same way
(1cc water = 1g)
(or 1 cm^3 if you prefer)
but a gallon weighs about 8 pounds
perlpilot: Not outside the U.S. apparently.
yes, there's a commonwealth/us difference there, I ran into it with respect to discussion of pints of beer once but don't recall details
I always wondered why a pint of beer was so large in an actual British pub, thinking it was some drinking-establishment-specific thing.  Oh no, it really is a larger pint than the one I'm used to.  Which at least was based on binary, which made sense to me.
m: my %h = foo => { bar => { ber => 42 } }; my %h2 = foo => { meow => { moo => 72 } }; %h ««=«« %h2; dd %h
rakudo-moar ff4a03: OUTPUT: «Hash %h = {:foo(${:bar(${:ber(42)}), :meow(72)})}␤»
m: my %h = foo => { bar => { ber => 42 } }; my %h2 = foo => { meow => { moo => 72 } }; %h «=« %h2; dd %h
rakudo-moar ff4a03: OUTPUT: «Hash %h = {:foo(${:bar(${:ber(42)}), :meow(72)})}␤»
UK pint is 20 UK Fluid Oz or 568ml
US is 473ml
yes, 16 US fluid oz
The Wizard of Fluid Oz
i've been beating my head against this for a while, time to ask the hivemind
`my $type := nqp::getattr($param, Parameter, '$!nominal_type');`
the `$type.HOW.name($type)` is 'Positional[Int]'
$type is not defined, not null, not concrete, not a container, and is false
if i `nqp::create($type)`, i get `You cannot create an instance of this type ((null))`
m: sub foo(Int @a?) { say @a ?? "@a[]" !! "no arg" }; foo(); # this is what this is all about
rakudo-moar ff4a03: OUTPUT: «Type check failed in binding to parameter '@a'; expected Positional[Int] but got Array ($[])␤  in sub foo at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»
and this is where i'm working: https://github.com/rakudo/rakudo/blob/nom/src/Perl6/Metamodel/BOOTSTRAP.nqp#L626-L628
anybody have a suggestion of what to try?
alcoholism?
rakudo-moar ff4a03: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Missing block␤at <tmp>:1␤------> 3cont($p), Parameter, q|$!nominal_type|))7⏏5<EOL>␤    expecting any of:␤        postfix␤        statement end␤        statement modifier␤        stateme…»
rakudo-moar ff4a03: OUTPUT: «(Positional[Array[Int]])␤You cannot create an instance of this type ((null))␤  in block <unit> at <tmp> line 1␤␤»
heh, i'll probably wait an hour or so for that
rakudo-moar ff4a03: OUTPUT: «(Positional[Array[Int]])␤Positional[Array[Int]].new␤»
rakudo-moar ff4a03: OUTPUT: «(Positional[Array[Int]])␤Positional[Array[Int]]␤»
i just tried `nqp::index($type.HOW.name($type), '[') > 0 ?? $type !! nqp::create(Array);` and get `Internal error: inconsistent bind result`
rakudo-moar ff4a03: OUTPUT: «Internal error: inconsistent bind result␤  in sub foo at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»
and the decont() is unnecessary in BOOTSTRAP.nqp
oh, and same thing without the ternary and just return $type
PR for everyone!
it's like christmas!
.ask timotimo i'm trying to work on RT #118555 (typed optional array parameters not working), but have hit a roadblock. some comments here: https://irclog.perlgeek.de/perl6-dev/2017-04-25#i_14485206 . any suggestions?
MasterDuke_: I'll pass your message to timotimo.
Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=118555
.ask lizmat i'm trying to work on RT #118555 (typed optional array parameters not working), but have hit a roadblock. some comments here: https://irclog.perlgeek.de/perl6-dev/2017-04-25#i_14485206 . any suggestions?
MasterDuke_: I'll pass your message to lizmat.
Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=118555
.ask jnthn i'm trying to work on RT #118555 (typed optional array parameters not working), but have hit a roadblock. some comments here: https://irclog.perlgeek.de/perl6-dev/2017-04-25#i_14485206 . any suggestions?
MasterDuke_: I'll pass your message to jnthn.
Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=118555
.ask TimToady i'm trying to work on RT #118555 (typed optional array parameters not working), but have hit a roadblock. some comments here: https://irclog.perlgeek.de/perl6-dev/2017-04-25#i_14485206 . any suggestions?
MasterDuke_: I'll pass your message to TimToady.
Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=118555
MasterDuke_: i'm not really knowledgable on the fine details of creating types that have parameterization applied to them, whether that's different from the more harmless types we have
MasterDuke_: you might have gotten "inconsistent bind result" because we generated code with the fast-path binder that caused a failure (because perhaps you haven't modified the fast-path binder yet? it's called lower_signature or some such) and then your modified code was signaling success and then the binder said "well, something's wrong and i can't be bothered to turn into general AI to fix it for you"
This is Rakudo version 2017.04.3-51-gff4a034dd built on MoarVM version 2017.04-44-gf0db8822
csv-ip5xs        3.020
test            12.956
test-t           4.996 - 4.996
csv-parser      12.956
Now, *that* is what I would call stable :)
nice
can we do this every time
Error encoding UTF-8 string: could not encode Unicode Surrogate codepoint 56887 (0xDE37)
in using utf8-c8
Error encoding UTF-8 string: could not encode codepoint 1821802 (0x1BCC6A), codepoint out of bounds. Cannot encode higher than 1114111 (0x10FFFF)
Error encoding UTF-8 string: could not encode codepoint 1184858 (0x12145A), codepoint out of bounds. Cannot encode higher than 1114111 (0x10FFFF)
it could be argued that for this case, utf8-c8 should also generate synthetics that help us roundtrip
I dare say that's the whole point of utf8-c8, isn't it?
ACTION nods
ACTION waits for that to be perferct in order to support real-binary (like images) in Text::CSV
yeah
FWIW I finally implemented :strict in Text::CSV_XS and Text::CSV
If this attribute is set to 1, any row that parses to a different number of fields than the previous row will cause the parser to throw error 2014.
1 → True in perl6
ACTION => $work
\o
can I trick one of you to merge https://github.com/perl6/nqp/pull/355 or am I supposed to do it myself (I do see a big green merge button...)
dogbert17, can you change your commit message
to actually describe what the fix is for
:)
just some short thing "Fix RT #8888 words words words words"
You mean on the first line, there are plenty words in the second paragraph
dogbert17: yes. Makes it easier for people who write change logs or the weekly
^
yeah the title/1st line
Hmm, dunno if my git fu is up to it, do I have to create a new PR or is there a more clever way
nope
"git commit --amend"
then git push --force
oh, will try
if you want to change the date on the commit as well: git commit --amend --date now
by defualt it doesn't change the date and leaves it identical
do you think I should change the date?
no
not unless you're changing actual code
which I won't
or whatever, since it helps github/peolpe looking at it know last time it was modified. yup
well, the change is now visible on my forked repo, wonder if the PR will be updated automatically
dogbert17: it already is, since the PR only points to a repo
cool
the build checks passed, wohoo
09:17Z <daxim> Zoffix: please do not forget about nuget/chocolatey specs for vip release
Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=130760
Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=130760
nine++
Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=130760
dogbert17: so maybe I should bump nqp ?
02:39Z <MasterDuke_> lizmat: i'm trying to work on RT #118555 (typed optional array parameters not working), but have hit a roadblock. some comments here: https://irclog.perlgeek.de/perl6-dev/2017-04-25#i_14485206 . any suggestions?
Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=118555
lizmat: to get the most out of the fix yes :)
ACTION tests
ACTION hides /o\
Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=130760
Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=130760
lizmat++
buggable: eco
Is the META.info swapper something that means I don't need to manually update the meta list now I've merged a ton of renaming PRs?
02:39Z <MasterDuke_> jnthn: i'm trying to work on RT #118555 (typed optional array parameters not working), but have hit a roadblock. some comments here: https://irclog.perlgeek.de/perl6-dev/2017-04-25#i_14485206 . any suggestions?
Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=118555
hah, wow
Nice
I was about to be like, darn, I don't have time to manually do that now, shoulda thought of it before I started merging :)
it's the future!
(whoever wrote that updating thingy)++
Probably Zoffix++ :)
jnthn: got time for a question about typed optional array parameters?
'friad not
(Got language class soon)
Should have later on today though :)
no worries, i'll ping again later if haven't figured it out by then
Alright
m: sub foo returns Int:U { 42 }; foo;
rakudo-moar d92a21: OUTPUT: «Type check failed for return value; expected Int but got 42␤  in sub foo at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»
m: sub foo returns Int:U { 42 }; dd foo.of
rakudo-moar d92a21: OUTPUT: «Type check failed for return value; expected Int but got 42␤  in sub foo at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»
m: sub foo returns Int:U { 42 }; dd &foo.of
rakudo-moar d92a21: OUTPUT: «Int:U␤»
m: sub foo returns Int:U { 42 }; try foo; say $!.^name
rakudo-moar d92a21: OUTPUT: «X::TypeCheck::Return␤»
m: my Int:U $x := 42
rakudo-moar 9f0b12: OUTPUT: «Type check failed in binding; expected Int:U but got Int (42)␤  in block <unit> at <tmp> line 1␤␤»
j: sub foo returns Int:U { 42 }; dd foo
rakudo-jvm fb4f16: OUTPUT: «Type check failed for return value; expected ?:? but got Int (42)␤  in method throw at gen/jvm/CORE.setting line 29502␤  in sub  at gen/jvm/CORE.setting line 31847␤  in block <unit> at <tmp> line 1␤␤»
# 1 lines longer than coding standard limit (100 columns):
oops, wrong channel
That was output of a failing test in a $work project
m: use nqp; sub { dd nqp::p6argvmarray }()
rakudo-moar 9f0b12: OUTPUT: «()␤»
m: use nqp; sub { dd nqp::p6argvmarray }(slip)
rakudo-moar 9f0b12: OUTPUT: «Too many positionals passed; expected 0 arguments but got 1␤  in sub  at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»
I actually enjoy not having to stick to that strict rule in rakudo code. I just don't enjoy having to read the resulting code ;)
m: use nqp; sub { dd nqp::p6argvmarray }(Empty)
rakudo-moar 9f0b12: OUTPUT: «Too many positionals passed; expected 0 arguments but got 1␤  in sub  at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»
m: use nqp; sub (+args) { dd nqp::p6argvmarray }(Empty)
rakudo-moar 9f0b12: OUTPUT: «(Empty,)␤»
m: use nqp; sub (+args) { dd nqp::atpos(nqp::p6argvmarray, 0)) }(Empty)
rakudo-moar 9f0b12: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Missing block␤at <tmp>:1␤------> 3s) { dd nqp::atpos(nqp::p6argvmarray, 0)7⏏5) }(Empty)␤    expecting any of:␤        postfix␤        statement end␤        statement modifier␤        st…»
m: use nqp; sub (+args) { dd nqp::atpos(nqp::p6argvmarray, 0) }(Empty)
rakudo-moar 9f0b12: OUTPUT: «Empty␤»
m: use nqp; sub (+args) { dd nqp::atpos(nqp::p6argvmarray, 0) =:= Empty }(Empty)
rakudo-moar 9f0b12: OUTPUT: «Bool::True␤»
rakudo-moar 9f0b12: OUTPUT: «Bool::True␤»
m: use nqp; sub (+args) { dd args; dd nqp::atpos(nqp::p6argvmarray, 0) =:= Empty }(Empty)
rakudo-moar 9f0b12: OUTPUT: «()␤Bool::True␤»
m: note (Nil andthen "foo" orelse Nil orelse "bar");
rakudo-moar 9f0b12: OUTPUT: «-> ;; $_ is raw { #`(Block|52520896) ... }␤»
s: &infix:<orelse>
.tell Zoffix_ https://rt.perl.org/Ticket/Display.html?id=130798
Zoffix: I'll pass your message to Zoffix_.
https://rt.perl.org/Ticket/Display.html?id=130798
m: say 1, 2 Xand "ab".ords;
rakudo-moar 9f0b12: OUTPUT: «Cannot invoke this object (REPR: Uninstantiable; Callable)␤  in block <unit> at <tmp> line 1␤␤»
m: ∞
rakudo-moar 9f0b12: ( no output )
m: Inf
rakudo-moar 9f0b12: ( no output )
m: Inf+42
rakudo-moar 9f0b12: OUTPUT: «WARNINGS for <tmp>:␤Useless use of "+" in expression "Inf+42" in sink context (line 1)␤»
m: 42
rakudo-moar 9f0b12: OUTPUT: «WARNINGS for <tmp>:␤Useless use of constant integer 42 in sink context (line 1)␤»
how was the game with this 'Hung lo' character or whatever his name was?
i loved the original shadow warrior, and have the the first new one, but haven't gotten to play it yet
the trio of low-brow humor Build engine games (duke nukem, shadow warrior, and redneck rampage) were all surprisingly good
m: sub aa { if @_ { for @_ { .say } } }; aa 42
rakudo-moar 9f0b12: ( no output )
m: sub aa { dd @_: if @_ { for @_ { .say } } }; aa 42
rakudo-moar 9f0b12: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Unexpected block in infix position (missing statement control word before the expression?)␤at <tmp>:1␤------> 3sub aa { dd @_: if @_7⏏5 { for @_ { .say } } }; aa 42␤    expecting any of:␤    …»
m: sub aa { dd @_; if @_ { for @_ { .say } } }; aa 42
rakudo-moar 9f0b12: OUTPUT: «[42]␤»
m: sub aa { dd @_; if so @_ { for @_ { .say } } }; aa 42
rakudo-moar 9f0b12: OUTPUT: «[42]␤»
m: sub aa { my @x = @_; if @x { for @_ { .say } } }; aa 42
rakudo-moar 9f0b12: ( no output )
m: my Int @a = 1 .. Inf;
rakudo-moar 9f0b12: ( no output )
m: my Int @a = 1 .. Inf;  dd @a
rakudo-moar 9f0b12: OUTPUT: «Array[Int] @a = (1, 2, 3, 4, 5, 6, 7, 8, 9, 10... lazy list)␤»
m: my Int @a = 1 .. Inf;  dd @a[*-1]
rakudo-moar 9f0b12: OUTPUT: «Cannot .elems a lazy list␤  in block <unit> at <tmp> line 1␤␤Actually thrown at:␤  in block <unit> at <tmp> line 1␤␤»
m: my Int @a = 1 .. Inf;  @a[*-1], @a[*-Inf], @a[Inf];
rakudo-moar 9f0b12: OUTPUT: «Cannot .elems a lazy list␤  in block <unit> at <tmp> line 1␤␤Actually thrown at:␤  in block <unit> at <tmp> line 1␤␤»
m: my Int @a = 1 .. 4.5;
rakudo-moar 9f0b12: ( no output )
m: my Int @a = 1 .. 4.5; say @a
rakudo-moar 9f0b12: OUTPUT: «[1 2 3 4]␤»
m: my Int @a = Inf .. Inf;  say @a
rakudo-moar 9f0b12: OUTPUT: «[...]␤»
m: my Int @a = 1 .. 4.5; say @a
rakudo-moar 9f0b12: OUTPUT: «[1 2 3 4]␤»
m: my Int @a = 1 .. 'a';; say @a
rakudo-moar 9f0b12: OUTPUT: «Cannot convert string to number: base-10 number must begin with valid digits or '.' in '3⏏5a' (indicated by ⏏)␤  in block <unit> at <tmp> line 1␤␤Actually thrown at:␤  in block <unit> at <tmp> line 1␤␤»
m: my Int @a = 1 .. 3.2; say @a
rakudo-moar 9f0b12: OUTPUT: «[1 2 3]␤»
m: my Int @a = eager 1 .. 3.2; say @a
rakudo-moar 9f0b12: OUTPUT: «[1 2 3]␤»
m: dd eager 1 .. 3.2
rakudo-moar 9f0b12: OUTPUT: «(1, 2, 3)␤»
m: dd eager 1.9 .. 3.2
rakudo-moar 9f0b12: OUTPUT: «(1.9, 2.9)␤»
m: my Int @a = 1.9 .. 3.2
rakudo-moar 9f0b12: OUTPUT: «Type check failed in assignment to @a; expected Int but got Rat (1.9)␤  in block <unit> at <tmp> line 1␤␤»
m: my Int @a = 1 .. Inf; say @a[*-1]\
rakudo-moar 9f0b12: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Confused␤at <tmp>:1␤------> 3my Int @a = 1 .. Inf; say @a[*-1]\7⏏5<EOL>␤    expecting any of:␤        postfix␤»
m: my Int @a = 1 .. Inf; say @a[*-1]
rakudo-moar 9f0b12: OUTPUT: «Cannot .elems a lazy list␤  in block <unit> at <tmp> line 1␤␤Actually thrown at:␤  in block <unit> at <tmp> line 1␤␤»
rakudo-moar 9f0b12: ( no output )
and by the time you would, you'd get a binding fail  :-)
Zoffix: perhaps you should pick up Destiny 2 when it is released
sometime I wonder whether we should have a stringy Inf to which all strings would be less
afk&   # 1x 20x faster and 2x 150x faster is a good score for today so far  :-)
m: my Int @a = lazy 1, NaN, Int;
rakudo-moar 9f0b12: ( no output )
m: my Int @a = lazy 1, NaN, Int; dd @a
rakudo-moar 9f0b12: OUTPUT: «Type check failed in assignment to @a; expected Int but got Num (NaN)␤  in block <unit> at <tmp> line 1␤␤»
m: my Int @a = 1 .. Inf; say @a[*-1];
rakudo-moar 9f0b12: OUTPUT: «Cannot .elems a lazy list␤  in block <unit> at <tmp> line 1␤␤Actually thrown at:␤  in block <unit> at <tmp> line 1␤␤»
m: my Int @a = lazy 1, NaN, Int; dd @a[*-1]
rakudo-moar 9f0b12: OUTPUT: «Cannot .elems a lazy list␤  in block <unit> at <tmp> line 1␤␤Actually thrown at:␤  in block <unit> at <tmp> line 1␤␤»
timotimo++  making essentially the same change to lower_signature in Actions.nqp that i did to handle_optional in BOOTSTRAP.nqp gets me much farther
there's an error late on make install, but perl6-m is created and `sub foo(Int @a?) { say @a ?? "@a[]" !! "no arg" }; foo();` now gives 'no arg' locally
m: my Int @a = lazy 1, NaN, Int; dd @a[1, 2']
rakudo-moar 9f0b12: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Two terms in a row␤at <tmp>:1␤------> 3my Int @a = lazy 1, NaN, Int; dd @a[1, 27⏏5']␤    expecting any of:␤        infix␤        infix stopper␤        statement end␤        statement mo…»
m: my Int @a = lazy 1, NaN, Int; .say for @a
rakudo-moar 9f0b12: OUTPUT: «1␤Type check failed in assignment to @a; expected Int but got Num (NaN)␤  in block <unit> at <tmp> line 1␤␤»
m: [][Inf]
rakudo-moar 9f0b12: OUTPUT: «Cannot coerce Inf to an Int␤  in block <unit> at <tmp> line 1␤␤Actually thrown at:␤  in block <unit> at <tmp> line 1␤␤»
m: [][1i42]
rakudo-moar 9f0b12: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Confused␤at <tmp>:1␤------> 3[][17⏏5i42]␤    expecting any of:␤        whitespace␤»
m: [][1i+42]
rakudo-moar 9f0b12: OUTPUT: «Can not convert 42+1i to Int: imaginary part not zero␤  in block <unit> at <tmp> line 1␤␤Actually thrown at:␤  in block <unit> at <tmp> line 1␤␤»
m: [][1+i42]
rakudo-moar 9f0b12: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Undeclared routine:␤    i42 used at line 1␤␤»
m: [][1+42i]
rakudo-moar 9f0b12: OUTPUT: «Can not convert 1+42i to Int: imaginary part not zero␤  in block <unit> at <tmp> line 1␤␤Actually thrown at:␤  in block <unit> at <tmp> line 1␤␤»
m: [][42i]
rakudo-moar 9f0b12: OUTPUT: «Can not convert 0+42i to Int: imaginary part not zero␤  in block <unit> at <tmp> line 1␤␤Actually thrown at:␤  in block <unit> at <tmp> line 1␤␤»
m: [][Inf]
rakudo-moar 9f0b12: OUTPUT: «Cannot coerce Inf to an Int␤  in block <unit> at <tmp> line 1␤␤Actually thrown at:␤  in block <unit> at <tmp> line 1␤␤»
m: [][42i]
rakudo-moar 9f0b12: OUTPUT: «Can not convert 0+42i to Int: imaginary part not zero␤  in block <unit> at <tmp> line 1␤␤Actually thrown at:␤  in block <unit> at <tmp> line 1␤␤»
m: [][Inf]
rakudo-moar 9f0b12: OUTPUT: «Cannot coerce Inf to an Int␤  in block <unit> at <tmp> line 1␤␤Actually thrown at:␤  in block <unit> at <tmp> line 1␤␤»
m: [][i]
rakudo-moar 9f0b12: OUTPUT: «Can not convert 0+1i to Int: imaginary part not zero␤  in block <unit> at <tmp> line 1␤␤Actually thrown at:␤  in block <unit> at <tmp> line 1␤␤»
self-referential junctions!
nice
Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=125576
rakudo-moar 9f0b12: ( no output )
rakudo-moar ee4593: OUTPUT: «(timeout)»
heh, every single spectest failed, the patch may need some more work
Zoffix: I'll pass your message to lizmat.
m: my $a = mix <a b>; my $b = mix <a b c>; dd $a (^) $b
rakudo-moar ee4593: OUTPUT: «("c"=>1).Mix␤»
m: my $a = mix <a b>; my $b = mix <a b c>; dd [ $a (^) $b, $a, $b ]
rakudo-moar ee4593: OUTPUT: «[("c"=>1).Mix, ("b"=>1,"a"=>1).Mix, ("b"=>1,"a"=>1,"c"=>1).Mix]␤»
c: 9f0b1218f3 my $a = mix <a b>; my $b = mix <a b c>; dd [ $a (^) $b, $a, $b ]
c: 9f0b1218f3 my $a = mix <a b c>; my $b = mix <a b c>; dd [ $a (^) $b, $a, $b ]
c: 9f0b1218f3,HEAD my $a = mix <a b c>; my $b = mix <a b c>; dd [ $a (^) $b, $a, $b ]
c: 9f0b1218f3,HEAD my $a = mix <a b>; my $b = mix <a b c>; dd [ $a (^) $b, $a, $b ]
c: 9f0b1218f3,HEAD my $a = mix <a b c>; my $b = mix <a b>; dd [ $a (^) $b, $a, $b ]
c: 9f0b1218f3,HEAD my $a = mix <a a a b c>; my $b = mix <a b>; dd [ $a (^) $b, $a, $b ]
.
14:17Z <Zoffix> lizmat: what was the problem not caught by tests? I'd like to add a test. RE https://github.com/rakudo/rakudo/commit/bea8ac6890
Zoffix: actually, it *may* have been me not running a spectest when It should have
I was adding the Baggy (^) Baggy candidate, and the Mixy (^) Mixy candidate started failing
is there a way to tell that a Parameter's $!nominal_type is parameterized? other than `if nqp::index($nominal_type.HOW.name($nominal_type), '[') > 0`
looking back on it now, I probably didn't run a spectest on 9f0b1218f3
afk again&
ah ha! now all spectests pass and `sub foo(Int @a?) { say @a ?? "@a[]" !! "no arg" }; foo();` gives 'no arg' locally
buggable: eco
buggable: tags
buggable: tag TESTNEEDED
m: use x $;
rakudo-moar ee4593: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Could not evaluate arguments␤at <tmp>:1␤------> 3use x $7⏏5;␤»
huggable: windows utf8 :is: chcp 65001
Like cmd.exe /c "echo Foo && echo Bar"
Though that's not very Windows specific I guess :)
jnthn: i hope this is a quick question: is there a way to tell that a Parameter's $!nominal_type is parameterized? other than `if nqp::index($nominal_type.HOW.name($nominal_type), '[') > 0`
uh, that's a really bad way :-)
Either something on .HOW.archetypes will tell you, or you'll often find that .HOW ~~ Metamodel::CurriedRoleHOW
Though some others (like Array) do whatever they like on parameterization
What's the context where you need to know this?
I think you were trying to fix stuff like Int @array?
yep
Yeah, the thing there is...
The type we have there is Positional[Array]
gah
The type we have there is Positional[Int]
But the type we should create by default is Array[Int] :)
m: say Positional[Int] ~~ Positional
rakudo-moar ee4593: OUTPUT: «True␤»
m: say Positional[Int].of
rakudo-moar ee4593: OUTPUT: «(Int)␤»
We only want to do this when the sigil is @ however
(There's a flag that states this)
so right here: https://github.com/rakudo/rakudo/blob/nom/src/Perl6/Actions.nqp#L8435 i added `if nqp::index($nomtype.HOW.name($nomtype), '[') > 0 { $var.default(QAST::WVal.new( :value($nomtype) )); } else {`
which passes all spectests and makes `Int @a?` work
More robust would be something like
if nqp::istype($nomtype, $*W.find_symbol(['Positional'])) && !($nomtype.of =:= $*W.find_symbol(['Mu'])
But yh
thanks, i'll give that a shot
But the thing it's doing in the barnch is wrong
*branch
If it passes the tests you didn't write enough :)
heh, haven't added any tests yet
sub x(Int @arr?) { @arr.push(42) }
Should work :)
And won't
You'd need to create an Array[Int]
Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=127925
And then nqp::create that
right. `Cannot modify an immutable Positional[Int]`
Yeah
So that's the second half
nqp::create(Array[Int]) doesn't work
i already tried hard-coding that
That's a mixing of levels
Array[Int] doesn't exist in NQP and if it did it'd be the wrong one :)
I think there's a $*W.parameterize_type or so
Which you can pass $*W.find_symbol(['Array']) and $nomtype.of to
Which will build the Array[Int] type
Which can then be stuck in a QAST::WVal and used with nqp::create
cool, let me try that
rrrrrrrrrrrrrrrrrrrrrrrrrrrrttttttttttttttttttttttttttttttttttttttttttttbsMy chances of finishing Persona 5 any time soon are incredibly slim. As much as I loved (yes, loved) forming a crack team of heart thieves, falling in love with a punk rock doctor, eating massive hamburgers for fabulous stats and prizes, and watching films about baked goods superheroes, I just can't see myself finding that much time
to do it all over again. I'll just have to live vicariously through just about everyone else on the site.
oops
/usr/bin/perl t/harness5 --fudge --moar --keep-exit-code --verbosity=1 t/spec/S32-list/minmax.t
t/spec/S32-list/minmax.rakudo.moar ..
MoarVM panic: Collectable 0x96a2648 in fromspace accessed
Nice find
it was with a small nursery
Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=130979
let me see if I can get some gdb output ...
cool
c: 87fe800 use Test; lives-ok {require ::("t::spec::S11-modules::SetConst") }, "require class with set constant";
hm, `!($nomtype.of =:= $*W.find_symbol(['Mu']))` won't compile and gives `Cannot find method 'WHY' on object of type Perl6::Metamodel::CurriedRoleHOW`
c:use Test; lives-ok {require ::("t::spec::S11-modules::SetConst") }, "require class with set constant";
c: use Test; lives-ok {require ::("t::spec::S11-modules::SetConst") }, "require class with set constant";
committable6: no, I fucking didn't, you stupid shit
m: say Positional[Int].HOW.WHAT
rakudo-moar ee4593: OUTPUT: «(CurriedRoleHOW)␤»
m: say Positional[Int].of
rakudo-moar ee4593: OUTPUT: «(Int)␤»
Hmm, odd
What code won't it compile?
If CORE.setting it may be a bootstrap issue
`if !($nomtype.of =:= $*W.find_symbol(['Mu'])) {` in Actions.nqp
Could always stick a try in there :)
yeah, this is during a rakudo build
Yeah but the error you showed is a Perl 6 one, not an NQP one
in parse
In parse of CORE.setting, I guess?
yeah
Hm
I guess another way is
m: say Positional[Int].HOW.^method-table
rakudo-moar ee4593: OUTPUT: «No such method 'method-table' for invocant of type 'NQPClassHOW'␤  in block <unit> at <tmp> line 1␤␤»
m: say Positional[Int].HOW.^method_table
rakudo-moar ee4593: OUTPUT: «No such method 'WHICH' for invocant of type 'NQPRoutine'␤  in block <unit> at <tmp> line 1␤␤»
m: dd Positional[Int].HOW.^method_table
rakudo-moar ee4593: OUTPUT: «No such method 'WHICH' for invocant of type 'NQPRoutine'␤  in block <unit> at <tmp> line 1␤␤»
m: dd Positional[Int].HOW.^method_table.keys
rakudo-moar ee4593: OUTPUT: «("name", "accepts_type", "set_shortname", "new_type", "pretend_to_be", "make_pun", "configure_punning", "shortname", "type_check", "instantiate_generic", "set_pun_repr", "set_name", "pretending_to_be", "inheritalize", "specialize", "find_method", "pun", …»
m: dd Positional[Int].HOW.^method_table.keys.grep(/arg/)
rakudo-moar ee4593: OUTPUT: «("role_arguments",).Seq␤»
Ah, that
m: say Positional[Int].role_arguments
rakudo-moar ee4593: OUTPUT: «No such method 'role_arguments' for invocant of type 'Positional[Int]'␤  in block <unit> at <tmp> line 1␤␤»
m: say Positional[Int].^role_arguments
rakudo-moar ee4593: OUTPUT: «((Int))␤»
That could be a way
m: say Positional.^role_arguments
rakudo-moar ee4593: OUTPUT: «No such method 'role_arguments' for invocant of type 'Perl6::Metamodel::ParametricRoleGroupHOW'␤  in block <unit> at <tmp> line 1␤␤»
Would need to be guarded by an nqp::can
But that saves the punning trap
And so shouldn't trip up CORE.setting compilation
yeah, the stack trace did have make_pun at the top
ok, i'll give that a try
m: BEGIN { role BetterWorld {}; $*W.HOW.mixin($*W, BetterWorld); dd $*W};
rakudo-moar ee4593: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤An exception occurred while evaluating a BEGIN␤at <tmp>:1␤Exception details:␤  No such method 'dispatch:<.?>' for invocant of type 'Perl6::World+{BetterWorld}'␤    in block  at <tmp> line 1␤␤»
m: BEGIN { role BetterWorld {}; $*W.HOW.mixin($*W, BetterWorld); dd $*W.^name};
rakudo-moar ee4593: OUTPUT: «"Perl6::World+\{BetterWorld}"␤»
jnthn; sorry for the delay, https://gist.github.com/dogbert17/12dc1eb9cf86e2673d221e07402c7bc7
dogbert17: No worries, I'm exhausted anyway
`Cannot find method 'list' on object of type NQPArray`, i get that from passing `$nomtype.HOW.role_arguments($nomtype)` as the $arglist parameter to $*W.parameterize_type, which does `for @($arglist) {`
m: try die("42"); say($!)
rakudo-moar ee4593: OUTPUT: «42␤  in block <unit> at <tmp> line 1␤␤»
m: try die("42"); $! and say("meow")
rakudo-moar ee4593: OUTPUT: «meow␤»
nqp: try die("42"); $! and say("meow")
nqp-moarvm: OUTPUT: «Confused at line 2, near "$! and say"␤   at gen/moar/stage2/NQPHLL.nqp:768  (/home/camelia/rakudo-m-inst-2/share/nqp/lib/NQPHLL.moarvm:panic)␤ from gen/moar/stage2/NQP.nqp:919  (/home/camelia/rakudo-m-inst-2/share/nqp/lib/nqp.moarvm:comp_unit)␤ from gen/mo…»
nqp: try die("42"); $! && say("meow")
nqp-moarvm: ( no output )
nqp: try die("42"); say($!)
nqp-moarvm: OUTPUT: «␤»
nqp-moarvm: OUTPUT: «␤»
m: say Positional[Int].^role_arguments
rakudo-moar ee4593: OUTPUT: «((Int))␤»
m: say Array[Positional[Int]].^role_arguments
rakudo-moar ee4593: OUTPUT: «No such method 'role_arguments' for invocant of type 'Perl6::Metamodel::ClassHOW+{<anon>}+{<anon>}'␤  in block <unit> at <tmp> line 1␤␤»
huh
jnthn: how is our native str to native num conversion supposed to work?
currently it's platform specific with on moarvm "Information" being converted to "Inf" on linux but not on windows
on the jvm it works even more differently
jnthn: I can make it consistent but I need to know what's the behaviour we want
m: my num $foo = '4.2'
rakudo-moar ee4593: OUTPUT: «This type cannot unbox to a native number: P6opaque, Str␤  in block <unit> at <tmp> line 1␤␤»
It's supposed to do that :)
m: my num $foo = '4.2'.Num
rakudo-moar ee4593: ( no output )
And going through Num should be sane
m: my str $s = '4.2'; my num $n = $s;
rakudo-moar ee4593: ( no output )
o.O
And that'd be a bug that it compiles
m: my str $s = '4.2'; my num $n = $s; say $n
rakudo-moar ee4593: OUTPUT: «4.2␤»
rakudo-moar ee4593: OUTPUT: «Inf␤»
:P
rakudo-moar ee4593: OUTPUT: «42␤»
I guess this is about the op taht's used at a lower level to do this, though :)
jnthn: so I should copy the .Num behavior?
pmurias: That'd seem sensible, yeah
I'd hope that path is well tested :)
our str to num has 4 recently added tests :)
jnthn: my num = 'bla bla'.Num;
m: my num = 'bla bla'.Num;
rakudo-moar ee4593: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Malformed my␤at <tmp>:1␤------> 3my num7⏏5 = 'bla bla'.Num;␤»
m: my num $x = 'bla bla'.Num;say $x
rakudo-moar ee4593: OUTPUT: «This type cannot unbox to a native number: P6opaque, Failure␤  in block <unit> at <tmp> line 1␤␤»
m: say 'bla bla'.Num
rakudo-moar ee4593: OUTPUT: «Cannot convert string to number: base-10 number must begin with valid digits or '.' in '3⏏5bla bla' (indicated by ⏏)␤  in block <unit> at <tmp> line 1␤␤Actually thrown at:␤  in block <unit> at <tmp> line 1␤␤»
jnthn: sorry to keep bothering you about this, but any suggestions for my two comments above (method 'list' on NQPArray, and role_arguments not working on things with multiple parameterizations)?
jnthn: do we want the str to num conversion to throw an exception in the cases it can't convert?
jnthn: also I spotted a BEGIN nqp::hash in our setting, not sure if it should be put in a WVal as normally BOOTHashes are specially handled
pmurias: i think lizmat did the `BEGIN nqp::hash` intentionally as an optimization of some kind
Array[...] is handled specially by the Array class rather than being a role parameterization
But I don't think for default you need to worry about multi-level, and the outer-most level will always be Positional?
pmurias: Probably would have to, because Failure is not an option
ah, that's probably true
jnthn: we have a choice between NaN and 0
pmurias: True, but I'd prefer throw-y to those :)
got to go meet a friend, I'll backlog and be back later
jnthn: any idea about the method 'list' business with role_arguments and parameterize_types?
MasterDuke_: it takes some getting used to :)
MasterDuke_: Dinner now, will have to look at that a bit more after
sure, np
MasterDuke_: nqp/t/nqp/035-prefix-sigil.t shows how this @($array) business is supposed to work. It does so in Perl6::Actions because parameterize_type is passed an $<arglist>.ast which is a QAST::Node which has a method list()
MasterDuke_: a quick n' dirty way around that would be to hllize the NQPArray you get from role_arguments, because Perl6 arrays do have a list() method ;)
nine++
A cleaner way would probably be to write a version of parameterize_type that takes an NQPArray. It's mostly just a wrapper around self.parameterize_type_with_args anyway
or maybe just inline and adapt the relevant parts of parameterize_type, since i only need it in one spot anyway
yes
heh, `Cannot iterate object with P6opaque representation (List)` when i pass in `nqp::hllizefor(@role_args, 'perl6')`. closer...
Add a .FLATTENABLE_LIST()
Then we've come full circle ;)
buggable: eco
huh again. `Method 'new-unit' must be implemented by CompUnit::PrecompilationStore because it is required by roles: CompUnit::PrecompilationStore.`
obviously did something wrong with my parameterize_type adaptation
Looks like you're punning roles there
yep, somehow
hm. rakudo built, but now `sub foo(Int @a?) { @a.push(42) }; foo();` gives `Cannot resolve caller STORE(Array[Int]: Array[Int]); none of these signatures match:`
That looks like a create or .new was missed somewhere
jnthn++
`sub foo(Int @a?) { @a.push(42); dd @a }; foo();` now gives `Array[Int].new(42)`
MasterDuke++
just need to run a final spectest before the PR
man, that kept alternating between 'looks hard', 'oh, looks approachable', 'nope, looks hard', 'but wait...'
rakudo-moar ee4593: OUTPUT: «62.105263% of META.infos are still unmerged␤»
METAcide
38% after what, 24h? not bad
i'll also write some tests in a bit
i think he was just being stubborn not wanting to fix his projects metadata
he didn't have any real reason but "this hasn't been discussed enough" even when it had been discussed many places
being put into practice etc, docs updated and s22 etc.
he didn't offer any reason he did not like the changes to license guidelines for META files though
Zoffix, https://irclog.perlgeek.de/perl6/search/?nick=&q=nuclear+blackmail
can find it when you searach for nuclear blackmail for irc.perl6.org :X
and he made that claim the day before even
then said it again more strongly the next day
he's been absent since a day after that, afaik. and modules still in place at least. i hope he cools off
interestingly he did fix the metadata on one project. the first one i PR'd
but then got mad when i wanted him through PR's to change all his modules.. i did the work for him even
Zoffix: I'll pass your message to RabidGravy.
Wow, I just found my name on https://docs.perl6.org/language/modules#index-entry-META6 next to a TODO "fix EVAL precomp bug". But I don't even know what that is. Unless it's something long gone?
Zoffix, licence and license is no issue SPDX even says those two words are equivilant
ACTION wonders whether it is considered polite/ethical to just keep forks of every repo that has ever been added to the ecosystem, so that we can say "part of the community agreement in being visible to package managers is that we deprive you of the nuclear option"
so since i'm following spdx, that is not a problem
(Where by "package manager" I am being intentionally vague)
japhb, github says you can
and it's expected when you put things on github to get forked. you agree to those terms
samcv: Link?
yeah
Well, there's a difference between theoretically possible, and *us actively doing it*.
well. i think we already do it for every module to keep backups just in case. or something
samcv: Where?
japhb, https://github.com/moritz/perl6-all-modules
samcv: Current commit in that repo is "Remove repos that no longer exist".
:X
So that's not actually serving that purpose.
japhb, but you can look in the history right?
git keeps all things
Zoffix: Is this done automatically for *all* modules in our ecosystem (releasing to CPAN, I mean)
samcv: git *can* keep all things.  ;-)  But yes, I get your point.
hmm
that's not in our TOS for ecosystem
Fair enough
i don't think
will have to check ToS for github. i think you have to allow forking and viewing at least. not sure about repackaging
since some don't have licenses
if that's something people should expect we should add it to https://github.com/perl6/ecosystem#legal
Well, the scenario would be "Person A invokes nuclear option, deletes all their repos from Github; one of the core team (or a bot) switches the ecosystem entry over to the community fork, and we consider that the canonical (mutable) repo from then on"
That's the thing to make sure we can reasonably do.
So we have to be able to have all the redistro rights we had before when we invoke the de-nuclear fix.
if somebody nuclear options, then the community fork is a new authority
Zoffix: that only happend because npm lack a spine
mst: Is there any infrastructure for letting the community authority cleanly take over, so that end users stay on the currently-maintained fork, oblivious to the averted disaster?
Zoffix: npm gave one of his other namespaces away because corporate pressure
japhb: the whole point of the authority system is to avoid *needing* a concept of a blessed-by-authority fork
if you wanted to really suck you'd prolly force overwrite the git repos
and then wait for the backups to pick it up... and update the meta info
mst: I meant, is there anyway to let end users know "This isn't just two actively maintained forks -- Authority A which you are currently following has been shut down completely, and here is the replacement"
Automated succession.
https://cry.nu/9PMBST.html that actually does automatically remove all your modules from ecosystem by 9pm bst
well i never ran it without $TEST = True; or the line to push to ecosystem commented out
We'd have the same problem if an active maintainer dies suddenly without a secession plan, and the community gets together to find a new maintainer
but it commits and everything hah
*succession
well when people die github doesn't usually remove their account
japhb: this is completely the wrong place to be discussing this, but the ecosystem is basically a giant pile of duct tape anyway, so the general answer to "is there infrastructure for" is "no, because lol what infrastructure"
mst: :-D   Fair enough.
OTOH this also means nothing is really set in stone
samcv: Yes, but if you're an end user, you would have no idea that bug/security fixes were no longer happening in that repo, but were happening elsewhere -- right up until the day your service gets owned because it hasn't updated its libraries in a while.
?
japhb, that's true.
japhb: right, I think *ideally* we would have certain authority sources that *can* be transferred
Zoffix: I'd've thought the toolchain channel, since that's where all the software that actually has to deal with this lives?
Didn't we have an -ecosystem or -toolchain or something channel?
what toolchain channel...
the one I set up in 2015 to discuss module installation related stuff
can you put it in the topic maybe?
i wouldn't even have known it existed
and people coming to perl6-dev may want to join it if they are interested in that kind of thing
samcv: You mean a mention in this channel's topic to look over there for ecosystem/toolchain?
I confess to being a little disappointed nobody bothered to tell you before giving you access to ecosystem
sure
mst: I'd heard about it a couple years ago, but had assumed this channel was taking over all of the dev discussions elsewhere.
Thanks
this channel is for language and compiler development, as was already in the topic
not sure how you assumed it also took over a bunch of other things, but ok
Zoffix: I *hadn't* heard about that one ...
:O
i'm in it now
mst: Because I'm not always here.  I took a vacation, came back and found this channel existed.
(where "here" means "paying attention and backlogging these channels")
nqp: my ($role, $base-type) := 42 ?? ('Positional', 'Array') !! ('Associative', 'Hash'); say($role); say($base-type)
nqp-moarvm: OUTPUT: «Confused at line 2, near "my ($role,"␤   at gen/moar/stage2/NQPHLL.nqp:768  (/home/camelia/rakudo-m-inst-2/share/nqp/lib/NQPHLL.moarvm:panic)␤ from gen/moar/stage2/NQP.nqp:919  (/home/camelia/rakudo-m-inst-2/share/nqp/lib/nqp.moarvm:comp_unit)␤ from gen/mo…»
nqp: my $role := 42 ?? 'Positional' !! 'Associative'; my $base-type = $role eq 'Positional' ?? 'Array' !! 'Hash'; say($role); say($base-type)
nqp-moarvm: OUTPUT: «Assignment ("=") not supported in NQP, use ":=" instead at line 2, near " $role eq "␤   at gen/moar/stage2/NQPHLL.nqp:768  (/home/camelia/rakudo-m-inst-2/share/nqp/lib/NQPHLL.moarvm:panic)␤ from <unknown>:1  (/home/camelia/rakudo-m-inst-2/share/nqp/lib/nqp.m…»
nqp: my $role := 42 ?? 'Positional' !! 'Associative'; my $base-type := $role eq 'Positional' ?? 'Array' !! 'Hash'; say($role); say($base-type)
nqp-moarvm: OUTPUT: «Positional␤Array␤»
nqp: my $role := 42 ?? 'Positional' !! 'Associative'; my $base-type := $role eq 'Positional' ?? 'Array' !! 'Hash'; say($role); say($base-type)
nqp-moarvm: OUTPUT: «Positional␤Array␤»
nqp: my %info := {}; %info<sigill> := '@'; my $role := %info<sigil> eq '@' ?? 'Positional' !! 'Associative'; my $base-type := %info<sigil> eq '@' ?? 'Array' !! 'Hash'; say($role); say($base-type)
nqp-moarvm: OUTPUT: «Associative␤Hash␤»
nqp: my %info := {}; %info<sigill> := '%'; my $role := %info<sigil> eq '@' ?? 'Positional' !! 'Associative'; my $base-type := %info<sigil> eq '@' ?? 'Array' !! 'Hash'; say($role); say($base-type)
nqp-moarvm: OUTPUT: «Associative␤Hash␤»
nqp: my %info := {}; %info<sigill> := '%'; say(%info); my $role := %info<sigil> eq '@' ?? 'Positional' !! 'Associative'; my $base-type := %info<sigil> eq '@' ?? 'Array' !! 'Hash'; say($role); say($base-type)
nqp-moarvm: OUTPUT: «cannot stringify this␤   at gen/moar/stage2/NQPCORE.setting:713  (/home/camelia/rakudo-m-inst-2/share/nqp/lib/NQPCORE.setting.moarvm:join)␤ from gen/moar/stage2/NQPCORE.setting:702  (/home/camelia/rakudo-m-inst-2/share/nqp/lib/NQPCORE.setting.moarvm:say)␤ …»
nqp: my %info := {}; %info<sigil> := '@'; my $role := %info<sigil> eq '@' ?? 'Positional' !! 'Associative'; my $base-type := %info<sigil> eq '@' ?? 'Array' !! 'Hash'; say($role); say($base-type)
nqp-moarvm: OUTPUT: «Positional␤Array␤»
nqp: my %info := {}; %info<sigil> := '@'; if my $is-array := %info<sigil> eq '@' or %info<sigil> eq '%' { my $role := $is-array ?? 'Positional' !! 'Associative'; my $base-type := $is-array ?? 'Array' !! 'Hash'; say($role); say($base-type) }
nqp-moarvm: OUTPUT: «Missing block at line 2, near "or %info<s"␤   at gen/moar/stage2/NQPHLL.nqp:768  (/home/camelia/rakudo-m-inst-2/share/nqp/lib/NQPHLL.moarvm:panic)␤ from <unknown>:1  (/home/camelia/rakudo-m-inst-2/share/nqp/lib/nqp.moarvm:pblock)␤ from <unknown>:1  (/home/…»
nqp: my %info := {}; %info<sigil> := '@'; if (my $is-array := %info<sigil> eq '@') or %info<sigil> eq '%' { my $role := $is-array ?? 'Positional' !! 'Associative'; my $base-type := $is-array ?? 'Array' !! 'Hash'; say($role); say($base-type) }
nqp-moarvm: OUTPUT: «Missing block at line 2, near "or %info<s"␤   at gen/moar/stage2/NQPHLL.nqp:768  (/home/camelia/rakudo-m-inst-2/share/nqp/lib/NQPHLL.moarvm:panic)␤ from <unknown>:1  (/home/camelia/rakudo-m-inst-2/share/nqp/lib/nqp.moarvm:pblock)␤ from <unknown>:1  (/home/…»
nqp: my %info := {}; %info<sigil> := '@'; if (my $is-array := (%info<sigil> eq '@')) or %info<sigil> eq '%' { my $role := $is-array ?? 'Positional' !! 'Associative'; my $base-type := $is-array ?? 'Array' !! 'Hash'; say($role); say($base-type) }
nqp-moarvm: OUTPUT: «Missing block at line 2, near "or %info<s"␤   at gen/moar/stage2/NQPHLL.nqp:768  (/home/camelia/rakudo-m-inst-2/share/nqp/lib/NQPHLL.moarvm:panic)␤ from <unknown>:1  (/home/camelia/rakudo-m-inst-2/share/nqp/lib/nqp.moarvm:pblock)␤ from <unknown>:1  (/home/…»
nqp: my %info := {}; %info<sigil> := '@'; if (my $is-array := (%info<sigil> eq '@')) || %info<sigil> eq '%' { my $role := $is-array ?? 'Positional' !! 'Associative'; my $base-type := $is-array ?? 'Array' !! 'Hash'; say($role); say($base-type) }
nqp-moarvm: OUTPUT: «Positional␤Array␤»
nqp: my %info := {}; %info<sigil> := '@'; if (my $is-array := %info<sigil> eq '@') || %info<sigil> eq '%' { my $role := $is-array ?? 'Positional' !! 'Associative'; my $base-type := $is-array ?? 'Array' !! 'Hash'; say($role); say($base-type) }
nqp-moarvm: OUTPUT: «Positional␤Array␤»
nqp: my %info := {}; %info<sigil> := '%'; if (my $is-array := %info<sigil> eq '@') || %info<sigil> eq '%' { my $role := $is-array ?? 'Positional' !! 'Associative'; my $base-type := $is-array ?? 'Array' !! 'Hash'; say($role); say($base-type) }
nqp-moarvm: OUTPUT: «Associative␤Hash␤»
m: say foo => 42 ?? 'a' !! 'b'
rakudo-moar ee4593: OUTPUT: «Unexpected named argument 'foo' passed␤  in block <unit> at <tmp> line 1␤␤»
m: say 'foo' => 42 ?? 'a' !! 'b'
rakudo-moar ee4593: OUTPUT: «foo => a␤»
m: say 'foo' => 0 ?? 'a' !! 'b'
rakudo-moar ee4593: OUTPUT: «foo => b␤»
m: say 8460 - 8435
rakudo-moar ee4593: OUTPUT: «25␤»
perl6-release can be ded.
oh wow madcapjake merged some of my META.info changes. he lives
gonna comment and tag here here https://github.com/MadcapJake/language-perl6fe/issues/55 maybe get a response
and that concludes my hacking for today
good night, #perl6-dev!
yep i pointed that out moritz
samcv: ok, I didn't backlog carefully enough then
np
This is Rakudo version 2017.04.3-61-g139243971 built on MoarVM version 2017.04-44-gf0db8822
csv-ip5xs        3.166
test            13.659
test-t           5.092 - 5.143
csv-parser      13.207
good point
any idea for a second entry under the ## Install heading?
perhaps nxadm's packages, and the docker images?
+1 to the packages
Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=118555
it's easy to forget about things like that
on http://rakudo.org/how-to-get-rakudo/ the top-right box for 32bit windows says "2016.01", shoudl that not be 2017?
nope, there's no rakudo star newer than 2016.01 for the no-jit version
i.e. for x86
timotimo: ok, just looked odd
yeah, hopefully we'll find someone who can build stuff on win32 for the next rakudo star
took me a few minutes to find the announcement options again
rakudo-moar a96806: OUTPUT: «WARNINGS for <tmp>:␤Useless use of constant integer 42 in sink context (line 1)␤»
rakudo-moar a96806: OUTPUT: «Non ast passed to WANTED: NQPMu␤Weird node in analyze: NQPMu␤WARNINGS for <tmp>:␤Useless use of constant integer 42 in sink context (line 1)␤===SORRY!===␤Unknown QAST node type NQPMu␤»
rakudo-moar a96806: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Undeclared name:␤    TOMP used at line 1␤␤»
i didn't know about TEMP being a thing
i don't think this whole TEMP method business has made it into anything
rakudo-moar a96806: OUTPUT: «1␤2␤Can only use 'temp' on a container␤  in block <unit> at <tmp> line 1␤␤»
well, temp in lowercase exists at leas
least*
m: 'foo' ~~ / $<foo>=.**2 /; dd $/.Capture
rakudo-moar a96806: OUTPUT: «Match.new(list => (), made => Any, pos => 2, hash => Map.new((:foo(Match.new(list => (), made => Any, pos => 2, hash => Map.new(()), orig => "foo", from => 0)))), orig => "foo", from => 0)␤»
m: 'foo' ~~ / $<foo>=.**2 /; say $/.Capture
rakudo-moar a96806: OUTPUT: «｢fo｣␤ foo => ｢fo｣␤»
m: 'foo' ~~ / $<foo>=.**2 /; say $/.Capture.hash
rakudo-moar a96806: OUTPUT: «Map.new((:foo(Match.new(list => (), made => Any, pos => 2, hash => Map.new(()), orig => "foo", from => 0))))␤»
m: 'foo' ~~ / $<foo>=.**2 /; say $/.Capture.hash».Str
rakudo-moar a96806: OUTPUT: «{foo => fo}␤»
m: 'foo' ~~ / $<foo>=.**2 /; say $/.Capture.hash.Str
rakudo-moar a96806: OUTPUT: «foo        fo␤»
m: 'foo' ~~ / $<foo>=.**2 /; say $/.Capture.hash».Str
rakudo-moar a96806: OUTPUT: «{foo => fo}␤»
m: 'foo' ~~ / $<foo>=.**2 /; say $/.Capture.hash».Str<foo>
rakudo-moar a96806: OUTPUT: «fo␤»
m: 'foo' ~~ / $<foo>=.**2 /; say $/.Capture.hash».Str
rakudo-moar a96806: OUTPUT: «{foo => fo}␤»
m: 'foo' ~~ / $<foo>=.**2 /; say $/.hash».Str
rakudo-moar a96806: OUTPUT: «{foo => fo}␤»
m: 'foo' ~~ / $<foo>=.**2 /; say $/.hash».Str.push: :github
rakudo-moar a96806: OUTPUT: «{foo => fo}␤»
m: 'foo' ~~ / $<foo>=.**2 /; my %h = $/.hash».Str.push: :github; dd %h
rakudo-moar a96806: OUTPUT: «Hash %h = {:foo("fo")}␤»
m: 'foo' ~~ / $<foo>=.**2 /; my %h = $/.hash».Str; %h.push: :github; dd %h
rakudo-moar a96806: OUTPUT: «Hash %h = {:foo("fo")}␤»
m: 'foo' ~~ / $<foo>=.**2 /; my %h = $/.hash».Str; %h.push: 'github' => Truew; dd %h
rakudo-moar a96806: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Undeclared name:␤    Truew used at line 1␤␤»
m: 'foo' ~~ / $<foo>=.**2 /; my %h = $/.hash».Str; %h.push: 'github' => True; dd %h
rakudo-moar a96806: OUTPUT: «Hash %h = {:foo("fo"), :github}␤»
m: 'foo' ~~ / $<foo>=.**2 /; say $/.hash».Str.push: :github
rakudo-moar a96806: OUTPUT: «{foo => fo}␤»
m: 'foo' ~~ / $<foo>=.**2 /; say $/.hash».Str.push: :github.Pair
rakudo-moar a96806: OUTPUT: «No such method 'Pair' for invocant of type 'Pair'␤  in block <unit> at <tmp> line 1␤␤»
m: 'foo' ~~ / $<foo>=.**2 /; say $/.hash».Str.push: |:github
rakudo-moar a96806: OUTPUT: «{foo => fo}␤»
m: 'foo' ~~ / $<foo>=.**2 /; say $/.hash».Str.push: :github.Pair
rakudo-moar a96806: OUTPUT: «No such method 'Pair' for invocant of type 'Pair'␤  in block <unit> at <tmp> line 1␤␤»
m: use MONKEY; augment class Pair { method Pair { self } }; 'foo' ~~ / $<foo>=.**2 /; say $/.hash».Str.push: :github.Pair
rakudo-moar a96806: OUTPUT: «{foo => fo, github => True}␤»
rakudo-moar a96806: OUTPUT: «{foo => fo, github => True}␤»
m: use MONKEY; augment class Pair { method Pair { self } }; 'foo' ~~ / $<foo>=.**2 /; say $/.hash».Str.push: |(:github)
rakudo-moar a96806: OUTPUT: «{foo => fo}␤»
m: use MONKEY; augment class Pair { method Pair { self } }; 'foo' ~~ / $<foo>=.**2 /; say $/.hash».Str.push: github =>True
rakudo-moar a96806: OUTPUT: «{foo => fo}␤»
m: use MONKEY; augment class Pair { method Pair { self } }; 'foo' ~~ / $<foo>=.**2 /; say $/.hash».Str.push: github => True
rakudo-moar a96806: OUTPUT: «{foo => fo}␤»
m: use MONKEY; augment class Pair { method Pair { self } }; 'foo' ~~ / $<foo>=.**2 /; say $/.hash».Str.push: 'github' => True
rakudo-moar a96806: OUTPUT: «{foo => fo, github => True}␤»
Zoffix: Things having themselves as a coercer is fine
I wonder if we can sensibly .Pair anything else... :)
single-element hashes potentially, but ... doesn't seem useful
m: "HI".Pair.perl.say
rakudo-moar a96806: OUTPUT: «No such method 'Pair' for invocant of type 'Str'␤  in block <unit> at <tmp> line 1␤␤»
rakudo-moar a96806: OUTPUT: «No such method 'Pair' for invocant of type 'List'␤  in block <unit> at <tmp> line 1␤␤»
m: <a b>.pairup.perl.say
rakudo-moar a96806: OUTPUT: «(:a("b"),).Seq␤»
m: use MONKEY; augment class Pair { method Pair { self } }; 'foo' ~~ / $<foo>=.**2 /; say $/.hash».Str.push: :42gihub.Pair
rakudo-moar a96806: OUTPUT: «{foo => fo, gihub => 42}␤»
m: use MONKEY; augment class Pair { method Pair { self } }; 'foo' ~~ / $<foo>=.**2 /; say $/.hash».Str.push: :gihub<foos>.Pair
rakudo-moar a96806: OUTPUT: «{foo => fo, gihub => foos}␤»
that's an interesting use case, yeah
i didn't even notice what you did up there
buggable: author zoffixznet
buggable: author zoffixznetads
Zoffix: I'll pass your message to moritz.
that's unfortunate
13:21Z <Zoffix> moritz: not sure if you've seen my comment on the Issue, but my suggestion to use CSS to break long lines on logs was wrong. That CSS property does jack all due to auto-resizing table the stuff is in. So lines no longer are broken right now: https://github.com/moritz/ilbot/issues/51#issuecomment-296676513
'#OK not indicate octal' are just regular comments?
rakudo-moar bd9e57: OUTPUT: «Potential difficulties:␤    Leading 0 does not indicate octal in Perl 6. Please use 0o1 if you mean that.␤    at <tmp>:1␤    ------> 03017⏏5<EOL>␤WARNINGS for <tmp>:␤Useless use of constant integer 1 in sink context (line 1)␤»
rakudo-moar bd9e57: OUTPUT: «Potential difficulties:␤    To refer to a positional match capture, just use $0 (numbering starts at 0).␤    Parenthesize as \(...) if you intended a capture of a single numeric value.␤    at <tmp>:1␤    ------> 3use Test; is "{\7⏏0501;42}",…»
rakudo-moar bd9e57: OUTPUT: «Potential difficulties:␤    To refer to a positional match capture, just use $0 (numbering starts at 0).␤    Parenthesize as \(...) if you intended a capture of a single numeric value.␤    at <tmp>:1␤    ------> 3\7⏏050␤»
m: use MONKEY; augment class Int { method Capture { die "no cookie" } }; use Test; is "{\01;42}", "42"
rakudo-moar bd9e57: OUTPUT: «Potential difficulties:␤    To refer to a positional match capture, just use $0 (numbering starts at 0).␤    Parenthesize as \(...) if you intended a capture of a single numeric value.␤    at <tmp>:1␤    ------> 3 { die "no cookie" } }; use Test…»
m: use MONKEY; augment class Int { method Capture { die "no cookie" } }; use Test; quietly is "{\01;42}", "42"
rakudo-moar bd9e57: OUTPUT: «Potential difficulties:␤    To refer to a positional match capture, just use $0 (numbering starts at 0).␤    Parenthesize as \(...) if you intended a capture of a single numeric value.␤    at <tmp>:1␤    ------> 3no cookie" } }; use Test; quietl…»
m: use MONKEY; augment class Int { method Capture { die "no cookie" } }; use Test; is "{\01;42}", "42"
rakudo-moar bd9e57: OUTPUT: «Potential difficulties:␤    To refer to a positional match capture, just use $0 (numbering starts at 0).␤    Parenthesize as \(...) if you intended a capture of a single numeric value.␤    at <tmp>:1␤    ------> 3 { die "no cookie" } }; use Test…»
rakudo-moar bd9e57: OUTPUT: «1␤»
s: &infix:<\\>
s: &prefix:<\\>
s: &prefix:<\>
m: use MONKEY; augment class Int { method Capture { die "no cookie" } }; dd 1.Capture
rakudo-moar bd9e57: OUTPUT: «no cookie␤  in method Capture at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»
m: use MONKEY; augment class Int { method Capture { die "no cookie" } }; dd \4\2
rakudo-moar bd9e57: OUTPUT: «5===SORRY!5===␤Confused␤at <tmp>:1␤------> 3od Capture { die "no cookie" } }; dd \4\7⏏052␤    expecting any of:␤        postfix␤Other potential difficulties:␤    To refer to a positional match capture, just use $0 (numbering start…»
m: use MONKEY; augment class Int { method Capture { die "no cookie" } }; dd \42
rakudo-moar bd9e57: OUTPUT: «Potential difficulties:␤    To refer to a positional match capture, just use $0 (numbering starts at 0).␤    Parenthesize as \(...) if you intended a capture of a single numeric value.␤    at <tmp>:1␤    ------> 3thod Capture { die "no cookie" }…»
m: use MONKEY; augment class Int { method Capture { die "no cookie" } }; dd \ 42
rakudo-moar bd9e57: OUTPUT: «42␤»
m: use MONKEY; augment class Int { method Capture { die "no cookie" } }; dd \( 42 0
rakudo-moar bd9e57: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Two terms in a row␤at <tmp>:1␤------> 3 Capture { die "no cookie" } }; dd \( 427⏏5 0␤    expecting any of:␤        infix␤        infix stopper␤        statement end␤        statement mo…»
m: use MONKEY; augment class Int { method Capture { die "no cookie" } }; dd \( 42 )
rakudo-moar bd9e57: OUTPUT: «\(42)␤»
m: use MONKEY; augment class Int { method Capture { die "no cookie" } }; dd \42
rakudo-moar bd9e57: OUTPUT: «Potential difficulties:␤    To refer to a positional match capture, just use $0 (numbering starts at 0).␤    Parenthesize as \(...) if you intended a capture of a single numeric value.␤    at <tmp>:1␤    ------> 3thod Capture { die "no cookie" }…»
m: use MONKEY; augment class Int { method Capture { die "no cookie" } }; dd \( 42 )
rakudo-moar bd9e57: OUTPUT: «\(42)␤»
rakudo-moar bd9e57: OUTPUT: «\("foo")␤"bar"␤»
m: class Foo { method Capture { die "meow " } }; dd \Foo.new
rakudo-moar bd9e57: OUTPUT: «\(Foo)␤»
m: class Foo { method Capture { die "meow " } }; dd \(Foo.new)
rakudo-moar bd9e57: OUTPUT: «\(Foo.new)␤»
m: class Foo { method Capture { die "meow " } }; dd \(Foo.new, 42)
rakudo-moar bd9e57: OUTPUT: «\(Foo.new, 42)␤»
m: class Foo { method Capture { die "meow " } }; dd \(Foo.new.Capture)
rakudo-moar bd9e57: OUTPUT: «meow ␤  in method Capture at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»
m: class Foo { method Capture { die "meow " } }; dd Foo.new.Capture
rakudo-moar bd9e57: OUTPUT: «meow ␤  in method Capture at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»
m: PROCESS::<$HOME2>
rakudo-moar bd9e57: ( no output )
m: PROCESS::<$HOME2> = $HOME2; dd $*HOME2
rakudo-moar bd9e57: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Variable '$HOME2' is not declared␤at <tmp>:1␤------> 3PROCESS::<$HOME2> = 7⏏5$HOME2; dd $*HOME2␤»
m: my $HOME2 = 42; PROCESS::<$HOME2> = $HOME2; dd $*HOME2
rakudo-moar bd9e57: OUTPUT: «Int <element> = 42␤»
m: my $HOME2 = Nil; PROCESS::<$HOME2> = $HOME2; dd $*HOME2
rakudo-moar bd9e57: OUTPUT: «Any <element> = Any␤»
m: my $HOME2 = Nil; PROCESS::<$HOME2> := $HOME2; dd $*HOME2
rakudo-moar bd9e57: OUTPUT: «Any $HOME2 = Any␤»
m: my $HOME2 is default(Nil) = Nil; PROCESS::<$HOME2> := $HOME2; dd $*HOME2
rakudo-moar bd9e57: OUTPUT: «Nil $HOME2 = Nil␤»
m: my $HOME2 is default(Nil) = Nil; PROCESS::<$HOME2> = $HOME2; dd $*HOME2
rakudo-moar bd9e57: OUTPUT: «Any <element> = Any␤»
m: my $HOME2 is default(Nil) = Nil; PROCESS::<$HOME2> := $HOME2; dd $*HOME2
rakudo-moar bd9e57: OUTPUT: «Nil $HOME2 = Nil␤»
m: my $HOME2 is default(Nil) = Nil; PROCESS::<$HOME2> := $HOME2; dd $*HOME2; $*HOME2 = 42
rakudo-moar bd9e57: OUTPUT: «Nil $HOME2 = Nil␤»
m: my $HOME2 is default(Nil) = Nil; PROCESS::<$HOME2> := $HOME2; dd $*HOME2; $*HOME2 = 42; dd $*HOME2
rakudo-moar bd9e57: OUTPUT: «Nil $HOME2 = Nil␤Int $HOME2 = 42␤»
m: my $HOME2 is default(Nil) = Nil; PROCESS::<$HOME2> := $HOME2; dd $*HOME2; $*HOME2 = 42; dd $*HOME2; $*HOME2 = Nil; dd $*HOME2
rakudo-moar bd9e57: OUTPUT: «Nil $HOME2 = Nil␤Int $HOME2 = 42␤Nil $HOME2 = Nil␤»
m: my $HOME2 is default(Nil); PROCESS::<$HOME2> := $HOME2; dd $*HOME2; $*HOME2 = 42; dd $*HOME2; $*HOME2 = Nil; dd $*HOME2
rakudo-moar bd9e57: OUTPUT: «Nil $HOME2 = Nil␤Int $HOME2 = 42␤Nil $HOME2 = Nil␤»
m: my $HOME2 is default(Nil); PROCESS::<$HOME2> := $HOME2 && IO::Path($HOME2); dd $*HOME2; $*HOME2 = 42; dd $*HOME2; $*HOME2 = Nil; dd $*HOME2
rakudo-moar bd9e57: OUTPUT: «Nil $HOME2 = Nil␤Int $HOME2 = 42␤Nil $HOME2 = Nil␤»
m: my $HOME2 is default(Nil) = 42; PROCESS::<$HOME2> := $HOME2 && IO::Path($HOME2); dd $*HOME2; $*HOME2 = 42; dd $*HOME2; $*HOME2 = Nil; dd $*HOME2
rakudo-moar bd9e57: OUTPUT: «Cannot find method 'IO::Path' on object of type Int␤  in block <unit> at <tmp> line 1␤␤»
m: my $HOME2 is default(Nil) = 42; PROCESS::<$HOME2> := $HOME2 && IO::Path.new($HOME2); dd $*HOME2; $*HOME2 = 42; dd $*HOME2; $*HOME2 = Nil; dd $*HOME2
rakudo-moar bd9e57: OUTPUT: «IO::Path is disallowed in restricted setting␤  in sub restricted at src/RESTRICTED.setting line 1␤  in method new at src/RESTRICTED.setting line 32␤  in block <unit> at <tmp> line 1␤␤»
m: my $HOME2 is default(Nil) = 42; PROCESS::<$HOME2> := $HOME2 && IntStr.new($HOME2); dd $*HOME2; $*HOME2 = 42; dd $*HOME2; $*HOME2 = Nil; dd $*HOME2
rakudo-moar bd9e57: OUTPUT: «Too few positionals passed; expected 3 arguments but got 2␤  in block <unit> at <tmp> line 1␤␤»
m: my $HOME2 is default(Nil) = 42; PROCESS::<$HOME2> := $HOME2 && IntStr.new($HOME2, 'z'); dd $*HOME2; $*HOME2 = 42; dd $*HOME2; $*HOME2 = Nil; dd $*HOME2
rakudo-moar bd9e57: OUTPUT: «IntStr.new(42, "z")␤Cannot modify an immutable IntStr␤  in block <unit> at <tmp> line 1␤␤»
hurm. it's magical somewhere, trying to remember if there was a p6 context.
fudge maybe?
m: my $HOME2 is default(Nil) = 42; PROCESS::<$HOME2> := $HOME2 && IntStr.new($HOME2, 'z'); dd $*HOME2; $*HOME2 = 42; dd $*HOME2; $*HOME2 = Nil; dd $*HOME2
rakudo-moar bd9e57: OUTPUT: «IntStr.new(42, "z")␤Cannot modify an immutable IntStr␤  in block <unit> at <tmp> line 1␤␤»
m: my $HOME2 is default(Nil) = 42; PROCESS::<$HOME2> := $HOME2 && $HOME2 = IntStr.new($HOME2, 'z'); dd $*HOME2; $*HOME2 = 42; dd $*HOME2; $*HOME2 = Nil; dd $*HOME2
rakudo-moar bd9e57: OUTPUT: «IntStr $HOME2 = IntStr.new(42, "z")␤Int $HOME2 = 42␤Nil $HOME2 = Nil␤»
m: my $HOME2 is default(Nil); PROCESS::<$HOME2> := $HOME2 && $HOME2 = IntStr.new($HOME2, 'z'); dd $*HOME2; $*HOME2 = 42; dd $*HOME2; $*HOME2 = Nil; dd $*HOME2
rakudo-moar bd9e57: OUTPUT: «Type check failed in binding to parameter '$i'; expected Int but got Nil (Nil)␤  in block <unit> at <tmp> line 1␤␤»
m: my $foo; my $bar := $foo && $foo = 42; dd $bar
rakudo-moar bd9e57: OUTPUT: «Int $foo = 42␤»
m: my $foo; my $bar := $foo && ($foo = 42); dd $bar
rakudo-moar bd9e57: OUTPUT: «Any $foo = Any␤»
m: my $foo = 70; my $bar := $foo && ($foo = 42); dd $bar
rakudo-moar bd9e57: OUTPUT: «Int $foo = 42␤»
m: my $foo = 70; $foo && ($foo = 42); dd $foo
rakudo-moar bd9e57: OUTPUT: «Int $foo = 42␤»
m: my $foo = 70; $foo && $foo = 42; dd $foo
rakudo-moar bd9e57: OUTPUT: «Int $foo = 42␤»
m: my $foo; $foo && $foo = 42; dd $foo
rakudo-moar bd9e57: OUTPUT: «Int $foo = 42␤»
m: my $foo; $foo and $foo = 42; dd $foo
rakudo-moar bd9e57: OUTPUT: «Any $foo = Any␤»
m: my $foo = 70; $foo and $foo = 42; dd $foo
rakudo-moar bd9e57: OUTPUT: «Int $foo = 42␤»
m: my $foo = 1; $foo && $foo = 42; say $foo
rakudo-moar bd9e57: OUTPUT: «42␤»
m: my $foo = 0; $foo && $foo = 42; say $foo
rakudo-moar bd9e57: OUTPUT: «42␤»
:)
m: my $foo = 0; $foo and $foo = 42; say $foo
rakudo-moar bd9e57: OUTPUT: «0␤»
m: my $foo = 1; $foo and $foo = 42; say $foo
rakudo-moar bd9e57: OUTPUT: «42␤»
`and` has the correct one for that, though :)
win 2
Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=130456
c: 2017.04.3 $*HOME = 42
bisect: $*HOME = 42
right??
m: Nil.add('.perl6/rakudo-history')
rakudo-moar d22303: ( no output )
m: dd Nil.add('.perl6/rakudo-history')
rakudo-moar d22303: OUTPUT: «Nil␤»
m: dd Nil.add('.perl6/rakudo-history').parent
rakudo-moar d22303: OUTPUT: «Nil␤»
rakudo-moar d22303: OUTPUT: «IO::Path is disallowed in restricted setting␤  in sub restricted at src/RESTRICTED.setting line 1␤  in method FALLBACK at src/RESTRICTED.setting line 31␤  in block <unit> at <tmp> line 1␤␤»
m: Int.abs
rakudo-moar d22303: OUTPUT: «Invocant requires an instance of type Int, but a type object was passed.  Did you forget a .new?␤  in block <unit> at <tmp> line 1␤␤»
rakudo-moar d22303: OUTPUT: «No such method 'absd' for invocant of type 'Int'␤  in block <unit> at <tmp> line 1␤␤»
rakudo-moar d22303: OUTPUT: «Invocant requires an instance of type Int, but a type object was passed.  Did you forget a .new?␤  in block <unit> at <tmp> line 1␤␤»
m: $*TMPDIR = 42
rakudo-moar 3c7cd9: ( no output )
perhaps someone should say "'file'.IO.words.Bag' to https://www.reddit.com/r/perl/comments/67vlf1/i_have_csv_file_and_want_to_count_words/
Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=118555
what can one do with, or what info can be obtained from, a lexpad?
test 74
can't reproduce
.tell buggable lizmat │ Zoffix: fwiw, I'bve just had a flapper in t/spec/S32-io/indir.t
Zoffix: I'll pass your message to buggable.
.tell buggable lizmat │ test 74
Zoffix: I'll pass your message to buggable.
huh?
jdv79_??
git Fu question: I want to reapply commit 1534652765, what do I do ?
idk.  i saw someone said something to me but lost it
cherry-pick maybe?
yeah, looks like
https://travis-ci.org/rakudo/rakudo/builds/226447653 https://github.com/rakudo/rakudo/compare/7412184fcdfb...d22303d01920
hey, travis is back
hah
MasterDuke_, it came back yesterday, to non freenode places at least
or 2 days ago when i added an irc field
so was suprised it actually worked, since it was broken here. hopefully it's fixed on freenode now. wonder if freenode blocked it for joining channels and spamming messnages all day long!
jnthn: in bind_one_param in BOOTSTRAP.nqp, would it be possible to find out the method bind_one_param is binding for from its $lexpad argument?
I think there's a nqp::ctxcode or so
Which you can use nqp::getcodeobj on
cool, i'll experiment with them
should `try { }<\n>|| something-else()` short-circuit without having to unspace like `try { }\<\n>|| something-else()`? https://gist.github.com/ugexe/47c6369bead8707a1aa158be78939bd2
Yes. The syntax rule is that a } at the end of a line (or only whitespce after it on the line) terminates the statement
So the next line will be a new statement
And the || will be interpreted as a prefix
m: try { }; || something-else()
rakudo-moar 3b2470: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Undeclared routine:␤    something-else used at line 1␤␤»
As there
I see... I was thinking like I do with map/grep, and now that you mention it those instances are using ({ }), not { }
`No such method 'e' for invocant of type 'Distribution::Resource'` when doing %?RESOURCES<...>.e - wonder if there is a better way to delegate all that IO stuff in Distribution::Resources so nothing is missed
afk&
(off to see some more Guardians Of The Galaxy)
can't ever win!
m: Int.abs
rakudo-moar aa23a9: OUTPUT: «Invocant requires an instance of type Int, but a type object was passed.  Did you forget a .new?␤  in block <unit> at <tmp> line 1␤␤»
Zoffix: locally i have that saying `Invocant requires an instance of type Int when method 'abs' is called on it, but a type object was passed.  Did you forget a .new?`
that wording is awkward, but the functionality is there
anybody have suggestions for a better worded message?
should we also be giving info about the type the method is declared on and the type object that  was actually passed?
or Invocant for $method requires...
because what if the type object you're passing is derived from the one you were supposed to pass
but that'd not be an actual problem
'Invocant' can also be 'Parameter $varname'
so the wording need to take that into account
or those two options changed also
samcv: what's the status of your unicode grant?
approved :)
yesterday
more than willing to help you with anything you need now/during the grant as well. since i had hoped the script i'm making could also do stuff for other backends as well
samcv: thanks, I'll look into the UCD module tommorow
I use the ModernPerl highlighter and yeah its still broken, but not for anything i ever reach for so it hasnt bothered me yet
another question about bind_one_param, can i tell if it's being called for a sub vs method?
This is Rakudo version 2017.04.3-71-gaa23a91fb built on MoarVM version 2017.04-44-gf0db8822
csv-ip5xs        3.101
test            13.365
test-t           5.121 - 5.425
csv-parser      14.323
timotimo: I'm probably biased, but to me the "Distro packages" link makes it look like nxadm's scripts are the only way to get at distro packages, when there are up to date packages for at least Debian and openSUSE.
nine: good point, i threw it out
huggable, optimizer debug
Zoffix: I'll pass your message to MasterDuke_.
m: try die "foo"; say $!
rakudo-moar 8928fb: OUTPUT: «foo␤  in block <unit> at <tmp> line 1␤␤»
m: try die "foo"; say $!.backtrace
rakudo-moar 8928fb: OUTPUT: «Backtrace.new␤»
m: try die "foo"; say $!.backtrace.gist
rakudo-moar 8928fb: OUTPUT: «Backtrace.new␤»
m: try die "foo"; say $!.backtrace.Str
rakudo-moar 8928fb: OUTPUT: «  in block <unit> at <tmp> line 1␤␤»
m: try die "foo"; say $!.full-backtrace.Str
rakudo-moar 8928fb: OUTPUT: «No such method 'full-backtrace' for invocant of type 'X::AdHoc'␤  in block <unit> at <tmp> line 1␤␤»
m: try die "foo"; say $!.^methods
rakudo-moar 8928fb: OUTPUT: «(message Numeric from-slurpy payload backtrace throw resume die is-compile-time gist Str reset-backtrace vault-backtrace rethrow resumable fail)␤»
:-(
Zoffix: I'll pass your message to MasterDuke_.
Zoffix: I'll pass your message to AlexDaniel.
Zoffix: I'll pass your message to AlexDaniel.
Zoffix: i'm working on a hack to let you do that :)
are you in the whateverable channel, zoffix?
please come over for a little bit
Zoffix: I'll pass your message to AlexDaniel.
i've shut it down again, but iirc you also have access to the server it runs on?
Bisectable-but-not-restricted.p6
YW
argh, copypasto in last line  :-(
lizmat^^
timotimo??
sometimes I wish we could create a commit to fix a commit message
well, you can forcepush :)
we should make something like gmail's "unsend" feature
i.e. it'll pretend you have already sent
but it only actually sends a minute later
so you get the sensation of "oh shit! i just sent something wrong!" with the pleasure of "phew, i could fix it before things went to hell"
lizmat: Maybe try to get used to doing "git show" before "git push" :)
No, please don't look the cat in!
that phone looks positively ancient :D
i'm just trying out plasma, and it's giving me a very wtf thing where i can use alt-1/2/3/4/5/6/7/9/0 to switch to weechat windows
but alt-8 does nothing at all
alt-8 would get me to this channel... this is a very important channel :|
ACTION yawns.
ACTION looks at an interesting set of molars
going to PR this soon, but it does break some tests in t/spec/S32-exceptions/misc.t and t/spec/S06-signature/types.t that are looking for specific words in a specific sequence
it might be possible to add the info i did without breaking the tests, but i reworded the message to something i think is a little better
but i wouldn't say the reworded message is nobel-literature-prize worthy, so don't mind changing if people don't like what i've done
any exception code that's looking for a specific message and not a type should be changable in 6.c-errata
Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=130456
m: my %h = a => "b"; dd %h.Bag   # a bit of a WAT to me
rakudo-moar 1b0e41: OUTPUT: «Type check failed in assignment; expected Int but got Str ("b")␤  in block <unit> at <tmp> line 1␤␤»
m: my %h = a => 42; dd %h.Bag   # a bit of a WAT to me
rakudo-moar 1b0e41: OUTPUT: «("a"=>42).Bag␤»
Hm, how so?
Possibly the error in the first case could be improved
jnthn: I sorta expected Set semantics when coercing to a Bag
so ignoring the value, as it does with the other set operators, set to 1
m: my %b is BagHash; %b<a> = 42; dd %b
rakudo-moar 1b0e41: OUTPUT: «("a"=>42).BagHash␤»
That's why I'm not surprised by (and would expect) the current behavior, fwiw
Can always say %h.keys.Bag to get the other thing
yeah, it was just a bit of a WAT to me
this concludes the (+) optimizations for now
lizmat: Nice set of speedups on those :)
yeah, there's room for more improvement, especially for immutables, but this will do for now  :-)
m: say v1.1 ~~ v1.*.2; # expected?
rakudo-moar 6de089: OUTPUT: «True␤»
not sure what to expect when the Whatever is not the last item
re my PR and tests for messages, i think there are a couple options:
1) change the texts and/or order of words the current tests check for
2) change the current tests to just check that they throw and add some message tests in rakudo's t/05-messages/01-errors.t
3) try to convert to typed Exceptions and change the current tests to check for those and add some message tests in rakudo's t/05-messages/01-errors.t
seems like currently a Whatever automatically adds a `+` to the end, so 1.*.2 -> 1.0.2+ which ACCEPTS v1.1
these are the failing tests: https://github.com/perl6/roast/blob/master/S06-signature/types.t#L40-L48 and https://github.com/perl6/roast/blob/master/S32-exceptions/misc.t#L795-L798
rakudo-moar ba3cf4: OUTPUT: «X::Multi::NoMatch␤»
rakudo-moar ba3cf4: OUTPUT: «X::AdHoc␤»
rakudo-moar 9cb26c: OUTPUT: «((3 4) (1 2))␤»
rakudo-moar 9cb26c: OUTPUT: «(Seq.new-consumed(), Seq.new-consumed()).Seq␤»
s: ((1, 2).Seq, (3, 4).Seq), 'sort', \({$^b[0] <=> $^a[0]})
s: ((1, 2).Seq, (3, 4).Seq).sort({$^b[0] <=> $^a[0]})[0], 'perl', \()
rakudo-moar 9cb26c: OUTPUT: «(Seq.new-consumed(), Seq.new-consumed())␤»
m: ((1, 2).Seq, (3, 4).Seq).sort({$^b[0] <=> $^a[0]})».cache.perl.say
rakudo-moar 9cb26c: OUTPUT: «This Seq has already been iterated, and its values consumed␤(you might solve this by adding .cache on usages of the Seq, or␤by assigning the Seq into an array)␤  in block <unit> at <tmp> line 1␤␤»
m: ((1, 2).Seq, (3, 4).Seq).sort({$^b[0] <=> $^a[0]}).cache».cache.perl.say
rakudo-moar 9cb26c: OUTPUT: «This Seq has already been iterated, and its values consumed␤(you might solve this by adding .cache on usages of the Seq, or␤by assigning the Seq into an array)␤  in block <unit> at <tmp> line 1␤␤»
s: (1,).Seq, 'cache', \()
m: ((1, 2).Seq, (3, 4).Seq).sort({$^b[0] <=> $^a[0]})[0].perl.say
rakudo-moar 9cb26c: OUTPUT: «Seq.new-consumed()␤»
m: use nqp; my $s = ((1, 2).Seq, (3, 4).Seq).sort({$^b[0] <=> $^a[0]})[0]; say $s
rakudo-moar 9cb26c: OUTPUT: «(3 4)␤»
m: use nqp; my $s = ((1, 2).Seq, (3, 4).Seq).sort({$^b[0] <=> $^a[0]})[0]; say $s.perl
rakudo-moar 9cb26c: OUTPUT: «Seq.new-consumed()␤»
m: use nqp; my $s := ((1, 2).Seq, (3, 4).Seq).sort({$^b[0] <=> $^a[0]})[0]; dd nqp::getattr($s, Seq, '$!iter')
rakudo-moar 9cb26c: OUTPUT: «Method 'pull-one' must be implemented by Iterator because it is required by roles: Iterator.␤  in block <unit> at <tmp> line 1␤␤»
m: use nqp; my $s := ((1, 2).Seq, (3, 4).Seq).sort({$^b[0] <=> $^a[0]})[0]; dd nqp::getattr($s, Seq, '$!iter').DEFINITE
rakudo-moar 9cb26c: OUTPUT: «Bool::False␤»
m: use nqp; my $s := ((1, 2).Seq, (3, 4).Seq).sort({$^b[0] <=> $^a[0]})[0]; dd nqp::getattr($s, Seq, '$!list').DEFINITE
rakudo-moar 9cb26c: OUTPUT: «Bool::True␤»
rakudo-moar 9cb26c: OUTPUT: «Bool::False␤»
m: use nqp; my $s := ((1, 2).Seq, (3, 4).Seq)[0]; dd nqp::getattr($s, Seq, '$!list').DEFINITE
rakudo-moar 9cb26c: OUTPUT: «Bool::False␤»
m: use nqp; my $s := ((1, 2).Seq, (3, 4).Seq)[0]; dd nqp::getattr($s, Seq, '$!iter').DEFINITE
rakudo-moar 9cb26c: OUTPUT: «Bool::True␤»
m: use nqp; my $s := ((1, 2).Seq, (3, 4).Seq)[0]; dd $s
rakudo-moar 9cb26c: OUTPUT: «(1, 2).Seq␤»
m: use nqp; my $s := ((1, 2).Seq, (3, 4).Seq).sort({ $^b[0] <=> $^a[0] })[0]; dd $s
rakudo-moar 9cb26c: OUTPUT: «This Seq has already been iterated, and its values consumed␤(you might solve this by adding .cache on usages of the Seq, or␤by assigning the Seq into an array)␤  in block <unit> at <tmp> line 1␤␤»
m: use nqp; my $s := ((1, 2).Seq, (3, 4).Seq).sort({ $^b[0] <=> $^a[0] })[0]; dd $s.cache
rakudo-moar 9cb26c: OUTPUT: «(3, 4)␤»
m: use nqp; my $s := ((1, 2).Seq, (3, 4).Seq).sort(-> @a, @b { @b[0] <=> @a[0] })[0]; dd $s.cache
rakudo-moar 9cb26c: OUTPUT: «(3, 4)␤»
m: use nqp; my $s := ((1, 2).Seq, (3, 4).Seq).sort(-> @a, @b { @b[0] <=> @a[0] })[0]; dd $s
rakudo-moar 9cb26c: OUTPUT: «This Seq has already been iterated, and its values consumed␤(you might solve this by adding .cache on usages of the Seq, or␤by assigning the Seq into an array)␤  in block <unit> at <tmp> line 1␤␤»
yummy, yummy!
that's my stash for the rainy day! Stay out of it!
Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=131222
Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=131222
Zoffix: Happy to.  Buggable doesn't appear to be in whateverable ... where is it?
Zoffix: Yes, if the data was normally distributed.  But it's not.  We're just (ab)using the calculation to find outliers.
Zoffix: Ah, good thinking
that is not where i expected that bug to be there
m: class A { ... }; method A::foo() { "foo" }; class A { }; dd A.foo   # bug or case of DIHWIDT ?
rakudo-moar 54f509: OUTPUT: «Potential difficulties:␤    Useless declaration of a has-scoped method in mainline (did you mean 'my method A::foo'?)␤    at <tmp>:1␤    ------> 3class A { ... }; method7⏏5 A::foo() { "foo" }; class A { }; dd A.f␤No such method 'foo' for in…»
m: class A { ... }; my method A::foo() { "foo" }; class A { }; dd A.foo   # no warning
rakudo-moar 54f509: OUTPUT: «No such method 'foo' for invocant of type 'A'␤  in block <unit> at <tmp> line 1␤␤»
m: class A { ... }; my method A::foo() { "foo" }; class A { }; dd A.foo   # no warning
rakudo-moar 54f509: OUTPUT: «No such method 'foo' for invocant of type 'A'␤  in block <unit> at <tmp> line 1␤␤»
m: class A { ... }; our method A::foo() { "foo" }; class A { }; dd A.foo   # our doesn't help either
rakudo-moar 54f509: OUTPUT: «No such method 'foo' for invocant of type 'A'␤  in block <unit> at <tmp> line 1␤␤»
ACTION votes for DIHWIDT; if someone is trying to emulate perl 5 behavior, that's because perl 5 "OO" was a hack using package scoped subs as methods
and yes, it'd be weird and bad if defining a package-scope sub did an "augment", especially without a MONKEY
Indeed. In Perl 6, method dispatch doesn't look at the contents of packages or lexpads, only in the meta-object
my blah A::foo means the A is lexically visible
The foo will be our-scoped within A because there's nothing else it could be :)
jnthn: note this was a method
That's irrelevant.
anyways, DIHWIDT it is  :-)
maybe it shouldn't be silent, though  :-)
Once you stick a my or our on the thing, it's just a Method code object that's getting put into the lexpad or package
Which is OK if you wanted to do it, but isn't a way to get something into the method dispatch table that the .foo calling syntax will care about.
I'd count it as "unusual to want to do, but an unusual thing to do by accident" :)
Well, I guess depending where you're coming from :)
again, it makes sense as a p5-ism
oh, so this gives you the env at precompilation time?
well, currently at core setting build time
oh, "for the core setting"
i didn't read that
timotimo: yeah, we would need to stick it in the package of a precomped module before writing to disk  :-)
fortunately we can easily serialize hashes now
yes, exactly  :-)
http://pl6anet.org/drop/rakudo-star-2017.04-RC1.tar.gz
anybody have a suggestion for what typed Exception(s) to use for my PR?
X::No
heh. i'll do the easy part of adding them, but am hoping to shift the blame for naming them
good idea
do we have a quick way of resetting an nqp::hash (aka deleting all the keys) ?
rakudo-moar d3e8c8: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Variable definition of type Str:D requires an initializer␤at <tmp>:1␤------> 3class { has Str:D $.foo 7⏏5}.new␤»
::InvalidConcreteness ?
nqp::isconcrete is in the if there
"concrete" is in the rakudo source some
"instantiatedness" is not better :)
also, aside from typed exceptions, what about my modifications to the language in the message? any comments/suggestions?
m: for ((1, 2).Seq, (3, 4).Seq) -> ($k,$v) { ($k,$v).say; }
rakudo-moar 1562da: OUTPUT: «Too few positionals passed; expected 2 arguments but got 0 in sub-signature␤  in block <unit> at <tmp> line 1␤␤»
m: for ((1, 2).Seq, (3, 4).Seq) -> ($k,$v) { }
rakudo-moar 1562da: OUTPUT: «Too few positionals passed; expected 2 arguments but got 0 in sub-signature␤  in block <unit> at <tmp> line 1␤␤»
m: for ((1, 2), (3, 4)) -> ($k,$v) { }
rakudo-moar 1562da: ( no output )
m: for ((1, 2).Seq, (3, 4).Seq) -> ($k,$v) { }
rakudo-moar 1562da: OUTPUT: «Too few positionals passed; expected 2 arguments but got 0 in sub-signature␤  in block <unit> at <tmp> line 1␤␤»
m: for ((1, 2), (3, 4)) -> ($k,$v) { }
rakudo-moar 1562da: ( no output )
s: (1, 2), 'Capture', \()
s: (1, 2).Seq, 'Capture', \()
rakudo-moar 1562da: OUTPUT: «"42"␤»
(in general, when adding exceptions, use more generic exception types and add the deets in the message)
[Coke]: there's a continuum though, since what i'm replacing is in fact the most generic exception with all the details in the message
Sure, of course.
unfortunately, the list of exceptions was grown organically, I suspect we'll have to be more rigorous in .d, and .e
yep. i'm currently working on X::InvalidConcreteness, but am still open to suggestions
and invocant
sure, technically, but do most people think of it as one?
or are you suggesting X::Param::InvalidConcreteness?
that's an easy change
m: dd (1, 2, 3).Capture
rakudo-moar 1562da: OUTPUT: «\(1, 2, 3)␤»
m: dd (1, 2, 3).Seq.Capture
rakudo-moar 1562da: OUTPUT: «\()␤»
yes, indeed :|
wonder if it gets deleted when you throw out the reference from the text box
yeah
a userscript could be made
Zoffix: Finally popped enough $work off my stack to send you a Buggable PR
what, autounfudge?
oh
i'm not sure i know about that
Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=131222
m: dd <a b c d>.Hash.Capture
rakudo-moar 1562da: OUTPUT: «\(:a("b"), :c("d"))␤»
m: dd <a b c d>.Hash.Set.Capture
rakudo-moar 1562da: OUTPUT: «\()␤»
m: dd <a b c d>.Hash.Set.Hash.Capture
rakudo-moar 1562da: OUTPUT: «\(:a, :c)␤»
m: dd <a b c d>.Hash.Set
rakudo-moar 1562da: OUTPUT: «set("a","c")␤»
m: dd <a b c d>.Set
rakudo-moar 1562da: OUTPUT: «set("d","b","a","c")␤»
m: dd <a b c d>.Set.Hash.Capture
rakudo-moar 1562da: OUTPUT: «\(:a, :b, :c, :d)␤»
m: dd <a b c d>.Bag.Hash.Capture
rakudo-moar 1562da: OUTPUT: «\(:a(1), :b(1), :c(1), :d(1))␤»
m: dd <a a b c>.Bag.Hash.Capture
rakudo-moar 1562da: OUTPUT: «\(:a(2), :b(1), :c(1))␤»
s: class {}, 'Hash', \()
good night, #perl6-dev!
night lizmat
o/
Night, lizmat!
also guys. should `author` be an allowed key in META6.json. it's not in the spec
`authors` is which is a list. but many commonly use `author` instead. should we change the spec or bring modules into compliance with the spec
which one
ask an OR question and get yes as the response :P
I had and maybe still have modules with "author" instead of "authors"
imo i think we shouldn't have redundant fields
you have many jnthn :)
And tbh I really can't be bothered with fixing that. :P
author is required for backcompat
is it?
with older rakudo?
most modules only have "authors"
its not, but we still made sure we didn't break any existing modules that are installed when we did the s22/distribution PRs
What is used to determine the auth?
the old Distribution defined `auth` as $!auth // $!author // $!authority
ok. but the question is. should 'author' be in the spec? or be not specced
and the people be told to use 'authors' instead
that's the question. i'm not saying to remove support for it from anything that allows it to exist
that's a different issue from what the standard should be imo
right
yeah
that's much easier
i use 'owner' in my stuff... originally i considered auth to be `$owner + $content_storage` (which aren't specced in s22 but mentioend)
but really auth should just be its own thing, so no real need for owner/author i suppose
owner is kind of vague. own what? copyright? the repo? idk.
but 'creator' would be ok for me instead of 'author'
errr i mean
you owned the urn
I'd presumed the author I was filling out in META6.json was the auth :)
creator instead of owner
owner:service
ugexe:github
Right, which is why there's probably two separate things needed here
heh
authors which is just a list of people who contributed for...whatever purpose :)
auth = authorization right?
authority
samcv: It's deliberately ambiguous between author and authority
agree, "auth" is immutable for a distribution, "authors" isn't
yeah that
really sleep&
authority and authorization are the same uh. thingy
authority authorizes etc.
authorization does not take place
it could i guess
but thats something for the recommendation managers / content storages to handle
well in the future..
yeah
check the auth is the same as where it got it from
no
no?
auth has no relation to where it comes from
coincidently it almost always is, but thats not its purpose
so it's not meant to have any verification?
no, a recommendation manager / content storage could build in verification for uploads though
yes
for sure
but if i have Foo::Bar:ver<1>:auth<XXX> and upload that to the ecosystem, cpan, and SomeOtherService it should retain its identity across them
i agree
fwiw I don't think authors even got saved pre 2017.07 or so (before s22 PR)
(when being installed)
er 2016.07
that was complying with panda spec
https://github.com/rakudo/rakudo/pull/729
Zoffix: Thought you might like that.  :-)
like what? what did i miss? :(
oh, it has little arrows now?
timotimo: The new code handles outliers better, so one large value doesn't cause the rest of the range to get all compressed.
cool!
The arrows indicate outlying values in the arrow direction.  :-)
fant4stic
this has been a very broken-up coding session, how bad is this code? https://gist.github.com/MasterDuke17/ff7043a44b5fa6921b87136ca0d7cbbe
oh, you have nothing for the case where a parameter might be anonymous
think it should be handled in the exception?
do you think we can get the index of the parameter?
so it could either be a string with the name or an int with the index?
and based on the type it'd say "anonymous parameter number $foo" or "parameter '$param'"
not sure if it'd help a lot
also, anything about subsignatures?
what about them?
maybe it'd be a good idea to split param vs invocant
well, it could point out that it's not the parameter of the routine directly but from a subsignature
i think i'll go to bed now
have a good one!
split them more than this? `my $beginning  = $!param-is-invocant  ?? 'Invocant of method' !! "Parameter '$!param' of routine";`
yeah
have others weigh in on this before accepting my suggestion please :)
heh, sure. later...
This is Rakudo version 2017.04.3-95-g5e74017d6 built on MoarVM version 2017.04-44-gf0db8822
csv-ip5xs        3.110
test            13.319
test-t           5.209 - 5.275
csv-parser      13.083
Files=1192, Tests=56861, 210 wallclock secs (12.21 usr  4.84 sys + 1222.40 cusr 120.80 csys = 1360.25 CPU)
is MVM_num_neginf(tc) different from -1 * MVM_neg_inf(tc) on some platform?
* MVM_neg_posinf
m: use Test; is (42 but role { has int $.x = 100 }).x, 100
rakudo-moar 9c9ebd: OUTPUT: «Invalid BUILD_LEAST_DERIVED plan␤  in block <unit> at <tmp> line 1␤␤»
jnthn: is the str type fully specced? it's only mentioned a few times in roast and not documented
pmurias: Yeah. We have to have *some* name for the thing inside of a Str (which is a P6opaque)
So str is that
It's not particularly widely known about/used, which is probably for the best :)
But we need it inside of CORE.setting, and some string-intensive code can - for the moment at least - get some performance wins by avoiding boxing overhead.
(In the future we should get better at optimizing away boxing in many cases.)
(Though even then there will still be cases where it can be a win.)
Funny you mention it 'cus I'm about to push another spectest that mentions it :-)
I'm working on the str to num MoarVM level conversion
jnthn: is it ok if I put it into src/strings/parse_num.c (it consists of a bunch of static functions and I don't want to clutter the coerce file)
pmurias: Seems reasonable
Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=131181
jnthn: do we have a codepoint/grapheme number that can't occur in a string?
m: say (2,(3,5)).Set
rakudo-moar 6179ab: OUTPUT: «set(5, 3, 2)␤»
is the above correct behaviour?
dogbert17: fwiw, I have wondered that myself, but spectest breakage occurs if it doesn't flatten
m: say (2,$(3,5)).Set
rakudo-moar 6179ab: OUTPUT: «set((3 5), 2)␤»
m: say (2,(3,5)).Bag
rakudo-moar 6179ab: OUTPUT: «bag(5, 3, 2)␤»
yeah, the behaviour is consistent  :-)
but not with arrays:
m: my @a = (2,(3,5)); dd @a
rakudo-moar 6179ab: OUTPUT: «Array @a = [2, (3, 5)]␤»
we'll it would seem to be correct then if the flattening bahviour is in roast ...
was looking at RT #130973
Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=130973
perhaps we need to discuss  :-)
to me it was a bit of a WAT as well
:)
specifically because STORE doesn't flatten
and setifying could be considered a way of STORE
I couldn't say which bahaviour is the correct one but at least there should consistency (as you wrote) no?
ACTION grr it's spelt behaviour
some input from jnthn or TimToady would be nice :)
ACTION or would it be preferable to specify what behaviour the user want, e.g. (1,(2,3)).Set(:no-flat)
wouldn't that just be (1,(2,3)).flat.Set?
dunno, suppose you want the result to be 'Set(1, (2,3))
er, i kind of said it backwards
i would have expected Set(1, (2,3)) unless i chose to put the .flat
sounds reasonable
ACTION continues browsing RT looking for some LHF
rakudo-moar 1a920d: OUTPUT: «mix(Broken-Robot, Zoffix, Frameless)␤»
Hi Zoffix
rakudo-moar 1a920d: OUTPUT: «mix(Zoffix, (Frameless Broken-Robot))␤»
ACTION shot down in flames /o\ :)
it means you disagree with RT #130973
Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=130973
rakudo-moar 1a920d: OUTPUT: «Zoffix|Frameless|Broken-Robot␤»
rakudo-moar 1a920d: OUTPUT: «Zoffix|Frameless Broken-Robot␤»
uh oh
yeah, according to lizmat changing the flattening should break some tests
i thought perl 6 got rid of most auto-flattening
rakudo-moar 1a920d: OUTPUT: «mix(Zoffix, (Frameless Broken-Robot))␤»
so it's at least simple to get the non flattening behaviour if that's what you want
buggable, eco
27 Apr 2017 17:05Z <Zoffix> buggable: lizmat │ Zoffix: fwiw, I'bve just had a flapper in t/spec/S32-io/indir.t
27 Apr 2017 17:05Z <Zoffix> buggable: lizmat │ test 74
Zoffix: so what, if anything, will you do with 'join'
that is at least consistent with the docs :)
speaking of consistency...
m: class Bar { subset Positive of Int where * >= 0; has Positive $.y; submethod TWEAK(Positive :$x = 0) { $!y = $x } }; Bar.new(x => 3).perl.say; Bar.new(x => -3).perl.say
rakudo-moar 1a920d: OUTPUT: «Bar.new(y => 3)␤Constraint type check failed in binding to parameter '$x'; expected Bar::Positive but got Int (-3)␤  in submethod TWEAK at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»
m: class Bar { subset Positive of Int where * >= 0; has Positive $.y; submethod BUILD(:$x = 0) { $!y = $x } }; Bar.new(x => -3).perl.say
rakudo-moar 1a920d: OUTPUT: «Type check failed in assignment to $!y; expected Bar::Positive but got Int (-3)␤  in submethod BUILD at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»
i noticed this over in #perl6. see the difference between the two errors? `parameter '$x'` vs `assignment to $!y`
i've noticed this other places as well. should we attempt to have consistency in how things like variable names, sub/method names, etc. are quoted or not in errors?
does that effect https://rt.perl.org/Ticket/Display.html?id=130226 at all?
then you could use Q[...]
and only escape ]
m: say Q[foo\bar\]baz].perl
rakudo-moar 1a920d: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Two terms in a row␤at <tmp>:1␤------> 3say Q[foo\bar\]7⏏5baz].perl␤    expecting any of:␤        infix␤        infix stopper␤        postfix␤        statement end␤        statement mo…»
or not
m: say Q[foo\bar\q(])baz].perl
rakudo-moar 1a920d: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Unexpected closing bracket␤at <tmp>:1␤------> 3say Q[foo\bar\q(]7⏏5)baz].perl␤»
oh, gist!
yes, yes
In theory, yes
Though running out of handles is also reason enough to take care to close things :)
rakudo-moar 6ef2ab: OUTPUT: «closed␤closed␤closed␤»
rakudo-moar 6ef2ab: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Missing block␤at <tmp>:1␤------> 3"closed" } }; for ^3 { my $fh will leave7⏏5 *.close = Foo.new }␤    expecting any of:␤        block or pointy block␤»
once you go block you never go back
m: multi sub trait_mod:<is>(Variable:D $_, :$IO! ) { .block.add_phaser('LEAVE', $v.willdo({ dd $v.close }) ); }; my $v is IO = class { method close { say "closed" } };
rakudo-moar 6ef2ab: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Variable '$v' is not declared␤at <tmp>:1␤------> 3lock.add_phaser('LEAVE', $v.willdo({ dd 7⏏5$v.close }) ); }; my $v is IO = class { ␤»
ohhhh
m: multi sub trait_mod:<is>(Variable:D $v, :$IO! ) { .block.add_phaser('LEAVE', $v.willdo({ dd $v.close }) ); }; my $v is IO = class { method close { say "closed" } };
rakudo-moar 6ef2ab: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤is trait on $-sigil variable not yet implemented. Sorry. ␤at <tmp>:1␤------> 3illdo({ dd $v.close }) ); }; my $v is IO7⏏5 = class { method close { say "closed" }␤    expecting any of:␤       …»
m: multi sub trait_mod:<does>(Variable:D $v, IO ) { .block.add_phaser('LEAVE', $v.willdo({ dd $v.close }) ); }; my $v does IO = class { method close { say "closed" } };
rakudo-moar 6ef2ab: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤No such method 'block' for invocant of type 'Any'␤at <tmp>:1␤»
m: multi sub trait_mod:<does>(Variable:D $v, IO ) { dd $v ); }; my $v does IO = class { method close { say "closed" } };
rakudo-moar 6ef2ab: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤Missing block␤at <tmp>:1␤------> 3_mod:<does>(Variable:D $v, IO ) { dd $v 7⏏5); }; my $v does IO = class { method clo␤    expecting any of:␤        postfix␤        statement end␤        s…»
m: multi sub trait_mod:<does>(Variable:D $v, IO ) { dd $v; }; my $v does IO = class { method close { say "closed" } };
rakudo-moar 6ef2ab: OUTPUT: «Variable $v = Variable.new(name => "\$v", scope => "my", var => Any, block => -> gnatur { #`(Block|62171504) ... }, slash => Perl6::Grammar.new() #`[140366187916096])␤»
m: multi sub trait_mod:<does>(Variable:D $v, IO ) { dd $v.block; }; my $v does IO = class { method close { say "closed" } };
rakudo-moar 6ef2ab: OUTPUT: «-> gnatur { #`(Block|56000176) ... }␤»
m: multi sub trait_mod:<does>(Variable:D $v, IO ) { $v.block.add_phaser: 'LEAVE', $v.willdo({ $v.close }); }; my $v does IO = class { method close { say "closed" } };
rakudo-moar 6ef2ab: OUTPUT: «No such method 'close' for invocant of type 'Variable'␤  in block  at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»
m: multi sub trait_mod:<does>(Variable:D $v, IO ) { $v.block.add_phaser: 'LEAVE', $v.willdo({ dd $v.var }); }; my $v does IO = class { method close { say "closed" } };
rakudo-moar 6ef2ab: OUTPUT: «Any $v = Any␤»
m: multi sub trait_mod:<does>(Variable:D $v, IO ) { $v.block.add_phaser: 'LEAVE', $v.willdo({ dd $v.var }); }; my $v does IO = class Foo { method close { say "closed" } }.new;
rakudo-moar 6ef2ab: OUTPUT: «Any $v = Any␤»
m: multi sub trait_mod:<does>(Variable:D $v, IO ) { $v.block.add_phaser: 'LEAVE', $v.willdo({ dd $v.var }); }; for ^2 { my $v does IO = class Foo { method close { say "closed" } }.new; }
rakudo-moar 6ef2ab: OUTPUT: «Any $v = Any␤Any $v = Any␤»
m: use nqp; multi sub trait_mod:<does>(Variable:D $v, IO ) { $v.block.add_phaser: 'LEAVE', $v.willdo({ dd nqp::atkey(nqp::ctxcaller(nqp::ctxcaller(nqp::ctxcaller(nqp::ctx()))), self.name) }); }; for ^2 { my $v does IO = class Foo { method close { say "closed" } }.new; }
rakudo-moar 6ef2ab: OUTPUT: «5===SORRY!5=== Error while compiling <tmp>␤'self' used where no object is available␤at <tmp>:1␤------> 3:ctxcaller(nqp::ctxcaller(nqp::ctx()))),7⏏5 self.name) }); }; for ^2 { my $v does I␤    expecting any of:␤        term␤»
m: use nqp; multi sub trait_mod:<does>(Variable:D $v, IO ) { $v.block.add_phaser: 'LEAVE', $v.willdo({ dd nqp::atkey(nqp::ctxcaller(nqp::ctxcaller(nqp::ctxcaller(nqp::ctx()))), $v.name) }); }; for ^2 { my $v does IO = class Foo { method close { say "closed" } }.new; }
rakudo-moar 6ef2ab: OUTPUT: «Lexical with name '$v' does not exist in this frame␤  in block  at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»
m: use nqp; multi sub trait_mod:<does>(Variable:D $v, IO ) { $v.block.add_phaser: 'LEAVE', $v.willdo({ dd nqp::atkey(nqp::ctxcaller(nqp::ctxcaller(nqp::ctxcaller(nqp::ctx()))), $v.var.name) }); }; for ^2 { my $v does IO = class Foo { method close { say "closed" } }.new; }
rakudo-moar 6ef2ab: OUTPUT: «No such method 'name' for invocant of type 'Any'␤  in block  at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»
m: use nqp; multi sub trait_mod:<does>(Variable:D $v, IO ) { $v.block.add_phaser: 'LEAVE', $v.willdo({ dd nqp::atkey(nqp::ctxcaller(nqp::ctxcaller(nqp::ctxcaller(nqp::ctx()))), $v.VAR.name) }); }; for ^2 { my $v does IO = class Foo { method close { say "closed" } }.new; }
rakudo-moar 6ef2ab: OUTPUT: «Lexical with name '$v' does not exist in this frame␤  in block  at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»
m: use nqp; multi sub trait_mod:<does>(Variable:D $v, IO ) { $v.block.add_phaser: 'LEAVE', $v.willdo({ dd nqp::atkey(nqp::ctxcaller(nqp::ctxcaller(nqp::ctxcaller(nqp::ctx()))), $v.name) }); }; for ^2 { my $z does IO = class Foo { method close { say "closed" } }.new; }
rakudo-moar 6ef2ab: OUTPUT: «Lexical with name '$z' does not exist in this frame␤  in block  at <tmp> line 1␤  in block <unit> at <tmp> line 1␤␤»
m: use nqp; multi sub trait_mod:<does>(Variable:D $v, IO ) { $v.block.add_phaser: 'LEAVE', $v.willdo({ dd nqp::atkey(nqp::ctxcaller(nqp::ctxcaller(nqp::ctxcaller(nqp::ctxcaller(nqp::ctx())))), $v.name) }); }; for ^2 { my $z does IO = class Foo { method close { say "closed" } }.new; }
rakudo-moar 6ef2ab: OUTPUT: «Foo $z = Foo.new␤Foo $z = Foo.new␤»
m: use nqp; multi sub trait_mod:<does>(Variable:D $v, IO ) { $v.block.add_phaser: 'LEAVE', $v.willdo({ nqp::atkey(nqp::ctxcaller(nqp::ctxcaller(nqp::ctxcaller(nqp::ctxcaller(nqp::ctx())))), $v.name).close }); }; for ^2 { my $z does IO = class Foo { method close { say "closed" } }.new; }
rakudo-moar 6ef2ab: OUTPUT: «closed␤closed␤»
m: use nqp; constant fh = class {}; multi sub trait_mod:<does>(Variable:D $v, fh ) { $v.block.add_phaser: 'LEAVE', $v.willdo({ nqp::atkey(nqp::ctxcaller(nqp::ctxcaller(nqp::ctxcaller(nqp::ctxcaller(nqp::ctx())))), $v.name).close }); }; for ^2 { my $z does fh = class Foo { method close { say "closed" } }.new; }
rakudo-moar 6ef2ab: OUTPUT: «closed␤closed␤»
s: &say, \(class A { method gist { 42 } }.new)
rock it with me \o/ https://www.youtube.com/watch?v=09U69zGLXwE
learn to play an instrument, you bum.
does any of :ratchet, :sigspace, :ignorecase, :ignoremark or :dba allow a number argument?
if none of them allow it, I'll remove this anti-feature
Zoffix: I forgot about :1 and :0 :(
timotimo++ # trisectable XD
Zoffix++ # perseverance :)
AlexDaniel: i'm the master of names :)
Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=130798
Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=130798
Working on in-process precompilation again. Seems like the break was actually helpful, as while trying to find out where I left off, I realized that my issue is not objects leaking into the precompilation, but objects leaking out.
oh, interesting!
This means that when I get an error during precompilation, I just have to try again and it will get further as it can use the already precompiled files.
Intriguingly at least one of the issues may be connected with multis.
Test is: echo 'use B;' > A.pm && echo 'unit class Foo; multi method new() {}' > B.pm && rm -Rf .precomp && perl6 -I. -MA -e ''
If i just remove the "multi" it works fine
It also works if I manually create the proto!
Indeed. When I add the missing protos in NativeCall::Types, I can compile and load all of NativeCall in a single process
That's...intriuging, though I don't immediately have any guesses
Proto auto-generation is implemented in terms of generic instantiation
Though from a pre-comp perspective I'm not immediately seeing why that's not just a comparatively boring bit of meta-programming.
Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=130798
Link:  https://rt.perl.org/rt3/Public/Bug/Display.html?id=130798
Zoffix: I'll pass your message to jnthn.
Zoffix: I'll pass your message to jnthn.
Yes, it's being Iterable that matters
21:51Z <Zoffix> jnthn: is it normal that +a slurpy breaks up hashes into a list of pairs? e.g. -> +a { dd a; dd a.^name; dd a.elems }( %(:42a, :72b, :55z) )  gives «(:z(55), :a(42), :b(72))␤"List"␤3␤» I would've expected «(%(:z(55), :a(42), :b(72)),)␤"Hash"␤1␤»
21:55Z <Zoffix> jnthn: never mind; I see *@a does it too. I guess it's normal, since Hash is Iterable... just weird.
**@a and |c are the ones that don't do it
Those just collect arguments as they are
Ah, looks like there _is_ still a leaking in issue as well, as I've just got a NativeCall::Types precomp file depending on Inline::Perl5::Interpreter
no andthen! I refuse to play your Chinese food mind games!
o/ Zoffix++
